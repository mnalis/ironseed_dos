diff --git a/BUILD b/BUILD
new file mode 100644
index 0000000..2afebb4
--- /dev/null
+++ b/BUILD
@@ -0,0 +1,29 @@
+Software required to build:
+
+	Borland Pascal 7 is requird to build the game and some tools used to create data files.
+
+	The Digital Mars D compiler is required to the conversation and log conversion tools.
+		http://digitalmars.com/d/1.0/index.html
+
+	Borland's BGI Toolkit is required for VGA256.BGI
+
+	Python is required for the fixnames.py script. This converts all files in a directory in lowercase.
+
+Wine/DOSBox setup:
+	The Makefile assumes that Borland Pascal has been installed to F:\BP and Ironseed is placed in S:\IRONSEED
+
+	The command "sudo echo 0 > /proc/sys/vm/mmap_min_addr" may be required to run DOS executables under Wine. Newer versions of Wine may invoke DOSBox execute the command.
+
+
+Borland Pascal 7 setup:
+	The directories use in Borland Pascal need to be configured.
+	Run BP and in the menu "Options -> Directories" configure the directories like below.
+		EXE & TPU directory:  s:\ironseed\code
+		Include directories:  s:\ironseed\code;s:\ironseed\dmp
+		Unit directories:     s:\ironseed\code;s:\ironseed\dmp;f:\bp\units;f:\bp\winunits
+		Object directories:   s:\ironseed\code;s:\ironseed\dmp
+		Resource directories: f:\bp\units;
+
+BGI Toolkit:
+	VGA256.BGI should be extracted from the toolkit. It should be then converted to a .OBJ file with BINOBJ.EXE included with Borland Pascal.
+	VGA256.OBJ should be place in ironseed/code
\ No newline at end of file
diff --git a/COPYING b/COPYING
new file mode 100644
index 0000000..94a9ed0
--- /dev/null
+++ b/COPYING
@@ -0,0 +1,674 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff --git a/makefile b/Makefile
similarity index 63%
rename from makefile
rename to Makefile
index 2ef64fd..3f61619 100644
--- a/makefile
+++ b/Makefile
@@ -1,6 +1,6 @@
 
 export WINEPREFIX=/home/xen/.wine-ironseed/
-WINEEXE=wine
+WINE=wine
 
 FIXNAMES=python code/fixnames.py
 
@@ -10,15 +10,17 @@ CREWGENSRC=code/crewgen.pas code/data.pas code/gmouse.pas code/saveload.pas code
 INTROSRC=code/intro.pas code/version.pas code/gmouse.pas code/modplay.pas $(DMPSRC)
 ISSRC=code/is.pas
 
-TPC=$(WINEEXE) g:/bp/bin/tpc.exe /Tg:\\bp\\bin
+TPC=$(WINE) f:/bp/bin/tpc.exe /Tf:\\bp\\bin
 TPCFLAGS=/B /Q /M /DUSE_EMS /L /GD /\$$N+ /\$$G+ /\$$S- /\$$I-
 TPCTOOLFLAGS=/B /Q /M /DUSE_EMS /L /GD /\$$N+ /\$$G+ /\$$S- /\$$I+
 # /Ecode /Ocode /Udmp /Idmp
 
+TASM=$(WINE) f:/bp/bin/tasm.exe 
+
 CREWCONVS=data/conv0001.dta data/conv0002.dta data/conv0003.dta data/conv0004.dta data/conv0005.dta data/conv0006.dta
 RACECONVS=data/conv1001.dta data/conv1002.dta data/conv1003.dta data/conv1004.dta data/conv1005.dta data/conv1006.dta data/conv1007.dta data/conv1008.dta data/conv1009.dta data/conv1010.dta data/conv1011.dta
 SPECCONVS=data/conv1100.dta data/conv1101.dta data/conv1102.dta data/conv1103.dta
-all: convmake logmake main.exe crewgen.exe intro.exe config.exe detsound.exe is.exe $(RACECONVS) $(SPECCONVS) $(CREWCONVS) data/log.dta datafiles
+all: convmake logmake main.exe crewgen.exe intro.exe detsound.exe is.exe $(RACECONVS) $(SPECCONVS) $(CREWCONVS) data/log.dta datafiles # sndcfg.exe
 
 convmake: makedata/convmake.d makedata/data.d
 	dmd makedata/convmake.d makedata/data.d
@@ -74,18 +76,18 @@ data/log.dta: makedata/logs.txt logmake
 	./logmake makedata/logs.txt data/titles.dta data/log.dta 
 
 # /CD /$$N+ /$$G+ /$$S- /$$I- 
-main.exe: $(MAINSRC)
+main.exe: $(MAINSRC) code/mover.obj code/vga256.obj
 	$(TPC) $(TPCFLAGS) code\\main.pas #| linefix
-	cat code/main.exe code/main.ovr > main.exe
 	$(FIXNAMES) code
+	cat code/main.exe code/main.ovr > main.exe
 	touch main.exe --reference=code/main.exe
 
-crewgen.exe: $(CREWGENSRC)
+crewgen.exe: $(CREWGENSRC) code/mover.obj code/vga256.obj
 	$(TPC) $(TPCFLAGS) code\\crewgen.pas #| linefix
 	$(FIXNAMES) code
 	cp code/crewgen.exe ./crewgen.exe
 
-intro.exe: $(INTROSRC)
+intro.exe: $(INTROSRC) code/scroller.obj code/vga256.obj
 	$(TPC) $(TPCFLAGS) code\\intro.pas #| linefix
 	$(FIXNAMES) code
 	cp code/intro.exe ./intro.exe
@@ -95,21 +97,38 @@ is.exe: $(ISSRC)
 	$(FIXNAMES) code
 	cp code/is.exe ./is.exe
 
-config.exe: code/config.pas makedata/win.pas
-	$(TPC) $(TPCFLAGS) code\\config.pas #| linefix
+sndcfg.exe: code/sndcfg.pas #makedata/win.pas
+	$(TPC) $(TPCFLAGS) code\\sndcfg.pas #| linefix
 	$(FIXNAMES) code
-	cp code/config.exe ./config.exe
+	cp code/sndcfg.exe ./sndcfg.exe
 
 detsound.exe: code/detsound.pas
 	$(TPC) $(TPCFLAGS) code\\detsound.pas #| linefix
 	$(FIXNAMES) code
 	cp code/detsound.exe ./detsound.exe
 
+code/graphics.obj: code/graphics.asm
+	$(TASM) code\\graphics.asm code\\
+	$(FIXNAMES) code
+code/mouse.obj: code/mouse.asm
+	$(TASM) code\\mouse.asm code\\
+	$(FIXNAMES) code
+code/mover.obj: code/mover.asm
+	$(TASM) code\\mover.asm code\\
+	$(FIXNAMES) code
+code/mover2.obj: code/mover2.asm
+	$(TASM) code\\mover2.asm code\\
+	$(FIXNAMES) code
+code/scroller.obj: code/scroller.asm
+	$(TASM) code\\scroller.asm code\\
+	$(FIXNAMES) code
+
 clean:
-	rm -f code/*.tpu code/*.exe code/*.ovr 
-	rm -f obj/*.o
+	rm -f code/*.tpu code/*.exe code/*.ovr code/*.map
+	rm -f code/graphics.obj code/mourse.obj code/mover.obj code/mover2.obj code/scroller.obj
 	rm -f main.exe crewgen.exe intro.exe
 	rm -f convmake logmake
+	rm -f data/iteminfo.dta data/creation.dta data/cargo.dta data/scan.dta data/sysnames.dta data/contact0.dta data/crew.dta data/artifact.dta data/elements.dta data/event.dta
 
 code/itemmake.exe: makedata/itemmake.pas
 	$(TPC) $(TPCTOOLFLAGS) makedata\\itemmake.pas #| linefix
@@ -123,18 +142,54 @@ code/cargmake.exe: makedata/cargmake.pas
 code/scanmake.exe: makedata/scanmake.pas
 	$(TPC) $(TPCTOOLFLAGS) makedata\\scanmake.pas #| linefix
 	$(FIXNAMES) code
+code/sysmake.exe: makedata/sysmake.pas
+	$(TPC) $(TPCTOOLFLAGS) makedata\\sysmake.pas #| linefix
+	$(FIXNAMES) code
+code/aliemake.exe: makedata/aliemake.pas
+	$(TPC) $(TPCTOOLFLAGS) makedata\\aliemake.pas #| linefix
+	$(FIXNAMES) code
+code/crewmake.exe: makedata/crewmake.pas
+	$(TPC) $(TPCTOOLFLAGS) makedata\\crewmake.pas #| linefix
+	$(FIXNAMES) code
+code/artimake.exe: makedata/artimake.pas
+	$(TPC) $(TPCTOOLFLAGS) makedata\\artimake.pas #| linefix
+	$(FIXNAMES) code
+code/elemmake.exe: makedata/elemmake.pas
+	$(TPC) $(TPCTOOLFLAGS) makedata\\elemmake.pas #| linefix
+	$(FIXNAMES) code
+code/eventmak.exe: makedata/eventmak.pas
+	$(TPC) $(TPCTOOLFLAGS) makedata\\eventmak.pas #| linefix
+	$(FIXNAMES) code
 
 data/iteminfo.dta: code/itemmake.exe makedata/iteminfo.txt
-	$(WINEEXE) code/itemmake.exe
+	$(WINE) code/itemmake.exe
 	$(FIXNAMES) code data
 data/creation.dta: code/creamake.exe makedata/creation.txt
-	$(WINEEXE) code/creamake.exe
-	$(FIXNAMES) code data
+	$(WINE) code/creamake.exe
+	$(FIXNAMES) code data other
 data/cargo.dta: code/cargmake.exe makedata/cargo.txt
-	$(WINEEXE) code/cargmake.exe
+	$(WINE) code/cargmake.exe
 	$(FIXNAMES) code data
 data/scan.dta: code/scanmake.exe makedata/scandata.txt
-	$(WINEEXE) code/scanmake.exe
-	$(FIXNAMES) code data .
+	$(WINE) code/scanmake.exe
+	$(FIXNAMES) code data
+data/sysname.dta: code/sysmake.exe makedata/names.txt
+	$(WINE) code/sysmake.exe
+	$(FIXNAMES) code data
+data/contact0.dta: code/aliemake.exe makedata/contact.txt
+	$(WINE) code/aliemake.exe
+	$(FIXNAMES) code data
+data/crew.dta: code/crewmake.exe makedata/crew.txt
+	$(WINE) code/crewmake.exe
+	$(FIXNAMES) code data
+data/artifact.dta: code/artimake.exe makedata/anom.txt
+	$(WINE) code/artimake.exe
+	$(FIXNAMES) code data
+data/elements.dta: code/elemmake.exe makedata/element.txt
+	$(WINE) code/elemmake.exe
+	$(FIXNAMES) code data
+data/event.dta: code/eventmak.exe makedata/event.txt
+	$(WINE) code/eventmak.exe
+	$(FIXNAMES) code data
 
-datafiles: data/iteminfo.dta data/creation.dta data/cargo.dta data/scandata.dta
+datafiles: data/iteminfo.dta data/creation.dta data/cargo.dta data/scan.dta data/sysname.dta data/contact0.dta data/crew.dta data/artifact.dta data/elements.dta data/event.dta
diff --git a/carglist.txt b/carglist.txt
deleted file mode 100644
index 34efbe4..0000000
--- a/carglist.txt
+++ /dev/null
@@ -1,143 +0,0 @@
-Dirk                /1000/400
-Scimitar            /1001/700
-Broadsword          /1002/1200
-Claymore            /1003/2000
-Blackjack           /1004/1000
-Whip                /1005/1800
-Flail               /1006/3000
-Short Bow           /1007/800
-Long Bow            /1008/1500
-Ballista            /1009/2700
-Hvy. Ballista       /1010/3000
-Arquebus            /1011/2300
-Tnglor Eggs         /1012/1500
-Needlers            /1013/1800
-Caltrops            /1014/2000
-Gyroid Cannons      /1015/1000
-Hive                /1016/2500
-Dopplegangers       /1017/700
-Grav-Pulse Launcher /1018/5000
-Ochre Embryons      /1019/450
-Ego Neurosynth      /1020/200
-Id Psychosynth      /1021/500
-Syntax Immobilizers /1022/1100
-Cyrexin Psychotrope /1023/2500
-Foom Cannon         /1024/2000
-Light Raizor        /1025/500
-Dual Raizor         /1026/900
-Gatling Raizor      /1027/1500
-Electron Guerrloid  /1028/1000
-Neutron Guerrloid   /1029/1300
-Positron Guerrloid  /1030/1700
-Heavy Ion Guerrloid /1031/2200
-Hydra Pulse Array   /1032/2800
-Null Pulse Cannon   /1033/3500
-Thynne Vortex       /1034/3200
-Sling of David      /1035/2700
-Death Weave         /1036/4200
-Dogath Buoy         /1037/600
-Disruptor Cannon    /1038/1800
-Imbreth Leech       /1039/300
-Guerrloid Grapple   /1040/2700
-Kyn-pox Ichor       /1041/900
-Corse Grenades      /1042/200
-Heavy Corse Grenade /1043/800
-Doom Gate           /1044/5700
-PyroSnare           /1045/2400
-Thaumaturge         /1046/4800
-Shade Ward          /1047/3200
-Catapulse Battery   /1048/1200
-Shadow Kiss         /1049/100
-Chain Flail         /1050/2100
-Philosopher's Stone /1051/3600
-Wolf Wand           /1052/3000
-Purgature           /1053/2000
-Bolt Glyph          /1054/900
-Wrath of Shiva      /1055/4000
-Mobius Device       /1056/5500
-Unknown Shield      /1500/0
-Reflective Hull     /1501/5000
-Quarter Shields     /1502/700
-Binary Shield       /1503/1100
-Torus Shield        /1504/1600
-Helical Field       /1505/2100
-Stasis Generator    /1506/2500
-Null Stasis Array   /1507/2800
-NeuroNull Array     /1508/3000
-Terminex Projection /1509/3100
-Shift Distortion    /1510/3500
-Inertial Barrier    /1511/3500
-MultiPhase Inverter /1512/2000
-Temporal Anchor     /1513/1500
-Nothing             /2000/0
-Probot              /2001/470
-Minebot             /2002/1250
-Manufactory         /2003/3430
-Fabricator          /2005/5120
-Fuel Nodules        /2004/6
-Reinforce Hull      /2015/750
-Increase Thrust     /2016/20
-Add Cargo Space     /2017/15
-Install Gun Node    /2018/5000
-Mind Enhancers      /2019/10
-Unknown Component   /3000/0
-Solonoid            /3001/3
-Data Board          /3002/4
-Cyberplasm          /3003/4
-Disei Conduit       /3004/5
-Steoplast           /3005/3
-Flux Lens           /3006/2
-Metal Weave         /3007/5
-Pulse Loom          /3008/5
-Biosynth            /3009/3
-Plasm Inverter      /3010/2
-Grav-Coupler        /3011/4
-Torque Stanchion    /3012/2
-Vac-Feeder          /3013/2
-Mulroid             /3014/1
-Proto-Nutrient      /3015/1
-Duct Battery        /3016/3
-Masking Pod         /3017/4
-Guidance Strut      /3018/3
-StrataMount         /3019/5
-Ion Cache           /3020/3
-ThermoPlast         /3021/3
-Unknown Material    /4000/1
-Protoplasm          /4001/1
-Polymers            /4002/1
-Crystals            /4003/1
-Oxidants            /4004/1
-Esper Seeds         /4005/1
-Heavy Ions          /4006/1
-Coolants            /4007/1
-Solvents            /4008/1
-Electrolytes        /4009/1
-Organics            /4010/1
-Alien Isotopes      /4011/1
-Conductants         /4012/1
-Magnetics           /4013/1
-Radioactives        /4014/1
-Liquid Gases        /4015/1
-Medicants           /4016/1
-Ceramics            /4017/1
-Alien Compounds     /4018/1
-Strange Particles   /4019/1
-Worthless Junk      /4020/1
-Protic liquids      /5000/1
-Alkene              /5010/1
-Alkyne              /5020/1
-Volatile compounds  /5030/1
-Ether               /5040/1
-Aldehydes/Ketone    /5050/1
-Carboxylic acid     /5060/1
-Amine               /5070/1
-Strong Acid         /5080/1
-Base                /5090/1
-Salts               /5100/1
-Lensing Solid       /5110/1
-Heavy Element       /5120/1
-Transition Metal    /5130/1
-Halogens/Noble Gas  /5140/1
-Amino Acid          /5150/1
-Industrial Chemical /5160/1
-DEBUG !!!!!!!!!!!!  /1/1
diff --git a/code/build.cfg b/code/build.cfg
deleted file mode 100644
index 75f103d..0000000
--- a/code/build.cfg
+++ /dev/null
@@ -1,16 +0,0 @@
-/Tf:\bp\bin\turbo.tpl
-/Ee:\ironseed\code
-/Ie:\ironseed\code;e:\ironseed\dmp
-/Ue:\ironseed\code;e:\ironseed\dmp;f:\bp\units
-/Oe:\ironseed\code;e:\ironseed\dmp
-
-/M
-/CD
-/L
-
-/GD
-
-/$N+
-/$G+
-/$S-
-/$I-
diff --git a/code/cargtool.pas b/code/cargtool.pas
index 2350b3c..62f3fdf 100644
--- a/code/cargtool.pas
+++ b/code/cargtool.pas
@@ -1,4 +1,20 @@
 unit cargtool;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    Cargo/Creation unit for IronSeed
diff --git a/code/combat.pas b/code/combat.pas
index 9063e5a..c724a23 100644
--- a/code/combat.pas
+++ b/code/combat.pas
@@ -1,4 +1,20 @@
 unit combat;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    Battle/Combat unit for IronSeed
diff --git a/code/comm.pas b/code/comm.pas
index bbbf125..b32e6a9 100644
--- a/code/comm.pas
+++ b/code/comm.pas
@@ -1,4 +1,20 @@
 unit comm;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    Communication unit for IronSeed
@@ -14,7 +30,7 @@ unit comm;
 {$O+}
 interface
 
-uses data,amp;
+uses data;
 
 procedure conversewithcrew;
 procedure continuecontact(hail: boolean);
diff --git a/code/comm2.pas b/code/comm2.pas
index fc43695..dd093cb 100644
--- a/code/comm2.pas
+++ b/code/comm2.pas
@@ -1,4 +1,20 @@
 unit comm2;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    Communication unit #2 for IronSeed
diff --git a/code/crew2.pas b/code/crew2.pas
index f4af393..e2ff7c3 100644
--- a/code/crew2.pas
+++ b/code/crew2.pas
@@ -1,4 +1,20 @@
 unit crew2;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    Crew Manipulation unit 2 for IronSeed
diff --git a/code/crewgen.pas b/code/crewgen.pas
index 92b3c34..25ca02a 100644
--- a/code/crewgen.pas
+++ b/code/crewgen.pas
@@ -1,4 +1,21 @@
 program crewgen;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
+
 {$M 4500,300000,300000}
 {$S-,L-,D-}
 
diff --git a/code/crewinfo.pas b/code/crewinfo.pas
index 1daf332..e7f32fa 100644
--- a/code/crewinfo.pas
+++ b/code/crewinfo.pas
@@ -1,4 +1,20 @@
 unit crewinfo;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    Crew Manipulation unit for IronSeed
diff --git a/code/crewtick.pas b/code/crewtick.pas
index c4e67df..84cff22 100644
--- a/code/crewtick.pas
+++ b/code/crewtick.pas
@@ -1,4 +1,20 @@
 unit crewtick;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {$O+}
 
diff --git a/code/data.pas b/code/data.pas
index 290233f..860835b 100644
--- a/code/data.pas
+++ b/code/data.pas
@@ -1,4 +1,20 @@
 unit data;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    Data unit for IronSeed
diff --git a/code/detsound.pas b/code/detsound.pas
index 991b970..5f8b75a 100644
--- a/code/detsound.pas
+++ b/code/detsound.pas
@@ -1,6 +1,22 @@
 program detectsoundinformation;
+(********************************************************************
+    This file is part of Ironseed.
 
-uses strings,crt,MCP,DET_SB,DET_PAS,DET_ARIA,DETGUS;
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
+
+{$I DSMI.INC}, strings,crt,MCP,DET_SB,DET_PAS,DET_ARIA,DETGUS;
 
 var
  scard: TSoundCard;
diff --git a/code/display.pas b/code/display.pas
index cdaa15f..a593cf6 100644
--- a/code/display.pas
+++ b/code/display.pas
@@ -1,4 +1,20 @@
 unit display;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    Ship Display Control unit for IronSeed
diff --git a/code/emstool.pas b/code/emstool.pas
index 2612fb8..103bc73 100644
--- a/code/emstool.pas
+++ b/code/emstool.pas
@@ -1,4 +1,20 @@
 unit emstool;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 interface
 
@@ -154,4 +170,4 @@ end;
 
 begin
  ems.initialize;
-end.
\ No newline at end of file
+end.
diff --git a/code/ending.pas b/code/ending.pas
index 0f60004..e12599b 100644
--- a/code/ending.pas
+++ b/code/ending.pas
@@ -1,4 +1,21 @@
 unit ending;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
+
 {***************************
 
   Endgame Sequence for IronSeed
diff --git a/code/explore.pas b/code/explore.pas
index 8a6db39..a6bd9ab 100644
--- a/code/explore.pas
+++ b/code/explore.pas
@@ -1,4 +1,20 @@
 unit explore;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    Planet Exploration unit for IronSeed
diff --git a/code/gmouse.pas b/code/gmouse.pas
index cba494b..da4854e 100644
--- a/code/gmouse.pas
+++ b/code/gmouse.pas
@@ -1,4 +1,20 @@
 unit gmouse;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    Mouse Utilities unit for IronSeed
diff --git a/code/gmouse.tpp b/code/gmouse.tpp
deleted file mode 100644
index 6f4e134..0000000
Binary files a/code/gmouse.tpp and /dev/null differ
diff --git a/code/graphics.asm b/code/graphics.asm
index 2e1d057..ce3d709 100644
--- a/code/graphics.asm
+++ b/code/graphics.asm
@@ -1,5 +1,21 @@
 ideal
 p486
+;********************************************************************
+;    This file is part of Ironseed.
+;
+;    Ironseed is free software: you can redistribute it and/or modify
+;    it under the terms of the GNU General Public License as published by
+;    the Free Software Foundation, either version 3 of the License, or
+;    (at your option) any later version.
+;
+;    Ironseed is distributed in the hope that it will be useful,
+;    but WITHOUT ANY WARRANTY; without even the implied warranty of
+;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;    GNU General Public License for more details.
+;
+;    You should have received a copy of the GNU General Public License
+;    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+;********************************************************************
 
 global mousehide: far
 global mousesetcursor: far
diff --git a/code/heapchk.pas b/code/heapchk.pas
index fa8a21c..b88f426 100644
--- a/code/heapchk.pas
+++ b/code/heapchk.pas
@@ -1,4 +1,20 @@
 unit heapchk;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 interface
 procedure WriteHexWord(w: Word);
diff --git a/code/info.pas b/code/info.pas
index fec4879..f0c81f1 100644
--- a/code/info.pas
+++ b/code/info.pas
@@ -1,4 +1,20 @@
 unit info;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    Information unit for IronSeed
diff --git a/code/init.pas b/code/init.pas
index babe559..95e635e 100644
--- a/code/init.pas
+++ b/code/init.pas
@@ -1,4 +1,20 @@
 unit init;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    Initialization unit for IronSeed
diff --git a/code/install.pas b/code/install.pas
index 8d97f66..80eb6e7 100644
--- a/code/install.pas
+++ b/code/install.pas
@@ -1,4 +1,21 @@
 program installit;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
+
 {$M 4000,0,0}
 {
   Installation Unit for IronSeed
diff --git a/code/intro.pas b/code/intro.pas
index 1f18067..4662c54 100644
--- a/code/intro.pas
+++ b/code/intro.pas
@@ -1,4 +1,21 @@
 program intro;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
+
 {$M 5500,436000,436000}
 {$S-,D-,L-}
 
diff --git a/code/is.pas b/code/is.pas
index 622e55f..b835d51 100644
--- a/code/is.pas
+++ b/code/is.pas
@@ -1,4 +1,21 @@
 program ironseed;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
+
 {$M 2600,0,0}
 {S-,D-,L-}
 
diff --git a/code/journey.pas b/code/journey.pas
index 40e7a1d..caa53e7 100644
--- a/code/journey.pas
+++ b/code/journey.pas
@@ -1,4 +1,20 @@
 unit journey;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    Main Control unit for IronSeed
diff --git a/code/main.pas b/code/main.pas
index 43bc175..666c39c 100644
--- a/code/main.pas
+++ b/code/main.pas
@@ -1,4 +1,21 @@
 program main;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
+
 {$M 6500,335000,655360} (*390000*)
 {$S-,L-,D-}
 
diff --git a/code/modplay.pas b/code/modplay.pas
index 638fa7b..3d71d54 100644
--- a/code/modplay.pas
+++ b/code/modplay.pas
@@ -1,4 +1,20 @@
 unit modplay;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {$O+}
 
diff --git a/code/mouse.asm b/code/mouse.asm
index 20cef14..56697df 100644
--- a/code/mouse.asm
+++ b/code/mouse.asm
@@ -1,5 +1,21 @@
 ideal
 p486
+;********************************************************************
+;    This file is part of Ironseed.
+;
+;    Ironseed is free software: you can redistribute it and/or modify
+;    it under the terms of the GNU General Public License as published by
+;    the Free Software Foundation, either version 3 of the License, or
+;    (at your option) any later version.
+;
+;    Ironseed is distributed in the hope that it will be useful,
+;    but WITHOUT ANY WARRANTY; without even the implied warranty of
+;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;    GNU General Public License for more details.
+;
+;    You should have received a copy of the GNU General Public License
+;    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+;********************************************************************
 
 global mousehide: far
 global mousesetcursor: far
diff --git a/code/mover.asm b/code/mover.asm
index 53afa07..6ad5389 100644
--- a/code/mover.asm
+++ b/code/mover.asm
@@ -1,6 +1,21 @@
-
 ideal
 p486
+;********************************************************************
+;    This file is part of Ironseed.
+;
+;    Ironseed is free software: you can redistribute it and/or modify
+;    it under the terms of the GNU General Public License as published by
+;    the Free Software Foundation, either version 3 of the License, or
+;    (at your option) any later version.
+;
+;    Ironseed is distributed in the hope that it will be useful,
+;    but WITHOUT ANY WARRANTY; without even the implied warranty of
+;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;    GNU General Public License for more details.
+;
+;    You should have received a copy of the GNU General Public License
+;    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+;********************************************************************
 
 global mymove: far
 global fillchar386: far
diff --git a/code/mover2.asm b/code/mover2.asm
index 24e2af8..f635d14 100644
--- a/code/mover2.asm
+++ b/code/mover2.asm
@@ -1,3 +1,19 @@
+;********************************************************************
+;    This file is part of Ironseed.
+;
+;    Ironseed is free software: you can redistribute it and/or modify
+;    it under the terms of the GNU General Public License as published by
+;    the Free Software Foundation, either version 3 of the License, or
+;    (at your option) any later version.
+;
+;    Ironseed is distributed in the hope that it will be useful,
+;    but WITHOUT ANY WARRANTY; without even the implied warranty of
+;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;    GNU General Public License for more details.
+;
+;    You should have received a copy of the GNU General Public License
+;    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+;********************************************************************
 
 ideal
 p486
diff --git a/code/num2str.asm b/code/num2str.asm
deleted file mode 100644
index 0dee884..0000000
--- a/code/num2str.asm
+++ /dev/null
@@ -1,67 +0,0 @@
-ideal
-p486
-
-global bignum2str: near
-
-
-segment num2str_text word 'code'
-assume cs: num2str_text
-
-proc bignum2str near
- mov bx, sp
- push es
- push bp
- sub sp, 14
- mov bp, sp
-
- mov eax, [ss: bx+2]
- mov ecx, 10
- xor di, di
- mov si, 4
-
- @@loop:
-  xor edx, edx
-  div ecx
-  dec si
-  jz @@addcomma
- @@continue:
-  add dl, 48
-  mov [ss:bp+di], dl
-  inc di
-  cmp eax, 0
-  jg @@loop
-
- mov cx, di
- mov ax, [ss:bx+8]
- mov es, ax
- mov di, [ss:bx+6]
- mov [es: di], cl
- inc di
-
- mov si, bp
- add si, cx
- dec si
-
- @@copyloop:
-  mov al, [ss: si]
-  mov [es: di], al
-  dec si
-  inc di
-  dec cx
-  jnz @@copyloop
-
- add sp, 14
- pop bp
- pop es
- ret
- @@addcomma:
-  mov dh, ','
-  mov [ss:bp+di], dh
-  inc di
-  mov si, 3
-  jmp @@continue
-endp bignum2str
-
-ends num2str_text
-
-end
\ No newline at end of file
diff --git a/code/old/combat2.pas b/code/old/combat2.pas
deleted file mode 100644
index f515525..0000000
--- a/code/old/combat2.pas
+++ /dev/null
@@ -1,714 +0,0 @@
-unit combat2;
-
-{***************************
-   Battle/Combat unit for IronSeed
-
-   Channel 7
-   Destiny: Virtual
-
-
-   Copyright 1994
-
-***************************}
-
-{$O+}
-
-interface
-
-procedure initiatecombat2;
-
-implementation
-
-uses crt, graph, data, gmouse, utils, utils2, modplay, weird, saveload, usecode, crewtick, heapchk;
-
-const
-   maxships				  = 25;
-   maxformations			  = 3;
-   shipclass : array[0..14] of string[14] = 
-   ('Shuttle       ','Scout         ','Fighter       ','Assault Scout ',
-    'Patrol Craft  ','Corvette      ','Frigate       ','Lt. Destroyer ',
-    'Hv. Destroyer ','Lt. Cruiser   ','Hv. Cruiser   ','Battle Cruiser',
-    'Flagship      ','Battleship    ','Dreadnaught   ');
-   formation : array[0..maxformations-1,0..4,1..3] of integer =
-   (
-    ((0,0,0),(-3000,0,0),(3000,0,0),(0,-3000,0),(0,3000,0)),               { planar plus }
-    ((0,0,0),(-3000,-3000,0),(3000,3000,0),(-3000,3000,0),(3000,-3000,0)), { planar cross}
-    ((0,0,0),(1000,0,1000),(2000,0,2000),(3000,0,3000),(4000,0,4000))      { 3d slash }
-    );
-type
-   xyz		  = record
-		       x, y, z : Real;
-		    end;       
-   xy		  = record
-		       x, y : Integer;
-		    end;    
-   combatshiptype = record
-		       p				  : xyz;{relative position}
-		       v				  : xyz;{relative velocity}
-		       a				  : xyz;{acceleration at last time point}
-		       scr				  : xy;{position on screen (relative tocenter)}
-		       faction, targetfaction		  : Word; {Faction bits, targetable faction bits}
-		       target				  : Integer;  {}
-		       targetrange			  : Real; {distance to target}
-		       techlevel, skill			  : Integer;
-		       hull, hullmax			  : Integer;
-		       accelmax				  : Integer;
-		       battery, batterycharge, batterymax : Integer;
-		       shieldlevel, shieldset		  : Integer;
-		       shieldtype			  : Integer;
-		       gunnodes				  : array[1..10] of byte;
-		       charges				  : array[1..10] of real;
-		       damages				  : array[1..7] of real;
-		       
-		    end;       
-   alienshiparray   = array[1..maxships] of alienshiptype;
-   combatshiparray  = array[0..maxships] of combatshiptype;
-var
-   totalships					: Integer;
-   scanning,autofire,engaging,alienpicmode,dead	: boolean;
-   poweredup					: array[1..10] of integer;
- userpowerup					: array[1..10] of boolean;
- learnchance					: Integer;
-
-{*******************************************************************************}
-
-(*procedure moveships;
-var am, ar, r, d : real;
-    a,j,i,t	 : integer;
-   ax, ay, az	 : Integer;
-   pax, pay, paz : Integer;
-   
-begin
-   a:=ship.accelmax;
-   if ship.damages[4]>89 then a:=a div 4;
-   if shipdir<4 then ay:=1
-   else if shipdir>6 then ay:=-1 else ay := 0;
-   if shipdir mod 3=1 then ax:=+1
-   else if shipdir mod 3=0 then ax:=-1 else ax := 0;
-   if shipdir2=1 then az:=-1
-   else if shipdir2=2 then az:=1 else az := 0;
-   ar := sqrt(ax * ax + ay * ay + az * az);
-   if ar > 0 then
-   begin
-      pax := round(ax * a / ar);
-      pay := round(ay * a / ar);
-      paz := round(az * a / ar);
-   end else begin
-      pax := 0;
-      pay := 0;
-      paz := 0;
-   end;
-
-   for j:=1 to nships do
-      with ships^[j] do
-      begin
-	 dx := dx + pax;
-	 dy := dy + pay;
-	 dz := dz + paz;
-	 if {(moveindex=5) and} (hulldamage>0) and (damages[4]<90) {and not fled} then
-	 begin
-	    am := accelmax;
-	 end else begin
-	    am := 0;
-	 end;
-	    
-	 if am < a then
-	 begin
-	    dx := dx - round(ax * am / ar);
-	    dy := dy - round(ay * am / ar);
-	    dz := dz - round(az * am / ar);
-	 end else begin
-	    r := sqrt(1.0 * relx * relx + 1.0 * rely * rely + 1.0 * relz * relz);
-	    if r < 1 then r := 1;
-	    if {(moveindex=5) and} (hulldamage>0) and (damages[4]<90) {and not fled} then
-	    begin
-	       d := sqrt(1.0 * dx * dx + 1.0 * dy * dy + 1.0 * dz * dz);
-	       am := accelmax;
-	       if ar > 0 then
-	       begin
-		  dx := Round(dx - (am - a) * relx / r);
-		  dy := Round(dy - (am - a) * rely / r);
-		  dz := Round(dz - (am - a) * relz / r);
-		  dx := dx - round(ax * a / ar);
-		  dy := dy - round(ay * a / ar);
-		  dz := dz - round(az * a / ar);
-	       end else begin
-		  dx := Round(dx - am * relx / r);
-		  dy := Round(dy - am * rely / r);
-		  dz := Round(dz - am * relz / r);
-	       end;
-		 
-	    end;
-	 end;
-	 if dx < -3000 then dx := -3000;
-	 if dx > 3000 then dx := 3000;
-	 if dy < -3000 then dy := -3000;
-	 if dy > 3000 then dy := 3000;
-	 if dz < -3000 then dz := -3000;
-	 if dz > 3000 then dz := 3000;
-
-	 inc(relx, dx div 10);
-	 inc(rely, dy div 10);
-	 inc(relz, dz div 10);
-
-	 if relx > 100000000 then relx := 100000000;
-	 if relx < -100000000 then relx := -100000000;
-	 if rely > 100000000 then rely := 100000000;
-	 if rely < -100000000 then rely := -100000000;
-	 if relz > 100000000 then relz := 100000000;
-	 if relz < -100000000 then relz := -100000000;
-
-	 r := r * 10;
-	 ( *if (moveindex=5) and (hulldamage>0) and (damages[4]<90) and not fled then
-	 begin
-	    if (relx<5000) and (relx>0) and (dx<-3000) then inc(dx,accelmax)
-	    else if (relx>-5000) and (relx<0) and (dx>3000) then dec(dx,accelmax)
-	    else if (relx>0) and (dx>-1000) then dec(dx,accelmax)
-	    else if (relx<0) and (dx<1000) then inc(dx,accelmax);
-	    if (rely<5000) and (rely>0) and (dy<-3000) then inc(dy,accelmax)
-	    else if (rely>-5000) and (rely<0) and (dy>3000) then dec(dy,accelmax)
-	    else if (rely>0) and (dy>-1000) then dec(dy,accelmax)
-	    else if (rely<0) and (dy<1000) then inc(dy,accelmax);
-	    if (relz<5000) and (relz>0) and (dz<-3000) then inc(dz,accelmax)
-	    else if (relz>-5000) and (relz<0) and (dz>3000) then dec(dz,accelmax)
-	    else if (relz>0) and (dz>-1000) then dec(dz,accelmax)
-	    else if (relz<0) and (dz<1000) then inc(dz,accelmax);
-	 end;
-	 relx:=relx+round(dx/5);
-	 rely:=rely+round(dy/5);
-	 relz:=relz+round(dz/5);
-	 r:=sqr(relx/10);
-	 r:=r+sqr(rely/10);
-	 r:=r+sqr(relz/10);
-	 r:=sqrt(r)*100;
-	 
-	 a:=ship.accelmax;
-	 if ship.damages[4]>89 then a:=a div 4;
-	 if shipdir<4 then rely:=rely+a
-	 else if shipdir>6 then rely:=rely-a;
-	 if shipdir mod 3=1 then relx:=relx+a
-	 else if shipdir mod 3=0 then relx:=relx-a;
-	 if shipdir2=1 then relz:=relz-a
-	 else if shipdir2=2 then relz:=relz+a;
-	  * )
-	 part:=ships^[j].range;
-	 if (hulldamage>0) {and not fled} then
-	    for a:=1 to 20 do
-	       if (charges[a]=100) then
-	       begin
-		  if part>=r then
-		  begin
-		     i:=random(120)-15*ship.options[4];
-		     {if (i<skill) or ((scanning) and (random(100)<20)) then}
-		     if not SkillTest(True, 4, skill + (ord(scanning) * 20), learnchance) then
-		     begin
-			displaymap;
-			impact(j,maxweapons);
-			displaymap;
-		     end;
-		     charges[a]:=0;
-		  end;
-	       end;
-	 if (abs(r)>1200000) then {fled:=true;}hulldamage:=0;
-	 if ((hulldamage=0) {or fled}) and (targetindex=j) then
-	 begin
-	    targetindex:=1;
-	    while (targetindex<=nships) and ((ships^[targetindex].hulldamage=0) {or fled}) do inc(targetindex);
-	    if targetindex>nships then done:=true;
-	 end;
-      end;
-   if moveindex=5 then moveindex:=0 else inc(moveindex);
-end;
-*)
-
-(*
-procedure findmouse;
-begin
- if not mouse.getstatus then exit;
- case mouse.x of
-  105..125: case mouse.y of
-             131..151: fireweapon:=1;
-             152..156: if (mouse.x>108) and (mouse.x<122) then
-                        begin
-                         if userpowerup[1] then
-                          begin
-                           plainfadearea(109,152,121,154,32);
-                           userpowerup[1]:=false;
-                          end
-                         else
-                          begin
-                           plainfadearea(109,152,121,154,-32);
-                           userpowerup[1]:=true;
-                          end;
-                        end
-                       else findtarget;
-             157..161: if (mouse.x>108) and (mouse.x<122) then
-                        begin
-                         if userpowerup[6] then
-                          begin
-                           plainfadearea(109,159,121,161,32);
-                           userpowerup[6]:=false;
-                          end
-                         else
-                          begin
-                           plainfadearea(109,159,121,161,-32);
-                           userpowerup[6]:=true;
-                          end;
-                        end
-                       else findtarget;
-             162..182: fireweapon:=6;
-             else findtarget;
-            end;
-  128..148: case mouse.y of
-             131..151: fireweapon:=2;
-             152..156: if (mouse.x>131) and (mouse.x<145) then
-                        begin
-                         if userpowerup[2] then
-                          begin
-                           plainfadearea(132,152,144,154,32);
-                           userpowerup[2]:=false;
-                          end
-                         else
-                          begin
-                           plainfadearea(132,152,144,154,-32);
-                           userpowerup[2]:=true;
-                          end;
-                        end
-                       else findtarget;
-             157..161: if (mouse.x>131) and (mouse.x<145) then
-                        begin
-                         if userpowerup[7] then
-                          begin
-                           plainfadearea(132,159,144,161,32);
-                           userpowerup[7]:=false;
-                          end
-                         else
-                          begin
-                           plainfadearea(132,159,144,161,-32);
-                           userpowerup[7]:=true;
-                          end;
-                        end
-                       else findtarget;
-             162..182: fireweapon:=7;
-             else findtarget;
-            end;
-  151..171: case mouse.y of
-             131..151: fireweapon:=3;
-             152..156: if (mouse.x>154) and (mouse.x<168) then
-                        begin
-                         if userpowerup[3] then
-                          begin
-                           plainfadearea(155,152,167,154,32);
-                           userpowerup[3]:=false;
-                          end
-                         else
-                          begin
-                           plainfadearea(155,152,167,154,-32);
-                           userpowerup[3]:=true;
-                          end;
-                        end
-                       else findtarget;
-             157..161: if (mouse.x>154) and (mouse.x<168) then
-                        begin
-                         if userpowerup[8] then
-                          begin
-                           plainfadearea(155,159,167,161,32);
-                           userpowerup[8]:=false;
-                          end
-                         else
-                          begin
-                           plainfadearea(155,159,167,161,-32);
-                           userpowerup[8]:=true;
-                          end;
-                        end
-                       else findtarget;
-             162..182: fireweapon:=8;
-             else findtarget;
-            end;
-  174..194: case mouse.y of
-             131..151: fireweapon:=4;
-             152..156: if (mouse.x>177) and (mouse.x<191) then
-                        begin
-                         if userpowerup[4] then
-                          begin
-                           plainfadearea(178,152,190,154,32);
-                           userpowerup[4]:=false;
-                          end
-                         else
-                          begin
-                           plainfadearea(178,152,190,154,-32);
-                           userpowerup[4]:=true;
-                          end;
-                        end
-                       else findtarget;
-             157..161: if (mouse.x>177) and (mouse.x<191) then
-                        begin
-                         if userpowerup[9] then
-                          begin
-                           plainfadearea(178,159,190,161,32);
-                           userpowerup[9]:=false;
-                          end
-                         else
-                          begin
-                           plainfadearea(178,159,190,161,-32);
-                           userpowerup[9]:=true;
-                          end;
-                        end
-                       else findtarget;
-             162..182: fireweapon:=9;
-             191..195: if (mouse.x>183) then switchalienmode else findtarget;
-             else findtarget;
-            end;
-  195..196: case mouse.y of
-             191..195: switchalienmode;
-             else findtarget;
-            end;
-  197..217: case mouse.y of
-             131..151: fireweapon:=5;
-             152..156: if (mouse.x>200) and (mouse.x<214) then
-                        begin
-                         if userpowerup[5] then
-                          begin
-                           plainfadearea(201,152,213,154,32);
-                           userpowerup[5]:=false;
-                          end
-                         else
-                          begin
-                           plainfadearea(201,152,213,154,-32);
-                           userpowerup[5]:=true;
-                          end;
-                        end
-                       else findtarget;
-             157..161: if (mouse.x>200) and (mouse.x<214) then
-                        begin
-                         if userpowerup[10] then
-                          begin
-                           plainfadearea(201,159,213,161,32);
-                           userpowerup[10]:=false;
-                          end
-                         else
-                          begin
-                           plainfadearea(201,159,213,161,-32);
-                           userpowerup[10]:=true;
-                          end;
-                        end
-                       else findtarget;
-             162..182: fireweapon:=10;
-             191..195: if (mouse.x<209) then switchalienmode else findtarget;
-             else findtarget;
-            end;
-  223..225: if (mouse.y>184) and (mouse.y<193) then previoustarget;
-  226..242: case mouse.y of
-             124..144: if range>5000 then
-                        begin
-                         displaymap;
-                         dec(range,5000);
-                         str(range:7,str1);
-                         printxy(33,110,str1);
-                         displaymap;
-                        end;
-             151..173: if not autofire then
-                        begin
-                         autofire:=true;
-                         mousehide;
-                         for i:=125 to 126 do
-                          fillchar(screen[i,163],52,63);
-                         mouseshow;
-                        end
-                       else
-                        begin
-                         autofire:=false;
-                         mousehide;
-                         for i:=125 to 126 do
-                          fillchar(screen[i,163],52,95);
-                         mouseshow;
-                        end;
-             185..192: if (mouse.x<241) then previoustarget;
-               89..97: if mouse.x<237 then setdir(1) else setdir(2);
-              99..107: if mouse.x<237 then setdir(4) else setdir(5);
-             109..117: if mouse.x<237 then setdir(7) else setdir(8);
-             else findtarget;
-            end;
-  244..260: case mouse.y of
-             124..144: if range<5000000 then
-                        begin
-                         displaymap;
-                         inc(range,5000);
-                         str(range:7,str1);
-                         printxy(33,110,str1);
-                         displaymap;
-                        end;
-             151..173: if not scanning then
-                        begin
-                         scanning:=true;
-                         mousehide;
-                         for i:=187 to 188 do
-                          fillchar(screen[i,163],52,63);
-                         mouseshow;
-                        end
-                       else
-                        begin
-                         scanning:=false;
-                         mousehide;
-                         for i:=187 to 188 do
-                          fillchar(screen[i,163],52,95);
-                         mouseshow;
-                        end;
-             185..192: if (mouse.x>245) then nexttarget;
-               69..77: if mouse.x>248 then setdir2(1);
-               79..87: if mouse.x>248 then setdir2(2);
-               89..97: if mouse.x<249 then setdir(2) else setdir(3);
-              99..107: if mouse.x<249 then setdir(5) else setdir(6);
-             109..117: if mouse.x<249 then setdir(8) else setdir(9);
-             else findtarget;
-            end;
-  261..263: if (mouse.y>184) and (mouse.y<193) then nexttarget else findtarget;
-  271..279: if (mouse.y<10) and (ship.options[2]>1) then
-             begin
-              dec(ship.options[2]);
-              tslice:=ship.options[2];
-              displaytimedelay;
-             end;
-  291..312: case mouse.y of
-             11..117: displayshieldpic(round((117-mouse.y)*100/102));
-             1..9: if (mouse.x>299) and (mouse.x<309) and (ship.options[2]<255) then
-                    begin
-                     inc(ship.options[2]);
-                     tslice:=ship.options[2];
-                     displaytimedelay;
-                    end;
-            end;
-  else findtarget;
- end;
-end;
-*)
-   
-(*procedure processkey;
-var ans: char;
-begin
- ans:=readkey;
- case upcase(ans) of
-   #0: begin
-        ans:=readkey;
-        case ans of
-         #71: setdir(1);
-         #72: setdir(2);
-         #73: setdir(3);
-         #75: setdir(4);
-         #77: setdir(6);
-         #79: setdir(7);
-         #80: setdir(8);
-         #81: setdir(9);
-         #16,#45	 : if yesnorequest('Do you want to quit?',0,31) then
-	 begin
-	    quit:=true;
-	    done:=true;
-	    dead:=true;
-	 end;
-        end;
-       end;
-  '-': setdir2(1);
-  '+': setdir2(2);
-  ' ': switchalienmode;
-  '<',',': previoustarget;
-  '>','.': nexttarget;
-  '`': bossmode;
-  'Q': fireweapon:=1;
-  'W': fireweapon:=2;
-  'E': fireweapon:=3;
-  'R': fireweapon:=4;
-  'T': fireweapon:=5;
-  'A': fireweapon:=6;
-  'S': fireweapon:=7;
-  'D': fireweapon:=8;
-  'F': fireweapon:=9;
-  'G': fireweapon:=10;
-  #10: printbigbox(GetHeapStats1,GetHeapStats2);
- end;
-end;
-*)
-   
-(*
-procedure mainloop;
-var index,cindex: integer;
-begin
- index:=0;
- cindex:=0;
- displaymap;
- repeat
-  fadestep(8);
-  findmouse;
-  if fastkeypressed then processkey;
-  inc(index);
-  if index=8 then
-   begin
-    suckpower;
-    index:=0;
-    displaymap;
-    moveships;
-    displaymap;
-   end;
-  displaystats;
-  displaytargetinfo;
-  powerup;
-    if not done then
-    begin
-       if cindex<16 then i:=cindex+32 else i:=64-cindex;
-       setrgb256(i,0,0,colors[i,3]);
-       if cindex<31 then inc(cindex) else cindex:=0;
-       if cindex<16 then i:=cindex+32 else i:=64-cindex;
-       setrgb256(i,0,0,63);
-       delay(tslice*3);
-    end;
- until done;
- wait(1);
- set256colors(colors);
-end;
-*)
-
-procedure readydata;
-var
-   j : Integer;
-begin
-   mousehide;
-   compressfile(tempdir+'\current',@screen);
-   fadestopmod(-8, 20);
-   playmod(true,'sound\combat.mod');
-   loadscreen('data\fight',@screen);
-   loadscreen('data\cloud',backgr);
-   
-   done:=false;
-   tcolor:=95;
-   bkcolor:=0;
-   autofire:=true;
-   scanning:=false;
-   loadscreen('data\waricon',backgr);
-   for j:=1 to 10 do
-   begin
-      {poweredup[j]:=-1;
-      if ship.armed then poweredup[j]:=99 else poweredup[j]:=0;
-      if ship.gunnodes[j]=0 then poweredup[j]:=-1;}
-   end;
-   mouseshow;
-end;
-
-procedure unloaddata;
-begin
-   loadscreen('data\cloud',backgr);
-   if ((tempplan^[curplan].state=6) and (tempplan^[curplan].mode=2)) then makeastoroidfield
-   else if (tempplan^[curplan].state=0) and (tempplan^[curplan].mode=1) then makecloud;
-end;
-(*
-procedure savevictories;
-var f : file of alientype;
-    t : alientype;
-   j  : Integer;
-begin
- assign(f,tempdir+'\contacts.dta');
- reset(f);
- if ioresult<>0 then errorhandler(tempdir+'\contacts.dta',1);
- i:=-1;
- repeat
-  inc(i);
-  read(f,t);
-  if ioresult<>0 then errorhandler(tempdir+'\contacts.dta',4);
- until t.id=ship.wandering.alienid;
- seek(f,i);
- if ioresult<>0 then errorhandler(tempdir+'\contacts.dta',4);
- i:=nships div 4;
- if i=0 then i:=1;
- inc(t.victory,i);
- i:=0;
- for j:=1 to 7 do i:=i+ship.damages[j];
- if i=0 then inc(t.victory,nships);
- if t.anger<200 then inc(t.anger)
- else if t.congeniality>0 then dec(t.congeniality);
- if t.victory>20000 then t.victory:=20000;
- write(f,t);
- if ioresult<>0 then errorhandler(tempdir+'\contacts.dta',4);
- close(f);
-end;
-*)
-
-(*
-procedure aftereffects;
-var cargoitems : array[0..13] of integer;
-   j	       : Integer;
-   dcnt	       : Integer;
-begin
-   dcnt := 0;
-   for j:=1 to nships do
-   begin
-      if ships^[j].hulldamage <= 0 then inc(dcnt);
-   end;
- playmod(true,'sound\victory.mod');
- mousehide;
- for i:=9 to 117 do
-  fillchar(screen[i,6],254,0);
- for i:=125 to 189 do
-  fillchar(screen[i,6],93,0);
- tcolor:=95;
-   if dcnt <= 0 then
-   begin
-      printxy(18,8,'ESCAPED!');
-   end else begin
-      printxy(18,8,'VICTORY!');
-   end;
- mouseshow;
- if (dcnt > 0) and yesnorequest('DEPLOY SCAVENGER BOTS?',0,31) then
-  begin
-   tcolor:=22;
-   bkcolor:=0;
-   mousehide;
-   printxy(18,18,'SCAVENGER BOTS DEPLOYED...');
-   mouseshow;
-   tcolor:=28;
-   fillchar(cargoitems,11,0);
-   i:=random(dcnt{nships});
-   if i>13 then i:=13;
-   a:=1;
-   while cargo[a].index<>3000 do inc(a);
-   for j:=0 to i do
-    begin
-     cargoitems[j]:=random(21);
-     mousehide;
-     printxy(24,28+j*6,cargo[a+cargoitems[j]].name);
-     mouseshow;
-     addcargo2(cargoitems[j]+3000, true);
-    end;
-   while fastkeypressed do readkey;
-   repeat
-   until (fastkeypressed) or (mouse.getstatus);
-   while fastkeypressed do readkey;
-  end;
-   if dcnt > 0 then
-      savevictories;
-end;
-*)
-
-procedure initiatecombat2;
-begin
-   readydata;
-   {mainloop;}
-   while fastkeypressed do readkey;
-   repeat
-   until (fastkeypressed) or (mouse.getstatus);
-   while fastkeypressed do readkey;
-   unloaddata;
- {if (not engaging) and (not dead) and (ship.wandering.alienid<1013) then aftereffects;}
- stopmod;
- removedata;
- if (engaging) and (targetready) then
-  engage(systems[nearby[target].index].x,systems[nearby[target].index].y,systems[nearby[target].index].z)
- else if engaging then
-  begin
-   targetready:=true;
-   engage(ship.posx-10+random(20),ship.posy-10+random(20),ship.posz-10+random(20));
-  end;
-end;
-
-var
-   j : Integer;
-begin
- for j :=1 to 10 do userpowerup[j]:=true;
-end.   
diff --git a/code/pcx2vga.pas b/code/pcx2vga.pas
deleted file mode 100644
index dfa15a7..0000000
--- a/code/pcx2vga.pas
+++ /dev/null
@@ -1,224 +0,0 @@
-program convertpcxfilestovgafiles;
-
-uses crt, graph, data;
-
-type
- pcxheadertype= record
-   signature,version,rleflag,bitpx: byte;
-   x1,y1,x2,y2,hres,vres: word;
-   colors: array[0..47] of byte;
-   vmode,nplanes: byte;
-   bplin,paltype,scrnw,scrnh: word;
-   filler: array[0..53] of byte;
-  end;
-{ colortype= array[1..3] of byte;
- paltype= array[0..255] of colortype; }
-var
- pcxheader: pcxheadertype;
- colors: paltype;
- i,j: integer;
-
-procedure errorhandler(s: string; errtype: integer);
-begin
- writeln;
- writeln;
- case errtype of
-  1: writeln('Opening File Error: ',s);
-  5: writeln('Read/Write File Error: ',s);
-  6: writeln('Program Error: ',s);
-  7: writeln('DOS Error: ',s);
-  8: writeln('PCX Error: ',s);
- end;
- halt(4);
-end;
-
-procedure initheader;
-begin
- with pcxheader do
-  begin
-   signature:=10;
-   version:=5;
-   rleflag:=1;
-   paltype:=1;
-   vmode:=0;
-   fillchar(colors,48,0);
-   fillchar(filler,54,0);
-  end;
- fillchar(colors,768,0);
-end;
-
-procedure displaystatus;
-begin
- writeln('PCXHEADER:');
- with pcxheader do
-  begin
-   writeln('  signature: ',signature);
-   write(  '  version  : ',version,', ');
-   case version of
-    0: writeln('version 2.5');
-    2: writeln('version 2.8 with palette');
-    3: writeln('version 2.8 without palette');
-    5: writeln('version 3.0+');
-    else writeln('unknown version');
-   end;
-   writeln('  rleflag  : ',rleflag);
-   write(  '  paltype  : ',paltype,', ');
-   case paltype of
-    1: writeln('color image');
-    2: writeln('grayscale image');
-    else writeln('unknown image type');
-   end;
-   writeln('  vmode    : ',vmode);
-   writeln('  bitpx    : ',bitpx);
-   writeln('  nplanes  : ',nplanes);
-   writeln('  bplin    : ',bplin);
-   writeln('  x1       : ',x1);
-   writeln('  y1       : ',y1);
-   writeln('  x2       : ',x2);
-   writeln('  y2       : ',y2);
-   writeln('  hres     : ',hres);
-   writeln('  vres     : ',vres);
-   writeln('  scrnw    : ',scrnw);
-   writeln('  scrnh    : ',scrnh);
-  end;
-end;
-
-procedure getpalette(s: string);
-var f: file;
-    ft: file of paltype;
-    j: word;
-begin
- if pcxheader.bitpx=1 then
-  begin
-   colors[1,1]:=63;
-   colors[1,2]:=63;
-   colors[1,3]:=63;
-  end
- else if pcxheader.bitpx=4 then
-  move(pcxheader.colors,colors,48)
- else if (pcxheader.bitpx=8) and (pcxheader.nplanes=1) then
-  begin
-   assign(f,s);
-   reset(f,1);
-   j:=filesize(f)-769;
-   if ioresult<>0 then errorhandler(s,1);
-   seek(f,j);
-   if ioresult<>0 then errorhandler(s,5);
-   blockread(f,i,1);
-   blockread(f,colors,768);
-   if ioresult<>0 then errorhandler(s,5);
-   close(f);
-
-{   if colors[0,1]<>12 then fillchar(colors,768,0); }
-
-   setgraphmode(0);
-   set256colors(colors);
-   for j:=0 to 255 do
-    for i:=0 to 199 do
-     screen[i,j]:=j;
-
-   readkey;
-
-
-  end;
- assign(ft,'tmp.pal');
- rewrite(ft);
- if ioresult<>0 then errorhandler('tmp.pal',5);
- write(ft,colors);
- if ioresult<>0 then errorhandler('tmp.pal',5);
- close(ft);
-end;
-
-procedure decode8bit(s: string);
-var hdrbyte,datbyte,datbyte2: byte;
-    cntbyte: integer;
-    size,bytecnt: longint;
-    f: file of byte;
-    ft: file of byte;
-    x,y: integer;
-label jumpend;
-begin
- assign(ft,'tmp.vga');
- if ioresult<>0 then errorhandler('tmp.vga',1);
- rewrite(ft);
- if ioresult<>0 then errorhandler('tmp.vga',5);
- assign(f,s);
- reset(f);
- if ioresult<>0 then errorhandler(s,1);
- seek(f,128);
- if ioresult<>0 then errorhandler(s,5);
- bytecnt:=0;
- cntbyte:=0;
- size:=(pcxheader.x2-pcxheader.x1+1);
- size:=size*(pcxheader.y2-pcxheader.y1+1);
- if size>64000 then size:=64000;
- x:=-1;
- y:=0;
- while (bytecnt<size) do
-  begin
-   read(f,hdrbyte);
-   if ioresult<>0 then goto jumpend;
-   if (hdrbyte and $C0)=$C0 then
-    begin
-     cntbyte:=hdrbyte and $3F;
-     read(f,datbyte);
-     if ioresult<>0 then goto jumpend;
-    end
-   else
-    begin
-     cntbyte:=1;
-     datbyte:=hdrbyte;
-    end;
-
-   datbyte2:=0;
-   for j:=0 to 7 do
-    if datbyte and (1 shl j)>0 then datbyte2:=datbyte2 or (1 shl (7-j));
-   for j:=1 to cntbyte do
-    begin
-     inc(x);
-     if (x>pcxheader.x2) then
-      begin
-       x:=-1;
-       inc(y);
-      end;
-     if x<320 then
-      begin
-{       write(ft,datbyte2);}
-       screen[y,x]:=datbyte2;
-      end;
-    end;
-   bytecnt:=bytecnt+cntbyte;
-  end;
-jumpend:
- close(ft);
- close(f);
-end;
-
-procedure decode124bit(s: string);
-begin
- {****************}
-end;
-
-procedure decodepcx(s: string);
-var f: file;
-begin
- textmode(co80);
- initheader;
- assign(f,s);
- reset(f,1);
- if ioresult<>0 then errorhandler(s,1);
- blockread(f,pcxheader,sizeof(pcxheader));
- if ioresult<>0 then errorhandler(s,5);
- close(f);
- displaystatus;
- if pcxheader.signature<>10 then errorhandler(s,8);
- getpalette(s);
- if pcxheader.bitpx=8 then
-  decode8bit(s)
- else decode124bit(s);
-end;
-
-begin
- decodepcx('\data\images\example3.pcx');
- readkey;
-end.
\ No newline at end of file
diff --git a/code/saveload.pas b/code/saveload.pas
index 237e7c2..e545b07 100644
--- a/code/saveload.pas
+++ b/code/saveload.pas
@@ -1,4 +1,20 @@
 unit saveload;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    Save/Load Game and Utility Unit for IronSeed
diff --git a/code/scroller.asm b/code/scroller.asm
index 45998b8..2af7819 100644
--- a/code/scroller.asm
+++ b/code/scroller.asm
@@ -1,3 +1,19 @@
+;********************************************************************
+;    This file is part of Ironseed.
+;
+;    Ironseed is free software: you can redistribute it and/or modify
+;    it under the terms of the GNU General Public License as published by
+;    the Free Software Foundation, either version 3 of the License, or
+;    (at your option) any later version.
+;
+;    Ironseed is distributed in the hope that it will be useful,
+;    but WITHOUT ANY WARRANTY; without even the implied warranty of
+;    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+;    GNU General Public License for more details.
+;
+;    You should have received a copy of the GNU General Public License
+;    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+;********************************************************************
 
 ideal
 p486
diff --git a/code/shipmake.pas b/code/shipmake.pas
index 84ceaea..bde1db8 100644
--- a/code/shipmake.pas
+++ b/code/shipmake.pas
@@ -1,4 +1,20 @@
 program makeship;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 type
  alienshiptype=
diff --git a/code/config.pas b/code/sndcfg.pas
similarity index 92%
rename from code/config.pas
rename to code/sndcfg.pas
index 31374a7..43b3f28 100644
--- a/code/config.pas
+++ b/code/sndcfg.pas
@@ -1,7 +1,24 @@
 program ConfigureFrinj;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
+
 {$M 2000,0,0}
 
-uses crt, win, strings, dos;
+uses crt, strings, dos;
 
 type
    configfile = 
diff --git a/code/starter.pas b/code/starter.pas
index febae7f..cfcfc38 100644
--- a/code/starter.pas
+++ b/code/starter.pas
@@ -1,4 +1,20 @@
 unit starter;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    Initialization for IronSeed
diff --git a/code/usecode.pas b/code/usecode.pas
index 5638079..9d41358 100644
--- a/code/usecode.pas
+++ b/code/usecode.pas
@@ -1,4 +1,20 @@
 unit usecode;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    Ship Display Initialization unit for IronSeed
diff --git a/code/utils.pas b/code/utils.pas
index 930e8d0..42759d1 100644
--- a/code/utils.pas
+++ b/code/utils.pas
@@ -1,4 +1,20 @@
 unit utils;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    General Utilities for IronSeed
diff --git a/code/utils2.pas b/code/utils2.pas
index 2dfa859..05771f8 100644
--- a/code/utils2.pas
+++ b/code/utils2.pas
@@ -1,4 +1,20 @@
 unit utils2;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    Overlayable Utilites for IronSeed
diff --git a/code/version.pas b/code/version.pas
index 130bfd2..5aba570 100644
--- a/code/version.pas
+++ b/code/version.pas
@@ -1,4 +1,20 @@
 unit version;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 interface
 var
@@ -7,5 +23,5 @@ implementation
 begin
    versionstring :=
    {1234567890}
-   'v1.20.0016';
+   'v1.30.0001';
 end.
diff --git a/code/weird.pas b/code/weird.pas
index a1b7840..9d274fb 100644
--- a/code/weird.pas
+++ b/code/weird.pas
@@ -1,4 +1,20 @@
 unit weird;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 {***************************
    CatchAll unit for IronSeed
diff --git a/code/win.asm b/code/win.asm
deleted file mode 100644
index 3719648..0000000
--- a/code/win.asm
+++ /dev/null
@@ -1,284 +0,0 @@
-; Turbo Pascal 6.0 example
-; Assembler include file for WIN.PAS unit
-; Copyright (c) 1989,90 by Borland International, Inc.
-
-        TITLE   WIN
-
-        LOCALS  @@
-
-; Coordinate record
-
-X               EQU     (BYTE PTR 0)
-Y               EQU     (BYTE PTR 1)
-
-; BIOS workspace equates
-
-CrtMode         EQU     (BYTE PTR 49H)
-CrtWidth        EQU     (BYTE PTR 4AH)
-
-DATA    SEGMENT WORD PUBLIC
-
-; Externals from CRT unit
-
-        EXTRN   CheckSnow:BYTE,WindMin:WORD,WindMax:WORD
-
-DATA    ENDS
-
-CODE    SEGMENT BYTE PUBLIC
-
-        ASSUME  CS:CODE,DS:DATA
-
-; procedure WriteStr(X, Y: Byte; S: String; Attr: Byte);
-
-        PUBLIC  WriteStr
-
-WriteStr:
-
-        PUSH    BP
-        MOV     BP,SP
-        LES     BX,[BP+8]
-        MOV     CL,ES:[BX]
-        MOV     SI,OFFSET CS:CrtWriteStr
-        CALL    CrtWrite
-        POP     BP
-        RETF    10
-
-; procedure WriteChar(X, Y, Count: Byte; Ch: Char; Attr: Byte);
-
-        PUBLIC  WriteChar
-
-WriteChar:
-
-        PUSH    BP
-        MOV     BP,SP
-        MOV     CL,[BP+10]
-        MOV     SI,OFFSET CS:CrtWriteChar
-        CALL    CrtWrite
-        POP     BP
-        RETF    10
-
-; procedure FillWin(Ch: Char; Attr: Byte);
-
-        PUBLIC  FillWin
-
-FillWin:
-
-        MOV     SI,OFFSET CS:CrtWriteChar
-        JMP     SHORT CommonWin
-
-; procedure ReadWin(var Buf);
-
-        PUBLIC  ReadWin
-
-ReadWin:
-
-        MOV     SI,OFFSET CS:CrtReadWin
-        JMP     SHORT CommonWin
-
-; procedure WriteWin(var Buf);
-
-        PUBLIC  WriteWin
-
-WriteWin:
-
-        MOV     SI,OFFSET CS:CrtWriteWin
-
-; Common FillWin/ReadWin/WriteWin routine
-
-CommonWin:
-
-        PUSH    BP
-        MOV     BP,SP
-        XOR     CX,CX
-        MOV     DX,WindMin
-        MOV     CL,WindMax.X
-        SUB     CL,DL
-        INC     CX
-@@1:    PUSH    CX
-        PUSH    DX
-        PUSH    SI
-        CALL    CrtBlock
-        POP     SI
-        POP     DX
-        POP     CX
-        INC     DH
-        CMP     DH,WindMax.Y
-        JBE     @@1
-        POP     BP
-        RETF    4
-
-; Write string to screen
-
-CrtWriteStr:
-
-        PUSH    DS
-        MOV     AH,[BP+6]
-        LDS     SI,[BP+8]
-        INC     SI
-        JC      @@4
-@@1:    LODSB
-        MOV     BX,AX
-@@2:    IN      AL,DX
-        TEST    AL,1
-        JNE     @@2
-        CLI
-@@3:    IN      AL,DX
-        TEST    AL,1
-        JE      @@3
-        MOV     AX,BX
-        STOSW
-        STI
-        LOOP    @@1
-        POP     DS
-        RET
-@@4:    LODSB
-        STOSW
-        LOOP    @@4
-        POP     DS
-        RET
-
-; Write characters to screen
-
-CrtWriteChar:
-
-        MOV     AL,[BP+8]
-        MOV     AH,[BP+6]
-        JC      @@4
-        MOV     BX,AX
-@@1:    IN      AL,DX
-        TEST    AL,1
-        JNE     @@1
-        CLI
-@@2:    IN      AL,DX
-        TEST    AL,1
-        JE      @@2
-        MOV     AX,BX
-        STOSW
-        STI
-        LOOP    @@1
-        RET
-@@4:    REP     STOSW
-        RET
-
-; Read window buffer from screen
-
-CrtReadWin:
-
-        PUSH    DS
-        PUSH    ES
-        POP     DS
-        MOV     SI,DI
-        LES     DI,[BP+6]
-        CALL    CrtCopyWin
-        MOV     [BP+6],DI
-        POP     DS
-        RET
-
-; Write window buffer to screen
-
-CrtWriteWin:
-
-        PUSH    DS
-        LDS     SI,[BP+6]
-        CALL    CrtCopyWin
-        MOV     [BP+6],SI
-        POP     DS
-        RET
-
-; Window buffer copy routine
-
-CrtCopyWin:
-
-        JC      @@4
-@@1:    LODSW
-        MOV     BX,AX
-@@2:    IN      AL,DX
-        TEST    AL,1
-        JNE     @@2
-        CLI
-@@3:    IN      AL,DX
-        TEST    AL,1
-        JE      @@3
-        MOV     AX,BX
-        STOSW
-        STI
-        LOOP    @@1
-        RET
-@@4:    REP     MOVSW
-        RET
-
-; Do screen operation
-; In    CL = Buffer length
-;       SI = Write procedure pointer
-;       BP = Stack frame pointer
-
-CrtWrite:
-
-        MOV     DL,[BP+14]
-        DEC     DL
-        ADD     DL,WindMin.X
-        JC      CrtExit
-        CMP     DL,WindMax.X
-        JA      CrtExit
-        MOV     DH,[BP+12]
-        DEC     DH
-        ADD     DH,WindMin.Y
-        JC      CrtExit
-        CMP     DH,WindMax.Y
-        JA      CrtExit
-        XOR     CH,CH
-        JCXZ    CrtExit
-        MOV     AL,WindMax.X
-        SUB     AL,DL
-        INC     AL
-        CMP     CL,AL
-        JB      CrtBlock
-        MOV     CL,AL
-
-; Do screen operation
-; In    CL = Buffer length
-;       DX = CRT coordinates
-;       SI = Procedure pointer
-
-CrtBlock:
-
-        MOV     AX,40H
-        MOV     ES,AX
-        MOV     AL,DH
-        MUL     ES:CrtWidth
-        XOR     DH,DH
-        ADD     AX,DX
-        SHL     AX,1
-        MOV     DI,AX
-        MOV     AX,0B800H
-        CMP     ES:CrtMode,7
-        JNE     @@1
-        MOV     AH,0B0H
-@@1:    MOV     ES,AX
-        MOV     DX,03DAH
-        CLD
-        CMP     CheckSnow,1
-        JMP     SI
-
-; Exit from screen operation
-
-CrtExit:
-
-        RET
-
-; function WinSize: Word;
-
-        PUBLIC  WinSize
-
-WinSize:
-
-        MOV     AX,WindMax
-        SUB     AX,WindMin
-        ADD     AX,101H
-        MUL     AH
-        SHL     AX,1
-        RETF
-
-CODE    ENDS
-
-        END
diff --git a/code/xscale1.asm b/code/xscale1.asm
deleted file mode 100644
index bd91125..0000000
--- a/code/xscale1.asm
+++ /dev/null
@@ -1,240 +0,0 @@
-;=========================================================================
-; XSCALE1.ASM by John A. Slagel, jas37876@uxa.cso.uiuc.edu
-; This is some code to do bitmap scaling in VGA Mode X.  It can scale a
-; bitmap of any size down to 2 pixels wide, or up to thousands of pixels
-; wide.  It performs complete clipping, with only a small constant amount
-; of time to clip, no matter how huge the image is.  It draws column by
-; column to reduce the number of plane switches, which are slow. The inner
-; column loop has been optimized for no memory accesses, except to read or
-; write a pixel.  This uses MASM 5.1 features, and can be compiled in any
-; memory model by changing the .MODEL line, but make sure that you always
-; pass a far pointer to the bitmap data, regardless of memory model.
-; C-callable as:
-;   void XSCALE1( int X, int Y, int DW, int DY,
-;                     int SW, int SH, void far * Bitmap );
-; X,Y   are the upper left-hand coordinates of where to draw the bitmap.
-; DW,DH are the width and height of the SCALEed bitmap
-; SW,SH are the width and height of the source bitmap.
-; Bitmap is a pointer to the bitmap bits.
-;
-;==========================================================================
-
-MASM51
-
-.MODEL LARGE, PASCAL
-.386
-
-.DATA
-SC_INDEX1   EQU 03C4h               ; Port number of VGA Sequencer Reg
-SC_INDEX2   EQU 03C5h               ; Port number of VGA Seqeuncer Data
-MAP_MASK    EQU 2                   ; Map Mask register index into Sequencer
-
-ClipLt      DW  1                  ; Left clipping boundry
-ClipRt      DW  319                 ; Right clipping boundry
-ClipTp      DW  1                  ; Top clipping boundry
-ClipBt      DW  399                 ; Bottom clipping boundry
-ModeXseg    DW  0A000h              ; Current VGA segment
-
-.CODE
-
-XSCALE1 PROC FAR USES DS DI SI, DestX:WORD, DestY:WORD,                 \
-                                    DestWidth:WORD, DestHeight:WORD,        \
-                                    SourceWidth:WORD, SourceHeight:WORD,    \
-                                    Bitmap:NEAR PTR, PageAddr:WORD
-LOCAL   DecisionX:WORD, DecisionY:WORD, ClippedWidth:WORD, ClippedHeight:WORD
-
-PUBLIC XSCALE1
-        cmp     DestWidth, 2        ; If destination width is less than 2
-        jl      Done                ;     then don't draw it.
-
-        cmp     DestHeight, 2       ; If destination height is less than 2
-        jl      Done                ;     then don't draw it.
-
-        mov     ax, DestY           ; If it is completely below the
-        cmp     ax, ClipBt          ; lower clip bondry,
-        jg      Done                ;     then don't draw it.
-
-        add     ax, DestHeight      ; If it is above clip boundries
-        dec     ax                  ;     then don't draw it.
-        cmp     ax, ClipTp
-        jl      Done
-
-        mov     ax, DestX           ; If it is to the right of the
-        mov     cx, ClipRt          ; right clip boundry
-        cmp     ax, ClipRt          ;     then don't draw it.
-        jg      Done
-
-        add     ax, DestWidth       ; If it is completely to the left
-        dec     ax                  ; of the left clip boundry,
-        cmp     ax, ClipLt          ;     then don't draw it.
-        jl      Done
-
-        les     si, Bitmap
-
-        mov     ax, DestWidth       ; ClippedWidth is initially set to
-        mov     ClippedWidth, ax    ; the requested dest width.
-
-        shl     ax,1                ; Initialize the X decision var
-        neg     ax                  ; to be -2*DestWidth
-        mov     DecisionX, ax       ;
-
-        mov     ax, DestHeight      ; ClippedHeight is initially set to
-        mov     ClippedHeight, ax   ; the requested dest size.
-
-        shl     ax,1                ; Initialize the Y decision var
-        neg     ax                  ; to be -2*DestHeight
-        mov     DecisionY, ax       ;
-
-        movsx   eax, ClipTp         ; If Y is below the top
-        mov     edx, eax            ; clipping boundry, then we don't
-        sub     dx, DestY           ; need to clip the top, so we can
-        js      NoTopClip           ; jump over the clipping stuff.
-
-        mov     DestY, ax           ; This block performs clipping on the
-        sub     ClippedHeight, dx   ; top of the bitmap.  I have heavily
-        movsx   ecx, SourceHeight   ; optimized this block to use only 4
-        imul    ecx, edx            ; 32-bit registers, so I'm not even
-        mov     eax, ecx            ; gonna try to explain what it's doing.
-        mov     edx, 0              ; But I can tell you what results from
-        movsx   ebx, DestHeight     ; this:  The DecisionY var is updated
-        idiv    ebx                 ; to start at the right clipped row.
-        movsx   edx, SourceWidth    ; Y is moved to the top clip
-        imul    edx, eax            ; boundry. ClippedHeight is lowered since
-        add     si, dx              ; we won't be drawing all the requested
-        imul    eax, ebx            ; rows.  SI is changed to point over
-        sub     ecx, eax            ; the bitmap data that is clipped off.
-        sub     ecx, ebx            ;
-        shl     ecx, 1              ;
-        mov     DecisionY, cx       ; <end of top clipping block >
-
-NoTopClip:
-        mov     ax, DestY           ; If the bitmap doesn't extend over the
-        add     ax, ClippedHeight   ; bottom clipping boundry, then we
-        dec     ax                  ; don't need to clip the bottom, so we
-        cmp     ax, ClipBt          ; can jump over the bottom clip code.
-        jle     NoBottomClip        ;
-
-        mov     ax, ClipBt          ; Clip off the bottom by reducing the
-        sub     ax, DestY           ; ClippedHeight so that the bitmap won't
-        inc     ax                  ; extend over the lower clipping
-        mov     ClippedHeight, ax   ; boundry.
-
-NoBottomClip:
-        movsx   eax, ClipLt         ; If X is to the left of the
-        mov     edx, eax            ; top clipping boundry, then we don't
-        sub     dx, DestX           ; need to clip the left, so we can
-        js      NoLeftClip          ; jump over the clipping stuff.
-
-        mov     DestX, ax           ; This block performs clipping on the
-        sub     ClippedWidth, dx    ; left of the bitmap.  I have heavily
-        movsx   ecx, SourceWidth    ; optimized this block to use only 4
-        imul    ecx, edx            ; 32-bit registers, so I'm not even
-        mov     eax, ecx            ; gonna try to explain what it's doing.
-        mov     edx, 0              ; But I can tell you what results from
-        movsx   ebx, DestWidth      ; this:  The DecisionX var is updated
-        idiv    ebx                 ; to start at the right clipped column.
-        add     si, ax              ; X is moved to the left clip
-        imul    eax, ebx            ; boundry. ClippedWidth is reduced since
-        sub     ecx, eax            ; we won't be drawing all the requested
-        sub     ecx, ebx            ; cols.  SI is changed to point over
-        shl     ecx, 1              ; the bitmap data that is clipped off.
-        mov     DecisionX, cx       ; <end of left clipping block >
-
-NoLeftClip:
-        mov     ax, DestX           ; If the bitmap doesn't extend over the
-        add     ax, ClippedWidth    ; right clipping boundry, then we
-        dec     ax                  ; don't need to clip the right, so we
-        cmp     ax, ClipRt          ; can jump over the right clip code.
-        jle     NoClipRight         ;
-
-        mov     ax, ClipRt          ; Clip off the right by reducing the
-        sub     ax, DestX           ; ClippedWidth so that the bitmap won't
-        inc     ax                  ; extend over the right clipping
-        mov     ClippedWidth, ax    ; boundry.
-
-        ;Calculate starting video address
-NoClipRight:
-        mov     ax, ModeXseg        ; We are going to set DS:DI to point
-        mov     ds, ax              ; to the place to start drawing in
-        mov     di, DestY           ; VGA memory. This code sets DS to the
-        imul    di, 80              ; VGA segment, which is usually at
-        mov     ax, DestX           ; segment 0A000. The offset DI is
-        mov     cx, ax              ; calculated by:
-        shr     ax, 2               ;     DI = Y*80+X/2
-        add     di, ax              ; DS:DI is ready!
-        add     di, PageAddr
-        mov     dx, SC_INDEX1       ; Point the VGA Sequencer to the Map
-        mov     al, MAP_MASK        ; Mask register, so that we only need
-        out     dx, al              ; to send out 1 byte per column.
-
-        inc     dx                  ; Move to the Sequencer's Data register.
-        and     cx, 3               ; Calculate the starting plane. This is
-        mov     al, 11h             ; just:
-        shl     al, cl              ; Plane =  (11h << (X AND 3))
-        out     dx, al              ; Select the first plane.
-
-                                    ; make sure that it is DWORD aligned.
-RowLoop:
-        push    si                  ; Save the starting source index
-        push    di                  ; Save the starting dest index
-        push    ax                  ; Save the current plane mask
-        push    bp                  ; Save the current base pointer
-
-        mov     ax, ClippedHeight   ; Use AL for row counter (0-239)
-        mov     bx, DecisionY       ; Use BX for decision variable
-        mov     cx, SourceWidth     ; Use CX for source width
-        mov     dx, SourceHeight    ; Use DX for source height * 2
-        shl     dx, 1
-        mov     bp, DestHeight      ; Use BP for dest height * 2
-        shl     bp, 1
-        mov     ah, es:[si]         ; Get the first source pixel
-
-ColumnLoop:
-        cmp     ah, 0
-        je      SkipDot
-        mov     ds:[di], ah         ; Draw a pixel
-SkipDot:
-        dec     al                  ; Decrement line counter
-        jz      DoneWithCol         ; See if we're done with this column
-        add     di, 80              ; Go on to the next screen row
-        add     bx, dx              ; Increment the decision variable
-        js      ColumnLoop          ; Draw this source pixel again
-
-IncSourceRow:
-        add     si, cx              ; Move to the next source pixel
-        sub     bx, bp              ; Decrement the decision variable
-        jns     IncSourceRow        ; See if we need to skip another source pixel
-        mov     ah, es:[si]         ; Get the next source pixel
-        jmp     ColumnLoop          ; Start drawing this pixel
-
-DoneWithCol:
-        pop     bp                  ; Restore BP to access variables
-        pop     ax                  ; Restore AL = plane mask
-        pop     di                  ; Restore DI to top row of screen
-        pop     si                  ; Restore SI to top row of source bits
-
-        rol     al, 1               ; Move to next plane
-        adc     di, 0               ; Go on to next screen column
-        mov     dx, SC_INDEX2       ; Tell the VGA what column we're in
-        out     dx, al              ; by updating the map mask register
-
-        shl     cx, 1               ; CX = SourceWidth * 2
-        mov     bx, DecisionX       ; Use BX for the X decision variable
-        add     bx, cx              ; Increment the X decision variable
-        js      NextCol             ; Jump if we're still in the same source col.
-        mov     dx, DestWidth       ; DX = W * 2
-        shl     dx, 1
-IncSourceCol:
-        inc     si                  ; Move to next source column
-        sub     bx, dx              ; Decrement X decision variable
-        jns     IncSourceCol        ; See if we skip another source column
-NextCol:
-        mov     DecisionX, bx       ; Free up BX for ColLoop
-        dec     ClippedWidth        ; If we're not at last column
-        jnz     RowLoop             ;    then do another column
-Done:
-        ret                         ; We're done!
-
-XSCALE1     ENDP
-
-            END
diff --git a/crealist.txt b/crealist.txt
deleted file mode 100644
index e69de29..0000000
diff --git a/data/artifact.dta b/data/artifact.dta
deleted file mode 100644
index 7db96b7..0000000
--- a/data/artifact.dta
+++ /dev/null
@@ -1,3 +0,0 @@
-
-CollapsingGlypticingClearicingOpaquecingGlowinging	PrismaticgMirroredcgMetalliccgModularccgMoldedrccgWhirringcgRotatingcgBlinkingcgPhasinggcgGlowinggcgGyratingcg	IntricategStrangetegMarbledtegGelidedtegSpheredtegGlobeedtegOrbbeedtegDisceedtegRodceedtegCycloidtegCubeoidtegConeoidtegTubeoidtegRingoidtegDevicedtegFrustrumegMachinemegPartinemegUnitinemeg	Implementg	ContainergCylinderrgStaffderrg	Graticuleg	Blisteredg	AmorphousgGlowingusgAcidicgusgWaxencgusgPustuledsg	Absorbentg	Pulsatingg
-UndulatingViscousingBlobousingGelatiningColloidingMassoidingOozeoidingSampledingGelpledingPlasmoidngSlimeoidngJellyoidng
\ No newline at end of file
diff --git a/data/cargo.dta b/data/cargo.dta
deleted file mode 100644
index 5a3d94a..0000000
Binary files a/data/cargo.dta and /dev/null differ
diff --git a/data/contact0.dta b/data/contact0.dta
deleted file mode 100644
index fffc1ca..0000000
Binary files a/data/contact0.dta and /dev/null differ
diff --git a/data/creation.dta b/data/creation.dta
deleted file mode 100644
index 1f2a648..0000000
Binary files a/data/creation.dta and /dev/null differ
diff --git a/data/crew.dta b/data/crew.dta
deleted file mode 100644
index f96a08a..0000000
Binary files a/data/crew.dta and /dev/null differ
diff --git a/data/elements.dta b/data/elements.dta
deleted file mode 100644
index 869c95e..0000000
--- a/data/elements.dta
+++ /dev/null
@@ -1 +0,0 @@
-UNKNOWN COMPOUND        METHANE                 ETHANE                  TRIBROMOETHANE          CYCLOPROPANE            CYCLOHEXANE             PHENYLPROPANE           HEXANE                  OCTANE                  DIMETHYLPROPANE         ISOBUTANE               TOLUENE                 NAPTHALENE              BENZENE                 METHYLENE CHLORIDE      PROPYLENE               DICHLOROETHYLENE        DIBROMOBENZENE          ANILINE                 NITROBENZENE            ANTHRACENE              ACETYLENE               ETHYLENE                PROPYNE                 TRIMETHYLPENTYNE        TRICHLOROETHYLYNE       HEXYNE                  DIBROMOBENZYNE          DIMETHYLPROPYNE         CYCLOPROPYNE            PHENYLPROPYNE           ETHYL ALCOHOL           ISOPROPYL ALCOHOL       BUTYL ALCOHOL           PRIM-ISO-AMYL ALCOHOL   HEPTYL ALCOHOL          ALLYL ALCOHOL           OCTYL ALCOHOL           HEXYL ALCOHOL           BENZYL ALCOHOL          FURFURYL ALCOHOL        PHENETOLE               ANISOLE                 DIPHENYL ETHER          DIETHYL ETHER           DI-ISO-PROPYL ETHER     ETHYL N-PROPYL ETHER    DI-ISO-BUTYL ETHER      ETHYL ACETATE           ETHYL STEARATE          RESORCINOL DIETHYL ETHERFORMALDEHYDE            ACETALDEHYDE            ACETONE                 NITROBENZALDEHYDE       MESITYL OXIDE           DIACETONE ALCOHOL       FURFURAL                BUTYRALDEHYDE           METHYL ETHYL KETONE     METHYL ISO-BUTYL KETONE FORMIC ACID             ACETIC ACID             BUTYRIC ACID            BENZOIC ACID            GLYCINE                 OXALIC ACID             CITRIC ACID             SILICIC ACID            CINCHOMERONIC ACID      QUINOLINIC ACID         ETHYLAMINE              ANILINE                 NAPTHHYLAMINE           BENZIDINE               PYRIDINE                THYMINE                 CYTOSINE                URACIL                  ADENINE                 GUANINE                 HYDROCHLORIC ACID       ACETIC ACID             SULFURIC ACID           PHOSPHORIC ACID         FLOURIC ACID            HYDROCYANIC ACID        CARBONIC ACID           NITRIC ACID             HYDROIODIC ACID         CHLOROUS ACID           SODIUM HYDROXIDE        BARIUM HYDROXIDE        AMMONIA                 CYANIDE                 CALCIUM CARBONATE       NICKEL OXIDE            AMMONIUM CHLORIDE       MAGNESIUM HYDROXIDE     IRON HYDROXIDE          POTASSIUM HYDROXIDE     EARLANDITE              HUMBOLDTINE             MELLITE                 OXAMMITE                WHEWELLITE              SODIUM CHLORIDE         AMMONIUM NITRATE        SODIUM FLOURIDE         LITHIUM SULPHATE        SELLENIUM CHLORIDE      GLASS                   QUARTZ                  DIAMONDS                RUBIES                  EMERALDS                ZIRCON                  ZEUNERITE               VANADINITE              TOURMALINE              PYRARGYRITE             URANIUM                 DYSPROSIUM              ERBIUM                  HOLMIUM                 LUTETIUM                NEODYMIUM               YTTERBIUM               THORIUM                 TERBIUM                 RHENIUM                 ZINC                    COPPER                  NICKEL                  GOLD                    SILVER                  TIN                     LEAD                    IRON                    MERCURY                 TUNGSTEN                FLOURINE                CHLORINE                BROMINE                 IODINE                  HELIUM                  NEON                    ARGON                   KRYPTON                 XENON                   RADON                   ASPARAGINE              ASPARTIC ACID           CYSTEINE                GLYCINE                 ISOLEUCINE              PHENYLALANINE           PROLINE                 TRYPTOPHAN              TYROSINE                VALINE                  SODIUM CARBONATE        UREA                    STYRENE                 CUMENE                  POTASH                  BUTADIENE               TITANIUM DIOXIDE        CAPROLACTAM             TEREPTHALIC ACID        FORMALDEHYDE            
\ No newline at end of file
diff --git a/data/event.dta b/data/event.dta
deleted file mode 100644
index 056f3cb..0000000
Binary files a/data/event.dta and /dev/null differ
diff --git a/data/iteminfo.dta b/data/iteminfo.dta
deleted file mode 100644
index f0d31a5..0000000
Binary files a/data/iteminfo.dta and /dev/null differ
diff --git a/data/planname.txt b/data/planname.txt
deleted file mode 100644
index cdb8b82..0000000
--- a/data/planname.txt
+++ /dev/null
@@ -1 +0,0 @@
-Hobyxonid      Euaveck        Fyfozad        Ixofuzane      Eyzi           Omyon          Fylofoe        Dreamers       Anolucesya     Pylaz          Oxielu         Zeorb          Levize         Urue           Kekeezox       Mybejysa       Denyvn         Xyd            Ytail          Bozyk          Levi           Uxoy           Myhatl         Elas           Benoi          Upaga          Nyga           Cyinite        Isoybolin      Iaroken        Imazoy         Kakovio        Avilynixoda    Rue            Udae           Kusyo          Uqurecs        Obachus        Focumaruda     Oveisekoraa    Xejie          Zalukoa        Jilazus        Fesaroga       Godova         CyaMsorabid    Lanyde         Ril Obyk       Pupok          NilGrynth      Koynosur       Ogoadeeku      Uxya           Oiloyomu       Axahi          Ciloc          Ekurj          Wizago         Hetumoe        Delorgeme      Utoy           Patonin        Oore           Kyga           Tulaizin       Bycapus        Vimaford       Quxalor        Agorimeta      Ehedipi        Bibizuuk       Obrafei        Anakelort      Atujo          Wanibork       Asyrukak       Ugynisu        Izydmoy        Esylekuwu      Anusat         Urv            Gybex          Jikanem        Himux          Vohaut         Gafauhu        Mauginypu      Guexyt         Feufeda        Biohyxia       Keui           Hunafixogyk    Udohodex       Uvozara        Jeoh           Itomyha        Dibugh         Olagypuloru    Ekuvenofer     Gixe           Pemyga         Rytogh         Unyzoroz       Micatyoz       Genao          Xily           Itoxobycea     Ukarore        Okuder         Olyli          Guk            Oju            Quob           Cikeodicerk    Ysae           Aibur          Jilumo         Jeuxim         Xedysy         Zevenat        Epasupeki      Oroaa          Sykuiduh       Ojufiku        Faladosh       Simocus        Eboi           Zepz           Quesevi        Gotabe         Zytug          Xygi           Ugur           Felog          Peykepodya     Pokegi         Beubyxs        Relivy         Butateba       Uxynoth        Ibuauro        Uwozea         Xao            Uves           Hezaxokie      Zeboahanoo     Seledabylao    Asat           Arumita        Xygona         Necronthila    Oramyleca      Nyoni          Uvehr          Ioulr          Romazoui       Sevab          Yhem           Ediry          Sotiy          Egobopex       Iticozil       Ydarye         Lulabu         Isixeu         Erojozeu       Nujupazera     Siareymokor    Owarieniker    Soygiro        Derenujexy     Igukama        Nybo           Qufiziee       Qukoma         Aexus          Aru            Efazoyt        Cyorazeem      Noximile       Nogui          Resynaleo      Oebeny         Amatygon       Gyliya         Yorion         Odyosezese     Movines        Yusa           Neospia        Uaxidee        Xuydya         Pejav          Alorid         Hyrii          Xeni           Uliheme        Bumus          Neuxobisu      Regou          Qusos          Koniba         Edimia         Ikiezo         Kuzur          Orusiok        Ynox           Asyma          Poy            Maax           Xitau          Mekaiba        Oharasu        Ryokyutu       Yzier          Eranyko        Azeremir       Kiahada        Ovolas         Eiloy          Nauroka        Nerufut        Lafia          Kamai          Lyrujatu       Valuzia        Xonuzyl        Tytyhn         Byluvuz        Fejyneso       Catobo         Kafuehor       Orym           Rofizu         Eygoko         Ozarimegi      Faluzr         Edujo          Uetir          Rya            Rugai          Uzikio         Godepina       Teurodoras     Hesunikiva     Iryxi          Dyhedo         Magus          Jyzorb         Dybolevau      Atiqune        Joiseru        Jebie          Ilalul         Uge            Fumyloi        Utuhyxa        Dyfokua        Ivejaru        Todu           Olunoeloo      Sicatu         Aqulie         Utezua         Yronu          Sonoh          Imao           Kiduvo         Yrixeda        Irayu          Fymo           Tusye          Ivuxol         Myu            Apuda          Sezinoxu       Zyx            Pexor          Izunitahiu     Xule           Cuzae          Denkafer       Ydoturiu       Udeg           Xodoryte       Xidom          Wopesulo       Tojucegio      Meodekien      Kokyxoi        Ebadii         Syegehur       Nurey          Esue           Eorigur        Yoquc          Jesagulok      Biyex          Kibec          Kovoneo        Yreo           Dasea          Dyza           Bolirx         Halouka        Selukani       Xemarum        Tysezu         Numozybalon    Atir           Xis            Casejo         Uwal           Udizei         Ijayti         Ira            Uvest          Siopeleris     Nymid          Uretie         Kurosori       Ymilo          Bodio          Medoz          Ygiree         Meozovor       Ejocia         Tatupee        Hajuzikua      Onarudea       Abegio         Goi            Yulazico       Zohua          Ypuxol         Ozexu          Nalityr        Acoma          Gueza          Yxur           Losal          Kiquex         Qulua          Moileae        Tehg           Okohyre        Yusivo         Udr            Oydyso         Ulomoe         Naberoa        Rilanoe        Acexes         Aadyen         Usinyri        Omelid         Kazutejuresi   Mujecidu       Leanosi        Uzices         Kuxete         Aledakeo       Jarodusaex     Juyro          Zamikusa       Gumuk          Zitu           Nipekis        Dahh           Deysurom       Nomubetiki     Xedasa         Yolit          Bavidum        Uhar           Vopoca         Beliock        Huak           Esapon         Lakawn         Setocas        Yut            Uld            Uroit          Asiln          Ytol           Tebesyi        Ohydee         Vibezu         Bynepecia      Igua           Utareo         Ejemok         Oetasa         Ycies          Okek           Kegufaca       Uteh           Izu            Upakeny        Acumizen       Agoila         Ixyul          Toi            Upulehet       Bodahetii      Hycoh          Tapei          Kufenu         Kyriro         Nydopik        Ojes           Jusuca         Befua          Apecyla        Korar          Lusasek        Ulm            Yoxud          Dyziryn        Mutoizo        Ologuru        Nalokie        Docix          Volyg          Agopev         Pyhure         Oozier         Nujeu          Icuda          Basuk          Misotapoma     Sejia          Ugoma          Xarala         Typopoxa       Titran         Akozadi        Zybud          Uzea           Akolixyie      Leree          Gisoan         Zeeso          Exolay         Gelyi          Olymezau       Econu          Favisinia      Ugalyels       Vokixe         Kulusu         Iyroosu        Iviho          Yabu           Sozuj          Kiwusia        Acedyi         Denonemi       Iuzeheko       Quez           Bosuk          Peur           Zeresa         Bilyo          Unutae         Luahak         Soekehul       Elonou         Wufexel        Ehugulevyx     Sewa           Zamyfanil      Etepity        Horotay        Leput          Bucopaa        Mokana         Joha           Qubikyes       Sielay         Raquzelo       Somaxale       Niradikupe     Byxuok         Xekihl         Fadero         Nefod          Oleld          Misatexake     Fyraug         Johya          Xyziryu        Kyina          Kegeneyu       Ivei           Dei            Cogyezan       Kaduyo         Ifamy          Eneboi         Siginofy       Ozakat         Jafyifi        Bacohu         Juzole         Cuxoe          Rogao          Nelupea        Yroladr        Guoi           Acipoa         Sugyade        Hysuva         Tugilex        Ucebi          Oza Qui        Ixihi          Gojei          Vugi           Mumiot         Rujid          Rydukado       Ymyek          Mizon          Xolas          Zarang         Lotig          Medulaz        Dumu           Vetule         Dyiluck        Keketi         Jegavesy       Tyfolan        Supougea       Ruekere        Kaxefu         Umx            Xute           Syxiapara      Axylai         Solylya        Enaw           Idulo          Sypigane       Yzetc          Ahemebg        Vediab         Doha           Lixasie        Cyxr           Eninai         Oyzu           Ecazoxa        Dyte           Ijouroa        Cypir          Azeu           Yug            Yunumiraz      Qulu           Cexor          Ugo            Jivizea        Cyei           Yapac          Ylari          Kusoas         Muze           Arusavie       Nudek          Iupe           Mezuk          Ymiek          Uniciu         Urec           Oxuxeo         Goy            Hemuxorua      Tecenatea      Kort           Yaxot          Metivux        Ilecy          Idaru          Aylox          Bygo           Orevoulo       Ejusay         Folum          Tefron         Xyresue        Taxua          Utass          Ygui           Erevato        Kocei          Dyroluz        Yexi           Evanio         Ymen           Yusell         Uhan           Etaro          Nat            Murapasi       Bavuza         Evoa           Typyhl         Uwek           Septid         Bazogs         Yzes           Tylavi         Nark Nark      Yluo           Kunolud        Yden           Recott         Wilaree        Xush           Oydug          Zyloque        Zyeng          Nodupi         Eberefezi      Etuse          Sepolacee      Univeru        Golo           Giusi          Emaus          Isice          Itys           Mokoi          Xepeu          Unom           Oobulest       Zunx           Sunic          Sigustus       Iroqua         Enadi          Toveco         Zysteu         Buxae          Muog           Lurth          Ogadi          Ubadulst       Sual           Amaozar        Ineaxur        Okahit         Enualeru       Xurez          Edosk          Meconae        Enizp          Axust          Ylen           Baalyod        Gaxoduse       Choizesas      Zege           Amulat         Ohel           Atans          Brunixe        Ehefuna        Naumz          Rayelyn        Izoe           Urnst          Ykoi           Sygunda        Dozuvain       Bolz           Livalx         Robiamahiza    Thuvahexash    Cyduka         Nabik          Methelusda     Ilisk          Xozodesiu      Evuria         Nulp           Qumexi         Alux           Jedavoy        Osazory        DaneMbyom      Gepaliv        Coazest        Aluga          Zoder          Yiver          Kufish         Inyrax         Yzihad         Nemi           Xuer           Unyki          Xao            Alinoa         Pyjicur        Medumar        Xyry           Iyesyrilui     Kuhoru         Abvoring       Obeju          Voke           Bazt           Yrifa          Fanexi         Aleyl          Nilaciast      Bielest        Mocor          Dienth         Tralam         Deisto         Mipeth Dio     Samtra         Kelrith        Jentrix        FiMindro       Deltrigh       Iandosomn      Thezinorag     Ost Yln        Ag Lin Omfeo   Goalst         Astrinog       Divesti        Promloth       Voytra         Est Janellpu   Ghot           Umbra          Urnst          Mlerne         Termig         Othlos         Bleghim        Zy Aglom       Quweri         
\ No newline at end of file
diff --git a/data/scan.dta b/data/scan.dta
deleted file mode 100644
index 982a3c1..0000000
Binary files a/data/scan.dta and /dev/null differ
diff --git a/dmp/_669load.pas b/dmp/_669load.pas
deleted file mode 100644
index 753bc7f..0000000
--- a/dmp/_669load.pas
+++ /dev/null
@@ -1,380 +0,0 @@
-(***************************************************************************
-
-                                 _669LOAD.PAS
-                                 ------------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-load669 and ampLoad669 functions
-Original C version by Otto Chrons
-
-***************************************************************************)
-
-Unit _669Load; {$I-,X+}
-
-{$O+}
-
-Interface
-Uses MCP,AMP,Loaders,CSupport;
-
-Function Load669(Var File_:File;Var Module_:PModule):Integer;
-Function ampLoad669(name:String;options:longint):PModule;
-
-Implementation
-{$IFDEF USE_EMS}
-uses emhm;
-{$ENDIF}
-
-Const order8            : array[0..7] of shortint =
-        (PAN_LEFT,PAN_RIGHT,PAN_LEFT,PAN_RIGHT,PAN_LEFT,PAN_RIGHT,PAN_LEFT,PAN_RIGHT);
-
-      Basic_Freq        = 8368;
-
-Type THeader669         = Record
-                            magic       : word;
-                            message     : Array[0..107] of char;
-                            ins,pats,
-                            loop        : byte;
-                            orders,tempos,
-                            breaks      : array[0..127] of byte;
-                          end;
-
-Var curTrack            : Integer;
-    patUsed             : Array[0..255] of byte;
-    module              : PModule;
-    f                   : File;
-    hdr                 : THeader669;
-    lastChan            : Integer;
-
-Function loadHeader(var f:file):Integer;
-var t,count,i  : Integer;
-    pat        : PPattern;
-begin
-  seek(f,0);
-  blockread(f,hdr,sizeof(hdr));
-  module^.channelCount:=8;
-  move(order8,module^.channelPanning,8);
-  module^.tempo:=80;
-  module^.speed:=4;
-  count:=0;
-  while (count<128) and (hdr.orders[count]<128) do inc(count);
-  module^.patternCount:=count;
-  module^.patterns:=calloc(count,sizeof(TPattern));
-  if module^.patterns=nil then begin
-    loadHeader:=MERR_MEMORY;
-    exit;
-  end;
-  inc(module^.size,count*sizeof(TPattern));
-  for t:=0 to count-1 do begin
-    patUsed[hdr.orders[t]]:=1;
-    pat:=addr(module^.patterns^[t]);
-    pat^.length:=64;
-    for i:=0 to 7 do pat^.tracks[i]:=
-      pointer(byte(hdr.orders[t]<>$ff)*(hdr.orders[t]*8+1+i));
-  end;
-  loadHeader:=MERR_NONE;
-end;
-
-function findBT(pat:integer):word;
-var i,t:integer;
-begin
-  for t:=0 to module^.patternCount-1 do
-    if hdr.orders[t]=pat then begin
-      findBT:=hdr.tempos[t];
-      exit;
-    end;
-  findBT:=0;
-end;
-
-type TIns669 = Record
-       name                     : array[0..12] of char;
-       length,loopstart,loopend : longint;
-     end;
-
-Function loadInstruments(Var f:File):Integer;
-Var t,i,a,b      : Word;
-    ins          : TIns669;
-    instr        : PInstrument;
-
-Begin
-  With Module^ do begin
-    instrumentCount:=hdr.ins;
-    instruments:=calloc(hdr.ins,sizeof(TInstrument));
-    If instruments=Nil then begin loadInstruments:=MERR_MEMORY; exit end;
-    Size:=Size+instrumentCount*sizeof(TInstrument);
-    for t:=0 to hdr.ins-1 do begin
-      Blockread(f,ins,sizeof(TIns669),a);
-      if a<>sizeOf(TIns669) then begin loadInstruments:=MERR_FILE; exit end;
-      instr:=@instruments^[t];
-      instr^.insType:=0;
-      strcpy(instr^.name,ins.name);
-      instr^.name[13]:=#0;
-      strcpy(instr^.filename,ins.name);
-      instr^.filename[12]:=#0;
-      instr^.rate:=BASIC_FREQ;
-      instr^.volume:=64;
-      instr^.size:=ins.length;
-      instr^.loopstart:=ins.loopstart;
-      instr^.loopend:=byte(ins.loopend<=ins.length)*ins.loopend;
-      instr^.sample:=nil;
-    end;
-  end;
-  loadInstruments:=MERR_NONE;
-end;
-
-Type TRow669 = Record
-       b1,b2,b3 : Byte;
-      end;
-
-Function loadPatterns(var f:file):Integer;
-Var pos,row,t,j,a,i,chan,tick,curTrack              : Integer;
-    note,ins,volume,command,data,curins,curvolume,b : byte;
-    bt,nvalue,count,volsld,breakat,tempo            : word;
-    track                                           : PTrack;
-    temptrack                                       : Array[0..575] of byte;
-    buffer                                          : Array[0..63,0..7] of TRow669;
-    c                                               : TRow669;
-
-Procedure insertNote(a,b:integer);
-Begin
-  temptrack[pos*3]:=tick;
-  temptrack[pos*3+1]:=a;
-  temptrack[pos*3+2]:=b;
-  inc(pos);
-end;
-
-Procedure insertCmd(a,b:integer);
-Begin
-  temptrack[pos*3]:=tick;
-  temptrack[pos*3+1]:=a;
-  temptrack[pos*3+2]:=b;
-  inc(pos);
-end;
-
-Begin
-  curTrack:=1;
-  count:=hdr.pats*8;
-  module^.trackCount:=count;
-  module^.tracks:=calloc(count+4,sizeof(PTrack));
-  if module^.tracks=nil then begin loadPatterns:=MERR_MEMORY; exit end;
-  inc(module^.size,(count+4)*sizeof(PTrack));
-  for t:=0 to hdr.pats-1 do begin
-    tempo:=findBT(t);
-    blockread(f,buffer,64*8*3,j);
-    if j<>64*8*3 then begin loadPatterns:=MERR_FILE; exit end;
-    for j:=0 to 7 do begin
-      fillchar(temptrack,576,$ff);
-      pos:=0;
-      curins:=$f0;
-      for tick:=0 to 63 do begin
-        if (tick=0) and (j=0) and (tempo<>0) then begin
-          insertCmd(cmdTempo,tempo);
-          insertCmd(cmdExtTempo,80);
-        end;
-        if (tick=hdr.breaks[t]) and (j=0) and (tick<>63) then insertCmd(cmdBreak,0);
-        note:=0;
-        volume:=$ff;
-        ins:=$ff;
-        c:=buffer[tick,j];
-        if c.b1<$fe then begin
-          note:=c.b1 shr 2;
-          ins:=((c.b1 and $3) shl 4) or (c.b2 shr 4);
-          if ins<>curIns then begin
-            curIns:=ins;
-            insertCmd(cmdInstr,ins);
-            module^.instruments^[ins].insType:=1;
-          end;
-        end;
-        if c.b1<$ff then volume:=c.b2 and $f;
-        command:=c.b3 shr 4;
-        data:=c.b3 and $f;
-        if command=2 then insertCmd(cmdBenderTo,data);
-        if note<>0 then begin
-          if volume<>$ff then insertNote(note+36,volume*4) else
-            insertNote(note+36,255);
-        end else if volume<>$ff then insertCmd(cmdVolumeAbs,volume*4);
-        case command of
-          0 : insertCmd(cmdBender,data);
-          1 : insertCmd(cmdBender,-data);
-          3 : insertCmd(cmdFinetune,-1);
-          4 : insertCmd(cmdVibrato,data shl 4+1);
-          5 : insertCmd(cmdTempo,data);
-        end;
-      end;
-      if pos=0 then track:=nil else begin
-        inc(pos);
-        if loadOptions and LM_IML>0 then for i:=1 to curTrack-1 do
-          if module^.tracks^[i]<>nil then
-            if (module^.tracks^[i]^.size=pos) and
-               (memcmp(@temptrack,pointer(longint(module^.tracks^[i])+3),pos*3)=0) then begin
-              track:=module^.tracks^[i];
-              pos:=0;
-              i:=curTrack-1;
-            end;
-        if pos<>0 then begin
-          track:=malloc(pos*3+3);
-          if track<>nil then begin
-            inc(module^.size,pos*3+3);
-            track^.size:=pos;
-            track^.trkType:=0;
-            move(temptrack,pointer(longint(track)+3)^,pos*3);
-          end else begin loadPatterns:=MERR_MEMORY; exit end;
-        end;
-      end;
-      module^.tracks^[curTrack]:=track;
-      inc(curTrack);
-    end;
-  end;
-  loadPatterns:=MERR_NONE;
-end;
-
-Function loadSamples(var f:file):integer;
-Var t,i           : Word;
-    instr         : PInstrument;
-    length,a,b    : Longint;
-    sample        : Pointer;
-{$IFDEF USE_EMS}
-    handle        : TEMSH;
-{$ENDIF}
-Label cont;
-Begin
-  seek(f,longint($1f1)+longint(hdr.ins)*longint(sizeof(TIns669))+longint(hdr.pats)*longint($600));
-  for t:=0 to hdr.ins-1 do begin
-    instr:=@module^.instruments^[t];
-    length:=instr^.size;
-    if (length>0) and (instr^.insType=1) then begin
-      a:=instr^.loopend-instr^.loopstart;
-      if (instr^.loopend<>0) and (a<crit_size) then begin
-        b:=(Crit_Size div a)*a;
-        instr^.loopend:=instr^.loopstart+b;
-        loadSamples:=MERR_MEMORY;
-        instr^.sample:=malloc(instr^.loopend+16);
-        if instr^.sample=nil then exit;
-        inc(module^.size,instr^.loopend);
-        if instr^.size>instr^.loopend then begin
-          loadSamples:=MERR_FILE;
-          blockread(f,instr^.sample^,instr^.loopend);
-          if IOresult<>0 then exit;
-          seek(f,filepos(f)+instr^.size-instr^.loopend);
-        end else begin
-          loadSamples:=MERR_FILE;
-          blockread(f,instr^.sample^,instr^.size);
-          if IOresult<>0 then exit;
-        end;
-        instr^.size:=instr^.loopend;
-        for i:=1 to (Crit_Size div a)-1 do
-          move(pointer(longint(instr^.sample)+instr^.loopstart)^,
-               pointer(longint(instr^.sample)+instr^.loopstart+a*i)^,a);
-      end else begin
-        if instr^.insType<>1 then begin
-          seek(f,length+filepos(f));
-          goto cont;
-        end;
-        inc(module^.size,length);
-        instr^.sample:=malloc(length);
-        loadSamples:=MERR_MEMORY;
-        if instr^.sample=nil then exit;
-        loadSamples:=MERR_CORRUPT;
-        blockread(f,instr^.sample^,length);
-        if IOresult<>0 then exit;
-{$IFDEF USE_EMS}
-        handle:=0;
-        if instr^.size>2048 then begin
-          handle:=emsAlloc(instr^.size);
-          if handle>0 then begin
-            emsCopyTo(handle,instr^.sample,0,instr^.size);
-            free(instr^.sample);
-            instr^.sample:=ptr($ffff,handle);
-          end;
-        end;
-{$ENDIF}
-      end;
-    end else begin
-      seek(f,instr^.size+filepos(f));
-      instr^.size:=0;
-      instr^.sample:=nil;
-    end;
-cont:
-  end;
-  loadSamples:=MERR_NONE;
-end;
-
-Procedure joinTracks2Patterns(var module:PModule);
-Var t,i     : Word;
-    pat     : PPattern;
-Begin
-  for t:=0 to module^.patternCount-1 do begin
-    pat:=@module^.patterns^[t];
-    for i:=0 to module^.channelCount-1 do
-      pat^.tracks[i]:=module^.tracks^[word(pat^.tracks[i])];
-  end;
-end;
-
-Function load669;
-var a:integer;
-Begin
-  module:=module_;
-  module^.size:=0;
-  lastChan:=0;
-  a:=loadHeader(file_);
-  load669:=a;
-  if a<>MERR_NONE then exit;
-  a:=loadInstruments(file_);
-  load669:=a;
-  if a<>MERR_NONE then exit;
-  a:=loadPatterns(file_);
-  load669:=a;
-  if a<>MERR_NONE then exit;
-  a:=loadSamples(file_);
-  load669:=a;
-  if (a<>MERR_NONE) and (a<>MERR_CORRUPT) then exit;
-  joinTracks2Patterns(module);
-  load669:=a;
-end;
-
-Function ampLoad669(name:String;options:longint):PModule;
-Var f:file;
-    l:longint;
-    module:PModule;
-    b:Integer;
-begin
-  loadOptions:=options;
-  module:=malloc(sizeof(TModule));
-  if module=nil then begin
-    moduleError:=MERR_MEMORY;
-    ampLoad669:=nil;
-    exit;
-  end;
-  fillchar(module^,0,sizeof(module^));
-  assign(f,name);
-  reset(f,1);
-  if IOresult<>0 then begin
-    moduleError:=MERR_FILE;
-    ampLoad669:=nil;
-    exit;
-  end;
-  module^.modType:=MOD_NONE;
-  seek(f,0);
-  blockread(f,b,2);
-  if b<>$6669 then begin
-    moduleError:=MERR_TYPE;
-    free(module);
-    ampLoad669:=nil;
-    exit;
-  end;
-  blockread(f,module^.name,32);
-  module^.name[31]:=#0;
-  moduleError:=load669(f,module);
-  if moduleError=MERR_NONE then begin
-    module^.modType:=MOD_669;
-    module^.filesize:=filesize(f)
-   end else begin
-    ampFreeModule(module);
-    free(module);
-    module:=nil;
-  end;
-  close(f);
-  ampLoad669:=module;
-end;
-
-end.
diff --git a/dmp/_669load.tpp b/dmp/_669load.tpp
deleted file mode 100644
index 15603e4..0000000
Binary files a/dmp/_669load.tpp and /dev/null differ
diff --git a/dmp/amfload.pas b/dmp/amfload.pas
deleted file mode 100644
index aff239f..0000000
--- a/dmp/amfload.pas
+++ /dev/null
@@ -1,234 +0,0 @@
-(***************************************************************************
-
-                                 AMFLOAD.PAS
-                                 -----------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-loadAMF and ampLoadAMF functions
-Original C version by Otto Chrons
-
-***************************************************************************)
-
-Unit AMFload;  {$I-,X+}
-
-{$O+}
-
-Interface
-Uses AMP,Loaders,Csupport;
-
-Function LoadAMF(Var f:File;Var Module:PModule):Integer;
-Function ampLoadAMF(name:String;options:longint):PModule;
-
-Implementation
-{$IFDEF USE_EMS}
-uses emhm;
-{$ENDIF}
-
-type TOldInstrument = record
-       t           : byte;
-       name        : array[0..31] of char;
-       filename    : array[0..12] of char;
-       sample      : pointer;
-       size        : word;
-       rate        : word;
-       volume      : byte;
-       loopstart,
-       loopend     : word;
-     end;
-
-const order16 : array[0..15] of shortint = (PAN_LEFT,PAN_RIGHT,PAN_RIGHT,PAN_LEFT,PAN_LEFT,PAN_RIGHT,PAN_RIGHT,PAN_LEFT,
-				            PAN_LEFT,PAN_RIGHT,PAN_RIGHT,PAN_LEFT,PAN_LEFT,PAN_RIGHT,PAN_RIGHT,PAN_LEFT);
-
-Procedure joinTracks2Patterns(Var Module:PModule);
-Var t,i   : Integer;
-    pat   : PPattern;
-Begin
-  For t:=0 to Module^.PatternCount-1 do begin
-    pat:=@Module^.patterns^[t];
-    for i:=0 to Module^.ChannelCount-1 do
-      if module^.trackCount<word(pat^.tracks[i]) then pat^.tracks[i]:=nil else
-        pat^.tracks[i]:=Module^.tracks^[word(pat^.tracks[i])];
-  end;
-end;
-
-Function loadAMF(var f:file; var module:PModule):Integer;
-Type sh              = Array[0..32000] of word;
-Var a,t,i,pan        : Integer;
-    sample           : ^sh;
-    tracks           : ^sh;
-    l                : longint;
-    track            : PTrack;
-    Smp              : Pointer;
-    oldIns           : Boolean;
-    oi               : TOldInstrument;
-    instr            : TInstrument;
-{$IFDEF USE_EMS}
-    handle           : TEMSH;
-{$ENDIF}
-Const insPtr         : Integer = 0;
-      size           : Integer = 0;
-      trckPtr        : Integer = 0;
-
-Begin
-  size:=0;
-  trckPtr:=0;
-  insPtr:=0;
-  module^.tempo:=125;
-  module^.speed:=6;
-  Seek(f,0);
-  Blockread(f,l,4);
-  BLockread(f,module^.name,32);
-  loadAMF:=MERR_TYPE;
-  oldIns:=true;
-  if l=$0C464D41 then pan:=32 else pan:=16;
-  if l=$01464D41 then size:=3 else
-  if l>=$0A464D41 then oldIns:=false else
-  if (l<>$08464D41) and (l<>$09464D41) then exit;
-  Blockread(f,module^.instrumentCount,1);
-  Blockread(f,module^.patternCount,1);
-  Blockread(f,module^.trackCount,2);
-  if l>=$09464D41 then begin
-    blockread(f,module^.channelCount,1);
-    blockread(f,module^.channelPanning,pan);
-    if l<$0B464D41 then move(order16,module^.channelPanning,16);
-  end;
-  loadAMF:=MERR_MEMORY;
-  module^.patterns:=calloc(module^.patternCount,sizeof(TPattern));
-  if module^.patterns=nil then exit;
-  module^.instruments:=calloc(module^.instrumentCount,sizeof(TInstrument));
-  if module^.instruments=nil then exit;
-  module^.tracks:=calloc(module^.trackCount+4,sizeof(pointer));
-  if module^.tracks=nil then exit;
-  module^.size:=module^.size+module^.patternCount*sizeof(TPattern)+
-                             module^.instrumentCount*sizeof(TInstrument)+
-                             module^.trackCount*sizeof(pointer);
-  for t:=0 to module^.patternCount-1 do
-    for i:=0 to module^.channelCount-1 do
-      blockread(f,module^.patterns^[t].tracks[i],2);
-  sample:=calloc(module^.instrumentCount,sizeof(word));
-  for t:=0 to module^.instrumentCount-1 do begin
-    if oldIns then begin
-      blockread(f,oi,sizeOf(TOldInstrument));
-      move(oi,module^.instruments^[t],sizeOf(TOldInstrument));
-      with module^.instruments^[t] do begin
-        size:=oi.size;
-        rate:=oi.rate;
-        volume:=oi.volume;
-        loopstart:=oi.loopstart;
-        loopend:=oi.loopend;
-        if loopend=65535 then loopend:=0;
-      end;
-    end else blockread(f,module^.instruments^[t],sizeof(TInstrument));
-    if Integer(module^.instruments^[t].sample)>insPtr then begin
-      sample^[insPtr]:=module^.instruments^[t].size;
-      inc(insPtr);
-    end;
-  end;
-  tracks:=calloc(module^.trackCount,sizeof(Word));
-  for t:=0 to module^.trackCount-1 do begin
-    blockread(f,tracks^[t],2);
-    if tracks^[t]>trckPtr then trckPtr:=tracks^[t];
-  end;
-
-  for i:=1 to module^.trackCount do
-    module^.tracks^[i]:=nil;
-  for t:=0 to trckPtr-1 do begin
-    Blockread(f,a,2);
-    Blockread(f,i,1);
-    if a=0 then track:=nil else begin
-      track:=malloc(3*a+6);
-      loadAMF:=MERR_MEMORY;
-      if track=nil then exit;
-      inc(module^.size,3*a+6);
-      track^.trkType:=0;
-      track^.size:=a;
-      blockread(f,track^.notes,a*3+size);
-    end;
-    for i:=0 to module^.trackCount-1 do
-      if tracks^[i]=t+1 then module^.tracks^[i+1]:=track;
-  end;
-
-  for t:=0 to insPtr-1 do begin
-    if sample^[t]>0 then begin
-      smp:=malloc(sample^[t]+16);
-      loadAMF:=-1;
-      if smp=nil then exit;
-      inc(module^.size,sample^[t]+16);
-      blockread(f,smp^,sample^[t]);
-      loadAMF:=-2;
-      if IOresult<>0 then exit;
-{$IFDEF USE_EMS}
-      handle:=0;
-      if sample^[t]>2048 then begin
-        handle:=emsAlloc(sample^[t]);
-        if handle>0 then begin
-          emsCopyTo(handle,smp,0,sample^[t]);
-          free(smp);
-          smp:=ptr($ffff,handle);
-        end;
-      end;
-{$ENDIF}
-      for i:=0 to module^.instrumentCount-1 do
-        if (word(module^.instruments^[i].sample)=t+1) and
-           (longint(module^.instruments^[i].sample) and $FFFF0000=0) then
-             module^.instruments^[i].sample:=smp;
-    end;
-  end;
-  for i:=0 to module^.instrumentCount-1 do
-    if longint(module^.instruments^[i].sample) and $FFFF0000=0 then
-       module^.instruments^[i].sample:=nil;
-  jointracks2Patterns(module);
-  free(pointer(sample));
-  free(pointer(tracks));
-  loadAMF:=MERR_NONE;
-End;
-
-Function ampLoadAMF(name:String;options:longint):PModule;
-var f         : file;
-    l         : longint;
-    module    : PModule;
-    t,b       : integer;
-
-begin
-  ampLoadAMF:=nil;
-  loadOptions:=options;
-  module:=malloc(sizeof(TModule));
-  if module=nil then begin
-    moduleError:=MERR_Memory;
-    exit;
-  end;
-  fillchar(module^,sizeof(TModule),0);
-  assign(f,name);
-  reset(f,1);
-  if IOresult<>0 then begin
-    moduleError:=MERR_File;
-    exit;
-  end;
-  seek(f,0);
-  blockread(f,l,4);
-  if (l=$01464D41) or (l=$08464D41) or (l=$09464D41) or (l=$0a464D41) or (l=$0b464D41) then begin
-    module^.modType:=MOD_AMF;
-    blockread(f,module^.name,20);
-    module^.name[20]:=#0;
-    if (l=$01464D41) or (l=$08464D41) then begin
-      module^.channelCount:=4;
-      move(order4,module^.channelPanning,4);
-    end;
-  end else begin
-    module^.modType:=MOD_NONE;
-    moduleError:=MERR_Type;
-    exit;
-  end;
-  b:=loadAMF(f,module);
-  moduleError:=b;
-  if b=MERR_None then module^.filesize:=filesize(f) else begin
-    ampFreeModule(module);
-    free(module);
-    module:=nil;
-  end;
-  close(f);
-  ampLoadAMF:=module;
-end;
-
-end.
diff --git a/dmp/amfload.tpp b/dmp/amfload.tpp
deleted file mode 100644
index 25d7b2b..0000000
Binary files a/dmp/amfload.tpp and /dev/null differ
diff --git a/dmp/amp.inc b/dmp/amp.inc
deleted file mode 100644
index b7c7307..0000000
--- a/dmp/amp.inc
+++ /dev/null
@@ -1,235 +0,0 @@
-;/************************************************************************
-; *
-; *     File        :   AMP.INC
-; *     Description :   Definitions for Advance Module Player assembly code
-; *
-; *     Copyright (C) 1992 Otto Chrons
-; *
-; ***********************************************************************/
-
-    AMP_INTERRUPT       = 1
-    AMP_MANUAL          = 0
-
-    MAXTRACKS   = 32
-
-    MOD_NONE    = 0
-    MOD_MOD     = 1
-    MOD_STM     = 2
-    MOD_AMF     = 3
-
-    PLAYING     = 1
-    PAUSED      = 2
-    MANUAL      = 4
-
-    PM_LOOP     = 1
-    TEMPO_STM   = 64
-    TEMPO_MOD   = 64
-    SAMPLE_CONTINUE = 1
-
-STRUC S_SAMPLEINFO                      ; Sample structure
-    sample      DD ?
-    length      DD ?
-    loopstart   DD ?
-    loopend     DD ?
-    mode        DB ?
-    sampleID    DW ?
-    orgrate     DW ?
-    rate        DD ?
-    volume      DB ?
-ENDS
-
-STRUC S_TRACKDATA
-    status      DW ?
-    note        DB ?
-    instrument  DB ?
-    velocity    DB ?
-    playtime    DW ?
-    command     DB ?
-    cmdvalue    DB ?
-    panning     DB ?
-ENDS
-
-STRUC S_MODULE
-    type                DB ?
-    size                DD ?
-    filesize            DD ?
-    mname               DB 32 dup(?)
-    channelCount        DB ?
-    channelPanning      DB MAXTRACKS dup(?)
-    instrumentCount     DB ?
-    instruments         DD ?
-    patternCount        DB ?
-    patterns            DD ?
-    trackCount          DW ?
-    tracks              DD ?
-    tempo               DB ?
-    speed               DB ?
-ENDS
-
-STRUC S_NOTE
-    timesig             DB ?
-    note                DB ?
-    velocity            DB ?
-ENDS
-
-STRUC S_MODCMD
-    timesig             DB ?
-    cmd                 DB ?
-    data                DB ?
-ENDS
-
-STRUC S_TRACK
-    size                DW ?
-    type                DB ?
-    note                S_NOTE <>
-ENDS
-
-STRUC S_PATTERN
-    length              DW ?
-    track               DD MAXTRACKS dup(?)
-ENDS
-
-STRUC S_INSTRUMENT
-    type                DB ?
-    insname             DB 32 dup(?)
-    filename            DB 13 dup(?)
-    sample              DD ?
-    size                DD ?
-    rate                DW ?
-    volume              DB ?
-    loopstart           DD ?
-    loopend             DD ?
-ENDS
-
-STRUC S_NOTEINFO
-    note                DB ?
-    instrument          DB ?
-    velocity            DB ?
-    played              DW ?
-    noteold             DW ?
-ENDS
-
-STRUC S_CMDINFO
-    command             DB ?
-    value               DB ?
-    bendervalue         DW ?
-    benderAdd           DB ?
-    benderCmd           DB ?
-    benderCmd2          DB ?
-    arpeggio1           DD ?
-    arpeggio2           DD ?
-    arpeggio3           DD ?
-    arpeggioPtr         DB ?
-    vibratoPos          DB ?
-    vibratoCmd          DB ?
-    tremoloCmd          DB ?
-    tremoloSpeed        DB ?
-    tremoloValue        DB ?
-    tremoloPos          DB ?
-    offsetValue         DB ?
-    delayValue          DB ?
-    delayNote           DB ?
-ENDS
-
-STRUC S_TRACKINFO
-    track               DD ?
-    pos                 DW ?
-    status              DW ?
-    note                S_NOTEINFO <?>
-    cmd                 S_CMDINFO <?>
-    pan                 DB ?
-ENDS
-
-STRUC S_PLAYINFO
-    initOptions         DW ?
-    status              DB ?
-    options             DW ?
-    firstPattern        DB ?
-    lastPattern         DB ?
-    pattern             DB ?
-    track               DB ?
-    ticks               DW ?
-    row                 DW ?
-    cmdcount            DB ?
-    patterndata         DD ?
-    instrdata           DD ?
-    tempo               DB ?
-    extTempo            DB ?
-    tempovalue          DB ?
-    sync                DB ?
-    break               DB ?
-    timerValue          DW ?
-    timerCount          DW ?
-    channelCount        DW ?
-    channelPanning      DB MAXTRACKS dup(?)
-ENDS
-
-;ENUM commandEnum \
-;        cInstr = 0,\
-;        cTempo,\
-;        cVolume,\
-;        cVolumeAbs,\
-;        cBender,\
-;        cBenderAbs,\
-;        cBenderTo,\
-;        cTremolo,\
-;        cArpeggio,\
-;        cVibrato,\
-;        cBenderVol,\
-;        cVibrVol,\
-;        cBreak,\
-;        cGoto,\
-;        cSync,\
-;        cRetrig,\
-;        cOffset,\
-;        cFinevol,\
-;        cFinetune,\
-;        cDelayNote,\
-;        cNoteCut,\
-;        cExtTempo,\
-;        cExtraFineBender,\
-;        cPan,\
-;        cLast
-   cInstr          = 0
-   cTempo          = 1
-   cVolume         = 2
-   cVolumeAbs      = 3
-   cBender         = 4
-   cBenderAbs      = 5
-   cBenderTo       = 6
-   cTremolo        = 7
-   cArpeggio       = 8
-   cVibrato        = 9
-   cBenderVol      = 10
-   cVibrVol        = 11
-   cBreak          = 12
-   cGoto           = 13
-   cSync           = 14
-   cRetrig         = 15
-   cOffset         = 16
-   cFinevol        = 17
-   cFinetune       = 18
-   cDelayNote      = 19
-   cNoteCut        = 20
-   cExtTempo       = 21
-   cExtraFineBender= 22
-   cPan            = 23
-   cLast           = 24
-
-
-
-
-MACRO   checkInit
-        RETVAL  -1
-        test    [ampStatus],1
-        jz      @@exit
-ENDM
-
-MACRO   calcTrack
-        cmp     [@@track],MAXTRACKS
-        jae     @@exit
-        mov     ebx,[@@track]
-        shl     _bx,1
-        mov     bx,[_bx+trackPtr]
-ENDM
-
diff --git a/dmp/amp.pas b/dmp/amp.pas
deleted file mode 100644
index 8101c5b..0000000
--- a/dmp/amp.pas
+++ /dev/null
@@ -1,337 +0,0 @@
-(****************************************************************************
-
-                                   AMP.PAS
-                                   -------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-Turbo/Borland pascal unit header file for AMP.
-Original C header by Otto Chrons
-
-****************************************************************************)
-
-Unit AMP;
-
-{$A+,B-,D+,E+,F+,G+,I+,L+,N-,O-,R-,S+,V+,X-,M 16384,0,655360}
-
-Interface
-Uses MCP,CDI;
-
-Const cmdInstr           = $80;
-      cmdTempo           = $81;
-      cmdVolume          = $82;
-      cmdVolumeAbs       = $83;
-      cmdBender          = $84;
-      cmdBenderAbs       = $85;
-      cmdBenderTo        = $86;
-      cmdTremolo         = $87;
-      cmdArpeggio        = $88;
-      cmdVibrato         = $89;
-      cmdToneVol         = $8A;
-      cmdVibrVol         = $8B;
-      cmdBreak           = $8C;
-      cmdGoto            = $8D;
-      cmdSync            = $8E;
-      cmdRetrig          = $8F;
-      cmdOffset          = $90;
-      cmdFinevol         = $91;
-      cmdFinetune        = $92;
-      cmdNoteDelay       = $93;
-      cmdNoteCut         = $94;
-      cmdExtTempo        = $95;
-      cmdExtraFineBender = $96;
-      cmdPan             = $97;
-
-      Crit_Size          = 256;
-
-      AMP_Interrupt      = 1;
-      AMP_Manual         = 0;
-
-      MOD_None           = 0;
-      MOD_MOD            = 1;
-      MOD_STM            = 2;
-      MOD_AMF            = 3;
-      MOD_15             = 4;
-      MOD_TREK           = 5;
-      MOD_S3M            = 6;
-      MOD_669            = 7;
-      MOD_MTM            = 8;
-
-      MERR_NONE          = 0;
-      MERR_MEMORY        = -1;
-      MERR_FILE          = -2;
-      MERR_TYPE          = -3;
-      MERR_CORRUPT       = 1;
-
-      LM_IML             = 1;
-      LM_OLDTEMPO        = 2;
-
-      PM_Loop            = 1;
-
-      TR_Paused          = 2;
-
-      MD_Playing         = 1;
-      MD_Paused          = 2;
-
-      Max_Tracks         = 32;
-
-      AMP_Timer          = 1193180 div 100;
-      PAN_Left           = -63;
-      PAN_Right          = 63;
-      PAN_Middle         = 0;
-      PAN_Surround       = 100;
-
-
-Type  PNote            = ^TNote;
-      TNote            = Record
-                           TimeSig          : Byte;
-                           Note             : Byte;
-                           Velocity         : Byte;
-                         End;
-
-      PCommand         = ^TCommand;
-      TCommand         = Record
-                           timeSig          : Byte;
-                           command          : Byte;
-                           value            : Byte;
-                         End;
-
-      PTrack           = ^TTrack;
-      TTrack           = Record
-                           Size             : Word;
-                           trkType          : Byte;
-                           Notes            : Array[0..0] of TNote;
-                         End;
-
-      PPattern         = ^TPattern;
-      TPattern         = Record
-                           Length           : Integer;
-                           Tracks           : Array[0..Max_Tracks-1] of PTrack;
-                         end;
-
-      PInstrument      = ^TInstrument;
-      TInstrument      = Record
-                           insType          : Byte;
-                           Name             : Array[0..31] of char;
-                           Filename         : Array[0..12] of char;
-                           Sample           : Pointer;
-                           Size             : Longint;
-                           Rate             : Word;
-                           Volume           : Byte;
-                           Loopstart,
-                           Loopend          : Longint;
-                         End;
-
-      AMTracks         = Array[0..15999] of PTrack;
-      AMInstr          = Array[0..(65520 div sizeof(TInstrument)-1)] of TInstrument;
-      AMPattern        = Array[0..(65520 div sizeof(TPattern)-1)] of TPattern;
-
-      PModule          = ^TModule;
-      TModule          = Record
-                           modType          : Byte;
-                           Size             : Longint;
-                           Filesize         : Longint;
-                           Name             : Array[0..31] of char;
-                           ChannelCount     : Byte;
-                           ChannelPanning   : Array[0..Max_Tracks-1] of shortint;
-                           InstrumentCount  : Byte;
-                           Instruments      : ^AMInstr;
-                           PatternCount     : Byte;
-                           Patterns         : ^AMPattern;
-                           TrackCount       : Word;
-                           Tracks           : ^AMTracks;
-                           Tempo            : Byte;
-                           Speed            : Byte;
-                         End;
-
-      PNoteInfo        = ^TNoteInfo;
-      TNoteInfo        = Record
-                           Note             : Shortint;
-                           Instrument       : Shortint;
-                           Velocity         : Shortint;
-                           Played           : Word;
-                         End;
-
-      PCmdInfo         = ^TCmdInfo;
-      TCmdInfo         = Record
-                           Command          : Word;
-                           Value            : Word;
-                         End;
-
-      PTrackData       = ^TTrackData;
-      TTrackData       = Record
-                           Status           : Word;
-                           Note             : Byte;
-                           Instrument       : Byte;
-                           Volume           : Byte;
-                           Playtime         : Word;
-                           Command          : Byte;
-                           CmdValue         : Byte;
-                           Panning          : Shortint;
-                         End;
-
-      S_MODULE         = Record
-                           modType          : byte;
-                           size             : longint;
-                           filesize         : longint;
-                           mname            : array[0..31] of char;
-                           channelCount     : byte;
-                           channelOrder     : byte;
-                           instrumentCount  : byte;
-                           instruments      : longint;
-                           patternCount     : byte;
-                           patterns         : longint;
-                           trackCount       : word;
-                           tracks           : longint;
-                         end;
-
-      S_TRACKDATA      = Record
-                           status           : word;
-                           note             : byte;
-                           instrument       : byte;
-                           velocity         : byte;
-                           playtime         : word;
-                           command          : byte;
-                           cmdvalue         : byte;
-                         end;
-
-      S_PLAYINFO       = Record
-                           initOptions      : word;
-                           status           : byte;
-                           options          : word;
-                           firstPattern     : byte;
-                           lastPattern      : byte;
-                           pattern          : byte;
-                           tracks           : byte;
-                           ticks            : word;
-                           row              : word;
-                           cmdcount         : byte;
-                           patterndata      : longint;
-                           instrdata        : longint;
-                           tempo            : byte;
-                           exttempo         : byte;
-                           tempovalue       : byte;
-                           sync             : byte;
-                           break            : byte;
-                           timerValue       : word;
-                           timerCount       : word;
-                           channelCount     : word;
-                           channelOrder     : array[0..max_Tracks-1] of byte;
-                         end;
-
-      S_NOTEINFO       = Record
-                           note             : byte;
-                           instrument       : byte;
-                           velocity         : byte;
-                           played           : word;
-                           noteold          : word;
-                         end;
-
-      S_CMDINFO        = Record
-                           command          : byte;
-                           value            : byte;
-                           bendervalue      : word;
-                           benderadd        : byte;
-                           bendercmd        : byte;
-                           arpeggio1        : longint;
-                           arpeggio2        : longint;
-                           arpeggio3        : longint;
-                           arpeggioptr      : byte;
-                           vibratopos       : byte;
-                           vibratocmd       : byte;
-                           tremolocmd       : byte;
-                           tremolospeed     : byte;
-                           tremolovalue     : byte;
-                           tremolopos       : byte;
-                           offsetvalue      : byte;
-                         end;
-
-      S_TRACKINFO      = Record
-                           track            : longint;
-                           pos              : word;
-                           status           : word;
-                           note             : S_NOTEINFO;
-                           cmd              : S_CMDINFO;
-                         end;
-
-      S_SAMPLEINFO     = Record
-                           sample           : longint;
-                           length           : word;
-                           loopstart        : word;
-                           loopend          : word;
-                           rate             : word;
-                           volume           : byte;
-                           mode             : byte;
-                           orgrate          : word;
-                         end;
-
-Var ModuleError        : Integer;
-
-Var _curModule       : TModule;
-    trackdata        : S_TRACKDATA;
-    moduleinfo       : S_PLAYINFO;
-    tracks           : Array[0..Max_Tracks-1] of S_TRACKINFO;
-    samples	     : Array[0..Max_Tracks-1] of S_SAMPLEINFO;
-
-Function  ampInit(options:longint):integer;
-Procedure ampClose;
-Function  ampPlayModule(module:PModule;opt:longint):integer;
-Function  ampPlayMultiplePatterns(module:PModule;startp,endp,opt:longint):integer;
-Function  ampPlayPattern(module:PModule;pat,opt:longint):integer;
-Function  ampStopModule:integer;
-Function  ampPauseModule:integer;
-Function  ampResumeModule:integer;
-Function  ampGetModuleStatus:integer;
-Function  ampPauseTrack(track:longint):integer;
-Function  ampResumeTrack(track:longint):integer;
-Function  ampGetTrackStatus(track:longint):integer;
-Function  ampGetTrackData(track:longint):PTrackdata;
-Function  ampGetPattern:integer;
-Function  ampGetRow:integer;
-Function  ampGetSync:integer;
-Function  ampGetTempo:word;
-Procedure ampSetTempo(tempo:longint);
-Procedure ampSetPanning(track,direction:longint);
-Procedure ampPlayRow;
-Procedure ampBreakPattern(direction:longint);
-Function  ampGetBufferDelta:longint;
-
-Procedure ampInterrupt; interrupt;
-Procedure ampPoll;
-
-Implementation
-{$IFDEF USE_EMS}
-uses mcpems;
-{$ELSE}
-uses mcpreala;
-{$ENDIF}
-
-{$L AMPlayer.OBJ}
-
-Function  ampInit(options:longint):integer; external;
-Procedure ampClose; external;
-Function  ampPlayModule(module:PModule;opt:longint):integer; external;
-Function  ampPlayMultiplePatterns(module:PModule;startp,endp,opt:longint):integer; external;
-Function  ampPlayPattern(module:PModule;pat,opt:longint):integer; external;
-Function  ampStopModule:integer; external;
-Function  ampPauseModule:integer; external;
-Function  ampResumeModule:integer; external;
-Function  ampGetModuleStatus:integer; external;
-Function  ampPauseTrack(track:longint):integer; external;
-Function  ampResumeTrack(track:longint):integer; external;
-Function  ampGetTrackStatus(track:longint):integer; external;
-Function  ampGetTrackData(track:longint):PTrackdata; external;
-Function  ampGetPattern:integer; external;
-Function  ampGetRow:integer; external;
-Function  ampGetSync:integer; external;
-Function  ampGetTempo:word; external;
-Procedure ampSetTempo(tempo:longint); external;
-Procedure ampSetPanning(track,direction:longint); external;
-Procedure ampPlayRow; external;
-Procedure ampBreakPattern(direction:longint); external;
-Function  ampGetBufferDelta:longint; external;
-
-Procedure ampInterrupt; external;
-Procedure ampPoll; external;
-
-End.
diff --git a/dmp/amp.tpp b/dmp/amp.tpp
deleted file mode 100644
index f4a915b..0000000
Binary files a/dmp/amp.tpp and /dev/null differ
diff --git a/dmp/amplayer.asm b/dmp/amplayer.asm
deleted file mode 100644
index a684809..0000000
--- a/dmp/amplayer.asm
+++ /dev/null
@@ -1,2640 +0,0 @@
-;/************************************************************************
-; *
-; *     File        :   AMPLAYER.ASM
-; *     Description :   Player routine for Advanced Module Player
-; *                     API routines for Advanced Module Player
-; *
-; *     Copyright (C) 1992 Otto Chrons
-; *
-; ***********************************************************************
-;
-;       Revision history of AMPLAYER.ASM
-;
-;       1.0     ??.??.93 :)
-;               First version with DSMI, supports most module commands
-;               and is rather bug free. Format is AMF.
-;
-;       1.01    16.4.93
-;               Corrected a bug with >6 channel modules, a 'sub bh,bh' was
-;               in a wrong place.
-;
-;       1.02    7.5.93
-;               Added cmdExtraFineBender
-;
-;               9.5.93  Fixed bender to note
-;
-;               11.5.93 Added support for panning.. no need for channel
-;                       orders. */ampSetPanning/*
-;
-;               26.7.93 Started adding CDI support
-;
-;               27.11.93
-;               New macros for easier conversion into 32-bit flat
-;               No more C or Pascal models...
-;
-; ***********************************************************************/
-
-        IDEAL
-        JUMPS
-        P386
-
-        INCLUDE "MODEL.INC"
-        INCLUDE "MCP.INC"
-        INCLUDE "AMP.INC"
-        INCLUDE "CDI.INC"
-
-        PRD2FRQ = 6848
-
-CSEGMENTS AMPLAYER
-
-IFDEF __PASCAL__
-        EXTRN   mcpSampleRealAddress:_FAR
-ELSE
-        EXTRN   _mcpSampleRealAddress:_FAR
-ENDIF
-
-CDATASEG
-
-        EXTRN   cdiStatus:WORD
-
-        DB      2048 dup(?)
-
-        LABEL   stack2  WORD
-        oldSP   DW ?
-        oldSS   DW ?
-
-IFDEF   __PASCAL__
-
-        EXTRN   _curModule:S_MODULE
-ELSE
-        CPUBLIC curModule
-
-        _curModule      S_MODULE <>
-ENDIF
-        trackdata       S_TRACKDATA <>
-        moduleinfo      S_PLAYINFO <>
-        tracks          S_TRACKINFO MAXTRACKS dup(<>)
-        samples         S_SAMPLEINFO MAXTRACKS dup(<>)
-        ampStatus       DB ?
-        bufferDelta     DW ?
-        timerSpeed      DW ?            ; 23863
-        DMAtick         DB ?
-        IRQmask         DB ?
-        tsTag           DW ?
-        bytes2Calculate DW ?
-        temp            DW ?
-        ampBusy         DB ?
-        timeValue       DW ?
-        calced          DD ?
-
-
-ENDS
-
-CCODESEG AMPLAYER
-
-        CPUBLIC ampInit, ampClose
-        CPUBLIC ampPlayModule, ampPlayMultiplePatterns, ampPlayPattern, ampPlayRow
-        CPUBLIC ampStopModule, ampPauseModule, ampResumeModule, ampGetModuleStatus
-        CPUBLIC ampGetTrackData, ampGetTrackStatus, ampPauseTrack, ampResumeTrack
-        CPUBLIC ampGetPattern, ampGetRow, ampGetSync
-        CPUBLIC ampGetTempo, ampSetTempo, ampSetPanning
-        CPUBLIC ampBreakPattern
-        CPUBLIC ampGetBufferDelta, ampInterrupt, ampPoll
-
-        copyrightText   DB "AMP v1.30 - (C) 1992,1993 Otto Chrons",0,1Ah
-
-        count = 0
-        LABEL   trackPtr WORD
-        REPT MAXTRACKS
-            DW count
-            count = count + SIZE S_TRACKINFO
-        ENDM
-
-        count = 0
-        LABEL   patternPtr WORD
-        REPT 255
-            DW count
-            count = count + SIZE S_PATTERN
-        ENDM
-
-        count = 0
-        LABEL   instrumentPtr WORD
-        REPT 127
-            DW count
-            count = count + SIZE S_INSTRUMENT
-        ENDM
-
-        count = 0
-        LABEL   samplePtr WORD
-        REPT MAXTRACKS
-            DW count
-            count = count + SIZE S_SAMPLEINFO
-        ENDM
-
-
-        LABEL   frequencyTable WORD
-
-            DW 001Fh,0021h,0023h,0026h,0028h,002Ah,002Dh,002Fh,0032h,0035h,0039h,003Ch
-            DW 003Fh,0043h,0047h,004Ch,0050h,0055h,005Ah,005Fh,0065h,006Bh,0072h,0078h
-            DW 007Fh,0087h,008Fh,0098h,00A1h,00AAh,00B5h,00BFh,00CBh,00D7h,00E4h,00F1h
-            DW 00FFh,010Fh,011Fh,0130h,0142h,0155h,016Ah,017Fh,0196h,01AEh,01C8h,01E3h
-            DW 01FFh,021Eh,023Eh,0260h,0285h,02ABh,02D4h,02FFh,032Ch,035Dh,0390h,03C6h
-            DW 03FFh,043Ch,047Dh,04C1h,050Ah,0556h,05A8h,05FEh,0659h,06BAh,0720h,078Dh
-            DW 0800h,0879h,08FAh,0983h,0A14h,0AADh,0B50h,0BFCh,0CB3h,0D74h,0E41h,0F1Ah
-            DW 1000h,10F3h,11F5h,1306h,1428h,155Bh,16A0h,17F9h,1966h,1AE8h,1C82h,1E34h
-            DW 8192,8679,9195,9741,10321,10935,11585,12274,13004,13777,14596,15464
-            DW 16384,17358,18390,19483,20642,21870,23170,24548,26008,27554,29163,30928
-            DW 12 dup(8000h)
-
-        LABEL   noteTable       WORD
-            DW 24 dup(54783)
-            DW 54783,51709,48806,46067,43482,41041,38738,36563,34511,32574,30746,29020
-            DW 27391,25854,24403,23033,21741,20520,19369,18281,17255,16287,15373,14510
-            DW 13695,12927,12201,11516,10870,10260,9684,9140,8627,8143,7686,7255
-            DW PRD2FRQ,6463,6100,5758,5435,5130,4842,4570,4313,4071,3843,3627
-            DW 3424,3231,3050,2879,2717,2565,2421,2285,2156,2035,1921,1813
-            DW 1712,1615,1525,1439,1358,1282,1210,1142,1078,1017,960,906
-            DW 856,807,762,719,679,641,605,571,539,508,480,453
-            DW 428,403,381,359,339,320,302,285,269,254,240,226
-            DW 214,201,190,179,169,160,151
-
-        HIGH_NOTE       =       25
-        LOW_NOTE        =       54783
-
-        LABEL   vibratoTable    WORD
-
-            DW 0,200,401,600,798,995,1188,1379
-            DW 1567,1750,1930,2105,2275,2439,2597,2750
-            DW 2895,3034,3165,3289,3404,3512,3611,3701
-            DW 3783,3855,3918,3972,4016,4050,4075,4090
-            DW 4095,4090,4075,4050,4016,3972,3918,3855
-            DW 3783,3701,3611,3512,3404,3289,3165,3034
-            DW 2895,2750,2597,2439,2275,2105,1930,1750
-            DW 1567,1379,1188,995,798,600,401,200
-
-        LABEL   arpeggioTable WORD
-
-            DW 1024,1085,1149,1218,1290,1367,1448,1534,1625,1722,1825,1933
-            DW 2048,2170,2298,2436
-
-IFDEF __32__
-        LABEL   commandProcs DWORD
-            DD offset CMDinstrument
-            DD offset CMDtempo
-            DD offset CMDvolume
-            DD offset CMDvolumeAbs
-            DD offset CMDbender
-            DD offset CMDbenderAbs
-            DD offset CMDbenderTo
-            DD offset CMDtremolo
-            DD offset CMDarpeggio
-            DD offset CMDvibrato
-            DD offset CMDbenderVol
-            DD offset CMDvibrVol
-            DD offset CMDbreak
-            DD offset CMDgoto
-            DD offset CMDsync
-            DD offset CMDretrig
-            DD offset CMDoffset
-            DD offset CMDfinevol
-            DD offset CMDfinetune
-            DD offset CMDdelaynote
-            DD offset CMDnotecut
-            DD offset CMDexttempo
-            DD offset CMDextrafinebender
-            DD offset CMDpanning
-ELSE
-        LABEL   commandProcs WORD
-            DW offset CMDinstrument
-            DW offset CMDtempo
-            DW offset CMDvolume
-            DW offset CMDvolumeAbs
-            DW offset CMDbender
-            DW offset CMDbenderAbs
-            DW offset CMDbenderTo
-            DW offset CMDtremolo
-            DW offset CMDarpeggio
-            DW offset CMDvibrato
-            DW offset CMDbenderVol
-            DW offset CMDvibrVol
-            DW offset CMDbreak
-            DW offset CMDgoto
-            DW offset CMDsync
-            DW offset CMDretrig
-            DW offset CMDoffset
-            DW offset CMDfinevol
-            DW offset CMDfinetune
-            DW offset CMDdelaynote
-            DW offset CMDnotecut
-            DW offset CMDexttempo
-            DW offset CMDextrafinebender
-            DW offset CMDpanning
-ENDIF
-
-
-PROC    CMDnone NEAR
-CMDbenderAbs:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDpanning
-; *
-; *     Description :   Pans channel to left or right
-; *
-; ************************************************************************/
-
-PROC    CMDpanning NEAR
-
-        mov     bx,dx
-        movzx   eax,[ESDI+S_MODCMD.data]
-        mov     [_bx+tracks.cmd.command],cPan
-        mov     [_bx+tracks.cmd.value],al        ; AL = panning value
-        cmp     al,100                          ; Surround
-        je      @@ok2
-        cmp     al,-63
-        jge     @@ok1
-        mov     al,-63
-@@ok1:
-        cmp     al,63
-        jle     @@ok2
-        mov     al,63
-@@ok2:
-        movzx   edx,[moduleinfo.track]
-        ecall   ampSetPanning edx,eax   ; Set new panning
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDnotecut
-; *
-; *     Description :   Cuts note in x frames
-; *
-; ************************************************************************/
-
-PROC    CMDnotecut NEAR
-
-        mov     bx,dx
-        mov     al,[ESDI+S_MODCMD.data]
-        mov     [_bx+tracks.cmd.command],cNotecut
-        mov     [_bx+tracks.cmd.value],al
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDdelaynote
-; *
-; *     Description :   Delays note from playing
-; *
-; ************************************************************************/
-
-PROC    CMDdelaynote NEAR
-
-        mov     bx,dx
-        mov     cl,[ESDI+S_MODCMD.data]
-        or      cl,cl                   ; Is CL = 0?
-        jnz     @@valueOK
-        inc     cl                      ; CL = 1 (minimum value)
-@@valueOK:
-        mov     [_bx+tracks.cmd.value],cl
-        mov     al,[ESDI+S_MODCMD.timesig]
-        cmp     al,[ESDI+3+S_MODCMD.timesig]
-        jne     @@exit
-        mov     al,[ESDI+3+S_NOTE.note]
-        test    al,80h
-        jnz     @@exit
-        cmp     al,7Fh
-        je      @@nonew
-        mov     [_bx+tracks.note.note],al
-@@nonew:
-        mov     al,[ESDI+3+S_NOTE.velocity]
-        cmp     al,255
-        je      @@10
-        mov     [_bx+tracks.note.velocity],al
-@@10:
-        mov     [_bx+tracks.cmd.command],cDelayNote
-        add     [_bx+tracks.pos],3
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void CMDfinetune
-; *
-; *     Description :   Changes note's pitch
-; *
-; ************************************************************************/
-
-PROC    CMDfinetune NEAR
-
-        mov     bx,dx
-        mov     al,[ESDI+S_MODCMD.data]
-        cbw
-        mov     [_bx+tracks.cmd.command],cFinetune
-        mov     [_bx+tracks.cmd.value],al
-        mov     cx,[_bx+tracks.note.noteold]
-        sal     ax,4                    ; * 16
-        add     cx,ax
-        js      @@top
-        cmp     cx,HIGH_NOTE
-        ja      @@noteok
-@@top:
-        mov     cx,HIGH_NOTE
-@@noteok:
-        mov     [_bx+tracks.note.noteold],cx
-        mov     al,[moduleinfo.track]
-        sub     ah,ah
-        mov     di,ax
-        shl     di,1
-        mov     di,[_di+samplePtr]
-        movzx   eax,[_di+samples.orgrate]
-        movzx   ecx,cx
-        mov     edx,PRD2FRQ
-        mul     edx
-        div     ecx
-        mov     [_di+samples.rate],eax
-        movzx   edx,[moduleinfo.track]
-        ecall   cdiSetFrequency edx,eax
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void CMDfinevol
-; *
-; *     Description :   Finetunes volume up/down.
-; *
-; ************************************************************************/
-
-PROC    CMDfinevol NEAR
-
-        mov     bx,dx
-        movzx   eax,[ESDI+S_MODCMD.data]
-        mov     [_bx+tracks.cmd.command],cFinevol
-        mov     [_bx+tracks.cmd.value],al        ; AL = volume change
-        add     al,[_bx+tracks.note.velocity]
-        jns     @@10
-        sub     al,al
-@@10:
-        cmp     al,64
-        jle     @@20
-        mov     al,64
-@@20:
-        mov     [_bx+tracks.note.velocity],al
-        movzx   edx,[moduleinfo.track]
-        ecall   cdiSetVolume edx,eax
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void CMDoffset
-; *
-; *     Description :   Sets a new sample offset
-; *
-; ************************************************************************/
-
-PROC    CMDoffset NEAR
-
-        mov     bx,dx
-        mov     ah,[ESDI+S_MODCMD.data]
-        mov     [_bx+tracks.cmd.command], cOffset
-        or      ah,ah
-        jnz     @@NewValue
-        mov     ah,[_bx+tracks.cmd.offsetValue]
-@@NewValue:
-        mov     [_bx+tracks.cmd.offsetValue],ah
-        sub     al,al
-        movzx   edx,[moduleinfo.track]  ; DX = Channel
-        movzx   esi,dx
-        shl     _si,1
-        mov     si,[_si+samplePtr]      ; DS:SI points to sample structure
-        movzx   eax,ax
-        cmp     eax,[_si+samples.length]
-        jna     @@lengthok
-        mov     eax,[_si+samples.loopstart]
-@@lengthok:
-        ecall   cdiSetPosition edx,eax  ; Set sample's offset
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void CMDretrig
-; *
-; *     Description :   Retrigs note rapidly
-; *
-; ************************************************************************/
-
-PROC    CMDretrig NEAR
-
-        mov     bx,dx
-        mov     al,[ESDI+S_MODCMD.data]
-        or      al,al
-        jz      @@exit
-        mov     [_bx+tracks.cmd.command],cRetrig
-        mov     [_bx+tracks.cmd.value],al
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDsync
-; *
-; *     Description :   Command for synchronization
-; *
-; ************************************************************************/
-
-PROC    CMDsync NEAR
-
-        mov     al,[ESDI+S_MODCMD.data]
-        mov     [moduleinfo.sync],al
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDvibrVol
-; *
-; *     Description :   Both vibrato & volume slide
-; *
-; ************************************************************************/
-
-PROC    CMDvibrVol NEAR
-
-        mov     bx,dx
-        mov     al,[ESDI+S_MODCMD.data]
-        mov     [_bx+tracks.cmd.command],cVibrVol
-        mov     [_bx+tracks.cmd.value],al
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDbenderVol
-; *
-; *     Description :   Both bender-to-note & volume slide
-; *
-; ************************************************************************/
-
-PROC    CMDbenderVol NEAR
-
-        mov     bx,dx
-        mov     al,[ESDI+S_MODCMD.data]
-        mov     [_bx+tracks.cmd.command],cBenderVol
-        mov     [_bx+tracks.cmd.value],al
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDtremolo
-; *
-; *     Description :   Vibrates sound
-; *
-; ************************************************************************/
-
-PROC    CMDtremolo NEAR
-
-        mov     bx,dx                   ; Restore BX
-        mov     al,[ESDI+S_MODCMD.data]
-        mov     [_bx+tracks.cmd.value],al
-        mov     dl,[_bx+tracks.cmd.tremoloCmd]
-        or      al,al
-        jz      @@20
-        mov     ah,al
-        and     al,0Fh
-        jz      @@10
-        and     dl,0F0h
-        or      dl,al
-@@10:
-        and     ah,0F0h
-        jz      @@20
-        and     dl,0Fh
-        or      dl,ah
-@@20:
-        mov     [_bx+tracks.cmd.tremoloCmd],dl
-        mov     ah,dl
-        mov     al,dl
-        and     al,0Fh
-        shr     ah,4
-        mov     [_bx+tracks.cmd.command],cTremolo
-        mov     [_bx+tracks.cmd.tremoloSpeed],ah
-        mov     [_bx+tracks.cmd.tremoloValue],al
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDvibrato
-; *
-; *     Description :   Vibrates sound
-; *
-; ************************************************************************/
-
-PROC    CMDvibrato NEAR
-
-        mov     bx,dx                   ; Restore BX
-        mov     al,[ESDI+S_MODCMD.data]
-        mov     [_bx+tracks.cmd.command],cVibrato
-        mov     dl,[_bx+tracks.cmd.vibratoCmd]
-        or      al,al
-        jz      @@20
-        mov     ah,al
-        and     al,0Fh
-        jz      @@10
-        and     dl,0F0h
-        or      dl,al
-@@10:
-        and     ah,0F0h
-        jz      @@20
-        and     dl,0Fh
-        or      dl,ah
-@@20:
-        mov     [_bx+tracks.cmd.vibratoCmd],dl
-        mov     [_bx+tracks.cmd.value],dl
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDarpeggio
-; *
-; *     Description :   Makes a chord
-; *
-; ************************************************************************/
-
-PROC    CMDarpeggio NEAR
-
-        mov     bx,dx                   ; Restore BX
-        mov     al,[ESDI+S_MODCMD.data]
-        or      al,al
-        jz      @@exit
-        mov     [_bx+tracks.cmd.command],cArpeggio
-        mov     [_bx+tracks.cmd.value],al
-        mov     al,[moduleinfo.track]
-        sub     ah,ah
-        movzx   esi,ax
-        shl     _si,1
-        mov     si,[_si+samplePtr]
-        mov     ecx,[_si+samples.rate]
-        mov     [_bx+tracks.cmd.arpeggio1],ecx
-        mov     al,[_bx+tracks.cmd.value]
-        shr     al,4
-        sub     ah,ah
-        movzx   esi,ax
-        shl     _si,1
-        movzx   eax,[_si+arpeggioTable]
-        mul     ecx
-        shrd    eax,edx,10                      ; EAX = EAX / 1024
-        mov     [_bx+tracks.cmd.arpeggio2],eax
-        mov     al,[_bx+tracks.cmd.value]
-        and     ax,000Fh
-        movzx   esi,ax
-        shl     _si,1
-        movzx   eax,[_si+arpeggioTable]
-        mul     ecx
-        shrd    eax,edx,10                      ; EAX = EAX / 1024
-        mov     [_bx+tracks.cmd.arpeggio3],eax
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDbenderTo
-; *
-; *     Description :   Slides track's pitch towards a note
-; *
-; ************************************************************************/
-
-PROC    CMDbenderTo NEAR
-
-        mov     bx,dx                   ; Restore BX
-        mov     cl,[ESDI+S_MODCMD.data]
-        or      cl,cl
-        jnz     @@01
-        mov     cl,[_bx+tracks.cmd.benderCmd]
-@@01:
-        mov     [_bx+tracks.cmd.benderCmd],cl
-        mov     al,[ESDI+S_MODCMD.timesig]
-        cmp     al,[ESDI+3+S_MODCMD.timesig]
-        jne     @@10
-        mov     al,[ESDI+3+S_NOTE.note]
-        test    al,80h
-        jnz     @@10
-        mov     [_bx+tracks.note.note],al
-        sub     ah,ah
-        movzx   esi,ax
-        shl     _si,1
-        mov     ax,[_si+noteTable]
-        mov     [_bx+tracks.cmd.bendervalue],ax
-        add     [_bx+tracks.pos],3
-        mov     al,[ESDI+3+S_NOTE.velocity]
-        cmp     al,255
-        je      @@10
-        mov     [_bx+tracks.note.velocity],al
-@@10:
-        mov     ax,[_bx+tracks.cmd.bendervalue]
-        cmp     ax,[_bx+tracks.note.noteold]
-        jge     @@05
-        neg     cl
-@@05:
-        mov     [_bx+tracks.cmd.command],cBenderTo
-        mov     [_bx+tracks.cmd.benderAdd],cl
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDbender
-; *
-; *     Description :   Slides track's pitch
-; *
-; ************************************************************************/
-
-PROC    CMDbender NEAR
-
-        mov     bx,dx                   ; Restore BX
-        mov     cl,[ESDI+S_MODCMD.data]
-        cmp     cl,-128
-        jne     @@00
-        mov     cl,[_bx+tracks.cmd.benderCmd2]
-        or      cl,cl
-        jl      @@01
-        neg     cl
-        jmp     @@01
-@@00:
-        or      cl,cl
-        jnz     @@01
-        mov     cl,[_bx+tracks.cmd.benderCmd2]
-        or      cl,cl
-        jg      @@01
-        neg     cl
-@@01:
-        mov     [_bx+tracks.cmd.benderCmd2],cl
-        mov     [_bx+tracks.cmd.command],cBender
-        mov     [_bx+tracks.cmd.value],cl
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDextrafinebender
-; *
-; *     Description :   Slides track's pitch very fine
-; *
-; ************************************************************************/
-
-PROC    CMDextrafinebender NEAR
-
-        mov     bx,dx                   ; Restore BX
-        mov     al,[ESDI+S_MODCMD.data]
-        cmp     al,0
-        je      @@exit
-        mov     [_bx+tracks.cmd.command],cExtraFineBender
-        mov     [_bx+tracks.cmd.value],al
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDvolume
-; *
-; *     Description :   Slides track's volume
-; *
-; ************************************************************************/
-
-PROC    CMDvolume NEAR
-
-        mov     bx,dx                   ; Restore BX
-        mov     al,[ESDI+S_MODCMD.data]
-        mov     [_bx+tracks.cmd.command],cVolume
-        mov     [_bx+tracks.cmd.value],al
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDvolumeAbs
-; *
-; *     Description :   Changes track's volume
-; *
-; ************************************************************************/
-
-PROC    CMDvolumeAbs NEAR
-
-        mov     bx,dx                   ; Restore BX
-        mov     al,[ESDI+S_MODCMD.data]
-        mov     [_bx+tracks.note.velocity],al
-        sub     ah,ah
-        movzx   edx,ax                  ; Save new volume
-        movzx   eax,[moduleinfo.track]
-        ecall   cdiSetVolume eax,edx
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDgoto
-; *
-; *     Description :   Changes current pattern
-; *
-; ************************************************************************/
-
-PROC    CMDgoto NEAR
-
-        mov     ah,[moduleinfo.pattern]
-        mov     al,[ESDI+S_MODCMD.data] ; AL = next pattern to play
-        dec     al
-        cmp     al,ah
-        jge     @@ok
-        test    [moduleinfo.options],PM_LOOP
-        jz      @@exit
-@@ok:
-        mov     al,[ESDI+S_MODCMD.data] ; AL = next pattern to play
-        dec     al
-        cmp     al,[moduleinfo.lastPattern]
-        jg      @@exit
-        mov     [moduleinfo.pattern],al
-        mov     [moduleinfo.break],1    ; Break current pattern
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDbreak
-; *
-; *     Description :   Breaks current pattern
-; *
-; ************************************************************************/
-
-PROC    CMDbreak NEAR
-
-        mov     [moduleinfo.break],1    ; End pattern
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDtempo
-; *
-; *     Description :   Changes module's tempo
-; *
-; ************************************************************************/
-
-PROC    CMDtempo NEAR
-
-        mov     al,[ESDI+S_MODCMD.data]  ; AL = tempo
-        cmp     al,[moduleinfo.tempo]   ; Is it the same
-        je      @@exit
-        or      al,al
-        jz      @@exit
-        mov     [moduleinfo.tempo],al
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDexttempo
-; *
-; *     Description :   Changes module's tempo (ProTracker extended)
-; *
-; ************************************************************************/
-
-PROC    CMDexttempo NEAR
-
-        mov     al,[ESDI+S_MODCMD.data]  ; AL = tempo
-        cmp     al,[moduleinfo.extTempo]        ; Is it the same
-        je      @@exit
-        or      al,al
-        jz      @@exit
-        mov     [moduleinfo.extTempo],al
-        sub     ah,ah
-        imul    ax,50
-        sub     dx,dx
-        mov     cx,125
-        div     cx
-        mov     [timeValue],ax
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   CMDinstrument
-; *
-; *     Description :   Sets a new instrument on the track
-; *
-; ************************************************************************/
-
-PROC    CMDinstrument NEAR
-locs=0
-        LOCALVAR        _byte @@noNote
-
-        enter   locs,0
-        mov     bx,dx                   ; Restore BX
-        mov     al,[ESDI+S_MODCMD.data]
-        mov     [_bx+tracks.note.instrument],al
-        mov     dl,[ESDI+S_MODCMD.timesig]
-        mov     [byte @@noNote],1
-        cmp     dl,[ESDI+3+S_MODCMD.timesig]
-        jne     @@ok
-        test    [ESDI+3+S_MODCMD.cmd],80h
-        jnz     @@ok
-        mov     [byte @@noNote],0
-@@ok:
-        sub     ah,ah
-        movzx   edi,ax
-        shl     _di,1
-        mov     di,[_di+instrumentPtr]
-IFDEF __C32__
-        mov     eax,[moduleinfo.instrdata]
-        add     edi,eax
-ELSE
-        les     ax,[moduleinfo.instrdata]
-        add     di,ax                   ; ESDI = new instrument
-ENDIF
-        mov     al,[moduleinfo.track]
-        sub     ah,ah
-        movzx   esi,ax
-        shl     _si,1
-        mov     si,[_si+samplePtr]      ; Copy instrument structure into
-                                        ; sample structure
-        mov     eax,[ESDI+S_INSTRUMENT.sample]
-        mov     [_si+samples.sample],eax
-        mov     eax,[ESDI+S_INSTRUMENT.size]
-        mov     [_si+samples.length],eax
-        mov     ax,[ESDI+S_INSTRUMENT.rate]
-        mov     [_si+samples.orgrate],ax
-        mov     eax,[ESDI+S_INSTRUMENT.loopstart]
-        mov     [_si+samples.loopstart],eax
-        mov     eax,[ESDI+S_INSTRUMENT.loopend]
-        mov     [_si+samples.loopend],eax
-        mov     al,[ESDI+S_INSTRUMENT.volume]
-        mov     [_si+samples.volume],al
-        mov     [_bx+tracks.note.velocity],al
-        mov     [_si+samples.mode],SAMPLE_CONTINUE
-
-        mov     [_si+samples.sampleID],0
-        cmp     [WORD HIGH si+samples.sample],0FFFFh
-        jne     @@noEMS
-        mov     ax,[WORD LOW si+samples.sample]
-        mov     [_si+samples.sampleID],ax
-@@noEMS:
-        movzx   eax,[moduleinfo.track]
-        lea     _dx,[_si+samples]
-IFDEF __C32__
-        ecall   cdiSetInstrument eax,edx
-ELSE
-        ecall   cdiSetInstrument eax,<ds dx>
-ENDIF
-        movzx   edx,[_si+samples.volume]
-        movzx   eax,[moduleinfo.track]
-        ecall   cdiSetVolume eax,edx
-@@exit:
-        leave
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   playCommand
-; *
-; *     Description :   Handles module commands
-; *
-; ************************************************************************/
-
-PROC    playCommand NEAR
-
-        push    _bx _si _di
-        PUSHES
-
-        sub     ah,ah
-        mov     al,[ESDI+S_MODCMD.cmd]
-        and     al,7Fh                  ; AX = command
-        mov     dx,bx                   ; Save BX
-        movzx   ebx,ax
-        cmp     _bx,cLast
-        ja      @@exit
-IFDEF __C32__
-        shl     _bx,2                   ; BX = command*4
-ELSE
-        shl     _bx,1                   ; BX = command*2
-ENDIF
-        call    [commandProcs+_bx]      ; Call appropriate routine
-@@exit:
-        POPES
-        pop     _di _si _bx
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   playNote
-; *
-; *     Description :   Plays sample on track
-; *
-; ************************************************************************/
-
-PROC    playNote NEAR
-
-        push    _bx _si _di
-        PUSHES
-        mov     al,[ESDI+S_NOTE.note]
-        cmp     al,07Fh
-        je      @@noNewNote
-        mov     [_bx+tracks.note.note],al
-@@noNewNote:
-        mov     al,[ESDI+S_NOTE.velocity]
-        cmp     al,255
-        je      @@10
-        mov     [_bx+tracks.note.velocity],al
-@@10:
-        mov     [_bx+tracks.note.played],0
-        mov     [_bx+tracks.cmd.vibratoPos],0
-        movzx   edi,[moduleinfo.track]
-        shl     _di,1
-        mov     di,[_di+samplePtr]      ; DS:DI = sample structure
-        push    ebx
-        push    bx
-        mov     bl,[_bx+tracks.note.note]
-        sub     bh,bh
-        shl     _bx,1
-        mov     ax,[_bx+noteTable]
-        sub     ebx,ebx
-        pop     bx
-        mov     [_bx+tracks.note.noteold],ax
-        mov     [_bx+tracks.cmd.bendervalue],ax
-        mov     bl,[_bx+tracks.note.note]
-        sub     bh,bh
-        shl     _bx,1
-        mov     bx,[_bx+frequencyTable]
-        movzx   eax,[_di+samples.orgrate]       ; EAX = frequency of middle-C
-        mul     ebx                     ; DX:AX = AX*(relative frequency)
-        shrd    eax,edx,10
-        pop     ebx
-        mov     [_di+samples.rate],eax
-        mov     ecx,eax
-        movzx   edx,[_bx+tracks.note.velocity]
-        mov     [_di+samples.volume],dl
-        movzx   eax,[moduleinfo.track]
-        test    [_bx+tracks.status],PAUSED
-        jnz     @@exit
-        ecall   cdiPlayNote eax,ecx,edx
-@@exit:
-        POPES
-        pop     _di _si _bx
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   playTrack
-; *
-; *     Description :   plays current note on track
-; *
-; *     Input       :   BX = track number to play
-; *
-; ************************************************************************/
-
-CPROC   playTrack
-        LOCALVAR        _word @@trck
-        LOCALVAR        _byte @@oldCommand
-
-        ENTERPROC       _cx _bx
-
-        mov     [moduleinfo.track],bl
-        shl     _bx,1
-        mov     bx,[_bx+trackPtr]
-        mov     [@@trck],bx
-        mov     al,[_bx+tracks.cmd.command]
-        mov     [byte @@oldCommand],al                  ; Save command byte
-        mov     [_bx+tracks.cmd.command],0      ; Stop command
-        mov     [_bx+tracks.cmd.value],0
-        cmp     [_bx+tracks.pos],-1     ; Is track finished?
-        je      @@exit
-        LESDI   [_bx+tracks.track]
-IFDEF __32__
-        or      edi,edi
-        jz      @@exit                  ; Yes, exit
-        movzx   eax,[ebx+tracks.pos]
-        add     edi,eax                 ; ESDI = track data
-ELSE
-        mov     ax,es
-        or      ax,di                   ; Is ESDI = NULL ?
-        jz      @@exit                  ; Yes, exit
-        add     di,[bx+tracks.pos]     ; ESDI = track data
-ENDIF
-@@next:
-        mov     al,[ESDI+S_NOTE.timesig]
-        cmp     al,0FFh                 ; Has track ended?
-        jne     @@continue
-        mov     [_bx+tracks.pos],-1
-        jmp     @@exit
-@@continue:
-        sub     ah,ah                   ; AX = next note's tick
-        cmp     ax,[moduleinfo.ticks]   ; Should we react
-        jg      @@exit                  ; Nope
-        push    [_bx+tracks.pos]
-        test    [ESDI+S_NOTE.note],80h  ; Is note actually a command?
-        jz      @@note
-        call    playCommand
-        jmp     short @@done
-@@note:
-        call    playNote
-@@done:
-        pop     ax
-        sub     ax,[_bx+tracks.pos]
-        neg     ax
-        cwde
-        add     _di,_ax
-        add     _di,3
-        add     [_bx+tracks.pos],3
-        jmp     @@next
-@@exit:
-        mov     al,[byte @@oldCommand]
-        cmp     al,[_bx+tracks.cmd.command]
-        je      @@alright
-        movzx   edx,[moduleinfo.track]
-        mov     _di,_dx
-        shl     _di,1
-        mov     di,[_di+samplePtr]
-        ecall   cdiSetFrequency edx,[_di+samples.rate]  ; Set right rate
-@@alright:
-IF32    <sub    ebx,ebx>
-        mov     bx,[@@trck]
-        movzx   eax,[_bx+tracks.note.velocity]
-        movzx   edx,[moduleinfo.track]
-        ecall   cdiSetVolume edx,eax
-        LEAVEPROC       _cx _bx
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   nextPattern
-; *
-; *     Description :   Breaks current patterns and continues with next one
-; *
-; ************************************************************************/
-
-PROC    nextPattern NEAR
-
-        mov     [moduleinfo.ticks],0    ; Reset ticks
-        mov     al,[moduleinfo.pattern]
-        cmp     al,[moduleinfo.lastPattern]     ; Is it the last pattern?
-        jb      @@10
-        test    [moduleinfo.options],PM_LOOP
-        jnz     @@20
-        ecall   ampStopModule
-        mov     ax,-1                   ; Stop moduleinfo
-        jmp     @@exit
-@@20:
-        mov     al,[moduleinfo.firstPattern]
-        mov     [moduleinfo.pattern],al ; Select the first pattern
-@@10:
-        push    _bx
-IF32    <sub    ebx,ebx>
-        mov     bl,al
-        sub     bh,bh
-        shl     bx,1
-        movzx   eax,[_bx+patternPtr]
-        pop     _bx
-        LESDI   [moduleinfo.patterndata]
-        add     _di,_ax                 ; ESDI = patterns[startpat]
-
-IF32    <sub    ecx,ecx>
-        mov     cx,[moduleinfo.channelCount]
-        push    _bx
-        sub     _bx,_bx
-@@loop:                                 ; Copy track pointers
-        mov     eax,[ESDI+S_PATTERN.track]
-        mov     [_bx+tracks.track],eax
-        mov     [_bx+tracks.pos],3
-        add     _di,4
-        add     _bx,SIZE S_TRACKINFO
-        loop    @@loop
-        pop     _bx
-        sub     _ax,_ax                 ; Still going
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   slideVolume
-; *
-; *     Description :   Slides track's volume
-; *
-; ************************************************************************/
-
-PROC    slideVolume NEAR
-
-        movzx   eax,[_bx+tracks.cmd.value]
-        add     al,[_bx+tracks.note.velocity]
-        jns     @@10
-        sub     al,al
-@@10:
-        cmp     al,64
-        jle     @@20
-        mov     al,64
-@@20:
-        mov     [_bx+tracks.note.velocity],al
-        movzx   edx,[moduleinfo.track]
-        ecall   cdiSetVolume edx,eax
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   slidePitchFine
-; *
-; *     Description :   Slides sample's pitch very fine
-; *
-; ************************************************************************/
-
-PROC    slidePitchFine NEAR
-
-        mov     cx,[_bx+tracks.note.noteold]
-        mov     al,[_bx+tracks.cmd.value]
-        cbw
-        add     cx,ax
-        js      @@top
-        or      ax,ax
-        jz      @@exit
-        cmp     cx,HIGH_NOTE
-        ja      @@noteok
-@@top:
-        mov     cx,HIGH_NOTE
-@@noteok:
-        mov     [_bx+tracks.note.noteold],cx
-        mov     al,[moduleinfo.track]
-        sub     ah,ah
-        mov     di,ax
-        shl     di,1
-        mov     di,[_di+samplePtr]
-        movzx   eax,[_di+samples.orgrate]
-        movzx   ecx,cx
-        mov     edx,PRD2FRQ
-        mul     edx
-        div     ecx
-        mov     [_di+samples.rate],eax
-        movzx   edx,[moduleinfo.track]
-        ecall   cdiSetFrequency edx,eax
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   slidePitch
-; *
-; *     Description :   Slides sample's pitch
-; *
-; ************************************************************************/
-
-PROC    slidePitch NEAR
-
-        mov     cx,[_bx+tracks.note.noteold]
-        mov     al,[_bx+tracks.cmd.value]
-        cbw
-        sal     ax,4                    ; * 16
-        add     cx,ax
-        js      @@top
-        or      ax,ax
-        jz      @@exit
-        cmp     cx,HIGH_NOTE
-        ja      @@noteok
-@@top:
-        mov     cx,HIGH_NOTE
-@@noteok:
-        cmp     cx,LOW_NOTE
-        jb      @@noteok2
-        mov     cx,LOW_NOTE
-@@noteok2:
-        mov     [_bx+tracks.note.noteold],cx
-        mov     al,[moduleinfo.track]
-        sub     ah,ah
-        mov     di,ax
-        shl     di,1
-        mov     di,[_di+samplePtr]
-        movzx   eax,[_di+samples.orgrate]
-        movzx   ecx,cx
-        mov     edx,PRD2FRQ
-        mul     edx
-        div     ecx
-        mov     [_di+samples.rate],eax
-        movzx   edx,[moduleinfo.track]
-        ecall   cdiSetFrequency edx,eax
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   slidePitchNote
-; *
-; *     Description :   Slides sample's pitch towards note
-; *
-; ************************************************************************/
-
-PROC    slidePitchNote NEAR
-
-        mov     cx,[_bx+tracks.note.noteold]
-        mov     al,[_bx+tracks.cmd.benderAdd]
-        cbw
-        sal     ax,4                    ; * 16
-        add     cx,ax
-        js      @@reset
-        or      ax,ax
-        jz      @@exit
-        js      @@10
-        cmp     cx,[_bx+tracks.cmd.bendervalue]
-        jbe     @@20
-        mov     cx,[_bx+tracks.cmd.bendervalue]
-        jmp     short @@20
-@@10:
-        cmp     cx,[_bx+tracks.cmd.bendervalue]
-        jae     @@20
-@@reset:
-        mov     cx,[_bx+tracks.cmd.bendervalue]
-@@20:
-        cmp     cx,HIGH_NOTE
-        ja      @@noteok
-        mov     cx,HIGH_NOTE
-@@noteok:
-        mov     [_bx+tracks.note.noteold],cx
-        mov     al,[moduleinfo.track]
-        sub     ah,ah
-        mov     di,ax
-        shl     di,1
-        mov     di,[_di+samplePtr]
-        movzx   eax,[_di+samples.orgrate]
-        movzx   ecx,cx
-        mov     edx,PRD2FRQ
-        mul     edx
-        div     ecx
-        mov     [_di+samples.rate],eax
-        movzx   edx,[moduleinfo.track]
-        ecall   cdiSetFrequency edx,eax
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   arpeggio
-; *
-; *     Description :   Implements a chord on track
-; *
-; ************************************************************************/
-
-PROC    arpeggio NEAR
-
-        sub     ah,ah
-        mov     al,[moduleinfo.cmdcount]
-        mov     dl,3
-        div     dl
-        xchg    ah,al                   ; AL = remainder
-        sub     ah,ah
-        movzx   edi,ax
-        shl     _di,2
-        mov     eax,[_bx+_di+tracks.cmd.arpeggio1]
-        movzx   edx,[moduleinfo.track]
-        ecall   cdiSetFrequency edx,eax
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   vibrato
-; *
-; *     Description :   Vibrates sound
-; *
-; ************************************************************************/
-
-PROC    vibrato NEAR
-
-        mov     al,[_bx+tracks.cmd.vibratoPos]
-        shr     al,2
-        and     ax,001Fh
-        mov     di,ax
-        shl     di,1
-        mov     dx,[_di+vibratoTable]
-        mov     al,[_bx+tracks.cmd.vibratoCmd]
-        and     al,0Fh
-        mul     dx
-        shrd    ax,dx,7
-
-        mov     cx,[_bx+tracks.note.noteold]    ; CX is Amiga note value
-        cmp     [_bx+tracks.cmd.vibratoPos],0
-        js      @@10
-        add     cx,ax
-        jmp     @@20
-@@10:
-        sub     cx,ax
-@@20:
-        cmp     cx,HIGH_NOTE
-        ja      @@noteok
-        mov     cx,HIGH_NOTE
-@@noteok:
-        mov     al,[moduleinfo.track]
-        sub     ah,ah
-        mov     di,ax
-        shl     di,1
-        mov     di,[_di+samplePtr]              ; DI = samples[track]
-        movzx   eax,[_di+samples.orgrate]
-        movzx   ecx,cx
-        mov     edx,PRD2FRQ
-        mul     edx
-        div     ecx
-        movzx   edx,[moduleinfo.track]
-        push    _bx
-        ecall   cdiSetFrequency edx,eax
-        pop     _bx
-
-        mov     al,[_bx+tracks.cmd.vibratoCmd]
-        shr     al,2
-        and     al,3Ch
-        add     [_bx+tracks.cmd.vibratoPos],al
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   tremolo
-; *
-; *     Description :   Changes samples volume rapidly
-; *
-; ************************************************************************/
-
-PROC    tremolo NEAR
-
-        mov     al,[_bx+tracks.cmd.tremoloPos]
-        shr     al,2
-        and     ax,001Fh
-        mov     di,ax
-        shl     di,1
-        mov     dx,[_di+vibratoTable]
-        mov     al,[_bx+tracks.cmd.tremoloValue]
-        mul     dx
-        shrd    ax,dx,10
-        mov     dx,ax
-
-        movzx   cx,[_bx+tracks.note.velocity]   ; CX is volume
-        cmp     [_bx+tracks.cmd.tremoloPos],0
-        jns     @@10
-        add     cx,dx
-        jmp     @@20
-@@10:
-        sub     cx,dx
-        jns     @@20                            ; If negative
-        sub     cx,cx                           ; then zero
-@@20:
-        cmp     cx,64                           ; Overflow?
-        jle     @@30
-        mov     cx,64
-@@30:
-        movzx   edx,[moduleinfo.track]
-        push    _bx
-        movzx   ecx,cx
-        ecall   cdiSetVolume edx,ecx
-        pop     _bx
-
-        mov     al,[_bx+tracks.cmd.tremoloSpeed]
-        shl     al,2
-        and     al,3Ch
-        add     [_bx+tracks.cmd.tremoloPos],al
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   benderVol
-; *
-; *     Description :   Runs benderTo & volume slide
-; *
-; ************************************************************************/
-
-PROC    benderVol NEAR
-
-        push    _bx
-        call    slidePitchNote
-        pop     _bx
-        call    slideVolume
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   vibratoVol
-; *
-; *     Description :   Runs vibrato & volume slide
-; *
-; ************************************************************************/
-
-PROC    vibratoVol NEAR
-
-        push    _bx
-        call    vibrato
-        pop     _bx
-        call    slideVolume
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   retrig
-; *
-; *     Description :   Retrigs note
-; *
-; ************************************************************************/
-
-PROC    retrig NEAR
-
-        mov     al,[moduleinfo.cmdcount]
-        sub     ah,ah
-        mov     dl,[_bx+tracks.cmd.value]
-        div     dl                      ; AH = remainder
-        or      ah,ah                   ; Is it zero?
-        jnz     @@exit
-        movzx   edx,[moduleinfo.track]  ; DX = Channel
-        ecall   cdiSetPosition edx,<LARGE 0>    ; Set sample's offset
-@@exit:
-        ret
-ENDP
-
-
-;/*************************************************************************
-; *
-; *     Function    :   delaynote
-; *
-; *     Description :   Plays a delayed note
-; *
-; ************************************************************************/
-
-PROC    delaynote NEAR
-
-        mov     al,[_bx+tracks.cmd.value]
-        cmp     al,[moduleinfo.cmdcount]
-        jne     @@exit
-        mov     [_bx+tracks.note.played],0
-        mov     al,[moduleinfo.track]
-        sub     ah,ah
-        mov     di,ax
-        shl     di,1
-        mov     di,[_di+samplePtr]      ; DS:DI = sample structure
-        push    _bx
-        push    _bx
-        mov     bl,[_bx+tracks.note.note]
-        sub     bh,bh
-        shl     bx,1
-        mov     ax,[_bx+noteTable]
-        sub     ebx,ebx
-        pop     _bx
-        mov     [_bx+tracks.note.noteold],ax
-        mov     [_bx+tracks.cmd.bendervalue],ax
-        sub     bh,bh
-        mov     bl,[_bx+tracks.note.note]
-        shl     bx,1
-        mov     bx,[_bx+frequencyTable]
-        movzx   eax,[_di+samples.orgrate]       ; EAX = frequency of middle-C
-        mul     ebx                     ; DX:AX = AX*(relative frequency)
-        shrd    eax,edx,10
-        pop     _bx
-        mov     [_di+samples.rate],eax
-        mov     ecx,eax
-        movzx   edx,[_bx+tracks.note.velocity]
-        mov     [_di+samples.volume],dl
-        movzx   eax,[moduleinfo.track]
-        test    [_bx+tracks.status],PAUSED
-        jnz     @@exit
-        ecall   cdiPlayNote eax,ecx,edx
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   notecut
-; *
-; *     Description :   Cuts note at x frame
-; *
-; ************************************************************************/
-
-PROC    notecut NEAR
-
-        mov     al,[_bx+tracks.cmd.value]
-        or      al,al
-        jz      @@goforit
-        cmp     al,[moduleinfo.cmdcount]
-        jne     @@exit
-@@goforit:
-        mov     [_bx+tracks.note.velocity],0
-        movzx   eax,[moduleinfo.track]
-        ecall   cdiSetVolume eax,<LARGE 0>
-@@exit:
-        ret
-ENDP
-
-IFDEF __32__
-        LABEL   runcommandProcs  word
-
-            DW  cVolume
-            DD  offset slideVolume
-            DW  cBender
-            DD  offset slidePitch
-            DW  cBenderTo
-            DD  offset slidePitchNote
-            DW  cVibrato
-            DD  offset vibrato
-            DW  cTremolo
-            DD  offset tremolo
-            DW  cBenderVol
-            DD  offset benderVol
-            DW  cVibrVol
-            DD  offset vibratoVol
-            DW  cRetrig
-            DD  offset retrig
-            DW  cDelayNote
-            DD  offset delaynote
-            DW  cNoteCut
-            DD  offset notecut
-            DW  cExtraFineBender
-            DD  offset slidePitchFine
-ELSE
-        LABEL   runcommandProcs word
-
-            DW  cVolume
-            DW  offset slideVolume
-            DW  cBender
-            DW  offset slidePitch
-            DW  cBenderTo
-            DW  offset slidePitchNote
-            DW  cVibrato
-            DW  offset vibrato
-            DW  cTremolo
-            DW  offset tremolo
-            DW  cBenderVol
-            DW  offset benderVol
-            DW  cVibrVol
-            DW  offset vibratoVol
-            DW  cRetrig
-            DW  offset retrig
-            DW  cDelayNote
-            DW  offset delaynote
-            DW  cNoteCut
-            DW  offset notecut
-            DW  cExtraFineBender
-            DW  offset slidePitchFine
-ENDIF
-
-
-        LABEL   alwaysProcs word
-
-IFDEF __32__
-            DW  cArpeggio
-            DD  offset arpeggio
-ELSE
-            DW  cArpeggio
-            DW  offset arpeggio
-ENDIF
-
-IFDEF __32__
-        lastAlways = ($-alwaysProcs)/6
-        lastCommand = ($-runcommandProcs)/6
-ELSE
-        lastAlways = ($-alwaysProcs)/4
-        lastCommand = ($-runcommandProcs)/4
-ENDIF
-
-;/*************************************************************************
-; *
-; *     Function    :   runCommand
-; *
-; *     Description :   Runs current command on track
-; *
-; *     Input       :   BX = track number
-; *
-; ************************************************************************/
-
-PROC    runCommand NEAR
-
-        push    _cx _bx _si
-        mov     [moduleinfo.track],bl
-        shl     _bx,1
-        mov     bx,[_bx+trackPtr]       ; (E)BX = tracks[(E)BX]
-        mov     al,[_bx+tracks.cmd.command]
-        sub     ah,ah
-        cmp     al,0
-        je      @@exit
-        mov     _cx,lastCommand
-        mov     _si,offset runcommandProcs
-        cmp     [moduleinfo.cmdcount],0
-        jne     @@runLoop
-        mov     _cx,lastAlways
-        mov     _si,offset alwaysProcs
-@@runLoop:
-        _segcs
-        cmp     ax,[_si]
-        jne     @@next
-        _segcs
-        call    [_OFS _si+2]
-        jmp     @@exit
-@@next:
-IFDEF __32__
-        add     esi,6
-ELSE
-        add     si,4
-ENDIF
-        loop    @@runLoop
-@@exit:
-        pop     _si _bx _cx
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   incPlayed
-; *
-; *     Description :   Increases track's played value
-; *
-; *     Input       :   BX = track
-; *
-; ************************************************************************/
-
-PROC    incPlayed NEAR
-
-        push    _bx
-        shl     _bx,1
-        mov     bx,[_bx+trackPtr]       ; BX = tracks[BX]
-
-        add     [_bx+tracks.note.played],1
-        jnc     @@10
-        mov     [_bx+tracks.note.played],65535
-@@10:
-        pop     _bx
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void ampPlayRow();
-; *
-; *     Description :   Plays one tick of the module
-; *
-; ************************************************************************/
-
-CPROC   ampPlayRow
-
-        ENTERPROC edi esi
-
-        test    [moduleinfo.status],PLAYING
-        jz      @@exit
-        test    [moduleinfo.status],PAUSED
-        jnz     @@exit
-
-IF32    <sub    ecx,ecx>
-        mov     cx,[moduleinfo.channelCount]
-        sub     _bx,_bx
-@@loop2:
-        call    runCommand
-        inc     _bx
-        loop    @@loop2
-@@dontRun:
-        inc     [moduleinfo.cmdcount]
-        mov     al,[moduleinfo.cmdcount]
-        cmp     al,[moduleinfo.tempo]
-        jb      @@noNewNote
-        mov     [moduleinfo.cmdcount],0 ; Reset command counter
-
-        cmp     [moduleinfo.break],0    ; Is break command issued?
-        jne     @@break
-        cmp     [moduleinfo.ticks],64   ; Did it go over?
-        jl      @@nobreak
-@@break:
-        mov     [moduleinfo.break],0
-        inc     [moduleinfo.pattern]
-        call    nextPattern             ; Load next pattern into tracks
-        or      ax,ax
-        jnz     @@exit
-@@nobreak:
-IF32    <sub    ecx,ecx>
-        mov     cx,[moduleinfo.channelCount]
-        sub     _bx,_bx
-@@trackLoop:
-        push    _cx _bx
-        ecall   playTrack
-        pop     _bx _cx
-        inc     _bx
-        loop    @@trackLoop
-
-        mov     ax,[moduleinfo.ticks]
-        mov     [moduleinfo.row],ax
-        inc     [moduleinfo.ticks]              ; Increase ticks
-@@noNewNote:
-IF32    <sub    ecx,ecx>
-        mov     cx,[moduleinfo.channelCount]
-        sub     _bx,_bx
-@@loopPlayed:
-        call    incPlayed
-        inc     _bx
-        loop    @@loopPlayed
-@@exit:
-        LEAVEPROC edi esi
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void ampPoll();
-; *
-; *     Description :   Polling routine for playing modules in the background
-; *
-; ************************************************************************/
-
-CPROC   ampPoll
-
-        ENTERPROC _di _si
-
-        checkInit
-
-        cmp     [ampBusy],1             ; Is AMP busy?
-        je      @@exit
-
-        mov     [ampBusy],1             ; Indicate busy
-        ecall   ampGetBufferDelta
-        mov     edi,eax                 ; EDI = delta
-        ecall   cdiGetDelta <LARGE 0>
-        mov     esi,eax                 ; ESI = buffer delta
-        add     eax,[calced]
-        cmp     eax,edi                 ; Is calced+bufferdelta > delta??
-        jg      @@goforit
-        cmp     esi,5000                ; Is buffer delta > 5msecs?
-        jl      @@calcdone
-        ecall   cdiPoll <LARGE 0>,esi   ; Fill buffer
-        add     [calced],esi
-        jmp     @@calcdone
-@@goforit:
-        mov     eax,edi
-        sub     eax,[calced]            ; EAX = delta-calced
-        sub     esi,eax                 ; ESI -= EAX
-        ecall   cdiPoll <LARGE 0>,eax   ; Fill buffer
-        ecall   ampPlayRow
-@@playloop:
-        cmp     esi,edi                 ; While ESI > EDI...
-        jle     @@loopdone
-        ecall   cdiPoll <LARGE 0>,edi
-        sub     esi,edi
-        ecall   ampPlayRow              ; Play music
-        ecall   ampGetBufferDelta
-        mov     edi,eax                 ; EDI = delta
-        jmp     @@playloop              ; endwhile
-@@loopdone:
-        mov     [calced],esi
-        ecall   cdiPoll <LARGE 0>,esi
-@@calcdone:
-        mov     [ampBusy],0
-@@exit:
-        LEAVEPROC _di _si
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   ampInterrupt
-; *
-; *     Description :   Int 8 handler taking care of module playing
-; *
-; ************************************************************************/
-
-CPROC   ampInterrupt
-
-        pushad
-        push    ds
-        push    es
-
-        mov     ax,DGROUP               ; Load data segment value
-        mov     ds,ax
-
-IFDEF __16__
-        cli
-        mov     [oldSS],ss
-        mov     [oldSP],sp
-
-        mov     ax,ds
-        mov     ss,ax
-        mov     sp,offset stack2
-        sti
-ENDIF
-
-;       in      al,21h
-;       or      al,00000010b            ; Mask out keyboard IRQ
-;       out     21h,al
-        sti
-
-        ecall   ampPoll
-
-        cli
-;       in      al,21h
-;       and     al,NOT 00000010b        ; Enable keyboard IRQ
-;       out     21h,al
-
-IFDEF __16__
-        mov     ss,[oldSS]
-        mov     sp,[oldSP]
-ENDIF
-        pop     es
-        pop     ds
-        popad
-        iret
-ENDP
-
-;/*************************************************************************
-; *                                                                       *
-; * HERE STARTS AMPRTNS                                                   *
-; *                                                                       *
-; ************************************************************************/
-
-;/*************************************************************************
-; *
-; *     Function    :   int ampInit(int options);
-; *
-; *     Description :   Initializes Advanced Module Player
-; *
-; *     Input       :   AMP options
-; *
-; *     Returns     :    0 = ok
-; *                     -1 = error
-; *
-; ************************************************************************/
-
-CPROC   ampInit  @@options
-
-        ENTERPROC _di
-
-        RETVAL  -1
-        test    [cdiStatus],CDI_INITED  ; Is CDI initialized?
-        jz      @@exit
-        mov     _di,offset moduleinfo   ; ESDI points to 'moduleinfo'
-        PUSHDS
-        POPES
-        mov     _cx,SIZE S_PLAYINFO
-        sub     al,al
-        cld
-        rep     stosb                   ; clear it
-
-        mov     _di,offset tracks       ; ESDI = tracks
-        mov     _cx,(SIZE S_TRACKINFO)*MAXTRACKS
-        rep     stosb                   ; clear it
-
-        mov     eax,[@@options]
-        mov     [moduleinfo.initOptions],ax
-
-        or      [ampStatus],1           ; Initialize variables
-        mov     [ampBusy],0
-        mov     [timeValue],50
-        mov     [calced],0
-        sub     _ax,_ax
-@@exit:
-        LEAVEPROC _di
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int ampClose()
-; *
-; *     Description :   Closes module player.
-; *
-; ************************************************************************/
-
-CPROC   ampClose
-
-        RETVAL  -1
-        test    [ampStatus],1
-        jz      @@exit
-
-        and     [ampStatus],NOT 1
-        mov     [moduleinfo.status],0   ; Stop module
-        sub     _ax,_ax
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int ampPlayMultiplePatterns(MODULE *mod,int start,
-; *                                             int end,int options)
-; *
-; *     Description :   Plays patterns from 'start' to 'end'
-; *
-; *     Input       :   options : bit 0 = 1 looping on
-; *
-; *     Returns     :   0 = no error, otherwise error
-; *
-; ************************************************************************/
-
-CPROC   ampPlayMultiplePatterns  @@module,@@startpat,@@endpat,@@options
-
-        ENTERPROC _si _di
-
-        checkInit
-
-        cld
-        PUSHDS
-        push    ds
-        pop     es
-        mov     _di,offset _curModule   ; ESDI = _curModule
-        LDSSI   [@@module]
-IFDEF __32__
-        or      esi,esi
-        jnz     @@notNULL
-ELSE
-        mov     ax,ds
-        or      ax,si                   ; is it NULL?
-        jnz     @@notNULL
-ENDIF
-        POPDS
-        RETVAL  -1
-        jmp     @@exit
-@@notNULL:
-        mov     _cx,SIZE S_MODULE
-        rep     movsb                   ; Copy module structure
-        POPDS
-
-        cmp     [_curModule.type],0
-        jz      @@exit                  ; No module
-
-        mov     ax,-2
-        mov     edx,[@@startpat]
-        cmp     dl,[_curModule.patternCount]
-        jae     @@exit                  ; Are startpattern & endpattern
-        mov     edx,[@@endpat]          ; legal?
-        cmp     dl,[_curModule.patternCount]
-        ja      @@exit
-
-        mov     [moduleinfo.status],0
-
-        mov     _di,offset tracks
-        PUSHDS
-        POPES
-        mov     _cx,(SIZE S_TRACKINFO)*MAXTRACKS
-        sub     al,al
-        rep     stosb                   ; Clear tracks
-
-        mov     [moduleinfo.tempovalue],TEMPO_STM
-        cmp     [_curModule.type],MOD_STM
-        je      @@10
-        mov     [moduleinfo.tempovalue],TEMPO_MOD
-@@10:
-        mov     [moduleinfo.break],0
-        mov     [moduleinfo.track],0
-        mov     [moduleinfo.row],0
-        mov     [moduleinfo.sync],0
-        mov     [moduleinfo.ticks],0
-        mov     [moduleinfo.timerCount],0
-        mov     al,[_curModule.speed]
-        mov     [moduleinfo.tempo],al
-        mov     al,[_curModule.tempo]
-        mov     [moduleinfo.extTempo],al        ; Tempos...
-        sub     ah,ah
-        imul    ax,50
-        sub     dx,dx
-        mov     cx,125
-        div     cx
-        mov     [timeValue],ax
-        mov     eax,[@@startpat]
-        mov     [moduleinfo.firstPattern],al
-        mov     [moduleinfo.pattern],al
-        mov     eax,[@@endpat]
-        mov     [moduleinfo.lastPattern],al
-        mov     eax,[@@options]
-        mov     [moduleinfo.options],ax
-        mov     eax,[_curModule.patterns]
-        mov     [moduleinfo.patterndata],eax
-        mov     eax,[_curModule.instruments]
-        mov     [moduleinfo.instrdata],eax
-        mov     al,[_curModule.channelCount]
-        sub     ah,ah
-        mov     [moduleinfo.channelCount],ax
-
-        mov     _cx,MAXTRACKS
-        sub     ebx,ebx
-@@loop0:
-        movzx   eax,[_bx+_curModule.channelPanning]
-        push    eax _bx _cx
-        ecall   ampSetPanning ebx,eax
-        pop     _cx _bx eax
-        mov     [_bx+moduleinfo.channelPanning],al
-        inc     _bx
-        loop    @@loop0
-
-        call    nextPattern
-
-IF32    <sub    ecx,ecx>
-        mov     cx,[moduleinfo.channelCount]
-        sub     ebx,ebx
-@@resumeLoop:
-        push    cx _bx
-        ecall   ampResumeTrack ebx
-        pop     _bx cx
-        inc     _bx
-        loop    @@resumeLoop
-        movzx   _cx,[_curModule.instrumentCount]
-        LESSI   [moduleinfo.instrdata]
-        sub     _bx,_bx
-@@insloop:
-        PUSHES
-        push    _si _cx _bx
-        imul    _bx,SIZE S_INSTRUMENT
-        add     _si,_bx
-        PUSHES
-        push    _si
-        sub     _dx,_dx
-        sub     _ax,_ax
-        cmp     [ESSI+S_INSTRUMENT.sample],0
-        je      @@nosample
-        cmp     [WORD HIGH ESSI+S_INSTRUMENT.sample],0FFFFh
-        jne     @@novirtual
-        PUSHES
-        push    _si
-        movzx   eax,[WORD LOW ESSI+S_INSTRUMENT.sample]
-        ecall   mcpSampleRealAddress eax,<LARGE 0>
-        pop     _si
-        POPES
-        ecall   cdiDownloadSample <LARGE 0>,<dx ax>,[ESSI+S_INSTRUMENT.sample],[ESSI+S_INSTRUMENT.size]
-        jmp     short @@nosample
-@@novirtual:
-        ecall   cdiDownloadSample <LARGE 0>,[ESSI+S_INSTRUMENT.sample],[ESSI+S_INSTRUMENT.sample],[ESSI+S_INSTRUMENT.size]
-@@nosample:
-        pop     _si
-        POPES
-        pop     _bx _cx _si
-        POPES
-        inc     _bx
-        loop    @@insloop
-        mov     [moduleinfo.status],PLAYING
-        sub     _ax,_ax
-@@exit:
-        LEAVEPROC _si _di
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int ampPlayModule(MODULE *mod, int options)
-; *
-; *     Description :   Plays the whole module
-; *
-; *     Input       :   options bit 0 = 1, looping on
-; *
-; ************************************************************************/
-
-CPROC   ampPlayModule  @@module,@@options
-
-        ENTERPROC
-
-        checkInit
-
-        LESBX   [@@module]
-        cmp     [ESBX+S_MODULE.type],0
-        je      @@exit
-        sub     eax,eax
-        movzx   edx,[ESBX+S_MODULE.patternCount]
-        ecall   ampPlayMultiplePatterns [@@module],eax,edx,[@@options]
-@@exit:
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int ampPlayPattern(MODULE *mod, int pattern, int options)
-; *
-; *     Description :   Plays one pattern
-; *
-; *     Input       :   pattern to play, (options as above)
-; *
-; ************************************************************************/
-
-CPROC   ampPlayPattern  @@module,@@pattern,@@options
-
-        ENTERPROC
-
-        checkInit
-
-        LESBX   [@@module]
-        cmp     [ESBX+S_MODULE.type],0
-        je      @@exit
-        mov     eax,[@@pattern]
-        cmp     al,[ESBX+S_MODULE.patternCount]
-        jae     @@exit
-        ecall   ampPlayMultiplePatterns [@@module],eax,eax,[@@options]
-@@exit:
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int ampStopModule()
-; *
-; *     Description :   Stops moduleinfo module
-; *
-; ************************************************************************/
-
-CPROC   ampStopModule
-
-        push    esi
-
-        checkInit
-
-        mov     eax,-2
-        cwd
-        test    [moduleinfo.status],PLAYING
-        jz      @@exit
-        and     [moduleinfo.status],NOT (PLAYING OR PAUSED)
-IF32    <sub    ecx,ecx>
-        mov     cx,[moduleinfo.channelCount]
-        sub     esi,esi
-@@loop:
-        push    _cx
-        ecall   cdiStopNote esi
-        inc     esi
-        pop     _cx
-        loop    @@loop
-
-        ecall   cdiUnloadSamples <LARGE 0>
-
-        sub     _ax,_ax                 ; No error
-@@exit:
-        pop     esi
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int ampPauseModule()
-; *
-; *     Description :   Pauses module from moduleinfo
-; *
-; *     Returns     :   0 = module paused
-; *                    -1 = no module
-; *                    -2 = module was already paused
-; *
-; ************************************************************************/
-
-CPROC   ampPauseModule
-
-        push    esi
-
-        checkInit
-
-        RETVAL  -2
-        test    [moduleinfo.status],PAUSED
-        jnz     @@exit
-IF32    <sub    ecx,ecx>
-        mov     cx,[moduleinfo.channelCount]
-        sub     esi,esi
-@@loop:
-        push    _cx
-        ecall   ampPauseTrack esi
-        inc     esi
-        pop     _cx
-        loop    @@loop
-        or      [moduleinfo.status],PAUSED
-        sub     _ax,_ax                 ; No error
-@@exit:
-        pop     esi
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int ampResumeModule()
-; *
-; *     Description :   Continues moduleinfo the module
-; *
-; *     Returns     :   0 = resumed successfully
-; *                    -1 = no module
-; *                    -2 = module was not paused
-; *
-; ************************************************************************/
-
-CPROC   ampResumeModule
-
-        push    esi
-
-        checkInit
-
-        RETVAL  -2
-        test    [moduleinfo.status],PAUSED
-        jz      @@exit
-        and     [moduleinfo.status],NOT PAUSED
-IF32    <sub    ecx,ecx>
-        mov     cx,[moduleinfo.channelCount]
-        sub     esi,esi
-@@loop:
-        push    _cx
-        ecall   ampResumeTrack esi
-        inc     esi
-        pop     _cx
-        loop    @@loop
-        sub     _ax,_ax                 ; No error
-@@exit:
-        pop     esi
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int ampGetModuleStatus()
-; *
-; *     Description :   Returns module's status
-; *
-; ************************************************************************/
-
-CPROC   ampGetModuleStatus
-
-        checkInit
-
-        movzx   eax,[moduleinfo.status]
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int ampGetTrackStatus(int track)
-; *
-; *     Description :   Returns track's status word
-; *
-; ************************************************************************/
-
-CPROC   ampGetTrackStatus  @@track
-
-        ENTERPROC
-
-        checkInit
-        calcTrack
-
-IF32    <sub    eax,eax>
-        mov     ax,[_bx+tracks.status]
-@@exit:
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int ampPauseTrack(int track)
-; *
-; *     Description :   Track stops moduleinfo until ampResumeTrack is issued
-; *
-; *     Input       :   track to pause
-; *
-; *     Returns     :   0 = paused successfully
-; *                    -1 = no module
-; *                    -2 = track was already paused
-; *
-; ************************************************************************/
-
-CPROC   ampPauseTrack  @@track
-
-        ENTERPROC
-
-        checkInit
-        calcTrack
-
-        RETVAL  -2
-        test    [_bx+tracks.status],PAUSED
-        jnz     @@exit
-        test    [moduleinfo.status],PAUSED
-        jnz     @@exit
-        or      [_bx+tracks.status],PAUSED
-        ecall   cdiPause [@@track]
-        RETVAL  0
-@@exit:
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int ampResumeTrack(int track)
-; *
-; *     Description :   Track continues moduleinfo
-; *
-; *     Input       :   track to resume
-; *
-; *     Returns     :   0 = resumed successfully
-; *                    -1 = no module
-; *                    -2 = track wasn't paused
-; *
-; ************************************************************************/
-
-CPROC   ampResumeTrack  @@track
-
-        ENTERPROC
-
-        checkInit
-
-        RETVAL  -2
-        test    [moduleinfo.status],PAUSED
-        jnz     @@exit
-
-        ecall   cdiResume [@@track]
-
-        calcTrack
-
-        RETVAL  -2
-        test    [_bx+tracks.status],PAUSED
-        jz      @@exit
-        and     [_bx+tracks.status],NOT PAUSED
-        RETVAL  0
-@@exit:
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int ampGetPattern()
-; *
-; *     Description :   Returns currently moduleinfo pattern
-; *
-; ************************************************************************/
-
-CPROC   ampGetPattern
-
-        checkInit
-
-        movzx   _ax,[moduleinfo.pattern]
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int ampGetRow()
-; *
-; *     Description :   Returns currently moduleinfo row
-; *
-; ************************************************************************/
-
-CPROC   ampGetRow
-
-        checkInit
-
-IF32    <sub    eax,eax>
-        mov     ax,[moduleinfo.row]
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int ampGetSync()
-; *
-; *     Description :   Returns current synchronization code and resets it
-; *
-; ************************************************************************/
-
-CPROC   ampGetSync
-
-        checkInit
-
-        movzx   _ax,[moduleinfo.sync]
-        mov     [moduleinfo.sync],0
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int ampGetTempo()
-; *
-; *     Description :   Returns module's current tempo
-; *
-; ************************************************************************/
-
-CPROC   ampGetTempo
-
-        checkInit
-
-IF32    <sub    eax,eax>
-        mov     al,[moduleinfo.tempo]
-        mov     ah,[moduleinfo.extTempo]
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void ampSetTempo(int new_tempo)
-; *
-; *     Description :   Sets new tempo on module
-; *
-; *     Input       :   new_tempo , 6 = normal tempo, 3 = twice as fast
-; *
-; ************************************************************************/
-
-CPROC   ampSetTempo  @@new_tempo
-
-        ENTERPROC
-
-        checkInit
-
-        mov     eax,[@@new_tempo]
-        or      al,al
-        jz      @@notempo
-        mov     [moduleinfo.tempo],al
-@@notempo:
-        or      ah,ah
-        jz      @@exit
-        mov     [moduleinfo.extTempo],ah
-        mov     al,ah
-        sub     ah,ah
-        imul    ax,50
-        sub     dx,dx
-        mov     cx,125
-        div     cx
-        mov     [timeValue],ax
-@@exit:
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   TRACKDATA  *ampGetTrackData(int track)
-; *
-; *     Description :   Allows program to know what note and command is
-; *                     currently playing on the track.
-; *
-; *     Returns     :   Pointer to TRACKDATA structure which is overwritten
-; *                     on every call. If error occurs, NULL is returned.
-; *
-; ************************************************************************/
-
-CPROC   ampGetTrackData  @@track
-
-        ENTERPROC       _di
-
-        sub     ax,ax
-        sub     dx,dx                   ; Return NULL on error
-        test    [ampStatus],1
-        jz      @@exit
-        movzx   ebx,[moduleinfo.channelCount]
-        cmp     [@@track],ebx
-        jbe     @@ok
-
-        mov     _di,offset trackdata
-        PUSHDS
-        POPES
-        mov     _cx,SIZE S_TRACKDATA
-        sub     al,al
-        cld
-        rep     stosb
-        jmp     @@done
-@@ok:
-        mov     ebx,[@@track]
-        shl     _bx,1
-        mov     bx,[_bx+trackPtr]
-        mov     ax,[_bx+tracks.status]
-        mov     [trackdata.status],ax
-        mov     al,[_bx+tracks.note.note]
-        mov     [trackdata.note],al
-        mov     al,[_bx+tracks.note.instrument]
-        mov     [trackdata.instrument],al
-        mov     al,[_bx+tracks.note.velocity]
-        mov     [trackdata.velocity],al
-        mov     ax,[_bx+tracks.note.played]
-        mov     [trackdata.playtime],ax
-        mov     al,[_bx+tracks.cmd.command]
-        or      al,80h
-        mov     [trackdata.command],al
-        mov     al,[_bx+tracks.cmd.value]
-        mov     [trackdata.cmdvalue],al
-        mov     al,[_bx+tracks.pan]
-        mov     [trackdata.panning],al
-@@done:
-IFDEF __32__
-        mov     eax,offset trackdata
-ELSE
-        mov     dx,ds
-        mov     ax,offset trackdata
-ENDIF
-@@exit:
-        LEAVEPROC       _di
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void ampBreakPattern(short direction);
-; *
-; *     Description :   Jumps to next pattern
-; *
-; ************************************************************************/
-
-CPROC   ampBreakPattern  @@direct
-
-        ENTERPROC       _di _si
-
-        checkInit
-
-        cmp     [moduleinfo.pattern],0
-        jne     @@cont
-        cmp     [@@direct],0
-        js      @@exit
-@@cont:
-        mov     eax,[@@direct]
-        cmp     eax,1
-        je      @@doit
-        cmp     eax,-1
-        jne     @@exit
-@@doit:
-        add     [moduleinfo.pattern],al
-        call    nextPattern
-@@exit:
-        LEAVEPROC       _di _si
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   long ampGetBufferDelta(void);
-; *
-; *     Description :   Returns the delta time, that should be mixed.
-; *
-; *     Returns     :   Delta time
-; *
-; ************************************************************************/
-
-CPROC   ampGetBufferDelta
-
-        checkInit
-
-        mov     eax,1000000             ; usecs
-        movzx   ebx,[timevalue]
-        sub     edx,edx
-        div     ebx
-        shld    edx,eax,16              ; DX:AX = EAX
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short ampSetPanning(short track, short panpos);
-; *
-; *     Description :   Sets panning for a track
-; *
-; *     Input       :   channel, panning position
-; *
-; ************************************************************************/
-
-CPROC   ampSetPanning  @@track,@@panpos
-
-        ENTERPROC
-
-        checkInit
-        calcTrack
-
-        mov     eax,[@@panpos]
-        mov     [_bx+tracks.pan],al
-
-        mov     edx,[@@track]
-        ecall   cdiSetPan edx,eax
-@@exit:
-        LEAVEPROC
-        ret
-ENDP
-
-ENDS
-
-END
diff --git a/dmp/binary.inc b/dmp/binary.inc
deleted file mode 100644
index 7118e27..0000000
--- a/dmp/binary.inc
+++ /dev/null
@@ -1,196 +0,0 @@
-;$Author:   DCODY  $
-;$Date:   25 Jun 1992 23:21:10  $
-;$Header:   W:/sccs/inc/binary.inv   1.1   25 Jun 1992 23:21:10   DCODY  $
-;$Log:   W:/sccs/inc/binary.inv  $
-;
-;   Rev 1.1   25 Jun 1992 23:21:10   DCODY
-;added generic SB mixer channel equates
-;
-;   Rev 1.0   15 Jun 1992 09:58:34   BCRANE
-;Initial revision.
-;$Logfile:   W:/sccs/inc/binary.inv  $
-;$Modtimes$
-;$Revision:   1.1  $
-;$Workfile:   binary.inc  $ 
-
-;   /*\
-;---|*|----====< BINARY.INC >====----
-;---|*|
-;---|*| Copyright (c) 1991, Media Vision, Inc.	All Rights Reserved.
-;---|*|
-;   \*/
-
-;
-; commands issued to the 2F interface
-;
-
-BI_INSTALLCHECK equ	0		; Check if the driver is installed
-BI_GETVERSION	equ	1		; Get the version #
-BI_GETSTATE	equ	2		; Get the state pointer and size
-BI_GETFUNCTION	equ	3		; Get the function table pointer
-BI_GETDMAIRQ	equ	4		; Get the DMA/IRQ/INT number
-BI_SENDCMD	equ	5		; reserved now. see function #3
-BI_GETSTATUSSTR equ	6		; Get the status string
-BI_reserved1	equ	7		; reserved
-BI_reserved2	equ	8		; reserved
-BI_reserved3	equ	9		; reserved
-BI_SETSCANCODE	equ    10		; set the hot key scan codes
-BI_GETPATH	equ    11		; get the file path
-
-;
-; TRUE/FALSE & ON/OFF logic values
-;
-
-BI_TRUE 	equ	-1
-BI_FALSE	equ	0
-
-BI_ON		equ	BI_TRUE 	; on state
-BI_OFF		equ	BI_FALSE	; off state
-
-BI_INT2FCODE1	equ	0BCH		; Bryan's initials
-
-; int 2F ID (func 0) return register values
-
-BI_INT2FREGBX	equ	6D00h		; 'm '
-BI_INT2FREGCX	equ	0076h		; ' v'
-BI_INT2FREGDX	equ	2020h		; UPPERCASE XOR MASK
-
-;
-; Command Block Structure
-;
-
-bcmdblk  struc
-
-  bc_blockID	  dw	?	; language command block	(mandatory)
-
-  bc_devcode	  dw	?	; device code (MIXER/VOLUME/CROSS/FILTER...)
-
-  bc_deviceselect dw	?	; INPUT|OUTPUT mixer select & more...
-
-  bc_fromflag	  dw	?	; [FROM <term>] TRUE/FALSE
-  bc_fromtype	  dw	?	; type fromvalue is type # or %
-  bc_fromvalue	  dw	?	; value derived from <term>
-
-  bc_toflag	  dw	?	; [TO <term>] TRUE/FALSE	(mandatory)
-  bc_totype	  dw	?	; type fromvalue is type # or %
-  bc_tovalue	  dw	?	; value derived from <term>
-
-  breserved1	  dw	?	; reserved for internal use
-
-  bc_leftchflag   dw	?	; set left channel  TRUE/FALSE
-  bc_leftchannel  dw	?	; left channel #
-
-  bc_ritchflag	  dw	?	; set right channel TRUE/FALSE
-  bc_ritchannel   dw	?	; right channel #
-
-  bc_secondsflag  dw	?	; TRUE/FALSE to do it over time
-  bc_secondcount  dw	?	; # of seconds to spread out the command
-
-  breserved2	  dw	?	; reserved for internal use
-
-  bc_errorcode	  dw	?	; holds the error number
-  bc_targetstr	  dd	?	; user's target string pointer
-
-bcmdblk  ends
-
-;
-; blockID Commands
-;
-
-BI_RESETCMD	equ	0		; Reset the hardware settings
-BI_SETCMD	equ	1		; SET parsed language block
-BI_GETCMD	equ	2		; GET parsed language block
-BI_HOLDCMD	equ	3		; Hold the queue
-BI_RELCMD	equ	4		; Release the queue
-
-;
-; execode Commands
-;
-
-BI_CROSSCMD	EQU	0		; command is for the cross channel
-BI_FILTERCMD	EQU	1		; command is for the filter
-BI_MIXERCMD	EQU	2		; command is for the mixer
-BI_REALCMD	EQU	3		; command is for the real sound switch
-BI_VOLUMECMD	EQU	4		; command is for the volume
-
-BI_LASTEXECMD	EQU	BI_VOLUMECMD	; Last valid command
-
-;
-; different logic flags for a TO condition (c_xxxxflag)
-;
-
-BI_DONTSET	equ	 0		; don't process FROM value
-BI_SETFROM	equ	-1		; FROM setting is available
-BI_SETTO	equ	-1		; TO setting is available (mandatory)
-BI_UPTO 	equ	-2		; set up from current setting
-BI_DOWNTO	equ	-3		; set down from current setting
-
-;
-; types of numeric data in FROM and TO fields (c_xxxxtype)
-;
-
-BI_TYPEINT	equ	1		; "getterm" return type
-BI_TYPEPCT	equ	2		; "getterm" return type
-
-;
-; deviceselect values (c_deviceselect)
-;
-;       (none for the filter)
-
-;       for mixers
-
-BI_OUTPUTMIXER	equ	00h		; output mixer H/W select
-BI_INPUTMIXER	equ	40h		; input mixer select
-BI_DEFMIXER	equ	0ffh		; use the default mixer
-
-;	for cross channel
-
-BI_RIGHT2RIGHT	equ	01h		; right to right
-BI_LEFT2RIGHT	equ	02h		; left	to right
-BI_RIGHT2LEFT	equ	04h		; right to left
-BI_LEFT2LEFT	equ	08h		; left	to left
-
-;	for volume control
-
-BI_VOLLOUD	equ	00h		; LOUDNESS switch
-BI_VOLENHANCE	equ	01h		; ENHANCED stereo
-BI_VOLBASS	equ	02h		; BASS (0-12)
-BI_VOLTREBLE	equ	03h		; TREBLE (0-12)
-BI_VOLLEFT	equ	04h		; LEFT VOLUME  (0-40)
-BI_VOLRIGHT	equ	05h		; RIGHT VOLUME (0-40)
-BI_VOLMODE	equ	06h		; MODE	(LEFT/STEREO/RIGHT)
-
-BI_bVOLLOUD	equ	0001b		; enhanced bass bit
-BI_bVOLENH	equ	0010b		; enhanced stereo bit
-
-;
-; left/right mixer channel selection
-;
-
-;	left channel values
-
-BI_L_FM 	equ	01h
-BI_L_IMIXER	equ	02h
-BI_L_EXT	equ	03h
-BI_L_INT	equ	04h
-BI_L_MIC	equ	05h
-BI_L_PCM	equ	06h
-BI_L_SPEAKER	equ	07h
-BI_L_SBDAC	equ	00h
-
-;	right channel values
-
-BI_R_FM 	equ	08h
-BI_R_IMIXER	equ	09h
-BI_R_EXT	equ	0Ah
-BI_R_INT	equ	0Bh
-BI_R_MIC	equ	0Ch
-BI_R_PCM	equ	0Dh
-BI_R_SPEAKER	equ	0Eh
-BI_R_SBDAC	equ	0Fh
-
-
-;   /*\
-;---|*| end of binary.inc
-;   \*/
-
diff --git a/dmp/cdi.asm b/dmp/cdi.asm
deleted file mode 100644
index 9a53d61..0000000
--- a/dmp/cdi.asm
+++ /dev/null
@@ -1,580 +0,0 @@
-;/************************************************************************
-; *
-; *     File        : CDI.ASM
-; *
-; *     Description : Channel Distributor for DSMI
-; *
-; *     Copyright (C) 1993 Otto Chrons
-; *
-; ***********************************************************************/
-
-        IDEAL
-        JUMPS
-        P386
-
-        INCLUDE "MODEL.INC"
-        INCLUDE "CDI.INC"
-
-MACRO   getDevice
-
-        mov     ebx,[@@channel]
-        movzx   _bx,[_bx+channelTable]
-        imul    _bx,SIZE CDIDEVICE
-        add     _bx,offset deviceTable
-ENDM
-
-CSEGMENTS CDI
-
-CDATASEG
-
-IFDEF   __PASCAL__
-        EXTRN   cdiStatus:WORD
-ELSE
-        PUBLIC  cdiStatus
-        cdiStatus       DW 0
-ENDIF
-
-        channelTable    DB 256 dup(?)
-        deviceTable     CDIDEVICE 8 dup(<>)
-        lastDevice      DW ?
-ENDS
-
-CCODESEG CDI
-
-;/*************************************************************************
-; *
-; *     Function    :   short cdiInit(void);
-; *
-; *     Description :   Initializes CDI
-; *
-; *     Returns     :   0 = no error, other = error
-; *
-; ************************************************************************/
-
-CPROC   cdiInit
-
-        push    _di _si
-
-        PUSHDS
-        POPES
-        mov     _di,offset channelTable
-        sub     ax,ax
-        cld
-        mov     _cx,256
-        rep     stosb                   ; Clear channel table
-        mov     _di,offset deviceTable
-        mov     _cx,SIZE deviceTable
-        rep     stosb                   ; Clear device table
-        mov     [lastDevice],0
-        mov     [cdiStatus],CDI_INITED
-
-        pop     _si _di
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short cdiRegister(CDIDEVICE *cdi,short chFirst,short chLast);
-; *
-; *     Description :   Registers a CDI device to given channels
-; *
-; *     Input       :   Pointer to CDI device structure, first and last channels
-; *
-; *     Returns     :   0 = no error, -1 CDI not initialized,
-; *                     -2 invalid channel
-; *
-; ************************************************************************/
-
-CPROC   cdiRegister @@pcdi,@@chfirst,@@chlast
-
-        ENTERPROC _di _si
-
-        RETVAL  -1
-        test    [cdiStatus],CDI_INITED
-        jz      @@exit
-        RETVAL  -2
-        mov     edx,[@@chfirst]
-        cmp     _dx,0                   ; Check channel limits
-        jl      @@exit
-        cmp     _dx,255
-        jg      @@exit
-        mov     ecx,[@@chlast]
-        cmp     _cx,0
-        jl      @@exit
-        cmp     _cx,255
-        jg      @@exit
-        cmp     _cx,_dx                 ; Last channel < first?
-        jl      @@exit
-        mov     _di,_dx
-        add     _di,offset channelTable
-        PUSHDS
-        POPES
-        sub     al,al
-        sub     _cx,_dx
-        inc     _cx                     ; CX = channel count
-        push    _cx _di
-        cld
-        repe    scasb
-        mov     ax,-2
-        or      _cx,_cx                 ; Are any channels reserved?
-        pop     _di _cx
-        jnz     @@exit
-        inc     [lastDevice]
-        mov     ax,[lastDevice]
-        rep     stosb                   ; Reserve channels
-
-        movzx   edi,[lastDevice]
-        imul    _di,SIZE CDIDEVICE      ; DI = offset to device table
-        add     _di,offset deviceTable
-        PUSHDS
-        PUSHDS
-        POPES                           ; ES:DI points to free entry in table
-        LDSSI   [@@pcdi]                ; DS:SI points to new CDI device
-        mov     _cx,SIZE CDIDEVICE
-        rep     movsb                   ; Copy structure
-        POPDS
-
-        RETVAL  0
-@@exit:
-        LEAVEPROC _di _si
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void cdiClose(void);
-; *
-; *     Description :   Closes CDI
-; *
-; ************************************************************************/
-
-CPROC   cdiClose
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void cdiSetInstrument(short @@channel, void *instrument);
-; *
-; *     Description :
-; *
-; *     Input       :
-; *
-; *     Returns     :
-; *
-; ************************************************************************/
-
-CPROC   cdiSetInstrument @@channel, @@inst
-
-        ENTERPROC
-
-        getDevice
-        ecallM  [_bx+CDIDEVICE.setsample] [@@channel],[@@inst]
-
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void cdiPlayNote(short @@channel,long freq, int volume);
-; *
-; ************************************************************************/
-
-CPROC   cdiPlayNote @@channel, @@freq, @@volume
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.playsample] [@@channel],[@@freq],[@@volume]
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void cdiStopNote(short @@channel);
-; *
-; ************************************************************************/
-
-CPROC   cdiStopNote @@channel
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.stopchannel] [@@channel]
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :    cdiSetVolume
-; *
-; ************************************************************************/
-
-CPROC   cdiSetVolume @@channel,@@volume
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.setvolume] [@@channel],[@@volume]
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :    cdiSetFrequency
-; *
-; ************************************************************************/
-
-CPROC   cdiSetFrequency @@channel,@@freq
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.setfrequency] [@@channel],[@@freq]
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :    cdiSetLinear
-; *
-; *     Description :
-; *
-; *     Input       :
-; *
-; *     Returns     :
-; *
-; ************************************************************************/
-
-CPROC   cdiSetLinear @@channel
-
-        ENTERPROC
-        getDevice
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :    cdiSetPosition
-; *
-; ************************************************************************/
-
-CPROC   cdiSetPosition @@channel,@@pos
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.setposition] [@@channel],[@@pos]
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :    cdiSetPan
-; *
-; ************************************************************************/
-
-CPROC   cdiSetPan @@channel,@@pan
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.setpanning] [@@channel],[@@pan]
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :    cdiSetMasterVolume
-; *
-; ************************************************************************/
-
-CPROC   cdiSetMasterVolume @@channel,@@volume
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.setmastervolume] [@@volume]
-        LEAVEPROC
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :    cdiPause
-; *
-; ************************************************************************/
-
-CPROC   cdiPause @@channel
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.pausechannel] [@@channel]
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :    cdiResume
-; *
-; ************************************************************************/
-
-CPROC   cdiResume @@channel
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.resumechannel] [@@channel]
-        LEAVEPROC
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :    cdiPauseAll
-; *
-; ************************************************************************/
-
-CPROC   cdiPauseAll @@channel
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.pauseall]
-        LEAVEPROC
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :    cdiResumeAll
-; *
-; ************************************************************************/
-
-CPROC   cdiResumeAll @@channel
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.resumeall]
-        LEAVEPROC
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void cdiPoll(long time);
-; *
-; *     Description :
-; *
-; *     Input       :
-; *
-; *     Returns     :
-; *
-; ************************************************************************/
-
-CPROC   cdiPoll @@channel,@@time
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.poll] [@@time]
-        LEAVEPROC
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :    cdiGetDelta
-; *
-; *     Description :
-; *
-; *     Input       :
-; *
-; *     Returns     :
-; *
-; ************************************************************************/
-
-CPROC   cdiGetDelta @@channel
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.getdelta]
-        LEAVEPROC
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   long cdiDownloadSample(short @@channel,void *sample,long length);
-; *
-; *     Description :
-; *
-; *     Input       :
-; *
-; *     Returns     :
-; *
-; ************************************************************************/
-
-CPROC   cdiDownloadSample @@channel,@@sample,@@sampletag,@@len
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.download]  [@@sample],[@@sampletag],[@@len]
-        LEAVEPROC
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void cdiUnloadSamples(short @@channel);
-; *
-; *     Description :
-; *
-; *     Input       :
-; *
-; *     Returns     :
-; *
-; ************************************************************************/
-
-CPROC   cdiUnloadSamples @@channel
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.unload]
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   ushort cdiGetVolume(short @@channel);
-; *
-; *     Description :   Returns the current volume on '@@channel'
-; *
-; ************************************************************************/
-
-CPROC   cdiGetVolume @@channel
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.getvolume] [@@channel]
-        LEAVEPROC
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   ushort cdiGetFrequency(short @@channel);
-; *
-; *     Description :   Returns the current frequency on '@@channel'
-; *
-; ************************************************************************/
-
-CPROC   cdiGetFrequency @@channel
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.getfrequency] [@@channel]
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   ushort cdiGetPosition(short @@channel);
-; *
-; *     Description :   Returns the current position on '@@channel'
-; *
-; ************************************************************************/
-
-CPROC   cdiGetPosition @@channel
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.getposition] [@@channel]
-        LEAVEPROC
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   ushort cdiGetPan(short @@channel);
-; *
-; *     Description :   Returns the current pan position on '@@channel'
-; *
-; ************************************************************************/
-
-CPROC   cdiGetPan @@channel
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.getpan] [@@channel]
-        LEAVEPROC
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   ushort cdiGetInstrument(short @@channel);
-; *
-; *     Description :   Returns the current sample on '@@channel'
-; *
-; ************************************************************************/
-
-CPROC   cdiGetInstrument @@channel
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.getsample] [@@channel]
-        LEAVEPROC
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short cdiSetupChannels(short @@channel, short count, ushort *volTable);
-; *
-; *     Description :   Sets up 'count' channels
-; *
-; ************************************************************************/
-
-CPROC   cdiSetupChannels @@channel,@@count,@@volTable
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.setupch] [@@count],[@@volTable]
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short cdiGetChannelsStatus( long @@channel );
-; *
-; *     Description :   Returns the 'status' of a channel
-; *
-; ************************************************************************/
-
-CPROC   cdiGetChannelStatus @@channel
-
-        ENTERPROC
-        getDevice
-        ecallM  [_bx+CDIDEVICE.getchannelstatus] [@@channel]
-        LEAVEPROC
-        ret
-ENDP
-
-ENDS
-
-END
diff --git a/dmp/cdi.inc b/dmp/cdi.inc
deleted file mode 100644
index bb5461b..0000000
--- a/dmp/cdi.inc
+++ /dev/null
@@ -1,49 +0,0 @@
-;/************************************************************************
-; *
-; *     File        : CDI.INC
-; *
-; *     Description : Include file for Channel Distributor
-; *
-; *     Copyright (C) 1993 Otto Chrons
-; *
-; ***********************************************************************/
-
-STRUC CDIDEVICE
-      setsample         DD ?
-      playsample        DD ?
-      setvolume         DD ?
-      setfrequency      DD ?
-      setlinearrate     DD ?
-      setposition       DD ?
-      setpanning        DD ?
-      setmastervolume   DD ?
-      pausechannel      DD ?
-      resumechannel     DD ?
-      stopchannel       DD ?
-      pauseall          DD ?
-      resumeall         DD ?
-      poll              DD ?
-      getdelta          DD ?
-      download          DD ?
-      unload            DD ?
-      getvolume         DD ?
-      getfrequency      DD ?
-      getposition       DD ?
-      getpan            DD ?
-      getsample         DD ?
-      setupch           DD ?
-      getchannelstatus  DD ?
-ENDS
-
-        CGLOBAL cdiInit:_FAR, cdiRegister:_FAR, cdiClose:_FAR
-
-        CGLOBAL cdiSetInstrument:_FAR, cdiPlayNote:_FAR, cdiStopNote:_FAR
-        CGLOBAL cdiSetVolume:_FAR, cdiSetFrequency:_FAR, cdiSetLinear:_FAR, cdiSetPosition:_FAR
-        CGLOBAL cdiSetPan:_FAR, cdiSetMasterVolume:_FAR, cdiPause:_FAR, cdiResume:_FAR
-        CGLOBAL cdiPauseAll:_FAR, cdiResumeAll:_FAR, cdiPoll:_FAR, cdiGetDelta:_FAR
-        CGLOBAL cdiDownloadSample:_FAR, cdiUnloadSamples:_FAR
-        CGLOBAL cdiGetVolume:_FAR, cdiGetFrequency:_FAR, cdiGetPosition:_FAR
-        CGLOBAL cdiGetPan:_FAR, cdiGetInstrument:_FAR, cdiSetupChannels:_FAR
-        CGLOBAL cdiGetChannelStatus:_FAR
-
-        CDI_INITED = 1
diff --git a/dmp/cdi.pas b/dmp/cdi.pas
deleted file mode 100644
index d07ea02..0000000
--- a/dmp/cdi.pas
+++ /dev/null
@@ -1,97 +0,0 @@
-{ -------------------------------------------------------------------------- }
-{                                                                            }
-{                                  CDI.PAS                                   }
-{                                  -------                                   }
-{                                                                            }
-{                         (C) 1993 Jussi Lahdenniemi                         }
-{         Original C file (C) 1993 Otto Chrons                               }
-{                                                                            }
-{ Channel Distributor unit file                                              }
-{                                                                            }
-{ -------------------------------------------------------------------------- }
-
-unit cdi;
-
-interface
-
-type    PCDIdevice = ^TCDIdevice;
-        TCDIdevice = Record
-          setsample, playsample, setvolume, setfrequency, setlinearrate,
-          setposition, setpanning, setmastervolume, pausechannel,
-          resumechannel, stopchannel, pauseall, resumeall, poll, getdelta,
-          download, unload, getvolume, getfrequency, getposition, getpan,
-          getsample, setupch : pointer;
-        end;
-
-var     cdiStatus  : word;
-
-{#if 0
-	GLOBAL	cdiInit:FAR, cdiRegister:FAR, cdiClose:FAR
-
-	GLOBAL	cdiSetInstrument:FAR, cdiPlayNote:FAR, cdiStopNote:FAR
-	GLOBAL	cdiSetVolume:FAR, cdiSetFrequency:FAR, cdiSetLinear:FAR, cdiSetPosition:FAR
-	GLOBAL	cdiPan:FAR, cdiSetMasterVolume:FAR, cdiPause:FAR, cdiResume:FAR
-	GLOBAL	cdiPauseAll:FAR, cdiResumeAll:FAR, cdiPoll:FAR, cdiGetDelta:FAR
-#endif}
-
-Function  cdiInit:integer;
-Function  cdiRegister(cdi:PCDIdevice;firstch,lastch:longint):integer;
-Procedure cdiClose;
-Procedure cdiSetInstrument(channel:longint;inst:pointer);
-Procedure cdiPlayNote(channel:longint;freq:longint;volume:longint);
-Procedure cdiStopNote(channel:longint);
-Procedure cdiSetVolume(channel:longint;volume:longint);
-Procedure cdiSetFrequency(channel:longint;freq:longint);
-Procedure cdiSetPosition(channel:longint;pos:longint);
-Procedure cdiSetPan(channel:longint;pan:longint);
-Procedure cdiSetMasterVolume(channel,volume:longint);
-Procedure cdiPause(channel:longint);
-Procedure cdiResume(channel:longint);
-Procedure cdiPauseAll(channel:longint);
-Procedure cdiResumeAll(channel:longint);
-Function  cdiPoll(channel:longint):integer;
-Function  cdiGetDelta(channel:longint):longint;
-Procedure cdiDownloadSample(channel:longint;sample,sampletag:pointer;len:longint);
-Procedure cdiUnloadSamples(channel:longint);
-
-Function  cdiSetLinear(channel:longint;linearRate:longint):integer;
-Function  cdiGetVolume(channel:longint):word;
-Function  cdiGetFrequency(channel:longint):longint;
-Function  cdiGetPosition(channel:longint):longint;
-Function  cdiGetPan(channel:longint):integer;
-Function  cdiGetInstrument(channel:longint):pointer;
-Function  cdiSetupChannels(channel,count:longint;volTable:pointer):integer;
-
-implementation
-
-Function  cdiInit:integer; external;
-Function  cdiRegister(cdi:PCDIdevice;firstch,lastch:longint):integer; external;
-Procedure cdiClose; external;
-Procedure cdiSetInstrument(channel:longint;inst:Pointer); external;
-Procedure cdiPlayNote(channel:longint;freq:longint;volume:longint); external;
-Procedure cdiStopNote(channel:longint); external;
-Procedure cdiSetVolume(channel:longint;volume:longint); external;
-Procedure cdiSetFrequency(channel:longint;freq:longint); external;
-Procedure cdiSetPosition(channel:longint;pos:longint); external;
-Procedure cdiSetPan(channel:longint;pan:longint); external;
-Procedure cdiSetMasterVolume(channel,volume:longint); external;
-Procedure cdiPause(channel:longint); external;
-Procedure cdiResume(channel:longint); external;
-Procedure cdiPauseAll(channel:longint); external;
-Procedure cdiResumeAll(channel:longint); external;
-Function  cdiPoll(channel:longint):integer; external;
-Function  cdiGetDelta(channel:longint):longint; external;
-Procedure cdiDownloadSample(channel:longint;sample,sampletag:pointer;len:longint); external;
-Procedure cdiUnloadSamples(channel:longint); external;
-
-Function  cdiSetLinear(channel:longint;linearRate:longint):integer; external;
-Function  cdiGetVolume(channel:longint):word; external;
-Function  cdiGetFrequency(channel:longint):longint; external;
-Function  cdiGetPosition(channel:longint):longint; external;
-Function  cdiGetPan(channel:longint):integer; external;
-Function  cdiGetInstrument(channel:longint):pointer; external;
-Function  cdiSetupChannels(channel,count:longint;volTable:pointer):integer; external;
-
-{$L cdi.obj}
-
-end.
diff --git a/dmp/cdi.tpp b/dmp/cdi.tpp
deleted file mode 100644
index cf0a478..0000000
Binary files a/dmp/cdi.tpp and /dev/null differ
diff --git a/dmp/checkv86.asm b/dmp/checkv86.asm
deleted file mode 100644
index 13eeb4e..0000000
--- a/dmp/checkv86.asm
+++ /dev/null
@@ -1,23 +0,0 @@
-; Check if the processor (386->) is in the v86-mode
-
-               MODEL TPASCAL
-               P386
-               IDEAL
-
-CODESEG
-
-               PUBLIC INV86
-
-PROC           INV86  FAR
-
-               Pushfd
-               Pop    eax
-               Test   eax,20000h
-               JZ     @@Nov86
-               Mov    ax,1
-               Ret
-@@NOV86:       Sub    ax,ax
-               Ret
-ENDP
-
-END
diff --git a/dmp/chorus b/dmp/chorus
deleted file mode 100644
index 8aa5852..0000000
Binary files a/dmp/chorus and /dev/null differ
diff --git a/dmp/common.inc b/dmp/common.inc
deleted file mode 100644
index 8dc1657..0000000
--- a/dmp/common.inc
+++ /dev/null
@@ -1,538 +0,0 @@
-;$Author:   DCODY  $
-;$Date:   04 Sep 1992 16:40:48  $
-;$Header:   X:/sccs/inc/common.inv   1.2   04 Sep 1992 16:40:48   DCODY  $
-;$Log:   X:/sccs/inc/common.inv  $
-;
-;   Rev 1.2   04 Sep 1992 16:40:48   DCODY
-;
-;   Rev 1.1   25 Jun 1992 23:23:26   DCODY
-;PAS2 update
-;
-;   Rev 1.0   15 Jun 1992 09:58:38   BCRANE
-;Initial revision.
-;$Logfile:   X:/sccs/inc/common.inv  $
-;$Modtimes$
-;$Revision:   1.2  $
-;$Workfile:   common.inc  $ 
-
-;   /*\
-;---|*|----====< COMMON.INC >====----
-;---|*|
-;---|*| This file contains the Media Vision hardware definition equates, and.
-;---|*| the PC hardware environment.
-;---|*|
-;---|*| Copyright (c) 1991,1992 Media Vision, Inc.  All Rights Reserved.
-;---|*|
-;   \*/
-
-; Hardware associated with the PAS1/PAS2/CDPC
-
-DEFAULT_BASE    EQU     00388h          ;; default base I/O address
-ALT_BASE_1      EQU     00384h          ;; first alternate address
-ALT_BASE_2      EQU     0038Ch          ;; second alternate address
-ALT_BASE_3      EQU     00288h          ;; third alternate address
-USE_ACTIVE_ADDR EQU     00000h          ;; uses what is currently active
-
-DUALFM          EQU     1               ;; Dual FM chips
-DUALMIXER       EQU     1               ;; Dual mixers
-FILTER          EQU     1               ;; Has filter after input mixer
-VOLUME          EQU     1               ;; Has total volume control
-
-TEXTVERSIONHI   EQU     '01'            ;; VERSION 01.00
-TEXTVERSIONLO   EQU     '00'
-
-SYSSPKRTMR      EQU     00042h          ;; System Speaker Timer Address
-SYSTMRCTLR      EQU     00043h          ;; System Timer Control Register
-SYSSPKRREG      EQU     00061h          ;; System Speaker Register
-JOYSTICK        EQU     00201h          ;; Joystick Register
-LFMADDR         EQU     00388h          ;; Left  FM Synthesizer Address Register
-LFMDATA         EQU     00389h          ;; Left  FM Synthesizer Data Register
-RFMADDR         EQU     0038Ah          ;; Right FM Synthesizer Address Register
-RFMDATA         EQU     0038Bh          ;; Right FM Synthesizer Data Register
-
-AUXADDR         EQU     00788h          ;; Auxiliary Register
-AUXDATA         EQU     00789h          ;; Auxiliary Register
-DFMADDR         EQU     00788h          ;; Dual  FM Synthesizer Address Register
-DFMDATA         EQU     00789h          ;; Dual  FM Synthesizer Data Register
-
-pAUDIOMIXR      EQU     0078Bh          ;; Parallel interface Audio Mixer Reg
-AUDIOMIXR       EQU     00B88h          ;; Audio Mixer Control Register
-AUDIOFILT       EQU     00B8Ah          ;; Audio Filter Control Register
-INTRCTLRST      EQU     00B89h          ;; Interrupt Control Status Register
-INTRCTLR        EQU     00B8Bh          ;; Interrupt Control Register write
-INTRCTLRRB      EQU     00B8Bh          ;; Interrupt Control Register read back
-PCMDATA         EQU     00F88h          ;; PCM data I/O register (low byte)
-PCMDATAH        EQU     00F89h          ;; PCM data I/O register (high byte)
-CROSSCHANNEL    EQU     00F8Ah          ;; Cross Channel Register
-SAMPLERATE      EQU     01388h          ;; (t0) Sample Rate Timer Register
-SAMPLECNT       EQU     01389h          ;; (t1) Sample Count Register
-SPKRTMR         EQU     0138Ah          ;; (t2) Local Speaker Timer Address
-TMRCTLR         EQU     0138Bh          ;; Local Timer Control Register
-MDIRQVECT       EQU     01788H          ;; MIDI-0 IRQ Vector Register
-MDSYSCTLR       EQU     01789H          ;; MIDI-1 System Control Register
-MDSYSSTAT       EQU     0178AH          ;; MIDI-2 IRQ Status Register
-MDIRQCLR        EQU     0178BH          ;; MIDI-3 IRQ Clear Register
-MDGROUP4        EQU     01B88H          ;; MIDI-4 Group #1 Register (MDGROUP1)
-MDGROUP5        EQU     01B89H          ;; MIDI-5 Group #2 Register (MDGROUP2)
-MDGROUP6        EQU     01B8AH          ;; MIDI-6 Group #3 Register (MDGROUP3)
-MDGROUP7        EQU     01B8BH          ;; MIDI-7 Group #4 Register (MDGROUP4)
-
-;
-; Factory Default Settings
-;
-DEFAULTDMA      equ     1               ;; DMA channel 1
-DEFAULTIRQ      equ     7               ;; IRQ channel 7
-DEFAULTINT      equ     65h             ;; Interrupt # for software interface
-
-;
-; mixer select
-;
-OUTPUTMIXER     equ     00h             ;; output mixer H/W select
-INPUTMIXER      equ     40h             ;; input mixer select
-DEFMIXER        equ     -1              ;; use last mixer selected
-MIXERMAX        equ     1fh             ;; maximum mixer setting
-
-MVVOLUMEMAX     equ     3fh             ;; MVA508 maximum mixer setting
-NSVOLUMEMAX     equ     28h             ;; National maximum mixer setting
-
-EQUALIZERMAX    equ     0ch             ;; maximum equalizer setting
-EQUALIZERMID    equ     06h             ;; maximum mid setting
-
-;
-;       Filter register bits
-;
-fFIdatabits     equ     00011111B       ;; filter select and decode field bits
-fFImutebits     equ     00100000B       ;; filter mute field bits
-fFIpcmbits      equ     11000000B       ;; filter sample rate field bits
-bFImute         equ     00100000B       ;; filter mute bit
-bFIsrate        equ     01000000B       ;; filter sample rate timer mask
-bFIsbuff        equ     10000000B       ;; filter sample buffer counter mask
-FILTERMAX       equ     6               ;; six possible settings
-
-;
-;       Cross Channel Bit definitions
-;
-fCCcrossbits    EQU     00001111B       ;; cross channel bit field
-fCCpcmbits      EQU     11110000B       ;; pcm/dma control bit field
-bCCr2r          EQU     00000001B       ;; CROSSCHANNEL Right to Right
-bCCl2r          EQU     00000010B       ;; CROSSCHANNEL Left  to Right
-bCCr2l          EQU     00000100B       ;; CROSSCHANNEL Right to Right
-bCCl2l          EQU     00001000B       ;; CROSSCHANNEL Left  to Left
-bCCdac          EQU     00010000B       ;; DAC/ADC Control
-bCCmono         EQU     00100000B       ;; PCM Monaural Enable
-bCCenapcm       EQU     01000000B       ;; Enable PCM state machine
-bCCdrq          EQU     10000000B       ;; Enable DRQ bit
-
-;
-;       Interrupt Control Register Bits
-;
-fICintmaskbits  EQU     00011111B       ;; interrupt mask field bits
-fICrevbits      EQU     11100000B       ;; revision mask field bits
-fICidbits       EQU     11100000B       ;; Board revision ID field bits
-bICleftfm       EQU     00000001B       ;; Left FM interrupt enable
-bICritfm        EQU     00000010B       ;; Right FM interrupt enable
-bICsamprate     EQU     00000100B       ;; Sample Rate timer interrupt enable
-bICsampbuff     EQU     00001000B       ;; Sample buffer timer interrupt enable
-bICmidi         EQU     00010000B       ;; MIDI interrupt enable
-   fICrevshr    EQU     5               ;; rotate rev bits to lsb
-
-;
-;       Interrupt Status Register Bits
-;
-fISints         EQU     00011111B       ;; Interrupt bit field
-bISleftfm       EQU     00000001B       ;; Left FM interrupt active
-bISritfm        EQU     00000010B       ;; Right FM interrupt active
-bISsamprate     EQU     00000100B       ;; Sample Rate timer interrupt active
-bISsampbuff     EQU     00001000B       ;; Sample buffer timer interrupt active
-bISmidi         EQU     00010000B       ;; MIDI interrupt active
-bISPCMlr        EQU     00100000B       ;; PCM left/right active
-bISActive       EQU     01000000B       ;; Hardware is active (not in reset)
-bISClip         EQU     10000000B       ;; Sample Clipping has occured
-
-;
-;       cross channel channel #s
-;
-RIGHT2RIGHT     equ     00h             ;; right to right
-LEFT2RIGHT      equ     01h             ;; left  to right
-RIGHT2LEFT      equ     02h             ;; right to left
-LEFT2LEFT       equ     03h             ;; left  to left
-
-;
-; left/right mixer channel selection
-;
-
-;       left channel values
-
-L_FM            equ     01h
-L_IMIXER        equ     02h
-L_EXT           equ     03h
-L_INT           equ     04h
-L_MIC           equ     05h
-L_PCM           equ     06h
-L_SPEAKER       equ     07h
-L_FREE          equ     00h
-L_SBDAC         equ     00h
-
-;       right channel values
-
-R_FM            equ     08h
-R_IMIXER        equ     09h
-R_EXT           equ     0Ah
-R_INT           equ     0Bh
-R_MIC           equ     0Ch
-R_PCM           equ     0Dh
-R_SPEAKER       equ     0Eh
-R_FREE          equ     0Fh
-R_SBDAC         equ     0Fh
-
-;       Mixer register bits
-
-fMImixerbits    EQU     00010111B       ;; mixer control bit fields
-fMIspkrbits     EQU     01000000B       ;; speaker integrator field bits
-bMIdata         EQU     00000001B       ;; data bit
-bMIclock        EQU     00000010B       ;; clock strobe
-bMImistrb       EQU     00000100B       ;; mixer output strobe
-bMIna1          EQU     00001000B       ;; not used
-bMIvol          EQU     00010000B       ;; total volume enabled
-bMIna2          EQU     00100000B       ;; not used
-bMIspkrint      EQU     01000000B       ;; speaker integrator
-bMImonofm       EQU     10000000B       ;; make both FMs mono
-
-bMIfmreset      EQU     bMIdata         ;; OPL3 FM chip reset
-bMIdacreset     EQU     bMIclock        ;; CODEC reset
-bMIsbreset      EQU     bMImistrb       ;; SB microprocessor reset
-bMI508reset     EQU     bMIvol          ;; MVA508 reset
-
-;       volume control channel #s
-
-VOLMUTE         equ     40h             ;; MUTE button
-VOLLOUDENH      equ     41h             ;; LOUDNESS and ENHANCED STEREO switch
-VOLBASS         equ     42h             ;; BASS level setting
-VOLTREBLE       equ     43h             ;; TREBLE level setting
-VOLLEFT         equ     44h             ;; MASTER LEFT LEVEL settting
-VOLRIGHT        equ     45h             ;; MASTER RIGHT LEVEL settting
-VOLMODE         equ     46h             ;; Model Select Left/Stereo/Right
-
-bVOLEbass       equ     0001b           ;; enhanced bass bit
-bVOLEstereo     equ     0010b           ;; enhanced stereo bit
-
-;       output control
-
-pmADDRSELECT    equ     80h             ;; Parallel mixer addr select
-pmDATASELECT    equ     00h             ;; Parallel mixer data select
-
-;       mixer channel programming selection
-
-pmCHANNELLR     equ     00h             ;; Left/Right channel select
-pmCHANNELL      equ     20h             ;; Left  channel only select
-pmCHANNELR      equ     40h             ;; Right channel only select
-
-;       device select
-
-pmMIXERSELECT   equ     10h             ;; Parallel Mixer device select
-pmVOLUMESELECT  equ     00h             ;; Parallel Volume device select
-
-;       Volume Device selects
-
-pmVOLUMEA       equ     01h             ;; Left/Right channel select
-pmVOLUMEB       equ     02h             ;; Left/Right channel select
-pmVOLUMEBASS    equ     03h             ;; Left/Right channel select
-pmVOLUMETREB    equ     04h             ;; Left/Right channel select
-pmVOLUMEMODE    equ     05h             ;; Left/Right channel select
-
-;       mixer selection
-
-pmOUTPUTMIXER   equ     00h             ;; Mixer-A selection
-pmINPUTMIXER    equ     20h             ;; Mixer-B selection
-
-;       mixer channel swap
-
-pmCHSWAP        equ     40h             ;; Mixer channel reroute
-                                        ;;
-;       int 2F application ID codes
-
-INT2FCODE1      equ     0BCH            ;; Bryan's initials
-
-;       int 2F ID (func 0) return register values
-
-INT2FREGBX      equ     6D00h           ;; 'm '
-INT2FREGCX      equ     0076h           ;; ' v'
-INT2FREGDX      equ     2020h           ;; UPPERCASE XOR MASK
-
-; hardware specific equates for the MV101 (digital ASIC)
-
-MASTERADDRP     equ     09a01h          ;; Master Address Pointer    (w)
-MIDIPRESCALE    equ     01788h          ;; MIDI prescale             (r/w)
-MIDITIMER       equ     01789h          ;; MIDI Timer                (r/w)
-MIDIDATA        equ     0178ah          ;; MIDI Data                 (r/w)
-MIDICONTROL     equ     0178bh          ;; MIDI Control              (r/w)
-MIDISTATUS      equ     01b88h          ;; MIDI Status               (r/w)
-MIDIFIFOS       equ     01b89h          ;; MIDI Fifo Status          (r/w)
-MIDICOMPARE     equ     01b8ah          ;; MIDI Compare Time         (r/w)
-MIDITEST        equ     01b8bh          ;; MIDI Test                 (w)
-MASTERCHIPR     equ     0ff88h          ;; Master Chip Rev           (r)
-SLAVECHIPR      equ     0ef88h          ;; Slave Chip Rev            (r)
-ENHANCEDSCSI    equ     07f89h          ;; Enhanced SCSI detect port
-SYSCONFIG1      equ     08388h          ;; System Config 1           (r/w)
-SYSCONFIG2      equ     08389h          ;; System Config 2           (r/w)
-SYSCONFIG3      equ     0838ah          ;; System Config 3           (r/w)
-SYSCONFIG4      equ     0838bh          ;; System Config 4           (r/w)
-IOCONFIG1       equ     0f388h          ;; I/O Config 1              (r/w)
-IOCONFIG2       equ     0f389h          ;; I/O Config 2              (r/w)
-IOCONFIG3       equ     0f38ah          ;; I/O Config 3              (r/w)
-IOCONFIG4       equ     0f38bh          ;; I/O Config 4              (r/w)
-COMPATREGE      equ     0f788h          ;; Compatible Rgister Enable (r/w)
-EMULADDRP       equ     0f789h          ;; Emulation Address Pointer (r/w)
-WAITSTATE       equ     0bf88h          ;; Wait State                (r/w)
-PUSHBUTTON      equ     0e388h          ;; Push Button (slave)       (???)
-AUXINTSTAT      equ     0e38ah          ;; Aux Int Status            (???)
-AUXINTENA       equ     0e38bh          ;; Aux Int Enable            (???)
-OVRSMPPRE       equ     0bf8ah          ;; Over Sample Prescale      (r/w)
-ANALSERD        equ     0bf89h          ;; Analog Chip Serial Data   (w)
-MASTERMODRD     equ     0ff8bh          ;; Master Mode Read          (r)
-SLAVEMODRD      equ     0ef8bh          ;; Slave Mode Read           (r)
-INTWATCHDOG     equ     0fb8bh          ;; Interrupt Watch Dog       (???)
-MASTERuPDATA    equ     0fb88h          ;; Master uP Data            (???)
-MASTERuPCMD     equ     0fb89h          ;; Master uP Command/Status  (???)
-MASTERuPRST     equ     0fb8ah          ;; Master uP Restart         (???)
-SLAVEuPDATA     equ     0eb88h          ;; Slave uP Data             (???)
-SLAVEuPCMD      equ     0eb88h          ;; Slave uP Command/Status   (???)
-SLAVEuPRST      equ     0eb88h          ;; Slave uP Restart          (???)
-CDTOCOUNTER     equ     04388h          ;; CD-ROM timeout counter    (r/w)
-CDTOSTAT        equ     04389h          ;; CD-ROM timeout status     (r/w)
-LEFTVURD        equ     02388h          ;; Left VU Read              (r)
-RITVURD         equ     02389h          ;; Right VU Read             (r)
-
-SBRST           equ     00206h          ;; SB Reset                  (w)
-SBDATA          equ     0020Ah          ;; SB Data Read              (r)
-SBCMD           equ     0020Ch          ;; SB CMD Write/Status Read  (r/w)
-SBSTAT          equ     0020Eh          ;; SB Data Status            (r)
-MPUDATA         equ     00300h          ;; MPU-401 data reg          (r/w)
-MPUCMD          equ     00301h          ;; MPU-401 command reg       (r/w)
-
-; Sys Config 1
-
-bSC1timena      equ     00000001b       ;; shadow enable
-bSC1pcmemu      equ     00000010b       ;; PCM Emulation of PAS1
-bSC128mhz       equ     00000100b       ;; 28mhz clock divisor
-bSC1invcom      equ     00001000b       ;; invert COM port interrupt input
-bSC1stspea      equ     00010000b       ;; stereoize pc speaker
-bSC1realsnd     equ     00100000b       ;; smart real sound emulatio
-bSC1d6          equ     01000000b       ;;
-bSC1mstrst      equ     10000000b       ;; master chip reset
-
-; Sys Config 2
-
-bSC2ovrsmp      equ     00000011b       ;; oversampling 0,1,2,4
-bSC216bit       equ     00000100b       ;; 16 bit audio
-bSC212bit       equ     00001000b       ;; 12 bit interleaving (d2 must be set too)
-bSC2msbinv      equ     00010000b       ;; invert MSB from standard method
-bSC2slavport    equ     01100000b       ;; slave port bits
-bSC2vcolock     equ     10000000b       ;; VCO locked (Sample Rate Clock Valid)
-
-; Sys Config 3
-
-bSC328mhzfil    equ     00000001b       ;; PCM Rate uses 28mhz
-bSC31mhzsb      equ     00000010b       ;; 1mhz timer for SB sample rate
-bSC3vcoinv      equ     00000100b       ;; invert VCO output
-bSC3bclkinv     equ     00001000b       ;; invert BCLK form 16 bit DAC
-bSC3lrsync      equ     00010000b       ;; 0=L/R, 1 = Sync Pulse
-bSC3d5          equ     00100000b       ;;
-bSC3d6          equ     01000000b       ;;
-bSC3d7          equ     10000000b       ;;
-
-; Sys Config 4
-
-bSC4drqahi      equ     00000001b       ;; DRQ from drive active high
-bSC4dackahi     equ     00000010b       ;; DRQ from drive active high
-bSC4intahi      equ     00000100b       ;; INT from drive active high
-bSC4drqvalid    equ     00001000b       ;; DRQ line valid from drive
-bSC4comena      equ     00010000b       ;; enable COM interrupt
-bSC4enascsi     equ     00100000b       ;; enable SCSI interrupt
-bSC4drqptr      equ     11000000b       ;; DRQ timing pointer bits
-
-; I/O Config 1
-
-bIC1ps2ena      equ     00000001b       ;; Enable Chip (PS2 only)
-bIC1comdcd      equ     00000110b       ;; COM port decode pointer
-bIC1comint      equ     00111000b       ;; COM port interrupt pointer
-bIC1joyena      equ     01000000b       ;; Enable joystick read
-bIC1wporena     equ     10000000b       ;; Enable warm boot reset
-
-; I/O Config 2
-
-bIC2dmaptr      equ     00000111b       ;; DMA channel select
-
-;;bIC28dmaptr   equ     00001111b       ;;  8 bit DMA channel select
-;;bIC216dmaptr  equ     11110000b       ;; 16 bit DMA channel select
-
-; I/O Config 3
-
-bIC3pcmint      equ     00001111b       ;; pcm IRQ channel select
-bIC3cdint       equ     11110000b       ;; cd  IRQ channel select
-
-; Compatibility Register
-
-cpMPUEmulation  equ     00000001b       ;; MPU emuation is on bit
-cpSBEmulation   equ     00000010b       ;; SB emuation is on bit
-
-; Emulation Address Pointer
-
-epSBptr         equ     00001111b       ;; bit field for SB emulation
-epMPUptr        equ     11110000b       ;; bit field for MPU emulation
-
-; Slave Mode Read
-
-bSMRDdrvtyp     equ     00000011b       ;; drive interface type
-bSMRDfmtyp      equ     00000100b       ;; FM chip type
-bSMRDdactyp     equ     00001000b       ;; 16 bit dac (1) or 8 bit dac (0)
-bSMRDimidi      equ     00010000b       ;; use internal MIDI
-bSMRDswrep      equ     10000000b       ;; switch is auto repeating
-
-; Master Mode Read
-
-bMMRDatps2      equ     00000001b       ;; AT(1) or PS2(0) bus
-bMMRDtmremu     equ     00000010b       ;; timer emulation enabled
-bMMRDmsmd       equ     00000100b       ;; master/slave mode
-bMMRDslave      equ     00001000b       ;; slave power on or device present
-bMMRDattim      equ     00010000b       ;; xt/at timing
-bMMRDmstrev     equ     11100000b       ;; master  rev level
-
-; MIDI Control Register
-
-bMCRenatstmp    equ     00000001b       ;; MIDI enable time stamp interrupt
-bMCRenacmptm    equ     00000010b       ;; MIDI enable compare time interrupt
-bMCRenafifoi    equ     00000100b       ;; MIDI enable FIFO input interrupt
-bMCRenafifoo    equ     00001000b       ;; MIDI enable FIFO output interrupt
-bMCRenafifooh   equ     00010000b       ;; MIDI enable FIFO output half int
-bMCRrstfifoi    equ     00100000b       ;; MIDI reset Input FIFO pointer
-bMCRrstfifoo    equ     01000000b       ;; MIDI reset Output FIFO pointer
-bMCRechoio      equ     10000000b       ;; MIDI echo input to output (THRU)
-
-; MIDI Status Register
-
-bMSRtimstamp    equ     00000001b       ;; MIDI time stamp interrupt
-bMSRcmptime     equ     00000010b       ;; MIDI compare time interrupt
-bMSRififo       equ     00000100b       ;; MIDI input FIFO data avail interrupt
-bMSRofifo       equ     00001000b       ;; MIDI output FIFO empty interrupt
-bMSRofifohalf   equ     00010000b       ;; MIDI output FIFO half empty interrupt
-bMSRififoovr    equ     00100000b       ;; MIDI input FIFO overrun error
-bMSRofifoovr    equ     01000000b       ;; MIDI output FIFO overrun error
-bMSRframeerr    equ     10000000b       ;; MIDI frame error
-
-; MIDI FIFO count
-
-bMFCififo       equ     00001111b       ;; MIDI input FIFO count
-bMFCofifo       equ     11110000b       ;; MIDI output FIFO count
-
-; Aux interrupt status/enable
-
-bAUfmrit        equ     00000001b       ;; FM right interrupt
-bAUpushb        equ     00000010b       ;; push button active
-bAUslavecpu     equ     00000100b       ;; slave coprocessor
-bAUaux0int      equ     00001000b       ;; aux 0 interrupt
-bAUaux1int      equ     00010000b       ;; aux 1 interrupt
-bAUaux2int      equ     00100000b       ;; aux 2 interrupt
-bAUaux3int      equ     01000000b       ;; aux 3 interrupt
-bAUmastrcpu     equ     10000000b       ;; master coprocessor or emulation active
-
-; Push Buttons on the Front Panel
-
-bPSHmute        equ     00000001b       ;; mute on the front panel
-bPSHdnarrow     equ     00000010b       ;; down arrow on the front panel
-bPSHuparrow     equ     00000100b       ;; up arrow on the front panel
-bPSauxbit1      equ     00001000b       ;; unused bit...
-bPSauxbit2      equ     00010000b       ;; unused bit...
-bPSauxbit3      equ     00100000b       ;; unused bit...
-bPSauxbit4      equ     01000000b       ;; unused bit...
-bPSauxbit5      equ     10000000b       ;; unused bit...
-
-;---------------------------====< PC HARDWARE >====---------------------------
-
-; Interrupt Controller #1 Port Addresses and Interrupt Masks
-
-IRQ1MASKREG     EQU     021h            ;; 8259 mask register
-IRQ1ACKREG      EQU     020h            ;; 8259 INT acknowledge register
-
-INT0MSK         EQU     00000001B       ;; interrupt 0 mask
-INT1MSK         EQU     00000010B       ;; interrupt 1 mask
-INT2MSK         EQU     00000100B       ;; interrupt 2 mask
-INT3MSK         EQU     00001000B       ;; interrupt 3 mask
-INT4MSK         EQU     00010000B       ;; interrupt 4 mask
-INT5MSK         EQU     00100000B       ;; interrupt 5 mask
-INT6MSK         EQU     01000000B       ;; interrupt 6 mask
-INT7MSK         EQU     10000000B       ;; interrupt 7 mask
-
-; Interrupt Controller #2 Port Addresses and Interrupt Masks
-
-IRQ2MASKREG     EQU     0A1h            ;; 8259 mask register
-IRQ2ACKREG      EQU     0A0h            ;; 8259 INT acknowledge register
-
-INT8MSK         EQU     00000001B       ;; interrupt 8 mask
-INT9MSK         EQU     00000010B       ;; interrupt 9 mask
-INTAMSK         EQU     00000100B       ;; interrupt A mask
-INTBMSK         EQU     00001000B       ;; interrupt B mask
-INTCMSK         EQU     00010000B       ;; interrupt C mask
-INTDMSK         EQU     00100000B       ;; interrupt D mask
-INTEMSK         EQU     01000000B       ;; interrupt E mask
-INTFMSK         EQU     10000000B       ;; interrupt F mask
-
-EOI             EQU     020h            ;; non specific end of interrupt
-
-; dma controller #1 port addresses
-
-DMAC0ADDR       EQU     000h            ;; DMA channel 0 Base & Current Address
-DMAC0COUNT      EQU     001h            ;; DMA channel 0 Base & Current Count
-DMAC1ADDR       EQU     002h            ;; DMA channel 1 Base & Current Address
-DMAC1COUNT      EQU     003h            ;; DMA channel 1 Base & Current Count
-DMAC2ADDR       EQU     004h            ;; DMA channel 2 Base & Current Address
-DMAC2COUNT      EQU     005h            ;; DMA channel 2 Base & Current Count
-DMAC3ADDR       EQU     006h            ;; DMA channel 3 Base & Current Address
-DMAC3COUNT      EQU     007h            ;; DMA channel 3 Base & Current Count
-
-DMA2C4ADDR      EQU     0C0h            ;; DMA channel 4 Base & Current Address
-DMA2C4COUNT     EQU     0C2h            ;; DMA channel 4 Base & Current Count
-DMA2C5ADDR      EQU     0C4h            ;; DMA channel 5 Base & Current Address
-DMA2C5COUNT     EQU     0C6h            ;; DMA channel 5 Base & Current Count
-DMA2C6ADDR      EQU     0C8h            ;; DMA channel 6 Base & Current Address
-DMA2C6COUNT     EQU     0CAh            ;; DMA channel 6 Base & Current Count
-DMA2C7ADDR      EQU     0CCh            ;; DMA channel 7 Base & Current Address
-DMA2C7COUNT     EQU     0CEh            ;; DMA channel 7 Base & Current Count
-
-DMARDSTAT       EQU     008h            ;; DMA read status
-DMAWRCNTRL      EQU     008h            ;; DMA write command register
-DMAWREQ         EQU     009h            ;; DMA write request register
-DMAWRSMR        EQU     00Ah            ;; DMA write single mask register
-DMAWRMODE       EQU     00Bh            ;; DMA write mode register
-DMACLEAR        EQU     00Ch            ;; DMA clear low/high flip-flop
-DMARDTEMP       EQU     00Dh            ;; DMA read temp register
-DMAWRCLR        EQU     00Dh            ;; DMA write master clear
-DMACLRMSK       EQU     00Eh            ;; DMA clear mask register
-DMAWRALL        EQU     00Fh            ;; DMA write all mask register bits
-
-DMA2RDSTAT      EQU     0D0h            ;; DMA read status
-DMA2WRCNTRL     EQU     0D0h            ;; DMA write command register
-DMA2WREQ        EQU     0D2h            ;; DMA write request register
-DMA2WRSMR       EQU     0D4h            ;; DMA write single mask register
-DMA2WRMODE      EQU     0D6h            ;; DMA write mode register
-DMA2CLEAR       EQU     0D8h            ;; DMA clear low/high flip-flop
-DMA2RDTEMP      EQU     0DAh            ;; DMA read temp register
-DMA2WRCLR       EQU     0DAh            ;; DMA write master clear
-DMA2CLRMSK      EQU     0DCh            ;; DMA clear mask register
-DMA2WRALL       EQU     0DEh            ;; DMA write all mask register bits
-
-CH0PAGEREG      EQU     087h            ;; Channel 0 Page Register
-CH1PAGEREG      EQU     083h            ;; Channel 1 Page Register
-CH2PAGEREG      EQU     081h            ;; Channel 2 Page Register
-CH3PAGEREG      EQU     082h            ;; Channel 3 Page Register
-
-CH5PAGEREG      EQU     08Bh            ;; Channel 5 Page Register
-CH6PAGEREG      EQU     089h            ;; Channel 6 Page Register
-CH7PAGEREG      EQU     08Ah            ;; Channel 7 Page Register
-
-;
-;   /*\
-;---|*| end of COMMON.INC
-;   \*/
-;
-
diff --git a/dmp/convsamp.asm b/dmp/convsamp.asm
deleted file mode 100644
index 59db0d9..0000000
--- a/dmp/convsamp.asm
+++ /dev/null
@@ -1,83 +0,0 @@
-;/************************************************************************
-; *
-; *     File        :   CONVSAMP.ASM
-; *
-; *     Description :   Converts unsigned 8-bit sample into signed and vice
-; *                     versa.
-; *
-; *     Copyright (C) 1992,1993 Otto Chrons
-; *
-; ***********************************************************************/
-
-        IDEAL
-        JUMPS
-        P386
-
-        INCLUDE "MODEL.INC"
-
-CSEGMENTS CONVSAMP
-
-CCODESEG CONVSAMP
-
-        CPUBLIC         mcpConvertSample
-
-;/*************************************************************************
-; *
-; *     Function    :   void mcpConvertSample(void far *sample, unsigned len);
-; *
-; *     Description :   Converts sample between signed and unsigned format
-; *                     (Amiga/PC-format)
-; *
-; *     Input       :   sample  = pointer to sample to convert
-; *                     len     = length of sample
-; *
-; ************************************************************************/
-
-CPROC   mcpConvertSample @@sample,@@len
-
-        ENTERPROC       _di
-
-        cmp     [@@sample],0              ; Check for illegal values
-        je      @@exit
-@@10:
-        LESDI   [@@sample]                ; Point ESDI to the sample
-        mov     ecx,[@@len]
-IFNDEF __C32__
-        cmp     ecx,65535
-        jle     @@normal
-@@normalize:
-        mov     ax,es
-        movzx   eax,ax
-        shl     eax,4
-        movzx   edi,di
-        add     eax,edi
-        mov     edi,eax
-        and     di,0Fh
-        shr     eax,4
-        mov     es,ax                   ; Normalize pointer
-@@loop0:
-        cmp     ecx,65000
-        jl      @@normal
-        push    ecx
-        mov     cx,65000
-@@loop1:
-        xor     [byte ESDI],80h
-        inc     di
-        loop    @@loop1
-        pop     ecx
-        sub     ecx,65000
-        jmp     @@normalize
-ENDIF
-@@normal:
-        xor     [byte ESDI],80h
-        inc     _di
-        loop    @@normal
-@@exit:
-        LEAVEPROC       _di
-        ret
-ENDP
-
-ENDS
-
-END
-
diff --git a/dmp/csupport.pas b/dmp/csupport.pas
deleted file mode 100644
index 965cb67..0000000
--- a/dmp/csupport.pas
+++ /dev/null
@@ -1,302 +0,0 @@
-(***************************************************************************
-
-                                 CSUPPORT.PAS
-                                 ------------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-C-language support functions
-
-***************************************************************************)
-
-Unit Csupport;
-
-Interface
-
-{ DO NOT USE THE FARMALLOC AND FARFREE ROUTINES; THEY ARE NOT FULLY FUNCTIONAL
-  AND MAY HANG YOUR COMPUTER! }
-
-Function  Ascz2Str(Var Az):String;
-Procedure Str2Ascz(S:String;Var Az);
-Function  calloc(Cnt:Word;Size:Word):Pointer;
-Function  malloc(Size:Word):Pointer;
-Procedure free(p:pointer);
-Function  farmalloc(Size:Longint):Pointer;
-Procedure farfree(loc:pointer);
-Procedure strcpy(var Dest,Sourc);
-Procedure strncpy(var Dest,Sourc;MaxCnt:Word);
-Function  memcmp(a,b:pointer;len:word):integer;
-Procedure atexit(func:pointer);
-
-Const mallocMinLeft : Longint = 0;  { Min. mem left before allocating }
-
-Implementation
-uses DOS;
-
-const fflag : boolean = false;
-
-Type TAscz = Array[0..255] of char;
-
-Function Ascz2Str;
-Var S:String;
-    W:Word;
-Begin
-  S:='';
-  W:=0;
-  While (TAscz(Az)[w]<>#0) and (W<255) do begin
-    S:=S+TAscz(Az)[W];
-    Inc(W);
-  end;
-  Ascz2Str:=s;
-end;
-
-Procedure Str2Ascz;
-Var W:Word;
-Begin
-  For w:=1 to length(S) do TAscz(Az)[w]:=S[w];
-end;
-
-Function calloc;
-var p:pointer;
-Begin
-  p:=malloc(Cnt*Size);
-  fillchar(p^,Cnt*Size,0);
-  calloc:=p;
-end;
-
-Function malloc;
-Var P:Pointer;
-Begin
-  if MaxAvail<Size+4+8+mallocMinLeft then malloc:=nil else begin
-    Getmem(p,Size+4+8);
-    meml[seg(p^):ofs(p^)]:=Size;
-    malloc:=pointer(longint(p)+4);
-  end;
-end;
-
-Procedure free(p:pointer);
-var b:boolean;
-begin
-{$IFNDEF DPMI}
-  if (p<>nil) and (seg(p^)>=seg(heapOrg^)) and (seg(p^)<=seg(heapPtr^)) then
-{$ELSE}
-  asm
-    verw [word ptr p+2]
-    db 0fh,94h,0c0h    { setz al }
-    mov [b],al
-  end;
-  fflag:=true;
-  if b then
-{$ENDIF}
-  if (ofs(p^)=4) or (ofs(p^)=12) then
-    if meml[seg(p^):ofs(p^)-4]>=65520 then farfree(p) else
-      freemem(pointer(longint(p)-4),meml[seg(p^):ofs(p^)-4]+4+8);
-  fflag:=false;
-end;
-
-Type PfreeRec = ^TfreeRec;
-     TfreeRec = record
-                  next : PfreeRec;
-                  size : Pointer;
-                end;
-
-Function farmalloc;
-
-{$IFNDEF DPMI}
-
-var go_on:boolean;
-    PtoC:PFreeRec;
-    lastP:PFreeRec;
-    fsize:Longint;
-    next:Pointer;
-    loc:Pointer;
-begin
-  if size<65520 then farmalloc:=malloc(size) else begin
-    go_on:=true;
-    loc:=nil;                       { Assume not enough free memory }
-    PtoC:=freeList;
-    lastP:=nil;
-    PfreeRec(heapPtr)^.next:=nil;
-    fsize:=seg(heapEnd^)-seg(heapPtr^);
-    fsize:=fsize*16+ofs(heapEnd^)-ofs(heapPtr^);
-    PfreeRec(heapPtr)^.size:=ptr(fsize div 16,fsize mod 16);
-    while loc=nil do begin
-      fsize:=seg(PtoC^.size^);
-      fsize:=fsize*16+ofs(PtoC^.size^);
-      if fsize>=size then begin { enough }
-        loc:=PtoC;
-        dec(fsize,size);
-        if fsize>0 then begin
-          inc(longint(PtoC),(size div 16)*65536+(size mod 16));
-          PtoC^.next:=PfreeRec(loc)^.next;
-          PtoC^.size:=ptr(fsize div 16,fsize mod 16);
-          if loc=heapPtr then heapPtr:=PtoC;
-          if lastP=nil then freeList:=PtoC else lastP^.next:=PtoC;
-        end else begin
-          if loc=heapPtr then heapPtr:=heapEnd;
-          if lastP=nil then freeList:=PtoC^.next else
-                            lastP^.next:=PtoC^.next;
-        end;
-      end;
-      lastP:=PtoC;
-      PtoC:=PtoC^.next;
-    end;
-    meml[seg(loc^):ofs(loc^)]:=size;
-    inc(longint(loc),4);
-    farMalloc:=loc;
-  end;
-end;
-
-{$ELSE}
-
-begin
-  if size<65520 then farmalloc:=malloc(size) else farmalloc:=nil;
-end;
-
-{$ENDIF}
-
-Procedure defragmentHeap;
-var PtoC,PtoC2:PfreeRec;
-    lastP,lastP2:PfreeRec;
-    hlp,hlp2:longint;
-begin
-{$IFNDEF DPMI}
-  if heapPtr<>heapEnd then with PfreeRec(heapPtr)^ do begin
-    next:=nil;
-    hlp:=seg(heapEnd^)-seg(heapPtr^);
-    hlp:=hlp*16+ofs(heapEnd^)-ofs(heapPtr^);
-    size:=ptr(hlp div 16,hlp mod 16);
-  end;
-  PtoC:=freeList;
-  lastP:=nil;
-  PtoC2:=freeList;
-  lastP2:=nil;
-  while (PtoC<>heapPtr) do begin
-    hlp:=seg(PtoC^.size^)+seg(PtoC^);
-    hlp:=hlp*16+ofs(PtoC^.size^)+ofs(PtoC^);
-    hlp2:=seg(PtoC2^);
-    hlp2:=hlp2*16+ofs(PtoC2^);
-    if (PtoC<>PtoC2) and (Hlp=Hlp2) then begin
-         hlp:=seg(PtoC^.size^)+seg(PtoC2^.size^);
-         hlp:=hlp*16+ofs(PtoC^.size^)+ofs(PtoC2^.size^);
-         PtoC^.size:=ptr(hlp div 16,hlp mod 16);
-         if PtoC2=heapPtr then begin
-           if lastP=nil then freeList:=PtoC^.next else lastP^.next:=PtoC^.next;
-           heapPtr:=PtoC;
-           if PtoC^.next^.next=nil then
-             if lastP=nil then freeList:=heapPtr else lastP^.next:=heapPtr;
-           PtoC^.next:=nil;
-           if lastP2=nil then freeList:=heapPtr else
-             if lastP2<>heapPtr then lastP2^.next:=heapPtr;
-         end else
-           if lastP2=nil then freeList:=PtoC2^.next else lastP2^.next:=PtoC2^.next;
-         PtoC:=freeList;
-         PtoC2:=freeList;
-         lastP:=nil;
-         lastP2:=nil;
-       end else begin
-         lastP2:=PtoC2;
-         PtoC2:=PtoC2^.next;
-         if PtoC2=nil then begin
-           PtoC2:=freeList;
-           lastP2:=nil;
-           lastP:=PtoC;
-           PtoC:=PtoC^.next;
-         end;
-       end;
-  end;
-{$ENDIF}
-end;
-
-Procedure farfree;
-{$IFNDEF DPMI}
-
-var p,q:pointer;
-    size:longint;
-
-begin
-  size:=meml[seg(loc^):ofs(loc^)-4];
-  dec(longint(loc),4);
-  p:=freeList;
-  q:=nil;
-  while longint(p)<longint(loc) do begin q:=p; p:=PfreeRec(p)^.next end;
-  PfreeRec(loc)^.size:=ptr(size div 16,size mod 16);
-  PfreeRec(loc)^.next:=p;
-  if q=nil then freeList:=loc else PfreeRec(q)^.next:=loc;
-  defragmentHeap;
-end;
-
-{$ELSE}
-
-begin
-{  if not fflag then free(p);
-  p:=nil;}
-end;
-
-{$ENDIF}
-
-Procedure strcpy;
-Var w:word;
-Begin
-  w:=0;
-  repeat
-    TAscz(Dest)[w]:=TAscz(Sourc)[w];
-    inc(w);
-  until Tascz(Sourc)[w-1]=#0;
-end;
-
-Procedure strncpy;
-Var w:word;
-Begin
-  w:=0;
-  repeat
-    TAscz(Dest)[w]:=TAscz(Sourc)[w];
-    inc(w);
-  until (Tascz(Sourc)[w-1]=#0) or (w=MaxCnt);
-end;
-
-Function memcmp;
-begin
-  asm
-            push        ds
-            mov         ax,[len]
-            mov         ax,cx
-            Jcxz        @@Null
-            Lds         si,[a]
-            Les         di,[b]
-            Cld
-            Rep         Cmpsb
-            Mov         al,[si-1]
-            Xor         ah,ah
-            Mov         cl,es:[di-1]
-            Xor         ch,ch
-@@Null:     Pop         ds
-            Sub         ax,cx
-  end;
-end;
-
-{$F+}
-
-type TExitProc  = Procedure;
-var oldExit     : Pointer;
-    exitProcs   : Array[1..20] of TExitProc;
-const exitCnt   : word = 0;
-
-Procedure atexit_proc;
-var w:word;
-
-begin
- if exitcnt>0 then for w:=exitCnt downto 1 do exitProcs[w];
- exitProc:=oldExit;
-end;
-
-Procedure atexit;
-begin
-  inc(exitCnt);
-  exitProcs[exitCnt]:=TExitProc(func);
-end;
-
-begin
-  oldExit:=exitProc;
-  exitProc:=@atexit_proc;
-end.
diff --git a/dmp/csupport.tpp b/dmp/csupport.tpp
deleted file mode 100644
index c4a6f8c..0000000
Binary files a/dmp/csupport.tpp and /dev/null differ
diff --git a/dmp/det_aria.pas b/dmp/det_aria.pas
index cb5bf4d..0c256b4 100644
--- a/dmp/det_aria.pas
+++ b/dmp/det_aria.pas
@@ -1,28 +1,5 @@
-(****************************************************************************
-
-                                 DET_ARIA.PAS
-                                 ------------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-Turbo/Borland pascal unit header file for ARIA detection routines.
-Original C header by Otto Chrons
-
-****************************************************************************)
-
-Unit Det_Aria;
-{$F+}
-{$O+}
-
-Interface
-Uses MCP;
-
-Function detectARIA(sCard:PSoundCard):Integer;
-
-Implementation
-
-Function detectARIA(sCard:PSoundCard):Integer; External;
-
-{$L Detaria.obj}
-
-end.
+unit det_aria;
+{$O+}
+interface
+implementation
+end.
diff --git a/dmp/det_aria.tpp b/dmp/det_aria.tpp
deleted file mode 100644
index 89aa42d..0000000
Binary files a/dmp/det_aria.tpp and /dev/null differ
diff --git a/dmp/det_pas.pas b/dmp/det_pas.pas
index 563c59c..1388f04 100644
--- a/dmp/det_pas.pas
+++ b/dmp/det_pas.pas
@@ -1,28 +1,5 @@
-(****************************************************************************
-
-                                 DET_PAS.PAS
-                                 -----------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-Turbo/Borland pascal unit header file for PAS detection routines.
-Original C header by Otto Chrons
-
-****************************************************************************)
-
-Unit Det_Pas;
-{$F+}
-{$O+}
-
-Interface
-Uses MCP;
-
-Function detectPAS(sCard:PSoundCard):Integer;
-
-Implementation
-
-Function detectPAS(sCard:PSoundCard):Integer; External;
-
-{$L Detpas.obj}
-
-end.
+unit det_pas;
+{$O+}
+interface
+implementation
+end.
diff --git a/dmp/det_pas.tpp b/dmp/det_pas.tpp
deleted file mode 100644
index c5338cc..0000000
Binary files a/dmp/det_pas.tpp and /dev/null differ
diff --git a/dmp/det_sb.pas b/dmp/det_sb.pas
index 40f790a..6b7a4fd 100644
--- a/dmp/det_sb.pas
+++ b/dmp/det_sb.pas
@@ -1,32 +1,5 @@
-(****************************************************************************
-
-                                 DET_SB.PAS
-                                 ----------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-Turbo/Borland pascal unit header file for SB detection routines.
-Original C header by Otto Chrons
-
-****************************************************************************)
-
-unit det_SB; { (C) 1993 Jussi Lahdenniemi }
-
-{$O+}
-
-interface
-uses MCP;
-
-Function  detectSB(SCard:PSoundCard):Integer;
-Function  detectSBpro(SCard:PSoundCard):Integer;
-Function  detectSB16(SCard:PSoundCard):Integer;
-
-implementation
-
-{$L detectSB.OBJ}
-
-Function  detectSB(SCard:PSoundCard):Integer; external;
-Function  detectSBpro(SCard:PSoundCard):Integer; external;
-Function  detectSB16(SCard:PSoundCard):Integer; external;
-
-end.
+unit det_sb;
+{$O+}
+interface
+implementation
+end.
diff --git a/dmp/det_sb.tpp b/dmp/det_sb.tpp
deleted file mode 100644
index 7ea3c36..0000000
Binary files a/dmp/det_sb.tpp and /dev/null differ
diff --git a/dmp/detaria.asm b/dmp/detaria.asm
deleted file mode 100644
index dcf0f69..0000000
--- a/dmp/detaria.asm
+++ /dev/null
@@ -1,431 +0,0 @@
-;/************************************************************************
-; *
-; *     File        : DETARIA.ASM
-; *
-; *     Description : Hardware detection routine for Aria cards
-; *
-; *     Copyright (C) 1993 Otto Chrons
-; *
-; ***********************************************************************/
-
-        IDEAL
-        JUMPS
-        P386N
-
-;       L_PASCAL        = 1             ; Uncomment this for pascal-style
-
-IFDEF   L_PASCAL
-        LANG    EQU     PASCAL
-        MODEL TPASCAL
-ELSE
-        LANG    EQU     C
-        MODEL LARGE,C
-ENDIF
-
-        INCLUDE "MODEL.INC"
-        INCLUDE "MCP.INC"
-
-        DSP_DATA = 0
-        DSP_STATUS = 2
-        DSP_CONTROL = 2
-        DSP_DMA_ADDRESS = 4
-        DSP_DMA_DATA = 6
-
-        INTPC_DSPRD     EQU  0001h      ; Interrupt PC on DSP read
-        INTPC_DSPWR     EQU  0002h      ; Interrupt PC on DSP write
-        INTDSP_PCRD     EQU  0004h      ; Interrupt DSP on PC read
-        INTDSP_PCWR     EQU  0008h      ; Interrupt DSP on PC write
-        INTPC_DMADONE   EQU  0010h      ; Interrupt PC on DMA completion
-        SAMP_RATE       EQU  0060h      ; Sample rate mask
-         SAMP_44K       EQU  0000h      ;    44.10 kHz
-         SAMP_32K       EQU  0020h      ;    31.50 kHz
-         SAMP_22K       EQU  0040h      ;    22.05 kHz
-         SAMP_16K       EQU  0060h      ;    15.75 kHz
-        C2MODE          EQU  0080h      ; Aria Wave Synthesis select
-        DSP_RESET       EQU  0100h      ; Reset DSP
-        DMA_DSPTOPC     EQU  0200h      ; DMA direction - DSP to PC
-        DMA_XFR         EQU  0400h      ; Initiate DMA transfer
-        ADC_SRC_AUX     EQU  0800h      ; ADC record source select
-        ADC_STEREO      EQU  1000h      ; ADC mono/stereo select
-        ADC_SRC_RIGHT   EQU  2000h      ; ADC monophonic source
-        ADC_DISABLE     EQU  4000h      ; ADC enable/disable
-        PORT0_BUSY      EQU  8000h      ; Data port busy flag
-
-DATASEG
-
-        oldInt10        DD ?
-        oldInt11        DD ?
-        oldInt12        DD ?
-        ioPort          DW ?
-        dspIRQ          DB ?
-
-CODESEG
-
-        PUBLIC  detectAria
-
-        Aria            CARDINFO <8,0,"Aria sound card",290h,10,5,4000,44100,1,1,2>
-
-;/*************************************************************************
-; *
-; *     Function    :   AriaCMD
-; *
-; *     Description :   Sends a command to Aria's DSP
-; *
-; *     Input       :   AX = cmd to send
-; *
-; ************************************************************************/
-
-PROC    NOLANGUAGE AriaCMD NEAR
-
-        push    cx
-        push    ax
-        mov     dx,[ioPort]
-        add     dx,DSP_STATUS
-        mov     cx,0
-@@wait:
-        in      ax,dx
-        test    ax,8000h
-        loopnz  @@wait
-
-        mov     dx,[ioPort]
-        pop     ax
-        out     dx,ax
-        pop     cx
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   putMem16
-; *
-; *     Description :   Puts a word into DSP's memory
-; *
-; *     Input       :   BX = address, AX = value
-; *
-; ************************************************************************/
-
-PROC    putMem16 NEAR
-
-        push    ax
-        mov     dx,[ioPort]
-        add     dx,DSP_DMA_ADDRESS
-        mov     ax,bx
-        out     dx,ax
-        mov     dx,[ioPort]
-        add     dx,DSP_DMA_DATA
-        pop     ax
-        out     dx,ax
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   getMem16
-; *
-; *     Description :   Gets a word into DSP's memory
-; *
-; *     Input       :   BX = address
-; *
-; *     Returns     :   AX = value
-; *
-; ************************************************************************/
-
-PROC    getMem16 NEAR
-
-        mov     dx,[ioPort]
-        add     dx,DSP_DMA_ADDRESS
-        mov     ax,bx
-        out     dx,ax
-        mov     dx,[ioPort]
-        add     dx,DSP_DMA_DATA
-        in      ax,dx
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int detectAria(SOUNDCARD *scard);
-; *
-; *     Description :   Detects the presence of Aria sound card
-; *
-; *     Input       :   Pointer to soundcard structure
-; *
-; *     Returns     :   0  if succesful
-; *                     -1 on error (no card found)
-; *
-; ************************************************************************/
-
-PROC    detectAria FAR USES si di,scard:FAR PTR CARDINFO
-
-        LESDI   [sCard]
-        mov     ax,es
-        or      ax,di                   ; Is sCard NULL?
-        jz      @@error
-        mov     si,offset Aria
-        mov     cx,SIZE CARDINFO        ; Copy sound card info into buffer
-        cld
-        push    ds
-        push    cs
-        pop     ds
-        rep     movsb
-        pop     ds
-        LESDI   [sCard]
-
-        call    getPort                 ; Find base port address
-        jc      @@error
-        LESDI   [sCard]
-        mov     [ESDI+CARDINFO.ioPort],ax
-
-        call    getIRQ                  ; Detect IRQ
-        jc      @@error
-        LESDI   [sCard]
-        mov     [ESDI+CARDINFO.DMAIRQ],al
-
-        call    getDMA                  ; Find out DMA channel
-        jc      @@error
-        LESDI   [sCard]
-        mov     [ESDI+CARDINFO.DMAChannel],al
-
-        sub     ax,ax                   ; No error
-        jmp     short @@exit
-@@error:
-        mov     ax,-1
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   getPort
-; *
-; *     Description :   Finds Aria card's base address
-; *
-; *     Returns     :   Carry = 0   --> AX = address
-; *                     Carry = 1       error
-; *
-; ************************************************************************/
-
-PROC    NOLANGUAGE getPort NEAR
-
-        mov     si,INTPC_DSPWR OR INTDSP_PCWR OR SAMP_22K OR C2MODE
-        mov     cx,280h                 ; First base address
-@@loop:
-        mov     dx,cx
-        add     dx,DSP_STATUS
-        in      ax,dx
-        cmp     ax,0FFFFh               ; Bus floating?
-        je      @@not1
-        mov     ax,si
-        out     dx,ax                   ; Output to control register
-        in      ax,dx
-        and     ax,7FFFh
-        cmp     ax,si                   ; Is it still the same?
-        je      @@ready
-@@not1:
-        add     cx,10h
-        cmp     cx,2C0h
-        jne     @@loop
-        stc                             ; Error
-        ret
-@@ready:
-        mov     [ioPort],cx
-
-        mov     dx,cx
-        mov     ax,00C8h                ; Init Aria
-        add     dx,DSP_CONTROL
-        out     dx,ax
-
-        mov     ax,0
-        mov     bx,6102h                ; DSP init
-        call    putMem16
-
-        cli
-        mov     ax,0                    ; System init
-        call    AriaCMD
-        mov     ax,0                    ; Add new task
-        call    AriaCMD
-        mov     ax,0                    ; Aria Synthesizer mode, ROM module
-        call    AriaCMD
-        mov     ax,0                    ; No address
-        call    AriaCMD
-        mov     ax,0FFFFh               ; End of command
-        call    AriaCMD
-        sti
-        mov     cx,2000
-@@wloop:
-        mov     dx,[ioPort]
-        add     dx,DSP_STATUS
-        in      ax,dx                   ; Delay
-        mov     bx,6102h
-        call    getMem16                ; Get value from DSP's memory
-        cmp     ax,1
-        loopne  @@wloop
-
-        mov     dx,[ioPort]
-        add     dx,DSP_CONTROL
-        mov     ax,00CAh                ; Init Aria mode..
-        out     dx,ax
-
-        clc                             ; No error, AX = address
-        mov     ax,[ioPort]
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   getIRQ
-; *
-; *     Description :   Finds Aria card's IRQ
-; *
-; *     Returns     :   Carry = 0   --> AL = IRQ
-; *                     Carry = 1       error
-; *
-; ************************************************************************/
-
-PROC    NOLANGUAGE getIRQ NEAR
-
-        cli
-        mov     ax,3572h                ; Save old interrupt vectors
-        int     21h
-        mov     [WORD HIGH oldInt10],es
-        mov     [WORD LOW oldInt10],bx
-        mov     ax,3573h
-        int     21h
-        mov     [WORD HIGH oldInt11],es
-        mov     [WORD LOW oldInt11],bx
-        mov     ax,3574h
-        int     21h
-        mov     [WORD HIGH oldInt12],es
-        mov     [WORD LOW oldInt12],bx
-
-        PUSHDS
-        push    cs                      ; set new vectors
-        pop     ds
-        mov     ah,25h
-        mov     al,72h
-        mov     dx,offset int72
-        int     21h
-        mov     al,73h
-        mov     dx,offset int73
-        int     21h
-        mov     al,74h
-        mov     dx,offset int74
-        int     21h
-        pop     ds
-        sti
-
-        in      al,0A1h                 ; Enable interrupts
-        mov     di,ax                   ; save old value
-        and     al,NOT (4+8+16)         ; Enable 10,11,12
-        out     0A1h,al
-
-        mov     [dspIRQ],0
-
-        cli
-        mov     ax,0Ah
-        call    AriaCMD
-        mov     ax,0FFFFh
-        call    AriaCMD
-        sti
-
-        mov     cx,10000
-@@loop:
-        jmp     short $+2               ; Delays
-        jmp     short $+2
-        mov     dx,[ioPort]
-        add     dx,DSP_STATUS
-        in      ax,dx                   ; Delay
-        mov     al,[dspIRQ]
-        or      al,al
-        loopz   @@loop
-
-        mov     ch,al                   ; Save IRQ
-
-        mov     ax,di                   ; Restore IRQ mask
-        out     0A1h,al
-        PUSHDS                  ; Restore old interrupt vectors
-        mov     dx,[WORD LOW oldInt10]
-        mov     ds,[WORD HIGH oldInt10]
-        mov     ax,2572h
-        int     21h
-        pop     ds
-        PUSHDS
-        mov     dx,[WORD LOW oldInt11]
-        mov     ds,[WORD HIGH oldInt11]
-        mov     ax,2573h
-        int     21h
-        pop     ds
-        PUSHDS
-        mov     dx,[WORD LOW oldInt12]
-        mov     ds,[WORD HIGH oldInt12]
-        mov     ax,2574h
-        int     21h
-        pop     ds
-
-        or      ch,ch
-        jz      @@error
-        mov     al,ch
-        sub     ah,ah
-        clc                             ; No error, IRQ in AL
-        ret
-@@error:
-        stc                             ; Error
-        ret
-ENDP
-
-PROC    NOLANGUAGE IRQhandlers FAR
-
-int72:
-        PUSHDS
-        push    ax
-        mov     ax,@DATA
-        mov     ds,ax
-        mov     [dspIRQ],10               ; Set interrupt number
-        jmp     short @@DMAdone
-int73:
-        PUSHDS
-        push    ax
-        mov     ax,@DATA
-        mov     ds,ax
-        mov     [dspIRQ],11               ; Set interrupt number
-        jmp     short @@DMAdone
-int74:
-        PUSHDS
-        push    ax
-        mov     ax,@DATA
-        mov     ds,ax
-        mov     [dspIRQ],12               ; Set interrupt number
-@@DMAdone:
-        sti
-        mov     al,20h
-        out     20h,al
-        out     0A0h,al
-        pop     ax
-        POPDS
-        iret
-
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   getDMA
-; *
-; *     Description :   Finds Aria card's DMA channel
-; *
-; *     Returns     :   Carry = 0   --> AL = channel
-; *                     Carry = 1       error
-; *
-; ************************************************************************/
-
-PROC    NOLANGUAGE getDMA NEAR
-
-        mov     al,5
-
-        ret
-ENDP
-
-
-END
diff --git a/dmp/detectsb.asm b/dmp/detectsb.asm
deleted file mode 100644
index 3618dc5..0000000
--- a/dmp/detectsb.asm
+++ /dev/null
@@ -1,1182 +0,0 @@
-; /***********************************************************************
-; *
-; *	File        : DETECTSB.ASM
-; *
-; *	Description : Sound Blaster detection routines
-; *
-; *	Copyright (C) 1992 Otto Chrons
-; *
-; ************************************************************************
-;
-;	Revision history of DETECTSB.ASM
-;
-;	1.0	16.4.93
-;		First version. Detects SB, SB Pro and SB 16. Support for
-;		8-bit DMA in SB16 is not implemented.
-;
-; ***********************************************************************/
-
-	IDEAL
-	JUMPS
-	P386N
-
-;	L_PASCAL	= 1		; Uncomment this for pascal-style
-
-IFDEF	L_PASCAL
-	LANG	EQU	PASCAL
-	MODEL TPASCAL
-ELSE
-	LANG	EQU	C
-	MODEL LARGE,C
-ENDIF
-
-	INCLUDE "MODEL.INC"
-	INCLUDE "MCP.INC"
-
-MACRO	waitSB
-	local	l1
-l1:
-	in	al,dx
-	or	al,al
-	js	l1
-ENDM
-
-MACRO	waitSBport
-	local	l1
-
-	mov	dx,[SoundBlaster.ioPort]
-	add	dx,0Ch
-l1:
-	in	al,dx
-	or	al,al
-	js	l1
-ENDM
-
-MACRO	waitSBPROport
-	local	l1
-
-	mov	dx,[SoundBlasterPro.ioPort]
-	add	dx,0Ch
-l1:
-	in	al,dx
-	or	al,al
-	js	l1
-ENDM
-
-DATASEG
-	dmaIRQ		DB ?
-	scardPtr	DD ?
-CODESEG
-
-	PUBLIC detectSB, detectSBPro, detectSB16
-
-	copyrightText	DB "SB-DETECT v1.0 - (C) 1992 Otto Chrons",0,1Ah
-	SoundBlaster	CARDINFO <1,0,"Sound Blaster",220h,7,1,4000,22050,0,0,1>
-	SoundBlasterPro	CARDINFO <2,0,"Sound Blaster Pro",220h,7,1,4000,22050,1,1,1>
-	SoundBlaster16	CARDINFO <6,0,"Sound Blaster 16 ASP",220h,5,5,4000,44100,1,1,2>
-
-;/*************************************************************************
-; *
-; *	Function    : 	checkPort_SB
-; *
-; *	Description :   Checks if given address is SB's I/O address
-; *
-; *	Input       : 	DX = port to check
-; *
-; *	Returns     :	AX = 0	succesful
-; *		      	AX = 1	unsuccesful
-; *
-; ************************************************************************/
-
-PROC	NOLANGUAGE checkPort_SB NEAR
-
-	push	dx
-	add	dl,6			; Init Sound Blaster
-	mov	al,1
-	out	dx,al
-	in	al,dx			; Wait for awhile
-	in	al,dx
-	in	al,dx
-	in	al,dx
-	in	al,dx
-	mov	al,0
-	out	dx,al
-	sub	dl,6
-
-	add	dl,0Eh          	; DSP data available status
-	mov	cx,1000
-@@loop:
-	in	al,dx			; port 22Eh
-	or	al,al
-	js	@@10
-	loop	@@loop
-
-	mov	ax,1
-	jmp	@@exit
-@@10:
-	sub	dl,4
-	in	al,dx			; port 22Ah
-	cmp	al,0AAh			; Is ID 0AAh?
-	mov	ax,0
-	je	@@exit
-	mov	ax,1
-@@exit:
-	pop	dx
-	or	ax,ax			; Set zero-flag accordingly
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    : 	findDMAIRQ_SB
-; *
-; *	Description :	Finds SB's DMA interrupt number
-; *
-; *	Returns     :	AX = 0	error
-; *			AX = port number (2,3,5,7)
-; *
-; ************************************************************************/
-
-PROC	findDMAIRQ_SB NEAR USES di si
-	local	saveVect:DWORD:6,intMask:BYTE
-
-	assume DS:NOTHING
-
-	PUSHDS
-	mov	ah,35h
-	mov	al,8+2
-	int	21h
-	mov	[WORD HIGH saveVect],es
-	mov	[WORD LOW saveVect],bx
-	mov	al,8+3
-	int	21h
-	mov	[WORD HIGH saveVect+4],es
-	mov	[WORD LOW saveVect+4],bx
-	mov	al,8+5
-	int	21h
-	mov	[WORD HIGH saveVect+8],es
-	mov	[WORD LOW saveVect+8],bx
-	mov	al,8+7
-	int	21h
-	mov	[WORD HIGH saveVect+12],es
-	mov	[WORD LOW saveVect+12],bx
-
-	PUSHCS
-	POPDS
-	mov	ah,25h
-	mov	dx,offset DMA2		; Set vectors
-	mov	al,8+2
-	int	21h
-	mov	dx,offset DMA3
-	mov	al,8+3
-	int	21h
-	mov	dx,offset DMA5
-	mov	al,8+5
-	int	21h
-	mov	dx,offset DMA7
-	mov	al,8+7
-	int	21h
-
-	in	al,21h
-	mov	[intMask],al		; Save interrupt mask
-	mov	al,0FFh
-	out	21h,al			; Mask out all interrupts
-	cli				; Disable interrupts
-
-	POPDS
-
-	assume	DS:@data
-
-	mov	al,[intMask]
-	and	al,01010011b		; Allow DMA interrupts (2,3,5 & 7)
-	out	21h,al
-	sti				; Set DMA up
-
-	mov	al,5
-	out	0Ah,al			; Break on
-	mov	al,0
-	out	0Ch,al			; Reset counter
-	mov	al,49h
-	out	0Bh,al			; DMA -> DSP (output)
-	mov	al,0
-	out	83h,al			; page 0
-	mov	al,0
-	out	2,al			; offset 0
-	mov	al,0
-	out	2,al			; whole address is 0000:0000
-	mov	al,1
-	out	3,al			; count = 1
-	mov	al,0
-	out	3,al
-	mov	al,1
-	out	0Ah,al			; Break off
-
-	LESDI	[scardPtr]
-	mov	dx,[ESDI+CARDINFO.ioPort]
-	add	dx,0Ch
-	waitSB
-	mov	al,40h                  ; Set DSP speed
-	out	dx,al
-	waitSB
-	mov	al,0D3h			; 22222 Hz
-	out	dx,al
-	waitSB
-	mov	al,14h			; 14h = output command
-	out	dx,al
-	waitSB
-	mov	al,1			; digitize 1 byte
-	out	dx,al
-	waitSB
-	mov	al,0
-	out	dx,al
-	mov	cx,0FFFFh		; Big loop
-	mov	[dmaIRQ],0		; Clear interrupt value
-@@loop:
-	cmp	[dmaIRQ],0		; Wait dmaIRQ to change
-	loope	@@loop			; loop if it doesn't
-	LESDI	[scardPtr]
-	mov	dx,[ESDI+CARDINFO.ioPort]
-	add	dl,0Eh
-	in	al,dx			; Reset SB
-
-	mov	al,[intMask]
-	out	21h,al			; Restore interrupt mask
-	sti				; Allow interrupts
-
-	PUSHDS
-	mov	ah,25h
-	lds	dx,[saveVect]
-	mov	al,8+2
-	int	21h
-	lds	dx,[saveVect+4]
-	mov	al,8+3
-	int	21h
-	lds	dx,[saveVect+8]
-	mov	al,8+5
-	int	21h
-	lds	dx,[saveVect+12]
-	mov	al,8+7
-	int	21h
-	POPDS
-	sub	ax,ax
-	mov	al,[dmaIRQ]		; Return with interrupt number
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    : 	findDMAIRQ_SBpro
-; *
-; *	Description :	Finds SBpro's DMA interrupt number
-; *
-; *	Returns     :	AX = 0	error
-; *			AX = port number (2,3,5,7,10)
-; *
-; ************************************************************************/
-
-PROC	findDMAIRQ_SBpro NEAR USES di si
-	local	saveVect:DWORD:4,intMask1:BYTE,intMask2:BYTE
-
-	assume DS:NOTHING
-
-	PUSHDS
-	mov	ah,35h
-	mov	al,8+2
-	int	21h
-	mov	[WORD HIGH saveVect],es
-	mov	[WORD LOW saveVect],bx
-	mov	al,8+5
-	int	21h
-	mov	[WORD HIGH saveVect+4],es
-	mov	[WORD LOW saveVect+4],bx
-	mov	al,8+7
-	int	21h
-	mov	[WORD HIGH saveVect+8],es
-	mov	[WORD LOW saveVect+8],bx
-	mov	al,72h
-	int	21h
-	mov	[WORD HIGH saveVect+12],es
-	mov	[WORD LOW saveVect+12],bx
-
-	in	al,21h
-	mov	[intMask1],al		; Save interrupt mask
-	mov	al,0FFh
-	out	21h,al			; Mask out all interrupts
-	in	al,0A1h
-	mov	[intMask2],al		; Save interrupt mask
-	mov	al,0FFh
-	out	0A1h,al			; Mask out all interrupts
-	cli				; Disable interrupts
-
-	PUSHCS
-	POPDS
-	mov	ah,25h
-	mov	dx,offset DMA2		; Set vectors
-	mov	al,8+2
-	int	21h
-	mov	dx,offset DMA5
-	mov	al,8+5
-	int	21h
-	mov	dx,offset DMA7
-	mov	al,8+7
-	int	21h
-	mov	dx,offset DMA10
-	mov	al,72h
-	int	21h
-	POPDS
-
-	assume	DS:@data
-
-	mov	al,[intMask1]
-	and	al,01010011b		; Allow DMA interrupts (2,3,5 & 7)
-	out	21h,al
-	mov	al,[intMask2]
-	and	al,11111011b		; Allow DMA interrupt 10
-	out	0A1h,al
-	sti
-
-	mov	cx,1000
-@@waitloop:
-	in	al,21h
-	loop	@@waitloop
-
-	mov	al,4
-	out	0Ah,al			; Break on
-	mov	al,5
-	out	0Ah,al			; Break on
-	mov	al,7
-	out	0Ah,al			; Break on
-
-	LESDI	[scardPtr]
-	mov	dx,[ESDI+CARDINFO.ioPort]
-	add	dx,0Ch
-	waitSB
-	mov	al,40h                  ; Set DSP speed
-	out	dx,al
-	waitSB
-	mov	al,0D3h			; 22222 Hz
-	out	dx,al
-	waitSB
-	mov	al,14h			; 14h = output command
-	out	dx,al
-	waitSB
-	mov	al,10			; digitize 1 byte
-	out	dx,al
-	waitSB
-	mov	al,0
-	out	dx,al
-	sti
-
-	mov	ax,1			; Check for DMA channel 1
-	call    findDMAchannel_SBpro
-	or	ax,ax
-	jnz	@@channelFound
-	mov	ax,0			; Channel 0
-	call	findDMAchannel_SBpro
-	or	ax,ax
-	jnz	@@channelFound
-	mov	ax,3			; Channel 3
-	call	findDMAchannel_SBpro
-	or	ax,ax
-	jnz	@@channelFound
-	mov	[dmaIRQ],0
-@@channelFound:
-	mov	[ESDI+CARDINFO.DMAChannel],al
-
-	mov	dx,[ESDI+CARDINFO.ioPort]
-	add	dl,6			; Init Sound Blaster
-	mov	al,1
-	out	dx,al
-	in	al,dx			; Wait for awhile
-	in	al,dx
-	in	al,dx
-	in	al,dx
-	in	al,dx
-	mov	al,0
-	out	dx,al
-	sub	dl,6
-
-	add	dx,0Eh			; Reset SB
-	in	al,dx
-
-	PUSHDS
-	mov	ah,25h
-	lds	dx,[saveVect]
-	mov	al,8+2
-	int	21h
-	lds	dx,[saveVect+4]
-	mov	al,8+5
-	int	21h
-	lds	dx,[saveVect+8]
-	mov	al,8+7
-	int	21h
-	lds	dx,[saveVect+12]
-	mov	al,72h
-	int	21h
-	POPDS
-
-	mov	al,[intMask1]
-	out	21h,al			; Restore interrupt mask
-	mov	al,[intMask2]
-	out	0A1h,al			; Restore interrupt mask
-	sti				; Allow interrupts
-@@exit:
-	sub	ax,ax
-	mov	al,[dmaIRQ]		; Return with interrupt number
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    : 	findDMAIRQ_SB16
-; *
-; *	Description :	Finds SB16's DMA interrupt number
-; *
-; *	Returns     :	AX = 0	error
-; *			AX = IRQ number (2,5,7,10)
-; *
-; ************************************************************************/
-
-PROC	findDMAIRQ_SB16 NEAR USES di si
-
-	LESDI	[scardPtr]
-	mov	dx,[ESDI+CARDINFO.ioPort]
-	add	dx,4			; Access mixer
-	mov	al,80h			; Read IRQ
-	out	dx,al
-	inc	dx
-	in	al,dx
-	mov	cl,2			; Assume 2
-	test	al,0001b
-	jnz	@@found
-	mov	cl,5
-	test	al,0010b
-	jnz	@@found
-	mov	cl,7
-	test	al,0100b
-	jnz	@@found
-	mov	cl,10
-@@found:
-
-	dec	dx
-	mov	al,81h			; Read DMA channel
-	out	dx,al
-	inc	dx
-	in	al,dx
-	mov	ch,5
-	test	al,00100000b		; Is it DMA 5?
-	jnz	@@foundDMA
-	mov	ch,6
-	test	al,01000000b
-	jnz	@@foundDMA
-	mov	ch,7
-	test	al,10000000b
-	jnz	@@foundDMA
-	mov	ch,3
-	test	al,00000100b
-	jnz	@@foundDMA
-	mov	ch,0
-	test	al,00000001b
-	jnz	@@foundDMA
-	mov	ch,1
-@@foundDMA:
-	mov	[ESDI+CARDINFO.DMAChannel],ch
-	mov	al,cl			; Return IRQ in AX
-	sub	ah,ah
-	ret
-IF 0
-/*
-	local	saveVect:DWORD:4,intMask1:BYTE,intMask2:BYTE
-
-	assume DS:NOTHING
-
-	PUSHDS
-	mov	ah,35h
-	mov	al,(8+2)
-	int	21h
-	mov	[WORD HIGH saveVect],es
-	mov	[WORD LOW saveVect],bx
-	mov	al,(8+5)
-	int	21h
-	mov	[WORD HIGH saveVect+4],es
-	mov	[WORD LOW saveVect+4],bx
-	mov	al,(8+7)
-	int	21h
-	mov	[WORD HIGH saveVect+8],es
-	mov	[WORD LOW saveVect+8],bx
-	mov	al,(72h)
-	int	21h
-	mov	[WORD HIGH saveVect+12],es
-	mov	[WORD LOW saveVect+12],bx
-
-	in	al,21h
-	mov	[intMask1],al		; Save interrupt mask
-	mov	al,0FFh
-	out	21h,al			; Mask out all interrupts
-	in	al,0A1h
-	mov	[intMask2],al		; Save interrupt mask
-	mov	al,0FFh
-	out	0A1h,al			; Mask out all interrupts
-	cli				; Disable interrupts
-
-	PUSHCS
-	POPDS
-	mov	ah,25h
-	mov	dx,offset DMA2		; Set vectors
-	mov	al,8+2
-	int	21h
-	mov	dx,offset DMA5
-	mov	al,8+5
-	int	21h
-	mov	dx,offset DMA7
-	mov	al,8+7
-	int	21h
-	mov	dx,offset DMA10
-	mov	al,72h
-	int	21h
-	POPDS
-
-	assume	DS:@data
-
-	mov	al,[intMask1]
-	and	al,01010011b		; Allow DMA interrupts (2,3,5 & 7)
-	out	21h,al
-	mov	al,[intMask2]
-	and	al,11111011b		; Allow DMA interrupt 10
-	out	0A1h,al
-	sti
-
-	mov	cx,1000
-@@waitloop:
-	in	al,21h
-	loop	@@waitloop
-
-	mov	al,4
-	out	0Ah,al			; Break on
-	mov	al,5
-	out	0Ah,al			; Break on
-	mov	al,7
-	out	0Ah,al			; Break on
-
-	mov	al,5
-	out	0D4h,al			; Break on
-	mov	al,6
-	out	0D4h,al			; Break on
-	mov	al,7
-	out	0D4h,al			; Break on
-
-	LESDI	[scardPtr]
-	mov	dx,[ESDI+CARDINFO.ioPort]
-	add	dx,0Ch
-	waitSB
-	mov	al,42h                  ; Set DSP speed
-	out	dx,al
-	waitSB
-	mov	al,0ACh			; 44100Hz
-	out	dx,al
-	waitSB
-	mov	al,044h
-	out	dx,al
-	waitSB
-	mov	al,0B6h			; 0B6h = output command
-	out	dx,al
-	waitSB
-	mov	al,30h			; digitize 5 bytes
-	out	dx,al
-	waitSB
-	mov	al,5
-	out	dx,al
-	waitSB
-	mov	al,0
-	out	dx,al
-	sti
-
-	mov	ax,5			; Check for DMA channel 1
-	call    findDMAchannel_SB16
-	or	ax,ax
-	jnz	@@channelFound
-	mov	ax,6			; Channel 0
-	call	findDMAchannel_SB16
-	or	ax,ax
-	jnz	@@channelFound
-	mov	ax,7			; Channel 3
-	call	findDMAchannel_SB16
-	jnz	@@channelFound
-	mov	ax,1			; Check for DMA channel 1
-	call    findDMAchannel_SBpro
-	or	ax,ax
-	jnz	@@channelFound
-	mov	ax,0			; Channel 0
-	call	findDMAchannel_SBpro
-	or	ax,ax
-	jnz	@@channelFound
-	mov	ax,3			; Channel 3
-	call	findDMAchannel_SBpro
-	or	ax,ax
-	jnz	@@channelFound
-	mov	[dmaIRQ],0
-@@channelFound:
-	LESDI	[scardPtr]
-	mov	[ESDI+CARDINFO.DMAChannel],al
-
-	mov	dx,[ESDI+CARDINFO.ioPort]
-	add	dl,6			; Init Sound Blaster
-	mov	al,1
-	out	dx,al
-	in	al,dx			; Wait for awhile
-	in	al,dx
-	in	al,dx
-	in	al,dx
-	in	al,dx
-	mov	al,0
-	out	dx,al
-	sub	dl,6
-
-	add	dx,0Fh			; Reset SB
-	in	al,dx
-
-	PUSHDS
-	mov	ah,25h
-	lds	dx,[saveVect]
-	mov	al,8+2
-	int	21h
-	lds	dx,[saveVect+4]
-	mov	al,8+5
-	int	21h
-	lds	dx,[saveVect+8]
-	mov	al,8+7
-	int	21h
-	lds	dx,[saveVect+12]
-	mov	al,72h
-	int	21h
-	POPDS
-
-	mov	al,[intMask1]
-	out	21h,al			; Restore interrupt mask
-	mov	al,[intMask2]
-	out	0A1h,al			; Restore interrupt mask
-	sti				; Allow interrupts
-@@exit:
-	sub	ax,ax
-	mov	al,[dmaIRQ]		; Return with interrupt number
-*/
-ENDIF
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	findDMAchannel_SBpro
-; *
-; *	Description :	Checks if given channel is the channel SBPro uses
-; *
-; *	Input       :	AX = Channel to test
-; *
-; *	Returns     :	AX = 0 if error
-; *			AX = channel if OK
-; *
-; ************************************************************************/
-
-PROC	findDMAchannel_SBpro NEAR
-	LOCAL	channel:BYTE
-
-	mov	[channel],al
-	add	al,4
-	out	0Ah,al			; Break on
-	mov	al,0
-	out	0Ch,al			; Reset counter
-	mov	al,48h
-	add	al,[channel]
-	out	0Bh,al			; DMA -> DSP (output)
-	mov	dx,87h
-	cmp	[channel],0
-	je	@@10
-	mov	dx,83h
-	cmp	[channel],1
-	je	@@10
-	mov	dx,82h			; Channel is 3
-@@10:
-	mov	al,0
-	out	dx,al			; page 0
-	mov	dl,[channel]
-	shl	dx,1
-	mov	al,0
-	out	dx,al			; offset 0
-	mov	al,0
-	out	dx,al			; whole address is 0000:0000
-	inc	dx
-	mov	al,10
-	out	dx,al			; count = 10
-	mov	al,0
-	out	dx,al
-	mov	al,[channel]
-	out	0Ah,al			; Break off
-
-	mov	cx,0FFFFh		; Big loop
-	mov	[dmaIRQ],0		; Clear interrupt value
-@@loop:
-	cmp	[dmaIRQ],0		; Wait dmaIRQ to change
-	loope	@@loop			; loop if it doesn't
-
-	mov	al,[channel]
-	add	al,4
-	out	0Ah,al			; Break on
-	mov	al,0
-	out	0Ch,al			; Reset counter
-	mov	al,[channel]
-	out	0Ah,al			; Break off
-
-	sub	ax,ax
-	cmp	[dmaIRQ],0
-	je	@@exit
-	inc	ah			; Indicate success
-	mov	al,[channel]
-@@exit:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	findDMAchannel_SB16
-; *
-; *	Description :	Checks if given channel is the channel SB16 uses
-; *
-; *	Input       :	AX = Channel to test (5,6 or 7)
-; *
-; *	Returns     :	AX = 0 if error
-; *			AX = channel if OK
-; *
-; ************************************************************************/
-
-PROC	findDMAchannel_SB16 NEAR
-	LOCAL	channel:BYTE
-
-	push	ax
-	and	al,3
-	mov	[channel],al
-	or	al,4
-	out	0D4h,al			; Break on
-	mov	al,0
-	out	0D8h,al			; Reset counter
-	mov	al,48h
-	or	al,[channel]
-	out	0D6h,al			; DMA -> DSP (output)
-	mov	dx,08Bh
-	cmp	[channel],0
-	je	@@10
-	mov	dx,089h
-	cmp	[channel],1
-	je	@@10
-	mov	dx,08Ah			; Channel is 3
-@@10:
-	mov	al,0
-	out	dx,al			; page 0
-	mov	dl,[channel]
-	shl	dx,2
-	add	dx,0C0h
-	mov	al,0
-	out	dx,al			; offset 0
-	mov	al,0
-	out	dx,al			; whole address is 0000:0000
-	add	dx,2
-	mov	al,10
-	out	dx,al			; count = 10
-	mov	al,0
-	out	dx,al
-	mov	[dmaIRQ],0		; Clear interrupt value
-	mov	al,[channel]
-	out	0D4h,al			; Break off
-
-	mov	cx,0FFFFh		; Big loop
-@@loop:
-	cmp	[dmaIRQ],0		; Wait dmaIRQ to change
-	loope	@@loop			; loop if it doesn't
-
-	mov	al,[channel]
-	add	al,4
-	out	0D4h,al			; Break on
-	mov	al,0
-	out	0D8h,al			; Reset counter
-
-	sub	ax,ax
-	cmp	[dmaIRQ],0
-	je	@@exit
-	pop	ax
-	inc	ah			; Indicate success
-@@exit:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    : 	DMAint_SB
-; *
-; *	Description :	Interrupt function that determines SB's interrupt
-; *
-; ************************************************************************/
-
-PROC	NOLANGUAGE DMAint_SB FAR
-
-DMA2:
-	PUSHDS
-	push	ax
-	mov	ax,@DATA
-	mov	ds,ax
-	mov	[dmaIRQ],2               ; Set interrupt number
-	jmp	short @@DMAdone
-DMA3:
-	PUSHDS
-	push	ax
-	mov	ax,@DATA
-	mov	ds,ax
-	mov	[dmaIRQ],3
-	jmp	short @@DMAdone
-DMA5:
-	PUSHDS
-	push	ax
-	mov	ax,@DATA
-	mov	ds,ax
-	mov	[dmaIRQ],5
-	jmp	short @@DMAdone
-DMA7:
-	PUSHDS
-	push	ax
-	mov	ax,@DATA
-	mov	ds,ax
-	mov	[dmaIRQ],7
-	jmp	short @@DMAdone
-DMA10:
-	PUSHDS
-	push	ax
-	mov	ax,@DATA
-	mov	ds,ax
-	mov	[dmaIRQ],10
-	mov	al,20h
-	out	0A0h,al
-@@DMAdone:
-	mov	al,20h
-	out	20h,al			; EOI (end of interrupt)
-	pop	ax
-	POPDS
-	iret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	int detectSB(SOUNDCARD *sCard);
-; *
-; *	Description :	Checks for presence of SB.
-; *
-; *	Input	    :   sCard	= pointer to info structure
-; *
-; *	Returns     :	0  if succesful
-; *			-1 on error (no card found)
-; *
-; ************************************************************************/
-
-PROC	detectSB FAR USES di si,sCard:DWORD
-	local	retvalue:WORD,retrycount:WORD
-
-	LESDI	[sCard]
-	mov	[WORD HIGH scardPtr],es
-	mov	[WORD LOW scardPtr],di
-	mov	ax,es
-	or	ax,di			; Is sCard NULL?
-	jz	@@nocopy
-	mov	si,offset SoundBlaster
-	mov	cx,SIZE CARDINFO	; Copy sound card info into buffer
-	cld
-	PUSHDS
-	PUSHCS
-	POPDS
-	rep	movsb
-	POPDS
-	LESDI	[sCard]
-@@nocopy:
-	mov	[retvalue],-1		; Assume failure
-	mov	dx,220h
-	call	checkPort_SB
-	jz	@@OK
-	mov	dx,210h
-	call	checkPort_SB		; Check for every possible I/O value
-	jz	@@OK
-	mov	dx,230h
-	call	checkPort_SB
-	jz	@@OK
-	mov	dx,240h
-	call	checkPort_SB
-	jz	@@OK
-	mov	dx,250h
-	call	checkPort_SB
-	jz	@@OK
-	mov	dx,260h
-	call	checkPort_SB
-	jnz	@@exit			; No match found, error exit
-@@OK:
-	mov	[ESDI+CARDINFO.ioPort],dx	; ioPort is for internal use only
-
-	PUSHES
-	push	di
-	call	findDMAIRQ_SB		; Find DMA interrupt number
-	pop	di
-	POPES
-	or	ax,ax			; 0 = error
-	jz	@@exit
-	mov	[ESDI+CARDINFO.DMAIRQ],al
-	mov	[ESDI+CARDINFO.DMAChannel],1
-
-	mov	[retrycount],10
-@@retry:
-	dec	[retrycount]
-	jnz	@@continue
-	mov	ax,0			; not found
-	jmp	@@done
-@@continue:
-	mov	dx,[ESDI+CARDINFO.ioPort]
-	add	dx,0Ch
-	waitSB
-	mov	al,0E1h			; Read version number
-	out	dx,al
-
-	add	dl,2			; DX = 22Eh
-	sub	al,al
-	mov	cx,1000
-@@10:
-	in	al,dx			; Read version high
-	or	al,al
-	js	@@10ok
-	loop	@@10
-	jmp	@@retry
-@@10ok:
-	mov	cx,1000
-	sub	dl,4
-	in	al,dx
-	mov	ah,al
-
-	add	dl,4
-	sub	al,al
-@@20:
-	in	al,dx			; Read version low
-	or	al,al
-	js	@@20ok
-	loop	@@20
-	jmp	@@retry
-@@20ok:
-	sub	dl,4
-	in	al,dx
-@@done:
-	mov	[ESDI+CARDINFO.ver],ax
-	mov	[retvalue],0
-@@exit:
-	mov	ax,[retvalue]		; Return with 'retvalue'
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	int detectSBPro(CARDINFO *sCard);
-; *
-; *	Description :	Checks for presence of SB Pro.
-; *
-; *	Input	    :   sCard	= pointer to info structure
-; *
-; *	Returns     :	0  if succesful
-; *			-1 on error (no card found)
-; *
-; ************************************************************************/
-
-PROC	detectSBPro FAR USES di si,sCard:DWORD
-	local	retvalue:WORD,retrycount:WORD
-
-	LESDI	[sCard]
-	mov	[WORD HIGH scardPtr],es
-	mov	[WORD LOW scardPtr],di
-	mov	ax,es
-	or	ax,di			; Is sCard NULL?
-	jz	@@nocopy
-	mov	si,offset SoundBlasterPro
-	mov	cx,SIZE CARDINFO	; Copy sound card info into buffer
-	cld
-	PUSHDS
-	PUSHCS
-	POPDS
-	rep	movsb
-	POPDS
-	LESDI	[sCard]
-@@nocopy:
-	mov	[retvalue],-1		; Assume failure
-	mov	dx,220h
-	call	checkPort_SB		; Check for every possible I/O value
-	jz	@@OK
-	mov	dx,240h
-	call	checkPort_SB
-	jnz	@@exit			; No match found, error exit
-@@OK:
-	mov	[ESDI+CARDINFO.ioPort],dx	; ioPort is for internal use only
-
-	mov	[retrycount],10
-@@retry:
-	dec	[retrycount]
-	jnz	@@continue
-	mov	ax,0			; not found
-	jmp	@@done
-@@continue:
-	mov	dx,[ESDI+CARDINFO.ioPort]
-	add	dx,0Ch
-	waitSB
-	mov	al,0E1h			; Read version number
-	out	dx,al
-
-	add	dl,2			; DX = 22Eh
-	sub	al,al
-	mov	cx,1000
-@@10:
-	in	al,dx			; Read version high
-	or	al,al
-	js	@@10ok
-	loop	@@10
-	jmp	@@retry
-@@10ok:
-	mov	cx,1000
-	sub	dl,4
-	in	al,dx
-	mov	ah,al
-
-	add	dl,4
-	sub	al,al
-@@20:
-	in	al,dx			; Read version low
-	or	al,al
-	js	@@20ok
-	loop	@@20
-	jmp	@@retry
-@@20ok:
-	sub	dl,4
-	in	al,dx
-@@done:
-	mov	[ESDI+CARDINFO.ver],ax
-	cmp	ax,0300h
-	jl	@@exit			; Not SBpro
-
-	PUSHES
-	push	di
-	call	findDMAIRQ_SBpro	; Find DMA interrupt number
-	pop	di
-	POPES
-	or	ax,ax			; 0 = error
-	jz	@@exit
-	mov	[ESDI+CARDINFO.DMAIRQ],al
-
-	mov	[retvalue],0
-@@exit:
-	mov	ax,[retvalue]		; Return with 'retvalue'
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	int detectSB16(CARDINFO *sCard);
-; *
-; *	Description :	Checks for presence of SB 16 ASP.
-; *
-; *	Input	    :   sCard	= pointer to info structure
-; *
-; *	Returns     :	0  if succesful
-; *			-1 on error (no card found)
-; *
-; ************************************************************************/
-
-PROC	detectSB16 FAR USES di,sCard:DWORD
-	local	retvalue:WORD,retrycount:WORD
-
-	LESDI	[sCard]
-	mov	[WORD HIGH scardPtr],es
-	mov	[WORD LOW scardPtr],di
-	mov	ax,es
-	or	ax,di			; Is sCard NULL?
-	jz	@@nocopy
-	mov	si,offset SoundBlaster16
-	mov	cx,SIZE CARDINFO	; Copy sound card info into buffer
-	cld
-	PUSHDS
-	PUSHCS
-	POPDS
-	rep	movsb
-	POPDS
-	LESDI	[sCard]
-@@nocopy:
-	mov	[retvalue],-1		; Assume failure
-	mov	dx,220h
-	call	checkPort_SB		; Check for every possible I/O value
-	jz	@@OK
-	mov	dx,240h
-	call	checkPort_SB		; Check for every possible I/O value
-	jz	@@OK
-	mov	dx,260h
-	call	checkPort_SB		; Check for every possible I/O value
-	jz	@@OK
-	mov	dx,280h
-	call	checkPort_SB
-	jnz	@@exit			; No match found, error exit
-@@OK:
-	mov	[ESDI+CARDINFO.ioPort],dx	; ioPort is for internal use only
-
-	mov	[retrycount],10
-@@retry:
-	dec	[retrycount]
-	jnz	@@continue
-	mov	ax,0			; not found
-	jmp	@@done
-@@continue:
-	mov	dx,[ESDI+CARDINFO.ioPort]
-	add	dx,0Ch
-	waitSB
-	mov	al,0E1h			; Read version number
-	out	dx,al
-
-	add	dl,2			; DX = 22Eh
-	sub	al,al
-	mov	cx,1000
-@@10:
-	in	al,dx			; Read version high
-	or	al,al
-	js	@@10ok
-	loop	@@10
-	jmp	@@retry
-@@10ok:
-	mov	cx,1000
-	sub	dl,4
-	in	al,dx
-	mov	ah,al
-
-	add	dl,4
-	sub	al,al
-@@20:
-	in	al,dx			; Read version low
-	or	al,al
-	js	@@20ok
-	loop	@@20
-	jmp	@@retry
-@@20ok:
-	sub	dl,4
-	in	al,dx
-@@done:
-	mov	[ESDI+CARDINFO.ver],ax
-	cmp	ax,0400h
-	jl	@@exit			; Not SB16
-
-	PUSHES
-	push	di
-	call	findDMAIRQ_SB16		; Find DMA interrupt number
-	pop	di
-	POPES
-	or	ax,ax			; 0 = error
-	jz	@@exit
-	mov	[ESDI+CARDINFO.DMAIRQ],al
-
-	mov	[retvalue],0
-@@exit:
-	mov	ax,[retvalue]		; Return with 'retvalue'
-	ret
-ENDP
-
-END
diff --git a/dmp/detgus.pas b/dmp/detgus.pas
index 53aca93..42ce4d6 100644
--- a/dmp/detgus.pas
+++ b/dmp/detgus.pas
@@ -1,89 +1,5 @@
-{ -------------------------------------------------------------------------- }
-{                                                                            }
-{                                 DETGUS.PAS                                 }
-{                                 ----------                                 }
-{                                                                            }
-{                         (C) 1993 Jussi Lahdenniemi                         }
-{         Original C file (C) 1993 Otto Chrons                               }
-{                                                                            }
-{ Detect GUS                                                                 }
-{                                                                            }
-{ -------------------------------------------------------------------------- }
-
-unit detgus;
-
-{$O+}
-
-interface
-uses cdi,mcp;
-
-function detectGUS(scard:PSoundcard):integer;
-
-implementation
-uses dos;
-
-procedure strip(var s:string);
-begin
-  while (s[1]=' ') and (s[0]>#0) do delete(s,1,1);
-  while (s[length(s)]=' ') and (s[0]>#0) do dec(s[0]);
-end;
-
-function hex2dec(s:string):word;
-const hs:string='0123456789ABCDEF';
-var w,w2:word;
-begin
-  w:=0;
-  for w2:=1 to length(s) do
-    w:=w+(pos(s[w2],hs)-1) shl (4*(length(s)-w2));
-  hex2dec:=w;
-end;
-
-Function detectGUS(scard:PSoundcard):integer;
-var ptr           : pointer;
-    dummy,DMA,DMA2,
-    IRQ,IRQ2      : integer;
-    s,s2          : string;
-    w             : word;
-
-begin
-  s:=getenv('ULTRASND');
-  if s='' then begin detectGUS:=-1; exit end;
-  strip(s);
-  w:=pos(',',s);
-  s2:=copy(s,1,w-1);
-  delete(s,1,w);
-  scard^.ioPort:=hex2dec(s2);
-  strip(s);
-  w:=pos(',',s);
-  s2:=copy(s,1,w-1);
-  delete(s,1,w);
-  val(s2,DMA,dummy);
-  strip(s);
-  w:=pos(',',s);
-  s2:=copy(s,1,w-1);
-  delete(s,1,w);
-  val(s2,DMA2,dummy);
-  strip(s);
-  w:=pos(',',s);
-  s2:=copy(s,1,w-1);
-  delete(s,1,w);
-  val(s2,IRQ,dummy);
-  strip(s);
-  val(s,IRQ2,dummy);
-  scard^.dmaChannel:=DMA;
-  scard^.dmaIRQ:=IRQ;
-  s:='Gravis Ultrasound'#0;
-  move(s[1],scard^.name,length(s));
-  scard^.id:=ID_GUS;
-  scard^.minrate:=19293;
-  scard^.maxrate:=44100;
-  scard^.stereo:=true;
-  scard^.mixer:=true;
-  scard^.sampleSize:=1;
-  scard^.version:=$100;
-  scard^.extraField[0]:=DMA2;
-  scard^.extraField[1]:=IRQ2;
-  detectGUS:=0;
-end;
-
-end.
+unit detgus;
+{$O+}
+interface
+implementation
+end.
diff --git a/dmp/detgus.tpp b/dmp/detgus.tpp
deleted file mode 100644
index 113c3b4..0000000
Binary files a/dmp/detgus.tpp and /dev/null differ
diff --git a/dmp/detpas.asm b/dmp/detpas.asm
deleted file mode 100644
index 2025a89..0000000
--- a/dmp/detpas.asm
+++ /dev/null
@@ -1,480 +0,0 @@
-;/************************************************************************
-; *
-; *     File        : DETPAS.ASM
-; *
-; *     Description : PAS detection routines for DSMI
-; *
-; *     Copyright (C) 1993 Otto Chrons
-; *
-; ***********************************************************************
-;
-;       Revision history of DETPAS.ASM
-;
-;       1.0     16.4.93
-;               First version. Detects all PAS types.
-;
-; ***********************************************************************/
-
-        IDEAL
-;       L_PASCAL        = 1             ; Uncomment this for pascal-style
-
-IFDEF   L_PASCAL
-        LANG    EQU     PASCAL
-        MODEL TPASCAL
-ELSE
-        LANG    EQU     C
-        MODEL LARGE,C
-ENDIF
-
-        INCLUDE "MODEL.INC"
-        include "mcp.inc"
-        quirks
-        masm51
-        include masm.inc
-        include common.inc
-        include target.inc
-        ideal
-        jumps
-
-;
-;---------------------------========================---------------------------
-;---------------------------====< DATA SECTION >====---------------------------
-;---------------------------========================---------------------------
-;
-        dataseg
-
-
-        ID      dw ?
-        DMA     db ?
-        IRQ     db ?
-        basea   dw ?
-
-;
-; The board base address for the original PAS card was based at 388. This will
-; be XORed to the new address to derive a translation code. This code can be
-; XORed back into any original PAS address resulting in the true card address.
-;
-
-VERSION_PAS             equ     0       ; Pro Audio Spectrum
-VERSION_PASPLUS         equ     1       ; Pro Audio Plus card
-VERSION_PAS16           equ     2       ; Pro Audio 16 card
-VERSION_CDPC            equ     3       ; CDPC card & unit
-
-
-;
-; The following equates build up a mask of bits that we do wish to keep
-; when comparing feature bits. The zero bits can be ignored, whereas, the
-; the 1 bits must match.
-;
-
-PASdocare       equ     <(bMVA508 OR bMVDAC16 OR bMVOPL3 OR bMV101 )>
-PASPLUSdocare   equ     <(bMVA508 OR bMVDAC16 OR bMVOPL3 OR bMV101 )>
-PAS16docare     equ     <(bMVA508 OR bMVDAC16 OR bMVOPL3 OR bMV101 )>
-CDPCdocare      equ     <(bMVA508 OR bMVDAC16 OR bMVOPL3 OR bMV101 )>
-
-;
-
-;
-;---------------------------========================---------------------------
-;---------------------------====< CODE SECTION >====---------------------------
-;---------------------------========================---------------------------
-;
-        codeseg
-
-        public  detectPAS
-
-        copyrightText   DB "PAS-DETECT v1.0 - (C) 1993 Otto Chrons",0,1Ah
-        PASnorm         CARDINFO <3,0,"Pro Audio Spectrum",388h,0,0,3000,44100,1,1,1>
-        PASplus         CARDINFO <4,0,"Pro Audio Spectrum+",388h,0,0,3000,44100,1,1,1>
-        PAS16           CARDINFO <5,0,"Pro Audio Spectrum 16",388h,0,0,3000,44100,1,1,2>
-
-        IRQtable        DB 0,2,3,4,5,6,7,10,11,12,13,15,0,0,0,0
-
-        label   ProductIDTable  word
-        dw      PRODUCT_PROAUDIO and PASdocare
-        dw      PRODUCT_PROPLUS  and PASPLUSdocare
-        dw      PRODUCT_PRO16    and PAS16docare
-        dw      PRODUCT_CDPC     and CDPCdocare
-        dw      -1
-;
-        label   DoCareBits      word
-        dw      PASdocare
-        dw      PASPLUSdocare
-        dw      PAS16docare
-        dw      CDPCdocare
-        dw      -1                              ; table terminator
-
-;
-;   /*\
-;---|*|----====< SearchHWVersion >====----
-;---|*|
-;---|*| Given a specific I/O address, this routine will see if the
-;---|*| hardware exists at this address.
-;---|*|
-;---|*| Entry Conditions:
-;---|*|     DI holds the I/O address to test
-;---|*|     BX:CX = bMVSCSI
-;---|*|
-;---|*| Exit Conditions:
-;---|*|     BX:CX = the bit fields that identify the board
-;---|*|
-;   \*/
-;
-proc    SearchHWVersion NEAR scard:FAR PTR CARDINFO
-        push    si                      ; save the C criticals
-        push    di
-;
-; calculate the translation code
-;
-        xor     di,DEFAULT_BASE         ; di holds the translation code
-
-        mov     ax,0BC00H               ; make sure MVSOUND.SYS is loaded
-        mov     bx,'??'                 ; this is our way of knowing if the
-        xor     cx,cx                   ; hardware is actually present.
-        xor     dx,dx
-        int     2fh                     ; get the ID pattern
-        xor     bx,cx                   ; build the result
-        xor     bx,dx
-        cmp     bx,'MV'                 ; if not here, exit...
-        jne     @@manual_detect
-
-; get the MVSOUND.SYS specified DMA and IRQ channel
-
-        mov     ax,0bc04h               ; get the DMA and IRQ numbers
-        int     2fh
-        mov     [IRQ],cl
-        mov     [DMA],bl
-        jmp     short @@detected
-@@manual_detect:
-        mov     dx,IOCONFIG2            ; get DMA channel
-        xor     dx,di
-        in      al,dx
-        and     al,0Fh
-        cmp     al,7
-        ja      sehw_bad                ; we have a bad board
-        cmp     al,0
-        je      sehw_bad
-        cmp     al,4
-        jne     @@DMAok
-        sub     al,al
-@@DMAok:
-        mov     [DMA],al
-        mov     dx,IOCONFIG3
-        xor     dx,di
-        in      al,dx                   ; Get IRQ (AL = 1-6 for IRQ 2-7 and
-        cmp     al,0Fh                  ; 7-10 for IRQ 10-13, 11 for IRQ 15)
-        ja      sehw_bad                ; we have a bad board
-
-        mov     bx,offset IRQtable
-        and     al,0Fh
-        xlat    [cs:bx]
-        or      al,al
-        jz      sehw_bad                ; we have a bad board
-        mov     [IRQ],al
-;
-; grab the version # in the interrupt mask. The top few bits hold the version #
-;
-@@detected:
-        mov     dx,INTRCTLR             ; board ID is in MSB 3 bits
-        xor     dx,di                   ; adjust to other address
-        in      al,dx
-        cmp     al,0FFh                 ; bus float meaning not present?
-        je      sehw_bad                ; yes, there is no card here
-
-        mov     ah,al                   ; save an original copy
-        xor     al,fICrevbits           ; the top bits wont change
-
-        out     dx,al                   ; send out the inverted bits
-        jmp     $+2
-        jmp     $+2
-        in      al,dx                   ; get it back...
-
-        cmp     al,ah                   ; both should match now...
-        xchg    al,ah                   ; (restore without touching the flags)
-        out     dx,al
-
-        jnz     sehw_bad                ; we have a bad board
-
-        and     ax,fICrevbits           ; isolate the ID bits & clear AH
-        mov     cl,fICrevshr            ; shift the bits into a meaningful
-        shr     al,cl                   ; position (least signficant bits)
-        mov     si,ax                   ; save the version #
-;
-; We do have hardware! Load the product bit definitions
-;
-        sub     bx,bx
-        mov     cx,bMVSCSI              ; setup bx:cx for the original PAS
-
-        or      al,al                   ; is this the first version of h/w?
-        jz      sehw_done               ; yes, simple exit will do.
-
-        call    FindBits                ; load all the rest of the h/w bits
-;
-sehw_done:
-;
-; loop on a table search to find identify the board
-;
-        push    bx                      ; save this high bits
-        mov     bx,-2
-    ;
-    sehw_05:
-        add     bx,2
-        cmp     [ProductIDTable+bx],-1  ; at the end of the table?
-        jz      sehw_bad_hw             ; yes, we can't identify this board
-        mov     dx,cx                   ; dx holds the product bits
-        and     dx,[DoCareBits+bx]      ; keep the bits we care about
-        cmp     dx,[ProductIDTable+bx]  ; do these bits match a product?
-        jnz     sehw_05                 ; no, keep looking
-
-        mov     dx,bx
-        shr     dx,1                    ; make word index a byte index
-        pop     bx
-
-        mov     ax,si                   ; load the h/w version #
-        sub     ah,ah                   ; for our purposes, we will return SCSI
-        xchg    ah,al                   ; into ah
-        clc                             ; The board was identified !
-
-        jmp     short sehw_exit
-;
-sehw_bad_hw:
-        pop     bx                      ; flush the stack
-        mov     ax,-2
-        cwd
-        stc
-        jmp     short sehw_exit
-;
-sehw_bad:
-        mov     ax,-1                   ; we got here due to a bad board
-        cwd
-        stc
-;
-sehw_exit:
-        pop     di
-        pop     si
-        ret
-
-endp
-
-;
-;   /*\
-;---|*|----====< long mvGetHWVersion() >====----
-;---|*|
-;---|*| Detects and identifies the installed Pro AudioSpectrum.
-;---|*|
-;---|*| Entry Conditions:
-;---|*|     word address containing the base address.
-;---|*|
-;---|*| Exit Conditions:
-;---|*|     DX:AX = -1, the hardware is not installed.
-;---|*|     DX:AX = -2, some type of hardware is installed - can't ID it.
-;---|*|     DX    = Product ID
-;---|*|     AH    = PAS hardware version
-;---|*|     AL    = SCSI, or MITSUMI CD-ROM interface installed.
-;---|*|     BX:CX = the bit fields that identify the board
-;---|*|     Carry is set on error
-;---|*|
-;   \*/
-
-
-proc    detectPAS scard:DWORD
-
-        push    si                      ; save the C criticals
-        push    di
-;
-; calculate the translation code
-;
-
-    ; search the default address
-
-        mov     di,DEFAULT_BASE         ; try the first address
-        mov     [basea],di
-        call    SearchHWVersion LANG,[scard]
-        cmp     dx,-1                   ; found?
-        jnz     mvgehw_exit             ; yes, exit now...
-
-    ; search the first alternate address
-
-        mov     di,ALT_BASE_1           ; try the first alternate
-        mov     [basea],di
-        call    SearchHWVersion LANG,[scard]
-        cmp     dx,-1                   ; found?
-        jnz     mvgehw_exit             ; yes, exit now...
-
-    ; search the second alternate address
-
-        mov     di,ALT_BASE_2           ; try the second alternate
-        mov     [basea],di
-        call    SearchHWVersion LANG,[scard]
-        cmp     dx,-1                   ; found?
-        jnz     mvgehw_exit             ; yes, exit now...
-
-    ; search the third, or user requested alternate address
-
-        mov     di,ALT_BASE_3           ; try the third alternate
-        mov     [basea],di
-        call    SearchHWVersion LANG,[scard]
-        cmp     dx,-1
-        jne     mvgehw_exit
-        mov     ax,-1
-        jmp     @@exitok
-mvgehw_exit:
-        LESDI   [scard]
-        mov     si,-1
-        PUSHDS
-        PUSHCS
-        POPDS
-        cmp     dx,0
-        jne     notNorm
-        mov     si,offset PASnorm
-notNorm:
-        cmp     dx,1
-        jne     notPlus
-        mov     si,offset PASplus
-notPlus:
-        cmp     dx,2
-        jne     not16
-        mov     si,offset PAS16
-not16:
-        cmp     si,-1
-        jne     cardok
-        POPDS
-        mov     ax,-1
-        jmp     @@exitok
-cardok:
-        mov     cx,SIZE CARDINFO
-        cld
-        rep     movsb
-        POPDS
-        LESDI   [scard]
-        mov     al,[DMA]
-        mov     [ESDI+CARDINFO.DMAchannel],al
-        mov     al,[IRQ]
-        mov     [ESDI+CARDINFO.DMAIRQ],al
-        mov     ax,[basea]
-        mov     [ESDI+CARDINFO.ioPort],ax
-        sub     ax,ax
-@@exitok:
-        pop     di
-        pop     si
-        ret
-endp
-
-;
-;   /*\
-;---|*|----====< FindBit >====----
-;---|*|
-;---|*| Checks the installed hardware for all the feature bits.
-;---|*|
-;---|*| Entry Conditions:
-;---|*|     DI holds the I/O address translation code
-;---|*|     BX:CX = bMVSCSI
-;---|*|
-;---|*| Exit Conditions:
-;---|*|     BX:CX = the bit fields that identify the board
-;---|*|
-;   \*/
-;
-
-proc    FindBits        near
-;
-masm
-quirks
-
-; All second generation Pro Audio cards use the MV101 and have SB emulation.
-;
-        or      cx,bMVSBEMUL+bMV101     ; force SB emulation
-;
-; determine if the enhanced SCSI interface is present
-;
-        mov     dx,ENHANCEDSCSI         ; test for SCSI mod (U48)
-        xor     dx,di                   ; modify via the translate code
-
-        out     dx,al                   ; strobe
-        jmp     $+2                             ; I/O bus delay
-        in      al,dx                   ; get the bit
-
-        and     al,1                    ; bit0==1 means old SCSI PAL
-        cmp     al,1                    ; reverse sense
-        sbb     ax,ax                   ; ax = ffff if enhanced SCSI
-        and     ax,bMVENHSCSI           ; save the bit
-        or      cx,ax                   ; merge it in
-;
-; determine AT/PS2, CDPC slave mode
-;
-        mov     dx,MASTERMODRD          ; check for the CDPC
-        xor     dx,di                   ; modify via the translate code
-
-        in      al,dx
-        test    al,bMMRDatps2           ; AT(1) or PS2(0)
-        jnz     @F
-        or      cx,bMVPS2
-    ;
-    @@:
-        test    al,bMMRDmsmd            ; Master(0) or Slave(1)
-        jz      @F
-        or      cx,bMVSLAVE
-    ;
-    @@:
-        push    cx                      ; move the revision bits
-
-        mov     dx,MASTERCHIPR
-        xor     dx,di
-
-        .errnz  bMV101_REV-(000Fh SHL 11)
-
-        in      al,dx                   ; get the low 4 bits of the chip rev
-        and     ax,000Fh                ; into ah
-        mov     cl,11                   ; FROM 0000 0000 0000 1111b
-        shl     ax,cl                   ; TO   0111 1000 0000 0000b
-
-        pop     cx
-        or      cx,ax                   ; merge in the bits
-;
-; determine the CDROM drive type, FM chip, 8/16 bit DAC, and mixer
-;
-        mov     dx,SLAVEMODRD           ; check for the CDPC
-        xor     dx,di                   ; modify via the translate code
-        in      al,dx
-
-        test    al,bSMRDdactyp          ; 16 bit DAC?
-        jz      @F                      ; no, its an 8 bit DAC
-        or      cx,bMVDAC16             ; its a 16 bit DAC
-    ;
-    @@:
-        test    al,bSMRDfmtyp           ; OPL3 chip?
-        jz      @F                      ; no, so it's the PAS16 card
-        or      cx,bMVOPL3              ; is an OPL3
-    ;
-    @@:
-        mov     dx,cx                   ; inference check for new mixer
-        and     dx,bMVSLAVE+bMVDAC16    ; Slave & 16 bit dac is the CDPC
-        cmp     dx,bMVDAC16             ; 16 bit DAC on master?
-        jnz     @F                      ; no, it's the CDPC with Nation mixer
-        or      cx,bMVA508
-    ;
-    @@:
-        and     al,bSMRDdrvtyp          ; isolate the CDROM drive type
-        cmp     al,2                    ; Sony 535 interface?
-        jnz     @F                      ; no, continue on...
-        and     cx,NOT (bMVSCSI+bMVENHSCSI) ; yes, flush the SCSI bits
-        or      cx,bMVSONY                  ; set the 535 bit
-    ;
-    @@:
-;
-; determine if MPU-401 emulation is active
-;
-        mov     dx,COMPATREGE           ; compatibility register
-        xor     dx,di                   ; modify via translate code
-        in      al,dx
-        test    al,cpMPUEmulation
-        jz      @F
-        or      cx,bMVMPUEMUL
-    ;
-    @@:
-        ret
-
-endp
-
-        end
-
diff --git a/dmp/dpmiapi.pas b/dmp/dpmiapi.pas
deleted file mode 100644
index 480014f..0000000
--- a/dmp/dpmiapi.pas
+++ /dev/null
@@ -1,100 +0,0 @@
-(****************************************************************************
-
-                                  DPMIAPI.PAS
-                                  -----------
-
-                           (C) 1993 Jussi Lahdenniemi
-
-DPMI API routines for Borland Pascal 7.0
-
-****************************************************************************)
-
-Unit DPMIAPI;
-
-{$IFNDEF DPMI}
-'This unit must be compiled in protected mode!'
-{$ENDIF}
-
-Interface
-
-Function  dpmiSeg2slc(seg:word):word;
-Function  dpmiGetLinearAddr(slc:word):Longint;
-Function  dpmiAllocDOS(amount:word;var segment,slc:word):word;
-Function  dpmiFreeDOS(slc:word):boolean;
-Function  dpmiResizeDOS(slc:word;newsize:word):word;
-Procedure dpmiVersion(var verMaj,verMin,processor:byte;var flags:word);
-
-const prc286              = 1;
-      prc386              = 2;
-      prc486              = 3;
-
-      flg386              = 1;
-      flgRealInt          = 2;
-      flgVirtualMemory    = 4;
-
-Implementation
-uses dos;
-
-var r:registers;
-
-Function dpmiSeg2Slc;
-begin
-  r.ax:=2;
-  r.bx:=seg;
-  intr($31,r);
-  if r.flags and 1=1 then dpmiSeg2Slc:=0 else dpmiSeg2Slc:=r.ax;
-end;
-
-Function dpmiGetLinearAddr;
-begin
-  r.ax:=6;
-  r.bx:=slc;
-  intr($31,r);
-  if r.flags and 1=1 then dpmiGetLinearAddr:=0 else
-    dpmiGetLinearAddr:=longint(r.cx)*65536+longint(r.dx);
-end;
-
-Function dpmiAllocDOS;
-begin
-  r.ax:=$100;
-  r.bx:=amount;
-  intr($31,r);
-  if r.flags and 1=1 then dpmiAllocDOS:=r.bx else begin
-    segment:=r.ax;
-    slc:=r.dx;
-    dpmiAllocDOS:=0;
-  end;
-end;
-
-Function dpmiFreeDOS;
-begin
-  r.ax:=$101;
-  r.dx:=slc;
-  intr($31,r);
-  dpmiFreeDOS:=r.flags and 1=0;
-end;
-
-Function dpmiResizeDOS;
-begin
-  r.ax:=$102;
-  r.bx:=newsize;
-  r.dx:=slc;
-  intr($31,r);
-  if r.flags and 1=1 then dpmiResizeDOS:=r.bx else dpmiResizeDOS:=0;
-end;
-
-Procedure dpmiVersion;
-begin
-  r.ax:=$400;
-  intr($31,r);
-  verMaj:=r.ah;
-  verMin:=r.al;
-  case r.cl of
-    2 : processor:=prc286;
-    3 : processor:=prc386;
-    4 : processor:=prc486;
-  end;
-  flags:=r.bx;
-end;
-
-end.
diff --git a/dmp/dpmiapi.tpp b/dmp/dpmiapi.tpp
deleted file mode 100644
index 9c0f788..0000000
Binary files a/dmp/dpmiapi.tpp and /dev/null differ
diff --git a/dmp/dsmi.inc b/dmp/dsmi.inc
deleted file mode 100644
index 6ffc54a..0000000
--- a/dmp/dsmi.inc
+++ /dev/null
@@ -1,26 +0,0 @@
-(****************************************************************************
-
-                                   DSMI.INC
-                                   --------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-Include file with a Uses-clause that includes all the necessary units of DSMI
-
-****************************************************************************)
-
-Uses DSMI,MCP,GUS,AMP,CDI,Timeserv,Mixer,VDS,
-     SDI__SB,SDI__PAS,SDI__SB1{,SDI__SB16},SDI__ARI{,SDI__ARIA},Det_SB,Det_PAS,Det_ARIA,DetGUS,
-     LoadM,Loaders,{STMload,}MODload,{AMFload,MTMload,S3MLoad,}Csupport
-
-{$IFDEF DPMI}
-,dpmiAPI
-{$ELSE}
-,SDI__DAC
-{$ENDIF}
-
-{$IFDEF USE_EMS}
-,mcpems
-{$ELSE}
-,mcpreala
-{$ENDIF}
diff --git a/dmp/dsmi.pas b/dmp/dsmi.pas
deleted file mode 100644
index 50c7c23..0000000
--- a/dmp/dsmi.pas
+++ /dev/null
@@ -1,177 +0,0 @@
-(****************************************************************************
-
-                                   DSMI.PAS
-                                   --------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-initDSMI routine for easer MCP, AMP and TS initialization
-
-****************************************************************************)
-
-unit DSMI;
-
-{$X+}
-{$IFDEF DPMI}
-{'initDSMI is not available in the protected mode! Real mode target only!'}
-{$ENDIF}
-
-interface
-
-uses MCP,CDI;
-
-Function initDSMI(rate,buffer,options:longint;scard:PSoundcard;override:boolean):Integer;
-
-Const No_Soundcard  = -1;
-      Invalid_SDI   = -2;
-      No_Memory     = -3;
-      MCP_InitError = -4;
-      AMP_InitError = -5;
-
-implementation
-uses AMP,SDI__SB,SDI__SB1{,SDI__SB16},SDI__PAS,SDI__ARI{,SDI__ARIA},DET_SB,DET_PAS,DET_ARIA,DETGUS,
-     TIMESERV,CSupport,GUS,mixer,vds
-{$IFDEF DPMI}
-,dpmiAPI
-{$ENDIF};
-
-Function initDSMI(rate,buffer,options:longint;scard:PSoundcard;override:boolean):Integer;
-var a,vdsok: Integer;
-    s: Word;
-    sdi: TSDI_Init;
-    temp: Pointer;
-    mcpstrc: TMCPStruct;
-    dds: tdds;
-begin
-  a:=0;
-  if (not override) then
-   begin
-    fillchar(scard^,sizeof(scard^),0);
-    a:=detectGUS(scard);
-    if a<>0 then a:=detectPAS(scard);
-    if a<>0 then a:=detectSB16(scard);
-    if a<>0 then a:=detectAria(scard);
-    if a<>0 then a:=detectSBPro(scard);
-    if a<>0 then a:=detectSB(scard);
-   end;
-  if a=0 then
-   begin
-    case scard^.ID of
-         ID_SB: sdi:=SDI_SB;
-      ID_SBPro: sdi:=SDI_SBpro;
-       ID_SB16: begin
-                 sdi:=SDI_SB16;
-                 if options and MCP_Mono>0 then scard^.stereo:=false;
-                end;
-       ID_ARIA: begin
-                 sdi:=SDI_ARIA;
-                 if options and MCP_Mono>0 then scard^.stereo:=false;
-                end;
-      ID_PAS,ID_PASplus,ID_PAS16 :
-                begin
-                 sdi:=SDI_PAS;
-                 if options and MCP_Mono>0 then scard^.stereo:=false;
-                end;
-       ID_GUS:;
-     else
-      begin
-       initDSMI:=Invalid_SDI;
-       exit;
-      end
-    end;
-    if scard^.id<>ID_GUS then
-     begin
-      if mcpInitSoundDevice(sdi,scard)<>0 then
-       begin
-        initdsmi:=invalid_sdi;
-        exit;
-       end;
-     end;
-   end
-  else
-   begin
-    initDSMI:=No_Soundcard;
-    exit;
-   end;
-  if scard^.ID=ID_SBPRO then
-   begin
-    mixerInit(MIXER_SBPRO,scard^.ioPort);
-    mixerSet(MIX_FILTEROUT,0);
-   end;
-  if scard^.id<>ID_GUS then
-   begin
-{$IFNDEF DPMI}
-    vdsOK:=byte(vdsInit=0);
-{$ENDIF}
-    mcpstrc.options:=0;
-    s:=buffer*2+MCP_Tablesize+16;
-    if options and MCP_Quality>0 then
-     begin
-      mcpstrc.options:=mcpstrc.options or MCP_Quality;
-      inc(s,MCP_Qualitysize);
-     end;
-{$IFDEF DPMI}
-    temp:=ptr(dseg,0);
-    dpmiAllocDOS(s div 16,word(a),mcpstrc.bufferSeg);
-{$ELSE}
-    temp:=malloc(s);
-{$ENDIF}
-    if temp=nil then
-     begin
-      initDSMI:=No_Memory;
-      exit;
-     end;
-    with mcpstrc do
-     begin
-{$IFDEF DPMI}
-      bufferLinear:=dpmiGetLinearAddr(bufferSeg);
-{$ELSE}
-      bufferSeg:=seg(temp^)+ofs(temp^) div 16+1;
-      if (vdsOK>0) and (scard^.id<>ID_DAC) then
-       begin
-        dds.size:=buffer;
-        dds.segment:=bufferSeg;
-        dds.offset:=0;
-        if vdsLockDMA(@dds)=0 then
-         begin
-          bufferLinear:=dds.address;
-          vdsDisableDMATranslation(scard^.dmaChannel);
-          vdsOK:=2;
-         end
-        else bufferLinear:=longint(bufferSeg) shl 4;
-       end else bufferLinear:=longint(bufferSeg) shl 4;
-{$ENDIF}
-      bufferSize:=buffer*2;
-      reqSize:=buffer;
-      samplingRate:=rate;
-     end;
-    if mcpInit(@mcpstrc)<>0 then
-     begin
-      initDSMI:=MCP_Initerror;
-      exit;
-     end;
-    atexit(@mcpClose);
-    cdiInit;
-    cdiRegister(@CDI_MCP,0,31);
-  end else
-   begin
-    gusInit(scard);
-    atexit(@gusClose);
-    gushminit;
-    cdiInit;
-    cdiRegister(@CDI_GUS,0,31);
-   end;
-  tsInit;
-  atexit(@tsClose);
-  if ampInit(0)<>0 then
-   begin
-    initDSMI:=AMP_Initerror;
-    exit;
-   end;
-  atexit(@ampClose);
-  tsAddRoutine(@ampInterrupt,AMP_Timer);
-  initDSMI:=0;
-end;
-
-begin
-end.
diff --git a/dmp/dsmi.tpp b/dmp/dsmi.tpp
deleted file mode 100644
index f3a7ce1..0000000
Binary files a/dmp/dsmi.tpp and /dev/null differ
diff --git a/dmp/dsmistub.pas b/dmp/dsmistub.pas
new file mode 100644
index 0000000..74e0ead
--- /dev/null
+++ b/dmp/dsmistub.pas
@@ -0,0 +1,252 @@
+unit DSMISTUB;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
+(* This is just provides a stub for the DMP library. *)
+
+
+interface
+
+Uses detgus, det_aria, det_pas, det_sb, loaders, modload;
+
+Const
+   ID_SB	= 1;
+   ID_SBPRO	= 2;
+   ID_PAS	= 3;
+   ID_PASPLUS	= 4;
+   ID_PAS16	= 5;
+   ID_SB16	= 6;
+   ID_DAC	= 7;
+   ID_ARIA	= 8;
+   ID_WSS	= 9;
+   ID_GUS	= 10;   
+   LM_IML	= 1;
+   LM_OLDTEMPO	= 2;
+   MCP_QUALITY	= 1;
+   MCP_486	= 2;
+   MCP_Mono	= 4;
+   PM_Loop	= 1;
+   MD_Playing	= 1;
+   MD_Paused	= 2;
+   PAN_Left	= -63;
+   PAN_Right	= 63;
+   PAN_Middle	= 0;
+   PAN_Surround	= 100;
+	       
+
+Type
+   PModule = ^TModule;
+   TModule = Record
+		(*                           modType : Byte;
+		Size				     : Longint;
+		Filesize			     : Longint;
+		Name				     : Array[0..31] of char;*)
+		ChannelCount			     : Byte;
+		(*ChannelPanning			     : Array[0..Max_Tracks-1] of shortint;
+		InstrumentCount			     : Byte;
+		Instruments			     : ^AMInstr;*)
+		PatternCount			     : Byte;
+		(*Patterns			     : ^AMPattern;
+		TrackCount			     : Word;
+		Tracks				     : ^AMTracks;
+		Tempo				     : Byte;
+		Speed				     : Byte;*)
+	     End;				     
+PSampleinfo        = ^TSampleInfo;
+     TSampleInfo        = Record
+                            Sample      : Pointer;
+                            Length,
+                            Loopstart,
+                            Loopend     : Longint;
+                            Mode        : Byte;
+                            SampleID    : Word;
+                          End;
+
+PSoundCard        = ^TSoundCard;
+      TSoundCard        = Record
+                            ID          : Byte;
+                            version     : Word;
+                            name        : Array[0..31] of char;
+                            IOPort      : Word;
+                            dmaIRQ      : Byte;
+                            dmaChannel  : Byte;
+                            minRate     : Word;
+                            maxRate     : Word;
+                            Stereo      : Boolean;
+                            mixer       : Boolean;
+                            sampleSize  : Byte;
+                            extraField  : array[0..7] of byte;
+                          End;
+
+Function initDSMI(rate,buffer,options:longint;scard:PSoundcard;override:boolean):Integer;
+Function  mcpSetMasterVolume(Volume:longint):Integer;
+Function  gusSetMasterVolume(Volume:longint):Integer;
+Procedure mcpClearBuffer;
+Function  ampPlayModule(module:PModule;opt:longint):integer;
+Function  ampStopModule:integer;
+Procedure ampFreeModule(var module:PModule);
+Function ampLoadMOD(name:String;options:longint):PModule;
+Function  mcpStartVoice:Integer;
+Function  gusStartVoice:integer;
+Function  cdiSetupChannels(channel,count:longint;volTable:pointer):integer;
+Procedure cdiSetPan(channel:longint;pan:longint);
+Procedure mcpConvertSample(Sample:Pointer;Length:Longint);
+Function  mcpSetSample(Channel:longint;s:PSampleInfo):Integer;
+Function  mcpPlaySample(channel:longint;rate:Longint;volume:longint):Integer;
+Function  mcpPauseVoice:Integer;
+Function  mcpResumeVoice:Integer;
+Function  gusPauseAll:Integer;
+Function  gusResumeAll:Integer;
+Function  ampGetPattern:integer;
+Function  ampGetRow:integer;
+Function  ampGetModuleStatus:integer;
+Procedure ampSetPanning(track,direction:longint);
+Function GetCPUtype:Integer;
+Function  emsInit(minmem,maxmem:integer):integer;
+Function detectGUS(scard:PSoundcard):integer;
+Function detectAria(scard:PSoundcard):integer;
+Function detectSB16(scard:PSoundcard):integer;
+Function detectSBPro(scard:PSoundcard):integer;
+Function detectSB(scard:PSoundcard):integer;
+Function detectPAS(scard:PSoundcard):integer;
+
+implementation
+
+   Function initDSMI(rate,buffer,options:longint;scard:PSoundcard;override:boolean):Integer;
+   begin
+      initDSMI := 0;
+   end;
+
+   Function  mcpSetMasterVolume(Volume:longint):Integer;
+   begin
+      mcpSetMasterVolume := 0;
+   end;
+   Function  gusSetMasterVolume(Volume:longint):Integer;
+   begin
+      gusSetMasterVolume := 0;
+   end;
+   Procedure mcpClearBuffer;
+   begin
+   end;
+   Function  ampPlayModule(module:PModule;opt:longint):integer;
+   begin
+      ampPlayModule := 0;
+   end;
+   Function  ampStopModule:integer;
+   begin
+      ampStopModule := 0;
+   end;
+   Procedure ampFreeModule(var module:PModule);
+   begin
+      dispose(module);
+   end;
+   Function ampLoadMOD(name:String;options:longint):PModule;
+   var
+      module : PModule;
+   begin
+      new(module);
+      ampLoadMOD := module;
+   end;
+   Function  mcpStartVoice:Integer;
+   begin
+      mcpStartVoice := 0;
+   end;
+   Function  gusStartVoice:integer;
+   begin
+      gusStartVoice := 0;
+   end;
+   Function  cdiSetupChannels(channel,count:longint;volTable:pointer):integer;
+   begin
+      cdiSetupChannels := 0;
+   end;
+   Procedure cdiSetPan(channel:longint;pan:longint);
+   begin
+   end;
+   Procedure mcpConvertSample(Sample:Pointer;Length:Longint);
+   begin
+   end;
+   Function  mcpSetSample(Channel:longint;s:PSampleInfo):Integer;
+   begin
+      mcpSetSample := 0;
+   end;
+   Function  mcpPlaySample(channel:longint;rate:Longint;volume:longint):Integer;
+   begin
+      mcpPlaySample := 0;
+   end;
+   Function  mcpPauseVoice:Integer;
+   begin
+      mcpPauseVoice := 0;
+   end;
+   Function  gusPauseAll:Integer;
+   begin
+      gusPauseAll := 0;
+   end;
+   Function  mcpResumeVoice:Integer;
+   begin
+      mcpResumeVoice := 0;
+   end;
+   Function  gusResumeAll:Integer;
+   begin
+      gusResumeAll := 0;
+   end;
+   Function  ampGetPattern:integer;
+   begin
+      ampGetPattern := 0;
+   end;
+   Function  ampGetRow:integer;
+   begin
+      ampGetRow := 0;
+   end;
+   Function  ampGetModuleStatus:integer;
+   begin
+      ampGetModuleStatus := MD_PLAYING;
+   end;
+   Procedure ampSetPanning(track,direction:longint);
+   begin
+   end;
+   Function GetCPUtype:Integer;
+   begin
+      GetCPUtype := 0;
+   end;
+   Function  emsInit(minmem,maxmem:integer):integer;
+   begin
+      emsInit := 0;
+   end;
+   Function detectGUS(scard:PSoundcard):integer;
+   begin
+      detectGUS := 0;
+   end;
+   Function detectAria(scard:PSoundcard):integer;
+   begin
+      detectAria := 0;
+   end;
+   Function detectSB16(scard:PSoundcard):integer;
+   begin
+      detectSB16 := 0;
+   end;
+   Function detectSBPro(scard:PSoundcard):integer;
+   begin
+      detectSBPro := 0;
+   end;
+   Function detectSB(scard:PSoundcard):integer;
+   begin
+      detectSB := 0;
+   end;
+   Function detectPAS(scard:PSoundcard):integer;
+   begin
+      detectPAS := 0;
+   end;
+end.
diff --git a/dmp/emhm.pas b/dmp/emhm.pas
index 19fca0c..e471791 100644
--- a/dmp/emhm.pas
+++ b/dmp/emhm.pas
@@ -1,357 +1,4 @@
-Unit emhm; { (C) 1993 Jussi Lahdenniemi,
-             original C version (C) 1993 Otto Chrons
-
-             EMS Heap Manager }
-
-{$IFDEF DPMI}
-'Only in real mode!'
-{$ENDIF}
-
-{$X+}
-
-Interface
-
-const EMS_ERROR    = -1;
-      EMS_MEMORY   = -2;
-      EMS_PAGE     = -3;
-      EMS_HANDLE   = -4;
-
-type  TEMSH        = integer;
-
-Function  emsInit(minmem,maxmem:integer):integer;
-Procedure emsClose;
-Function  emsAlloc(size:longint):TEMSH;
-Procedure emsFree(handle:TEMSH);
-Function  emsLock(handle:TEMSH;start:longint;length:word):pointer;
-Function  emsCopyTo(handle:TEMSH;ptr:Pointer;start,length:longint):integer;
-Function  emsCopyFrom(ptr:Pointer;handle:TEMSH;start,length:longint):integer;
-Function  emsCopy(handleTo,handleFrom:TEMSH;start1,start2,length:longint):integer;
-Procedure emsSaveState;
-Procedure emsRestoreState;
-Function  emsHeapfree:longint;
-Procedure emsShowHeap;
-
-Implementation
-uses CSupport;
-
-{ Internal structures }
-
-const EMSMOVE_CONV    = 0;
-      EMSMOVE_EMS     = 1;
-
-type  PHandle         = ^THandle;
-      THandle         = record
-        handle        : TEMSH;
-        start,size    : longint;
-        next,prev     : PHandle;
-      end;
-
-      PEmsMove        = ^TEmsMove;
-      TEmsMove        = record          { Structure for memory moves }
-        size          : longint;        { to/from EMS                }
-        srcType       : byte;
-        srcHandle     : word;
-        srcOffset     : word;
-        srcSegment    : word;
-        destType      : byte;
-        destHandle    : word;
-        destOffset    : word;
-        destSegment   : word;
-      end;
-
-{ External low-level functions }
-
-{$F+}
-Function  _emsInit:integer; external;
-Function  _emsAllocPages(pages:integer):integer; external;
-Function  _emsMapPages(lpage,ppage:integer):integer; external;
-Procedure _emsSaveState; external;
-Procedure _emsRestoreState; external;
-Function  _emsQueryFree:integer; external;
-Function  _emsGetFrame:word; external;
-Procedure _emsMoveMem(move:PEmsMove); external;
-Procedure _emsClose; external;
-{$L EMSHARD.OBJ}
-{$F-}
-
-{ Internal varliables }
-
-const emsMax          : longint = 0;
-      emsMem          : longint = 0;
-      first           : PHandle = nil;
-      last            : PHandle = nil;
-      locked          : PHandle = nil;
-      status          : integer = 0;
-      physicalPages   : array[0..3] of integer = (0,0,0,0);
-      nextHandle      : TEMSH   = 0;
-      EMMname         : array[0..8] of char = ('E','M','M','X','X','X','X','0',#0);
-
-var   lowHandle       : integer;
-      frame           : pointer;
-
-{ EMS heap manager internal functions }
-
-Function findHandle(which:TEMSH):PHandle;
-var handle : PHandle;
-begin
-  handle:=first;
-  if which=0 then begin findHandle:=nil; exit end;
-  while (handle^.next<>nil) do begin
-    if handle^.handle=which then begin findHandle:=handle; exit end;
-    handle:=handle^.next;
-  end;
-  findHandle:=nil;
-end;
-
-{ EMS heap manager interface functions }
-
-Function  emsInit(minmem,maxmem:integer):integer;
-var a:word;
-Label noems,emsfound;
-begin
-  if status<>0 then begin emsInit:=EMS_ERROR; exit end;
-  asm
-        mov     ax,3d00h
-        mov     dx,offset EMMname
-        int     21h
-        jc      noems
-        mov     bx,ax
-        mov     ax,4400h
-        int     21h
-        pushf
-        mov     ax,3e00h
-        int     21h
-        popf
-        jc      noems
-        and     dx,80h
-        jz      noems
-        jmp     emsfound
-  end;
-noems:
-  emsInit:=EMS_ERROR;
-  exit;
-emsfound:
-  if _emsInit<>0 then begin emsInit:=EMS_ERROR; exit end;
-  emsMEM:=longint(maxmem)*1024;
-  a:=longint(_emsQueryFree)*16;
-  if a<minmem then begin emsInit:=EMS_MEMORY; exit end;
-  if a>maxmem then begin
-    lowHandle:=_emsAllocPages((maxmem+15) div 16);
-    if lowHandle<0 then begin emsInit:=EMS_MEMORY; exit end;
-  end else begin
-    lowHandle:=_emsAllocPages(a div 16);
-    if lowHandle<0 then begin emsInit:=EMS_MEMORY; exit end;
-    emsMem:=longint(a)*1024;
-  end;
-  new(first);
-  new(last);
-  with first^ do begin
-    handle:=0;
-    start:=0;
-    size:=0;
-    next:=last;
-    prev:=nil;
-  end;
-  with last^ do begin
-    handle:=0;
-    start:=emsMem;
-    size:=0;
-    next:=nil;
-    prev:=first;
-  end;
-  status:=1;
-  frame:=ptr(_emsGetFrame,0);
-  atExit(@emsClose);
-  emsInit:=0;
-end;
-
-Procedure emsClose;
-var handle,h:PHandle;
-begin
-  handle:=first;
-  if status<>1 then exit;
-  _emsClose;
-  status:=0;
-  while (handle<>nil) do begin
-    h:=handle^.next;
-    dispose(handle);
-    handle:=h;
-  end;
-end;
-
-Function  emsAlloc(size:longint):TEMSH;
-var newHandle,handle,best : PHandle;
-    bestSize,a,b          : longint;
-    align                 : integer;
-begin
-  handle:=first;
-  best:=first;
-  bestSize:=33554432; { 32 MB }
-  align:=0;
-  if status<>1 then begin emsAlloc:=-1; exit end;
-  size:=(size+15) and (not longint(15));
-  if size>=48*1024 then align:=1;
-  while handle^.next<>nil do begin
-    if align<>0 then a:=handle^.next^.start-(((handle^.start+16383) and (not longint(16383)))+handle^.size)
-      else a:=handle^.next^.start-(handle^.start+handle^.size);
-    if (a>size) and (a<bestSize) then begin
-      bestSize:=a;
-      best:=handle;
-    end;
-    handle:=handle^.next;
-  end;
-  if bestSize=33554432 then begin emsAlloc:=EMS_MEMORY; exit end;
-  new(newHandle);
-  newHandle^.next:=best^.next;
-  best^.next:=newHandle;
-  newHandle^.prev:=best;
-  newHandle^.next^.prev:=newHandle;
-  newHandle^.start:=best^.start+best^.size;
-  if align<>0 then newHandle^.start:=(newHandle^.start+16383) and (not longint(16383));
-  newHandle^.size:=size;
-  inc(nextHandle);
-  newHandle^.handle:=nextHandle;
-  emsAlloc:=nextHandle;
-end;
-
-Procedure emsFree(handle:TEMSH);
-var h:PHandle;
-begin
-  if status<>1 then exit;
-  h:=findHandle(handle);
-  if h=nil then exit;
-  h^.prev^.next:=h^.next;
-  h^.next^.prev:=h^.prev;
-  dispose(h);
-end;
-
-Function  emsLock(handle:TEMSH;start:longint;length:word):pointer;
-var h              : PHandle;
-    mapped         : longint;
-    page,pPage     : integer;
-    ptr            : Pointer;
-    tmp            : longint;
-begin
-  mapped:=0;
-  pPage:=0;
-  if status<>1 then begin emsLock:=nil; exit end;
-  h:=findHandle(handle);
-  if h=nil then begin emsLock:=nil; exit end;
-  if start>h^.size then begin emsLock:=nil; exit end;
-  if length+start>h^.size then length:=h^.size-start;
-  page:=longint(h^.start+start) div 16384;
-  tmp:=h^.start+start-longint(page)*16384;
-  ptr:=pointer(longint(seg(frame^)+tmp div 16)*longint(65536)+(tmp and longint($F)));
-  mapped:=16384-h^.start+start+longint(page)*16384;
-  _emsMapPages(page,pPage);
-  physicalPages[pPage]:=page;
-  while (length>mapped) and (pPage<3) do begin
-    inc(page);
-    inc(pPage);
-    _emsMapPages(page,pPage);
-    physicalPages[pPage]:=page;
-    inc(mapped,16384);
-  end;
-  emsLock:=ptr;
-end;
-
-Function  emsCopyTo(handle:TEMSH;ptr:Pointer;start,length:longint):integer;
-var h       : PHandle;
-    move    : TEMSMove;
-begin
-  if status<>1 then begin emsCopyTo:=-1; exit end;
-  h:=findHandle(handle);
-  if h=nil then begin emsCopyTo:=-4; exit end;
-  with move do begin
-    size:=length;
-    srcType:=EMSMOVE_CONV;
-    srcHandle:=0;
-    srcOffset:=ofs(ptr^);
-    srcSegment:=seg(ptr^);
-    destType:=EMSMOVE_EMS;
-    destHandle:=lowHandle;
-    destOffset:=(h^.start+start) and 16383;
-    destSegment:=(h^.start+start) div 16384;
-  end;
-  _emsMoveMem(@move);
-  emsCopyTo:=0;
-end;
-
-Function  emsCopyFrom(ptr:Pointer;handle:TEMSH;start,length:longint):integer;
-var h       : PHandle;
-    move    : TEMSMove;
-begin
-  if status<>1 then begin emsCopyFrom:=-1; exit end;
-  h:=findHandle(handle);
-  if h=nil then begin emsCopyFrom:=-4; exit end;
-  with move do begin
-    size:=length;
-    destType:=EMSMOVE_CONV;
-    destHandle:=0;
-    destOffset:=ofs(ptr^);
-    destSegment:=seg(ptr^);
-    srcType:=EMSMOVE_EMS;
-    srcHandle:=lowHandle;
-    srcOffset:=(h^.start+start) and 16383;
-    srcSegment:=(h^.start+start) div 16384;
-  end;
-  _emsMoveMem(@move);
-  emsCopyFrom:=0;
-end;
-
-Function  emsCopy(handleTo,handleFrom:TEMSH;start1,start2,length:longint):integer;
-var h1,h2   : PHandle;
-    move    : TEMSMove;
-begin
-  if status<>1 then begin emsCopy:=-1; exit end;
-  h1:=findHandle(handleTo);
-  if h1=nil then begin emsCopy:=-4; exit end;
-  h2:=findHandle(handleFrom);
-  if h2=nil then begin emsCopy:=-4; exit end;
-  with move do begin
-    size:=length;
-    destType:=EMSMOVE_EMS;
-    destHandle:=lowHandle;
-    destOffset:=(h1^.start+start1) and 16383;
-    destSegment:=(h1^.start+start1) div 16384;
-    srcType:=EMSMOVE_EMS;
-    srcHandle:=lowHandle;
-    srcOffset:=(h2^.start+start2) and 16383;
-    srcSegment:=(h2^.start+start2) div 16384;
-  end;
-  _emsMoveMem(@move);
-  emsCopy:=0;
-end;
-
-Procedure emsSaveState;
-begin
-  if status<>1 then exit;
-  _emsSaveState;
-end;
-
-Procedure emsRestoreState;
-begin
-  if status<>1 then exit;
-  _emsRestoreState;
-end;
-
-Function  emsHeapfree:longint;
-begin
-  if status<>1 then begin emsHeapfree:=0; exit end;
-  emsHeapfree:=longint(_emsQueryFree)*16384;
-end;
-
-Procedure emsShowHeap; { Debugging function }
-var h:PHandle;
-begin
-  h:=first;
-  if status<>1 then exit;
-  writeln('EMS Heap:');
-  while h^.next<>nil do begin
-    with h^ do
-      writeln('Start: ',start,', size: ',size,', end: ',start+size);
-    h:=h^.next;
-  end;
-end;
-
-end.
+unit emhm;
+interface
+implementation
+end.
diff --git a/dmp/emshard.asm b/dmp/emshard.asm
deleted file mode 100644
index 741445c..0000000
--- a/dmp/emshard.asm
+++ /dev/null
@@ -1,266 +0,0 @@
-;/************************************************************************
-; *
-; *	File        : EMSHARD.ASM
-; *
-; *	Description : EMS low-level functions for EMSHM
-; *
-; *	Copyright (C) 1993 Otto Chrons
-; *
-; ***********************************************************************/
-
-	IDEAL
-	JUMPS
-	P286
-
-;	L_PASCAL	= 1		; Uncomment this for pascal-style
-
-IFDEF	L_PASCAL
-	LANG	EQU	PASCAL
-	MODEL TPASCAL
-ELSE
-	LANG	EQU	C
-	MODEL LARGE,C
-ENDIF
-
-MACRO	EMScall funct
-
-	mov	ah,funct
-	int	67h
-ENDM
-
-DATASEG
-
-	pageFrame	DW ?
-	status		DW ?
-	handle		DW ?
-	pageCount	DW ?
-
-CODESEG
-
-	PUBLIC	_emsInit, _emsAllocPages, _emsClose
-	PUBLIC	_emsMapPages, _emsSaveState, _emsRestoreState, _emsQueryFree
-	PUBLIC	_emsGetFrame, _emsMoveMem
-
-;/*************************************************************************
-; *
-; *	Function    :	int _emsInit(void);
-; *
-; *	Description :	Initializes EMS handler
-; *
-; *	Returns     :	0 if success
-; *			-1 no EMS handler
-; *			-2 other error
-; *
-; ************************************************************************/
-
-PROC	_emsInit FAR
-
-	EMScall	40h			; Get status
-	or	ah,ah
-	jnz	@@error			; error
-
-	EMScall	41h			; Get page frame address
-	or	ah,ah
-	jnz	@@error			; error
-	mov	[pageFrame],bx
-
-	EMScall	46h			; Version...
-	cmp	al,40h			; is it 4.0 or above?
-	jb	@@error
-
-	mov	[handle],-1		; No handle
-        mov	[pageCount],0
-	mov	[status],1		; Status OK.
-	sub	ax,ax			; No error
-	jmp	@@exit
-@@error:
-	mov	ax,-2
-@@exit:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	int _emsAllocPages(int pages);
-; *
-; *	Description :	Allocates EMS memory
-; *
-; *	Input       :	pages = how many 16K pages to allocate
-; *
-; *	Returns     :	0 if successful
-; *			-1 EMSHM not initialized
-; *			-2 not enough memory
-; *
-; ************************************************************************/
-
-PROC	_emsAllocPages FAR pages:WORD
-
-	mov	al,-1
-	cmp	[status],1		; Is EMSHM initialized
-	jne	@@exit
-
-	mov	bx,[pages]		; BX = pages
-	or	bx,bx
-	jz	@@exit
-
-	mov	[pageCount],bx
-
-	EMScall	43h			; Allocate...
-	mov	al,-1
-	or	ah,ah
-	jnz	@@exit			; not enough memory??
-
-	mov	[handle],dx		; Save handle
-	mov	ax,dx
-@@exit:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	int _emsMapPages(int logical, int physical);
-; *
-; *	Description :	Maps logical pages into the physical region
-; *
-; *	Input       :	logical and physical pages
-; *
-; *	Returns     :	0 if successful
-; *			-1 EMSHM not initialized
-; *			-3 illegal logical page
-; *
-; ************************************************************************/
-
-PROC	_emsMapPages FAR lpage:WORD,ppage:WORD
-
-	mov	al,-1
-	cmp	[status],1		; Is EMSHM initialized
-	jne	@@exit
-
-	mov	bx,[lpage]
-	cmp	bx,[pageCount]		; Is logical page within range?
-	mov	ax,-3
-	jae	@@exit
-
-	mov	ax,[ppage]		; AL = Physical page
-	and	ax,3
-	mov	dx,[handle]
-	EMScall	44h			; Map memory
-
-	sub	ax,ax
-@@exit:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	void _emsSaveState(void);
-; *
-; *	Description :	Saves EMM's state (in interrupt or so..)
-; *
-; ************************************************************************/
-
-PROC	_emsSaveState FAR
-
-	mov	dx,[handle]
-	EMScall	47h
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	void _emsRestoresState(void);
-; *
-; *	Description :	Restores EMM's state (in interrupt or so..)
-; *
-; ************************************************************************/
-
-PROC	_emsRestoreState FAR
-
-	mov	dx,[handle]
-	EMScall	48h
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	int _emsQueryFree(void);
-; *
-; *	Description :	Returns how many pages are available
-; *
-; *	Returns     :	Pages available
-; *
-; ************************************************************************/
-
-PROC	_emsQueryFree FAR
-
-	EMScall	42h			; Get unallocated pages
-	or	ah,ah
-	jnz	@@error
-@@exit:
-	mov	ax,bx			; AX = free pages
-	ret
-@@error:
-	mov	ax,-1			; Error
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	void _emsClose(void);
-; *
-; *	Description :	Closes EMSHM and releases all EMS memory allocated
-; *
-; ************************************************************************/
-
-PROC	_emsClose FAR
-
-	mov	dx,[handle]
-	EMScall	45h			; Deallocate all pages
-
-	mov	[status],0		; EMSHM closed
-	mov	[handle],-1
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	unsigned _emsGetFrame(void);
-; *
-; *	Description :	Returns EMS page frame address
-; *
-; *	Returns     :	Frame segment (i.e. C000h)
-; *
-; ************************************************************************/
-
-PROC	_emsGetFrame FAR
-
-	mov	ax,[pageFrame]
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	void _emsMoveMem(EMSMOVE *mm);
-; *
-; *	Description :	Moves memory between EMS and EMS or EMS and
-; *			conventional memory.
-; *
-; *	Input       :	Pointer to EMSMOVE structure
-; *
-; ************************************************************************/
-
-PROC	_emsMoveMem FAR USES ds si,mm:DWORD
-
-	lds	si,[mm]
-	mov	al,0
-	EMScall	57h
-
-	ret
-ENDP
-
-
-END
diff --git a/dmp/example.amf b/dmp/example.amf
deleted file mode 100644
index 151acf7..0000000
Binary files a/dmp/example.amf and /dev/null differ
diff --git a/dmp/example1.pas b/dmp/example1.pas
deleted file mode 100644
index f1d54ae..0000000
--- a/dmp/example1.pas
+++ /dev/null
@@ -1,46 +0,0 @@
-(****************************************************************************
-
-                                 EXAMPLE1.PAS
-                                 ------------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-Example program #1 for DSMI tutorial
-
-****************************************************************************)
-
-{$I dsmi.inc} ,crt;           { For the readkey }
-
-var sample : TSampleInfo;
-    sc     : TSoundCard;
-    p      : pointer;
-    w      : word;
-
-begin
-  if initDSMI(22000,2048,0,@sc)<>0 then exit;  { Error }
-  if sc.ID<>ID_GUS then mcpStartVoice else gusStartVoice;
-  cdiSetupChannels(0,2,nil);
-  p:=malloc(5500);
-  with sample do begin
-    sample:=ptr(0,1);         { Pointer to sampledata }
-    move(sample^,p^,5500);
-
-{    sample:=malloc(5500);
-    p:=sample;
-    fillchar(sample^,5500,0);}
-
-    length:=5500;             { Length of sample }
-    loopstart:=0;
-    loopend:=5500;               { looping }
-    mode:=0;
-    sampleID:=0;
-  end;
-  cdiDownloadSample(0,sample.sample,sample.sample,sample.length);
-  cdiSetInstrument(0,@sample);
-  cdiPlayNote(0,8800,32);    { Play at 8800Hz with }
-                               { half volume }
-  readkey;                     { Wait for keypress }
-  cdiStopNote(0);           { Stop voice }
-  for w:=0 to 5499 do if mem[seg(p^):ofs(p^)+w]<>mem[0:1+w] then writeln(w);
-end.
-
diff --git a/dmp/example2.pas b/dmp/example2.pas
deleted file mode 100644
index 95ad572..0000000
--- a/dmp/example2.pas
+++ /dev/null
@@ -1,77 +0,0 @@
-(****************************************************************************
-                                 EXAMPLE2.PAS
-                                 ------------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-Tutorial example program #2 for DSMI
-
-****************************************************************************)
-
-{$I dsmi.inc} ,crt;
-
-var si     : TSampleInfo;
-    f      : file;
-    sc     : TSoundCard;
-    module : pmodule;
-    j: integer;
-
-begin
-  if initDSMI(44100,4096,0,@sc)<>0 then halt(1);   { Error }
-  module:=amploadmodule('\projects\spell\sound\klf_arca.s3m',LM_IML);
-  cdiSetupChannels(0,module^.channelcount+3,nil);
-
-  if sc.ID<>ID_GUS then mcpStartVoice else gusStartVoice;
-  ampplaymodule(module,PM_LOOP);
-
-  assign(f,'sound\i1a.sam');
-  reset(f,1);
-  writeln(#10#10);
-  writeln('1 ',memavail);
-  si.sample:=malloc(fileSize(f));
-  writeln('2 ',memavail);
-  if si.sample=nil then halt(1);
-  blockread(f,si.sample^,filesize(f));
-  with si do begin
-    length:=filesize(f);
-    loopstart:=0;
-    loopend:=0;   { No looping }
-    mode:=0;
-    sampleID:=0;
-  end;
-  mcpconvertsample(si.sample,si.length);
-  cdiDownloadSample(module^.channelcount+1,si.sample,si.sample,si.length);
-  cdiSetInstrument(module^.channelcount+1,@si);
-  cdiPlayNote(module^.channelcount+1,8000,64);   { Play at 8800 Hz }
-  readkey;
-  cdistopNote(module^.channelcount+1);
-
-  writeln('5 ',memavail);
-  cdidownloadsample(module^.channelcount+1,si.sample,si.sample,si.length);
-  free(si.sample);
-
-{  assign(f,'sfx\gun2.sam');
-  reset(f,1);
-  writeln('1 ',memavail);
-  sample.sample:=malloc(fileSize(f));
-  writeln('2 ',memavail);
-  if sample.sample=nil then halt(1);
-  blockread(f,sample.sample^,filesize(f));
-  with sample do begin
-    length:=filesize(f);
-    loopstart:=0;
-    loopend:=0;
-    mode:=0;
-    sampleID:=0;
-  end;
-  mcpconvertsample(sample.sample,sample.length);
-  writeln('3 ',memavail);
-  cdiDownloadSample(0,sample.sample,sample.sample,sample.length);
-  writeln('4 ',memavail);
-  cdiSetInstrument(0,@sample);
-  cdiPlayNote(0,8800,64);
-  readkey;
-  cdistopNote(0); }
-
-  writeln('6 ',memavail);
-end.
diff --git a/dmp/example3.pas b/dmp/example3.pas
deleted file mode 100644
index 5adc966..0000000
--- a/dmp/example3.pas
+++ /dev/null
@@ -1,52 +0,0 @@
-(****************************************************************************
-
-                                 EXAMPLE3.PAS
-                                 ------------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-Example program #3 for DSMI tutorial
-
-****************************************************************************)
-
-{$I dsmi.inc}, crt;
-
-var module : PModule;
-    sc     : TSoundCard;
-    j,i: integer;
-    track: ptrackdata;
-    ctrack: ttrackdata;
-
-procedure drawtracks;
-begin
-{ for j:=1 to module^.channelcount do
-  begin}
-   track:=ampgettrackdata(1);
-   move(track^,ctrack,sizeof(ttrackdata));
-   for i:=1 to ctrack.volume do write('*');
-   if ctrack.volume<64 then
-    for i:=ctrack.volume+1 to 64 do write(' ');
-   write(#13);
-   delay(15);
-{  end; }
-end;
-
-begin
-{  clrscr; }
-
-{  emsinit(400,800); }
-
-  if initDSMI(44100,2048,MCP_QUALITY,@sc)<>0 then exit;  { Error }
-  module:=ampLoadMod('c:\ironseed\sound\psychic.mod',LM_IML);
-  if sc.id<>ID_GUS then mcpStartVoice else gusStartVoice;
-  cdiSetupChannels(0,module^.channelCount,nil);
-  ampPlayModule(module,PM_Loop);   { Play looping }
-  readkey;
-{  repeat
-   drawtracks;
-  until keypressed; }
-  ampStopModule;
-  ampfreeModule(module);
-
-end.
-
diff --git a/dmp/example4.pas b/dmp/example4.pas
deleted file mode 100644
index 7114463..0000000
--- a/dmp/example4.pas
+++ /dev/null
@@ -1,49 +0,0 @@
-(****************************************************************************
-
-                                 EXAMPLE4.PAS
-                                 ------------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-Example program #4 for DSMI tutorial
-
-****************************************************************************)
-
-{$I dsmi.inc} ,crt;
-
-var module : PModule;
-    f      : file;
-    sample : TSampleinfo;
-    sc     : TSoundCard;
-
-begin
-  if initDSMI(44100,2048,0,@sc)<>0 then halt(1);   { Error }
-  if sc.ID<>ID_GUS then mcpStartVoice else gusStartVoice;
-  cdiSetupChannels(0,8,nil);
-  module:=ampLoadmodule('\utility\music\sourcep\EXAMPLE.AMF',0);
-  ampplaymodule(module,PM_LOOP);
-  assign(f,'sound\i1a.sam');
-  reset(f,1);
-  sample.sample:=malloc(fileSize(f));
-  if sample.sample=nil then halt(1);
-  blockread(f,sample.sample^,filesize(f));
-  with sample do
-   begin
-    length:=filesize(f);
-    loopstart:=500;
-    loopend:=9400;
-    mode:=0;
-    sampleID:=0;
-   end;
-
-
-  mcpconvertsample(sample.sample,sample.length);
-  cdiDownloadSample(31,sample.sample,sample.sample,sample.length);
-  ampPlayModule(module,PM_LOOP);
-  cdiSetInstrument(6,@sample);
-  cdiSetInstrument(7,@sample);
-  cdiPlayNote(6,8368,64);
-  cdiPlayNote(7,8368,64);
-  readkey;
-  ampStopModule;
-end.
diff --git a/dmp/getcpu.pas b/dmp/getcpu.pas
index 8c43a24..2e1ed43 100644
--- a/dmp/getcpu.pas
+++ b/dmp/getcpu.pas
@@ -1,17 +1,5 @@
-Unit GetCPU;
-{$O+}
-
-Interface
-
-Function GetCPUtype:Integer;
-Function inV86:Boolean;
-
-Implementation
-
-Function GetCPUtype; External;
-Function inV86:Boolean; External;
-
-{$L GETCPU.OBJ}
-{$L CHECKV86.OBJ}
-
-end.
+unit getcpu;
+{$O+}
+interface
+implementation
+end.
diff --git a/dmp/getcpu.tpp b/dmp/getcpu.tpp
deleted file mode 100644
index 980e412..0000000
Binary files a/dmp/getcpu.tpp and /dev/null differ
diff --git a/dmp/gus.asm b/dmp/gus.asm
deleted file mode 100644
index e74e4ee..0000000
--- a/dmp/gus.asm
+++ /dev/null
@@ -1,2795 +0,0 @@
-;/************************************************************************
-; *
-; *     File        :   GUS.ASM
-; *
-; *     Description :   Interface for Gravis Ultrasound
-; *
-; *     Copyright (C) 1993 Otto Chrons
-; *
-; ***********************************************************************
-;
-;       Revision history of GUS.ASM
-;
-;       1.0     31.7.93
-;               Well, maybe it works
-;       2.0     11.11.93
-;               Now it seems to be working pretty well... Some probs with
-;               IRQs from wavetable and volume ramps.. odd..
-;
-; ***********************************************************************/
-
-        IDEAL
-        JUMPS
-        P386
-
-        INCLUDE "MODEL.INC"
-        INCLUDE "MCP.INC"
-        INCLUDE "GUS.INC"
-        INCLUDE "CDI.INC"
-
-STRUC   GUSEVENT
-    time        DD ?
-IFDEF __32__
-    func        DD ?
-ELSE
-    func        DW ?                    ; Pointer to function
-ENDIF
-    p1          DD ?                    ; Parameters
-    p2          DD ?
-    p3          DD ?
-ENDS
-
-STRUC   SAMPLELINK
-    origSample  DD ?
-    gusSample   DD ?
-ENDS
-
-	TIMER2  = 12
-
-IFDEF __PASCAL__
-	EXTRN   gushmAlloc:_FAR, gushmFreeAll:_FAR, gushmFree:_FAR
-ELSE
-	EXTRN   _gushmAlloc:_FAR, _gushmFreeAll:_FAR, _gushmFree:_FAR
-ENDIF
-
-STRUC   DMAPORT
-
-	addr    DW ?
-	count   DW ?
-	page    DW ?
-	wcntrl  DW ?
-	wreq    DW ?
-	wrsmr   DW ?
-	wrmode  DW ?
-	clear   DW ?
-	wrclr   DW ?
-	clrmask DW ?
-	wrall   DW ?
-ENDS
-
-MACRO   checkPause
-
-	movzx   ebx,[WORD @@channel]
-	cmp     [_bx+chPaused],1
-	je      @@exit
-ENDM
-
-MACRO   selectChannel x
-
-        mov     al,x
-        mov     dx,[gusChannelAddr]
-        out     dx,al
-ENDM
-
-MACRO	memSet 	memOfs,memSize
-	mov	_di,offset memOfs
-IF (memSize AND 3) EQ 0
-	mov	_cx,memSize/4
-	rep	stosd
-ELSEIF (memSize AND 1) EQ 0
-	mov	_cx,memSize/2
-	rep	stosw
-ELSE
-	mov	_cx,memSize
-	rep	stosb
-ENDIF
-
-ENDM
-
-CSEGMENTS GUS
-
-CDATASEG
-
-	MAXEVENT        = 200
-	MAXSAMPLE       = 128
-	TIME_DELTA      = 30000                 ; 30msec
-
-	eventQueue              GUSEVENT MAXEVENT+8 dup(<>)
-	sampleList              SAMPLELINK MAXSAMPLE dup(<>)
-	sampleListLength        DW ?
-	firstEvent              DW ?
-	lastEvent               DW ?
-	staticEvent             GUSEVENT <>
-	curTime                 DD ?
-	pseudoTime              DD ?
-	deltaTime               DD ?
-	gusVoices               DB ?
-	gusBaseAddr             DW ?
-	gusCmdAddr              DW ?
-	gusChannelAddr          DW ?
-	gusIRQ                  DB ?
-	gusDMA                  DB ?
-	oldIRQ                  DD ?
-	chBase                  DD 32 dup(?)
-	chFreq                  DD 32 dup(?)
-	chVolume                DW 32 dup(?)
-	chPaused                DB 32 dup(?)
-	oldSS                   DW ?
-	oldSP                   DW ?
-	gusBUSY                 DW ?
-	masterVol               DW ?
-	curDMA                  DMAPORT <>
-	dmaActive               DB ?
-	irqStatus               DB ?
-	testIRQ                 DB ?
-
-IFDEF __PASCAL__
-	extrn                   gusDeltaTime:DWORD
-ELSE
-	CPUBLIC		gusDeltaTime
-
-	_gusDeltaTime		DD ?
-	gusDeltaTime EQU _gusDeltaTime
-ENDIF
-
-IFDEF __PASCAL__
-
-	EXTRN CDI_GUS:CDIDEVICE
-
-ELSE
-	CPUBLIC CDI_GUS
-
-	_CDI_GUS        CDIDEVICE <\
-	_far ptr _gusSetSample,\
-	_far ptr _gusPlaySample,\
-	_far ptr _gusSetVolume,\
-	_far ptr _gusSetRate,\
-	0,\
-        _far ptr _gusSetPosition,\
-	_far ptr _gusSetPanning,\
-	_far ptr _gusSetMasterVolume,\
-        _far ptr _gusPauseChannel,\
-        _far ptr _gusResumeChannel,\
-        _far ptr _gusStopChannel,\
-        _far ptr _gusPauseAll,\
-        _far ptr _gusResumeAll,\
-        _far ptr _gusPoll,\
-        _far ptr _gusGetDelta,\
-        _far ptr _gusDownload,\
-        _far ptr _gusUnloadAll,\
-        _far ptr _gusGetVolume,\
-        _far ptr _gusGetRate,\
-        _far ptr _gusGetPosition,\
-        _far ptr _gusGetPanning,\
-        _far ptr _gusGetSample,\
-        _far ptr _gusSetupChannels,\
-        _far ptr _gusGetChannelStatus>
-ENDIF
-
-ENDS
-
-CCODESEG GUS
-
-	CPUBLIC gusInit, gusClose, gusStartVoice, gusStopVoice
-        CPUBLIC gusSetSample, gusPlaySample, gusStopChannel, gusSetVolume, gusSetRate
-        CPUBLIC gusSetPosition, gusSetPanning, gusSetMasterVolume, gusGetSamplingRate
-        CPUBLIC gusPauseChannel, gusResumeChannel, gusPauseAll, gusResumeAll
-        CPUBLIC gusPoll, gusGetDelta, gusDownload, gusUnload, gusUnloadAll
-	CPUBLIC gusGetVolume, gusGetRate, gusGetPosition, gusGetPanning
-        CPUBLIC gusGetSample, gusSetupChannels
-
-        CPUBLIC gusPoke, gusPeek
-
-        LABEL DMAports  DMAPORT
-
-            DMAPORT <0,1,87h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-            DMAPORT <2,3,83h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-            DMAPORT <4,5,81h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-            DMAPORT <6,7,82h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-            DMAPORT <0,0,0,0,0,0,0,0,0,0,0>
-            DMAPORT <0C4h,0C6h,8Bh,0D0h,0D2h,0D4h,0D6h,0D8h,0DAh,0DCH,0DEh>
-            DMAPORT <0C8h,0CAh,89h,0D0h,0D2h,0D4h,0D6h,0D8h,0DAh,0DCH,0DEh>
-            DMAPORT <0CCh,0CEh,8Ah,0D0h,0D2h,0D4h,0D6h,0D8h,0DAh,0DCH,0DEh>
-
-IFDEF __C32__
-	cpublic  debugit
-
-CPROC   debugit
-
-        mov     ebx,0B8000h
-        mov     ah,07
-        mov     [ebx],ax
-        ret
-ENDP
-
-ENDIF
-
-PROC    nullFunc NEAR
-        ret
-ENDP
-
-PROC    gusDelay NEAR
-        push    ax dx
-	mov     dx,300h
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-        pop     dx ax
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    : initEventQueue();
-; *
-; *     Description : Initializes event queue
-; *
-; ************************************************************************/
-
-PROC    initEventQueue NEAR
-
-	push    _di
-	PUSHDS
-	POPES
-	mov     _di,offset eventQueue
-	cld
-	mov     _cx,(SIZE GUSEVENT)*(MAXEVENT+8)
-	mov     al,0FFh
-	rep     stosb                   ; Clear events
-	mov     [firstEvent],0
-	mov     [lastEvent],0
-	mov     [curTime],0
-	mov     [pseudoTime],0
-	mov     [deltaTime],320*TIMER2  ; 2560usec
-	pop     _di
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    : insertEvent();
-; *
-; *     Description : Inserts an event to GUS' event queue (static structure)
-; *
-; ************************************************************************/
-
-PROC    insertEvent NEAR
-
-	push    _di _si
-
-        saveIRQ
-
-        movzx   edi,[lastEvent]
-        inc     [lastEvent]
-        cmp     [lastEvent],MAXEVENT
-	jb      @@ok
-        mov     [lastEvent],0
-@@ok:
-	mov	eax,[gusDeltaTime]
-	add     [staticEvent.time],eax
-        imul    _di,SIZE GUSEVENT
-	add     _di,offset eventQueue
-        mov     _si,offset staticEvent  ; DS:SI points to the event to be inserted
-        PUSHDS
-        POPES                           ; ES:DI points to event queue
-        mov     _cx,SIZE GUSEVENT
-        cld
-        rep     movsb
-
-        restoreIRQ
-
-        pop     _si _di
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    : getEvent();
-; *
-; *     Description : Gets an event from GUS' event queue
-; *
-; ************************************************************************/
-
-PROC    getEvent NEAR
-
-        push    _di _si
-	mov     _ax,-1                  ; -1 = no event
-	movzx   esi,[firstEvent]
-	cmp     si,[lastEvent]
-	je      @@exit
-@@ok:
-	imul    _si,SIZE GUSEVENT
-	add     _si,offset eventQueue
-	mov     _di,offset staticEvent  ; ES:(E)DI points to the event to be fetched
-	PUSHDS
-	POPES                           ; DS:(E)SI points to event queue
-	mov     _cx,SIZE GUSEVENT
-	cld
-	rep     movsb
-	sub     _ax,_ax                 ; Event is loaded into the static buffer
-@@exit:
-	pop     _si _di
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    : processEvent();
-; *
-; *     Description : Processes current event in queue
-; *
-; ************************************************************************/
-
-PROC    processEvent NEAR
-
-	mov     _ax,-1                  ; -1 = not processed
-	mov     edx,[curTime]
-	cmp     [staticEvent.time],edx  ; Is it time?
-	ja      @@exit
-	mov     eax,[staticEvent.p1]    ; Pass parametres
-	mov     ebx,[staticEvent.p2]
-	mov     ecx,[staticEvent.p3]
-	cmp	[staticEvent.func],0	; Is pointer NULL?
-	je	@@nocall
-	call    [staticEvent.func]      ; Call function
-@@nocall:
-        inc     [firstEvent]            ; Purge event
-        cmp     [firstEvent],MAXEVENT
-        jl      @@ok
-        mov     [firstEvent],0
-@@ok:
-        sub     _ax,_ax                 ; 0 = processed
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   interruptHandler
-; *
-; *     Description :   Handles GUS' interrupts
-; *
-; ************************************************************************/
-
-PROC    interruptHandler NEAR
-
-        mov     eax,[deltaTime]
-        add     [curTime],eax
-
-@@again:
-        mov     dx,[gusBaseAddr]
-        add     dx,6
-        in      al,dx                   ; IRQ status
-        mov     [irqStatus],al
-        sti
-
-        cmp     al,0
-        je      @@busy
-
-        test    [irqStatus],10000000b   ; DMA IRQ?
-        jz      @@notDMAIRQ
-
-	mov     dx,[gusCmdAddr]
-        mov     al,41h
-        out     dx,al
-        add     dx,2
-        in      al,dx
-;       test    al,01000000b
-;       jz      @@notDMAIRQ
-        mov     [dmaActive],0
-
-@@notDMAIRQ:
-        test    [irqStatus],00001000b   ; Timer 2
-        jz      @@busy
-
-        mov     dx,[gusCmdAddr]
-        mov     al,45h
-        out     dx,al
-        add     dx,2
-        sub     al,al
-        out     dx,al
-	sub     dx,2
-        DELAY
-        mov     al,45h
-        out     dx,al
-        add     dx,2
-        mov     al,8
-        out     dx,al
-
-        cmp     [gusBUSY],0
-        jne     @@busy
-
-        mov     [gusBUSY],1
-        PUSHDS
-        POPES
-@@loop:
-        call    getEvent
-        or      ax,ax
-        jnz     @@exit
-        call    processEvent
-        or      ax,ax
-        jz      @@loop
-@@exit:
-	mov     [gusBUSY],0
-@@busy:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    : interruptGUS();
-; *
-; *     Description : Interrupt service routine for handling events
-; *
-; ************************************************************************/
-
-PROC    interruptGUS
-
-        pushad
-        push    es ds
-
-        mov     ax,DGROUP
-        mov     ds,ax
-        mov     es,ax
-
-        mov     al,20h
-        out     20h,al
-        out     0A0h,al
-
-IFDEF __C32__
-	mov     al,[testIRQ]
-        inc     [testIRQ]
-        ecall   debugit
-ENDIF
-        call    near interruptHandler
-
-        pop     ds es
-        popad
-        nop
-IFDEF __C32__
-        iretd
-ELSE
-        iret
-ENDIF
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   long(eax) findSample(void *ptr);
-; *
-; *     Description :   Returns the offset of the sample in GUS' memory
-; *
-; *     Returns     :   EAX = offset
-; *                     BX = offset to sample list
-; *
-; ************************************************************************/
-
-CPROC   findSample @@pptr
-
-        ENTERPROC
-
-        sub     eax,eax
-        movzx   ecx,[sampleListLength]
-        jcxz    @@exit
-        sub     _bx,_bx
-@@loop:
-        mov     edx,[_bx+sampleList.origSample]
-        cmp     edx,[@@pptr]
-        je      @@found
-        add     _bx,SIZE SAMPLELINK
-	loop    @@loop
-	sub	_bx,_bx
-@@found:
-        mov     eax,[_bx+sampleList.gusSample]
-@@exit:
-        LEAVEPROC
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void insertSample(void *ptr, long offset);
-; *
-; *     Description :   Inserts a sample to sample list
-; *
-; ************************************************************************/
-
-CPROC   insertSample @@pptr,@@gusoffset
-
-        ENTERPROC
-        mov     _cx,MAXSAMPLE
-        sub     _bx,_bx
-@@loop:
-        cmp     [_bx+sampleList.origSample],0
-	je      @@found
-        add     _bx,SIZE SAMPLELINK
-        loop    @@loop
-        jmp     @@exit
-@@found:
-        mov     eax,[@@pptr]
-        mov     [_bx+sampleList.origSample],eax
-        mov     eax,[@@gusoffset]
-        mov     [_bx+sampleList.gusSample],eax
-        shr     _bx,3
-        inc     _bx
-        cmp     bx,[sampleListLength]
-        jle     @@exit
-        mov     [sampleListLength],bx
-@@exit:
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short gusStartVoice(void);
-; *
-; *     Description :   Starts output
-; *
-; ************************************************************************/
-
-CPROC   gusStartVoice
-
-        mov     al,[gusIRQ]
-        test    al,8                    ; Is IRQ > 7
-        jz      @@01
-        add     al,60h                  ; Yes, base is 70h
-@@01:
-        add     al,8                    ; AL = DMA interrupt number
-        push    es
-        push    ax
-        mov     ah,35h                  ; Get interrupt vector
-        int     21h
-        mov     [WORD LOW oldIRQ],bx    ; Save it
-        mov     [WORD HIGH oldIRQ],es
-        pop     ax                      ; Replace vector with the address
-        pop     es
-        mov     ah,25h                  ; of own interrupt routine
-        push    ds
-	push    cs
-        pop     ds
-        mov     _dx,offset interruptGUS ; Set interrupt vector
-        int     21h
-	pop     ds
-
-        mov     cl,[gusIRQ]
-        mov     ah,1
-        test    cl,8                    ; Is IRQ > 7
-        jnz     @@15
-        shl     ah,cl
-        not     ah
-        in      al,21h
-        and     al,ah
-        out     21h,al                  ; Allow DMA interrupt
-        jmp     @@20
-@@15:
-        and     cl,7
-        shl     ah,cl
-        not     ah
-        in      al,0A1h
-        and     al,ah
-        out     0A1h,al                 ; Allow DMA interrupt
-@@20:
-        saveIRQ
-
-        mov     dx,[gusCmdAddr]
-	mov     al,47h
-        out     dx,al
-        add     dx,2
-        mov     al,256-TIMER2           ; = 320*TIMER2
-        out     dx,al
-
-        sub     dx,2
-        mov     al,45h
-        out     dx,al
-        add     dx,2
-        mov     al,8                    ; Enable timer 2
-        out     dx,al
-
-        mov     dx,[gusBaseAddr]        ; Start timer
-        add     dx,8
-        mov     al,4
-        out     dx,al
-        inc     dx
-	mov     al,2h
-        out     dx,al
-
-        restoreIRQ
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short gusStopVoice(void);
-; *
-; *     Description :   Stops output
-; *
-; ************************************************************************/
-
-CPROC   gusStopVoice
-
-        mov     dx,[gusCmdAddr]
-        mov     al,47h
-        out     dx,al
-        add     dx,2
-        mov     al,256-TIMER2           ; = 320*TIMER2
-        out     dx,al
-
-        sub     dx,2
-        mov     al,45h
-	out     dx,al
-        add     dx,2
-        mov     al,0                    ; Disable timer 2
-        out     dx,al
-
-        mov     dx,[gusBaseAddr]        ; Stop timer
-        add     dx,8
-        mov     al,4
-        out     dx,al
-        inc     dx
-        mov     al,0C0h
-        out     dx,al
-
-        mov     cl,[gusIRQ]             ; Disable interrupt
-        mov     ah,1
-        test    cl,8
-        jnz     @@10
-        shl     ah,cl
-	in      al,21h
-        or      al,ah
-        out     21h,al
-        jmp     @@20
-@@10:
-        and     cl,7
-        shl     ah,cl
-        in      al,0A1h
-        or      al,ah
-        out     0A1h,al
-@@20:
-        PUSH    ds
-        mov     al,[gusIRQ]
-        test    al,8                    ; Is IRQ > 7
-        jz      @@01
-        add     al,60h                  ; Yes, base is 70h
-@@01:
-        add     al,8
-IF32    <sub     edx,edx>
-        mov     dx,[WORD LOW oldIRQ]
-        mov     ds,[WORD HIGH oldIRQ]
-        mov     ah,25h
-        int     21h                     ; Restore IRQ vector
-        POP     ds
-
-        mov     _cx,16
-        sub     eax,eax
-@@closeLoop:
-        push    eax _cx
-        ecall   gusStopChannel eax
-        pop     _cx eax
-        inc     eax
-        loop    @@closeloop
-
-        mov     dx,[gusCmdAddr]         ; Close outputs/inputs
-        mov     al,00001011b
-        out     dx,al
-
-        mov     ax,14
-        mov     bx,[gusBaseAddr]
-        call    NEAR _gusReset
-
-        ret
-ENDP
-
-u_IRQLatch      db      0,0,1,3,0,2,0,4,0,0,0,5,6,0,0,7
-u_DMALatch      db      0,1,0,2,0,3,4,5
-
-;/*************************************************************************
-; *
-; *     Function    :   short gusInit(CARDINFO *scard);
-; *
-; *     Description :   Inits GUS
-; *
-; ************************************************************************/
-
-CPROC   gusInit @@scard
-
-        ENTERPROC esi edi
-IFDEF __C32__
-        mov     al,''
-        ecall   debugit
-ENDIF
-        LESSI   [@@scard]
-        mov     al,[ESSI+CARDINFO.DMAIRQ]
-        mov     [gusIRQ],al
-        mov     al,[ESSI+CARDINFO.DMAchannel]
-        mov     [gusDMA],al
-
-        cli
-        sub     _bx,_bx
-        mov     bl,[ESSI+1+CARDINFO.extraField]
-	mov     cl,[_bx+u_IRQLatch]
-        shl     cl,3
-	mov     bl,[ESSI+CARDINFO.DMAIRQ]
-        or      cl,[_bx+u_IRQLatch]
-        cmp     bl,[ESSI+1+CARDINFO.extraField]
-        jne     @@JustStore
-        or      cl,40h
-@@JustStore:
-        push    cx
-        mov     bl,[ESSI+CARDINFO.DMAchannel]
-        mov     cl,[_bx+u_DMALatch]
-        shl     cl,3
-        mov     bl,[ESSI+CARDINFO.extraField]
-        or      cl,[_bx+u_DMALatch]
-        cmp     bl,[ESSI+CARDINFO.DMAchannel]
-        jne     @@JustStore2
-        or      cl,40h
-@@JustStore2:
-	mov     bl,cl
-        pop     cx
-
-        ; Set up for Digital ASIC
-	mov     dx,[ESSI+CARDINFO.ioPort]
-        add     dl,0fh
-        mov     al,5
-        out     dx,al
-	mov     dx,[ESSI+CARDINFO.ioPort]
-        xor     al,al
-        out     dx,al
-        add     dl,0Bh
-        out     dx,al
-        add     dl,4
-        out     dx,al
-        sub     dl,0Fh
-
-        ; First do DMA control register
-        xor     al,al
-        out     dx,al
-        add     dl,0Bh
-        mov     al,bl
-        or      al,80h
-        out     dx,al
-        sub     dl,0Bh
-
-        ; IRQ CONTROL REG
-	mov     al,40h
-        out     dx,al
-	add     dl,0Bh
-        mov     al,cl
-        out     dx,al
-        sub     dl,0Bh
-
-        ; First do DMA control register
-        xor     al,al
-        out     dx,al
-        add     dl,0Bh
-        mov     al,bl
-        out     dx,al
-        sub     dl,0Bh
-
-        ; IRQ CONTROL REG
-        mov     al,40h
-        out     dx,al
-	add     dl,0Bh
-        mov     al,cl
-        out     dx,al
-        sub     dl,0Bh
-
-        ; IRQ CONTROL, ENABLE IRQ
-        ; just to Lock out writes to irq\dma register ...
-        selectChannel   0
-
-        ; enable output & irq, disable line & mic input
-        mov     dx,[ESSI+CARDINFO.ioPort]
-        mov     al,9
-        out     dx,al
-
-        ; IRQ CONTROL, ENABLE IRQ
-        ; just to Lock out writes to irq\dma register ...
-        selectChannel   0
-        sti
-@@Exit:
-        cld
-        PUSHES
-        push    _si
-        movzx   _bx,[ESSI+CARDINFO.DMAchannel]
-        imul    _bx,_bx,SIZE DMAPORT
-        lea     _si,[_bx+DMAports]      ; SI = DMAports[DMAchannel]
-        PUSHDS
-        POPES
-	mov     _di,offset curDMA       ; ESDI = curDMA
-        mov     _cx,SIZE DMAPORT
-	cli
-        _segcs
-        rep     movsb                   ; Copy structure
-        sti
-        pop     _si
-        POPES
-
-        mov     dx,[ESSI+CARDINFO.ioPort]         ; Close outputs/inputs
-        mov     al,00001011b
-        out     dx,al
-
-        mov     ax,16
-        mov     bx,[ESSI+CARDINFO.ioPort]
-        call    _gusReset
-
-        mov     dx,[gusCmdAddr]         ; Open output
-	mov     al,00001001b
-        out     dx,al
-
-        call    initEventQueue
-	mov     ax,[gusBaseAddr]
-        sub     ebx,ebx
-        mov     cl,0
-        call    __gusPoke
-	mov     ax,[gusBaseAddr]
-	mov     ebx,1
-	mov     cl,0
-	call    __gusPoke
-
-	mov     [sampleListLength],0
-	mov     [masterVol],200
-	mov     [dmaActive],0
-	mov     [gusBUSY],0
-	mov     [irqStatus],0
-	mov	[gusDeltaTime],TIME_DELTA
-
-	PUSHDS                          ; Prepare for clearing tables
-	POPES
-	sub	eax,eax
-	cld
-
-	memSet	sampleList,<(SIZE SAMPLELINK)*MAXSAMPLE>
-	memSet	chBase,32*4
-	memSet	chPaused,32
-	memSet	chFreq,32*4
-	memSet	chVolume,32*2
-
-	LEAVEPROC esi edi
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void gusClose(void);
-; *
-; *     Description :   Closes GUS
-; *
-; ************************************************************************/
-
-CPROC   gusClose
-
-	ecall   gusStopVoice
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short gusSetSample(short channel, SAMPLEINFO *sinfo);
-; *
-; *     Description :   Sets a new sample on a channel
-; *
-; ************************************************************************/
-
-CPROC   gusSetSample @@channel,@@sinfo
-
-        ENTERPROC
-        mov     eax,[pseudoTime]
-        mov     [staticEvent.time],eax
-        mov     [staticEvent.func],offset __gusPrimeVoice
-        LESBX   [@@sinfo]
-        mov     eax,[@@channel]
-        mov     edx,[ESBX+SAMPLEINFO.loopStart]
-        shl     edx,8
-        or      eax,edx
-        mov     [staticEvent.p1],eax
-        mov     eax,[ESBX+SAMPLEINFO.voiceData]
-        mov     [staticEvent.p2],eax
-        mov     eax,[ESBX+SAMPLEINFO.loopEnd]
-	mov     edx,[ESBX+SAMPLEINFO.length]
-        shl     edx,16
-        or      eax,edx
-	mov     [staticEvent.p3],eax
-
-	call    insertEvent
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short gusPlaySample(short @@channel, long freq, short volume);
-; *
-; *     Description :   Plays the sample
-; *
-; ************************************************************************/
-
-CPROC   gusPlaySample @@channel,@@freq,@@volume
-
-        ENTERPROC
-        mov     eax,[pseudoTime]
-        mov     [staticEvent.time],eax
-        mov     [staticEvent.func],offset __gusGoVoice
-        mov     eax,[@@channel]
-        mov     [staticEvent.p1],eax
-        mov     eax,[@@freq]
-        mov     [staticEvent.p2],eax
-        mov     eax,[@@volume]
-        mov     [staticEvent.p3],eax
-        call    insertEvent
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short gusSetVolume(short @@channel, short volume);
-; *
-; *     Description :   Sets new volume on a @@channel
-; *
-; ************************************************************************/
-
-CPROC   gusSetVolume @@channel,@@volume
-
-        ENTERPROC
-        mov     eax,[pseudoTime]
-        mov     [staticEvent.time],eax
-	mov     [staticEvent.func],offset __gusSetVolume
-        mov     eax,[@@channel]
-	mov     [staticEvent.p1],eax
-        mov     eax,[@@volume]
-        mov     [staticEvent.p2],eax
-        call    insertEvent
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short gusSetRate(short @@channel, long freq);
-; *
-; *     Description :   Sets new playing frequency
-; *
-; ************************************************************************/
-
-CPROC   gusSetRate @@channel,@@freq
-
-        ENTERPROC
-        mov     eax,[pseudoTime]
-        mov     [staticEvent.time],eax
-        mov     [staticEvent.func],offset __gusSetRate
-        mov     eax,[@@channel]
-        mov     [staticEvent.p1],eax
-        mov     eax,[@@freq]
-        mov     [staticEvent.p2],eax
-        call    insertEvent
-        LEAVEPROC
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short gusSetPosition(short @@channel, long position);
-; *
-; *     Description :   Resets sample to a new playing position
-; *
-; ************************************************************************/
-
-CPROC   gusSetPosition @@channel,@@position
-
-        ENTERPROC
-	mov     eax,[pseudoTime]
-        mov     [staticEvent.time],eax
-	mov     [staticEvent.func],offset __gusSetPosition
-        mov     eax,[@@channel]
-        mov     [staticEvent.p1],eax
-        mov     eax,[@@position]
-        mov     [staticEvent.p2],eax
-        call    insertEvent
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short gusSetPanning(short @@channel, short panning);
-; *
-; *     Description :   Sets voice's panning position
-; *
-; ************************************************************************/
-
-CPROC   gusSetPanning @@channel,@@panning
-
-        ENTERPROC
-        mov     eax,[pseudoTime]
-        mov     [staticEvent.time],eax
-        mov     [staticEvent.func],offset __gusSetPan
-        mov     eax,[@@channel]
-        mov     [staticEvent.p1],eax
-        mov     eax,[@@panning]
-        cmp     eax,PAN_SURROUND
-        jne     @@noSurround
-        mov     eax,PAN_MIDDLE
-@@noSurround:
-        mov     [staticEvent.p2],eax
-        call    insertEvent
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short gusSetMasterVolume(short volume);
-; *
-; *     Description :   Sets new master volume
-; *
-; ************************************************************************/
-
-CPROC   gusSetMasterVolume @@volume
-
-        ENTERPROC
-        mov     eax,[@@volume]
-        shl     ax,2
-        mov     [masterVol],ax
-
-        movzx   ecx,[gusVoices]
-        sub     _dx,_dx
-@@loop:
-        mov     _ax,_dx
-        mov     _bx,_dx
-        shl     _bx,1
-	mov     bx,[chVolume+_bx]
-        push    _cx _dx
-	call    __gusSetVolume
-	pop     _dx _cx
-        inc     _dx
-        loop    @@loop
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short gusPauseChannel(short @@channel);
-; *
-; *     Description :   Pauses the voice
-; *
-; ************************************************************************/
-
-CPROC   gusPauseChannel @@channel
-
-        ENTERPROC
-        saveIRQ
-
-        mov     ebx,[@@channel]
-        mov     [_bx+chPaused],1
-
-        selectChannel bl
-
-	mov     ax,0
-	call    rampVolume
-
-	REPT 3
-	mov     dx,[gusCmdAddr]
-	mov     al,0
-	out     dx,al
-	add     dx,2
-	in      al,dx
-	or      al,3                    ; Stop voice
-	out     dx,al
-	sub	dx,2
-	DELAY
-	ENDM
-
-	restoreIRQ
-	LEAVEPROC
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short gusResumeChannel(short @@channel);
-; *
-; *     Description :   Resumes the voice
-; *
-; ************************************************************************/
-
-CPROC   gusResumeChannel @@channel
-
-        ENTERPROC
-        saveIRQ
-
-        mov     ebx,[@@channel]
-        mov     [_bx+chPaused],0
-
-        selectChannel bl
-
-	REPT 3
-	mov     dx,[gusCmdAddr]
-	mov     al,0
-	out     dx,al
-	add     dx,2
-	in      al,dx
-	and     al,NOT 3                ; Continue voice
-	out     dx,al
-	sub	dx,2
-	DELAY
-	ENDM
-
-        mov     ebx,[@@channel]
-	shl     _bx,1
-        mov     ax,[chVolume+_bx]
-	call    rampVolume
-
-        restoreIRQ
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short gusPauseAll(void);
-; *
-; *     Description :   Pauses all channels
-; *
-; ************************************************************************/
-
-CPROC   gusPauseAll
-
-        movzx   ecx,[gusVoices]
-@@loop:
-        push    ecx
-        dec     ecx
-        ecall   gusPauseChannel ecx
-        pop     ecx
-        loop    @@loop
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short gusResumeAll(void);
-; *
-; *     Description :   Resumes all channels
-; *
-; ************************************************************************/
-
-CPROC   gusResumeAll
-
-        movzx   ecx,[gusVoices]
-@@loop:
-        push    ecx
-        dec     ecx
-        ecall   gusResumeChannel ecx
-	pop     ecx
-        loop    @@loop
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short gusPoll(long time);
-; *
-; *     Description :   "Plays buffer"
-; *
-; ************************************************************************/
-
-CPROC   gusPoll @@time
-
-	ENTERPROC
-        mov     eax,[curTime]
-        cmp     eax,[pseudoTime]
-	jb      @@ok
-        mov     [pseudoTime],eax
-@@ok:
-        mov     eax,[@@time]
-        add     [pseudoTime],eax
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   long gusGetDelta(void);
-; *
-; *     Description :   Gets "delta" time
-; *
-; ************************************************************************/
-
-CPROC   gusGetDelta
-
-        mov     eax,[pseudoTime]
-        sub     eax,[curTime]
-        jns     @@ok
-        sub     eax,eax
-@@ok:
-	cmp     eax,[gusDeltaTime]
-        jbe     @@now
-        mov     eax,0
-@@now:
-	sub     eax,[gusDeltaTime]
-	neg     eax
-IFDEF __16__
-        shld    edx,eax,16
-ENDIF
-        ret
-ENDP
-
-LABEL   gusVolumes WORD
-        dw      00E00h
-GusVol          dw 20000,39120,41376,42656,43936,45072,45696,46240,46848,47408
-                dw 47952,48528,49072,49360,49632,49920,50160,50432,50704,50928
-                dw 51168,51424,51680,51952,52160,52448,52672,52912,53152,53312
-                dw 53440,53584,53664,53808,53952,54048,54144,54288,54400,54496
-		dw 54608,54720,54832,54944,55072,55184,55312,55440,55552,55696
-                dw 55760,55888,56016,56096,56240,56304,56448,56528,56672,56752
-                dw 56896,56976,57136,57216
-IF 0
-        dw      0B000h,0B800h,0BC00h,0BE00h,0C000h,0C400h,0C800h,0CC00h
-        dw      0D000h,0D200h,0D400h,0D600h,0D800h,0DA00h,0DC00h,0DE00h
-        dw      0E000h,0E100h,0E200h,0E300h,0E400h,0E500h,0E600h,0E700h
-        dw      0E800h,0E900h,0EA00h,0EB00h,0EC00h,0ED00h,0EE00h,0EF00h
-        dw      0F080h,0F100h,0F180h,0F200h,0F280h,0F300h,0F380h,0F400h
-        dw      0F480h,0F500h,0F580h,0F600h,0F680h,0F700h,0F780h,0F800h
-        dw      0F880h,0F900h,0F980h,0FA00h,0FA80h,0FB00h,0FB80h,0FC00h
-        dw      0FC80h,0FD00h,0FD80h,0FE00h,0FE40h,0FE80h,0FEC0h,0FF00h
-ENDIF
-
-LABEL   freqs WORD
-        DW 44100,41160,38587,36317,34300,32494,30870,29400,28063,26843,25725
-        DW 24696,23746,22866,22050,21289,20580,19916,19293
-
-;/*************************************************************************
-; *
-; *     Function    :   rampVolume
-; *
-; *     Description :   Ramps the volume to AX
-; *
-; *     Input       :   AX = end volume
-; *
-; ************************************************************************/
-
-PROC    rampVolume NEAR
-
-	cmp     ax,64
-        jbe     @@volok
-	mov     ax,64
-@@volok:
-        imul    [masterVol]
-        shr     ax,8
-        movzx   ebx,ax
-        shl     ebx,1
-        mov     cx,[gusVolumes+_bx]
-
-        mov     dx,[gusCmdAddr]
-        mov     al,89h
-        out     dx,al
-        inc     dx
-        in      ax,dx
-	push    cx
-        push    ax
-        shr     ax,8
-	shr     cx,8
-        cmp     ax,cx
-;       je      @@Done2
-        jbe     @@OK
-        xchg    cx,ax
-@@OK:
-        push    ax
-        mov     dx,[gusCmdAddr]
-        mov     al,7
-        out     dx,al
-        add     dx,2
-        pop     ax
-        out     dx,al
-        mov     dx,[gusCmdAddr]
-        mov     al,8
-        out     dx,al
-        add     dx,2
-        mov     ax,cx
-        out     dx,al
-        mov     dx,[gusCmdAddr]
-        mov     al,6
-        out     dx,al
-        add     dx,2
-        mov     al,00011111b
-        out     dx,al
-        mov     bl,00000000b
-        pop     ax
-	pop     cx
-        cmp     ax,cx
-	jb      @@OK2
-        or      bl,01000000b
-@@OK2:
-	REPT 2
-	mov     dx,[gusCmdAddr]
-	mov     al,0Dh
-	out     dx,al
-	add     dx,2
-	mov     al,bl
-	out     dx,al
-	DELAY
-	ENDM
-	jmp     @@Done
-@@Done2:
-	pop     ax ax
-@@Done:
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Description : Sets up ('primes') a sample to be played in the @@channel
-; *
-; *     Input       :   ax      = @@channel
-; *
-; ************************************************************************/
-
-PROC    __gusPrimeVoice NEAR
-locs = 0
-procargs = 0
-LOCALVAR        _word @@channel
-LOCALVAR        _dword @@sample
-LOCALVAR        _dword @@loopStart
-LOCALVAR        _dword @@loopEnd
-LOCALVAR        _dword @@voicegus
-LOCALVAR        _dword @@slength
-
-        ENTERPROC _si
-        mov     [@@channel],ax
-        and     [word @@channel],7Fh
-        shr     eax,8
-        mov     [@@loopStart],eax
-        mov     [@@sample],ebx
-        mov     [@@loopEnd],ecx
-        and     [dword @@loopEnd],0FFFFh
-	shr     ecx,16
-	mov     [@@slength],ecx
-
-	saveIRQ
-
-	PUSHES
-	ecall   findSample <[dword @@sample]>
-	POPES
-	mov     [@@voicegus],eax
-	movzx   ebx,[word @@channel]
-	shl     ebx,2
-	cmp     [_bx+chBase],eax
-	je      @@done
-	mov     [_bx+chBase],eax
-
-	selectChannel <[byte @@channel]>
-
-	mov     dx,[gusCmdAddr]
-	sub     al,al
-	out     dx,al
-	cmp     [DWORD @@loopEnd],0
-	jz      @@noloop
-	or      al,8
-@@noloop:
-	or      al,2
-	mov	cl,al
-	add     dx,2
-	out     dx,al
-	DELAY
-	sub     dx,2
-	sub     al,al
-	out     dx,al
-	add     dx,2
-	mov	al,cl
-	out     dx,al
-
-	mov     dx,[gusCmdAddr]
-	mov     ebx,[@@voicegus]
-	cmp     [DWORD @@loopEnd],0
-	je      @@noloopings
-	add     ebx,[@@loopStart]
-@@noloopings:
-	mov     al,02h
-	out     dx,al                   ; Set start of loop
-	inc     dx
-	mov     eax,ebx
-	shr     eax,7
-	and     ax,1fffh
-	out     dx,ax
-	dec     dx
-	mov     al,03h
-	out     dx,al
-	inc     dx
-	mov     ax,bx
-	and     ax,07fh
-	shl     ax,9
-	out     dx,ax
-
-	mov     dx,[gusCmdAddr]
-	mov     ebx,[@@voicegus]
-	mov     eax,[@@loopEnd]
-	or      eax,eax
-	jne     @@looping
-	mov     eax,[@@slength]
-@@looping:
-	add     ebx,eax
-	mov     al,04h
-	out     dx,al                   ; Set end of loop
-	inc     dx
-	mov     eax,ebx
-	shr     eax,7
-	and     ax,1fffh
-	out     dx,ax
-	dec     dx
-	mov     al,05h
-	out     dx,al
-	inc     dx
-	mov     ax,bx
-	and     ax,07fh
-	shl     ax,9
-	out     dx,ax
-@@done:
-	restoreIRQ
-	DELAY
-	DELAY
-@@exit:
-        sub     _ax,_ax
-        LEAVEPROC _si
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Description : Plays a sample that has been primed beforehand
-; *
-; *     Input       :   ax      = @@channel number
-; *                     ebx     = rate
-; *                     cx      = volume
-; *
-; ************************************************************************/
-
-PROC    __gusGoVoice NEAR
-locs = 0
-procargs = 0
-LOCALVAR        _word @@channel
-LOCALVAR        _dword @@rate
-LOCALVAR        _word @@vol
-LOCALVAR        _dword @@base
-
-	ENTERPROC
-	mov     [@@channel],ax
-	mov     [@@rate],ebx
-	mov     [@@vol],cx
-
-	saveIRQ
-
-	movzx   ebx,[WORD @@channel]
-	shl     ebx,1
-	mov     ax,[@@vol]
-	mov     [_bx+chVolume],ax
-	shl     ebx,1
-	mov     eax,[_bx+chBase]
-	mov     [@@base],eax
-
-	selectChannel <[byte @@channel]>
-
-	mov     dx,[gusCmdAddr]         ; Stop old voice
-	mov     al,80h
-	out     dx,al
-	add     dx,2
-	in      al,dx
-	or      al,3
-	mov	cl,al
-	sub     dx,2
-	mov     al,0
-	out     dx,al
-	add     dx,2
-	mov	al,cl
-	out     dx,al
-	sub     dx,2
-	DELAY
-	mov     al,0
-	out     dx,al
-	add     dx,2
-	mov	al,cl
-	out     dx,al
-	sub     dx,2
-	DELAY
-	mov     al,0
-	out     dx,al
-	add     dx,2
-	mov	al,cl
-	out     dx,al
-
-	REPT 2
-	mov     dx,[gusCmdAddr]
-	mov     al,0ah
-	out     dx,al                   ; Set beginning of data
-	inc     dx
-	mov     eax,[@@base]
-	shr     eax,7
-	and     ax,1fffh
-	out     dx,ax
-	dec     dx
-	mov     al,0bh
-	out     dx,al
-	inc     dx
-	mov     ax,[WORD @@base]
-	and     ax,07fh
-	shl     ax,9
-	out     dx,ax
-	DELAY
-	ENDM
-
-	movzx   ebx,[gusVoices]
-	sub     ebx,14
-	shl     ebx,1
-	movzx   eax,[freqs+_bx]         ; Set playing frequency
-	mov     ecx,eax
-	mov     ebx,[@@rate]
-	shl     ebx,9
-	shr     eax,1
-	add     eax,ebx
-	sub     edx,edx
-	idiv    ecx
-	shl     eax,1
-	mov     ecx,eax
-	REPT 2
-	mov     dx,[gusCmdAddr]
-	mov     al,1
-	out     dx,al
-	inc     dx
-	mov     ax,cx
-	out     dx,ax
-	DELAY
-	ENDM
-
-	movzx   ebx,[WORD @@channel]
-	shl     ebx,1
-	mov     eax,[@@rate]
-	mov     [_bx+chFreq],eax
-
-	mov     dx,[gusCmdAddr]
-	mov     al,9
-	out     dx,al
-	inc     dx
-	mov     ax,0E00h                ; Volume = 0
-	out     dx,ax
-	DELAY
-	out	dx,ax
-
-	mov     dx,[gusCmdAddr]
-	mov     al,80h
-	out     dx,al
-	add     dx,2
-	in      al,dx			; Get voice status
-	sub     dx,2
-	and	al,not 3		; Enable playing
-	mov	cl,al
-	mov	al,0
-	out	dx,al
-	add	dx,2
-	mov	al,cl
-	out	dx,al			; Start voice 4 times!
-	DELAY
-	sub	dx,2
-	mov	al,0
-	out	dx,al
-	add	dx,2
-	mov	al,cl
-	out	dx,al
-	DELAY
-	sub	dx,2
-	mov	al,0
-	out	dx,al
-	add	dx,2
-	mov	al,cl
-	out	dx,al
-	DELAY
-	sub	dx,2
-	mov	al,0
-	out	dx,al
-	add	dx,2
-	mov	al,cl
-	out	dx,al
-
-	movzx   ebx,[WORD @@channel]
-	cmp     [_bx+chPaused],1
-	je      @@novol
-
-	mov     ax,[@@vol]
-	call    rampVolume
-@@novol:
-
-	restoreIRQ
-@@exit:
-	sub     _ax,_ax
-	LEAVEPROC
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    : int gusSetVolume(int @@channel,unsigned volume);
-; *
-; *     Description : Changes the volume of a @@channel
-; *
-; *     Input       :   ax = @@channel nr.
-; *                     bx = volume
-; *
-; ************************************************************************/
-
-PROC    __gusSetVolume NEAR
-locs = 0
-procargs = 0
-LOCALVAR        _word @@channel
-LOCALVAR        _word @@vol
-
-        ENTERPROC
-        mov     [@@channel],ax
-        mov     [@@vol],bx
-
-        checkPause
-
-        movzx   ebx,[WORD @@channel]
-        shl     ebx,1
-        mov     ax,[@@vol]
-	mov     [_bx+chVolume],ax
-
-        saveIRQ
-
-        selectChannel <[byte @@channel]>
-
-        mov     ax,[@@vol]
-        call    rampVolume
-
-	restoreIRQ
-@@exit:
-	LEAVEPROC
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    : int gusStopChannel(int @@channel);
-; *
-; *     Description : Stops the voice on @@channel
-; *
-; *     Input       :   ax = @@channel nr.
-; *
-; ************************************************************************/
-
-CPROC   gusStopChannel @@channel
-
-	ENTERPROC _si
-	saveIRQ
-
-	selectChannel <[byte @@channel]>
-
-	mov     ebx,[@@channel]
-	shl     ebx,1
-        mov     [_bx+chFreq],0
-        mov     [_bx+chVolume],0
-	shl     ebx,1
-	mov     [_bx+chBase],-1
-
-	mov     ax,0
-	call    rampVolume
-
-	DELAY
-
-	REPT 2
-	mov     dx,[gusCmdAddr]
-	mov     al,0Dh
-	out     dx,al
-	inc     dx
-	mov     ax,11b                  ; Stop ramp
-	out     dx,ax
-	DELAY
-	ENDM
-
-	mov     dx,[gusCmdAddr]
-	mov     al,0
-	out     dx,al
-	add     dx,2
-	mov     al,3                    ; Stop voice
-	out     dx,al
-	sub     dx,2
-	DELAY
-	mov     al,0
-	out     dx,al
-	add     dx,2
-	mov     al,3                    ; Stop voice second time
-	out     dx,al
-	sub     dx,2
-
-        DELAY
-
-	mov     dx,[gusCmdAddr]
-	mov     al,9
-        out     dx,al
-        inc     dx
-	mov     ax,0E00h                ; Volume = 0
-	out     dx,ax
-
-	REPT 2
-	mov     dx,[gusCmdAddr]
-	mov     al,0ah                  ; Current position
-	out     dx,al
-	inc     dx
-	mov     ax,0
-	out     dx,ax
-	dec     dx
-	mov     al,0bh
-	out     dx,al
-	inc     dx
-	mov     ax,0
-	out     dx,ax
-	dec     dx
-	DELAY
-	ENDM
-
-        mov     al,02h                  ; Loop start
-        out     dx,al
-        inc     dx
-        mov     ax,0
-        out     dx,ax
-        dec     dx
-        mov     al,03h
-        out     dx,al
-        inc     dx
-        mov     ax,0
-        out     dx,ax
-	dec     dx
-
-        mov     al,04h                  ; Loop end
-	out     dx,al
-	inc     dx
-	mov     ax,0
-	out     dx,ax
-	dec     dx
-	mov     al,05h
-	out     dx,al
-	inc     dx
-	mov     ax,0
-	out     dx,ax
-	dec     dx
-
-	mov	_cx,MAXEVENT
-	sub	_si,_si
-	mov	dl,[byte @@channel]
-@@clearChannelEvents:
-	cmp	dl,[byte _si+eventQueue.p1] ; Is channel the same?
-	jne	@@next
-	mov	[_si+eventQueue.func],0	; Don't call it
-@@next:
-	add	_si,SIZE GUSEVENT
-	loop	@@clearChannelEvents
-
-	restoreIRQ
-	LEAVEPROC _si
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    : int gusSetRate(int @@channel,unsigned long rate);
-; *
-; *     Description : Changes the rate (frequency) of a @@channel
-; *
-; *     Input       :   ax  = @@channel
-; *                     ebx = rate
-; *
-; ************************************************************************/
-
-PROC    __gusSetRate NEAR
-locs = 0
-procargs = 0
-LOCALVAR        _word @@channel
-LOCALVAR        _dword @@rate
-
-        ENTERPROC
-        mov     [@@channel],ax
-        mov     [@@rate],ebx
-        mov     ecx,[@@rate]
-
-        movzx   ebx,[WORD @@channel]
-        shl     ebx,1
-        cmp     [_bx+chFreq],ecx
-	je      @@exit
-        mov     [_bx+chFreq],ecx
-
-	checkPause
-
-        movzx   _bx,[gusVoices]
-        sub     _bx,14
-        shl     _bx,1
-        movzx   eax,[freqs+_bx]
-        mov     ecx,eax
-	mov     ebx,[@@rate]
-        shl     ebx,9
-        shr     eax,1
-	add     eax,ebx
-        sub     edx,edx
-        idiv    ecx
-        shl     eax,1
-	mov     cx,ax
-
-
-        saveIRQ
-
-        selectChannel <[byte @@channel]>
-
-	DELAY
-
-        mov     dx,[gusCmdAddr]
-        mov     al,1
-        out     dx,al
-        inc     dx
-        in      ax,dx
-        cmp     ax,cx
-        je      @@nochange
-	mov     ax,cx
-	out     dx,ax
-@@nochange:
-	restoreIRQ
-@@exit:
-	LEAVEPROC
-	ret
-ENDP
-
-
-
-;/*************************************************************************
-; *
-; *     Description : Sets the sample position to an absolute location
-; *
-; *     Input       : ax = @@channel
-; *                   ebx = pos
-; *
-; ************************************************************************/
-
-PROC    __gusSetPosition NEAR
-locs = 0
-procargs = 0
-LOCALVAR        _word @@channel
-LOCALVAR        _dword @@pos
-
-	ENTERPROC
-	mov     [@@channel],ax
-	mov     [@@pos],ebx
-
-	checkPause
-
-	saveIRQ
-
-	movzx   ebx,[WORD @@channel]
-	shl     ebx,2
-	mov     eax,[_bx+chBase]
-	add     [@@pos],eax
-
-	selectChannel <[byte @@channel]>
-
-	mov     dx,[gusCmdAddr]
-	mov     al,0ah
-	out     dx,al
-	inc     dx
-	mov     eax,[@@pos]
-	shr     eax,7
-	out     dx,ax
-	dec     dx
-	mov     al,0bh
-	out     dx,al
-	inc     dx
-	mov     ax,[WORD @@pos]
-	shl     ax,9
-	out     dx,ax
-
-	DELAY
-
-	mov     dx,[gusCmdAddr]
-	mov     al,0ah
-	out     dx,al
-	inc     dx
-	mov     eax,[@@pos]
-	shr     eax,7
-	out     dx,ax
-	dec     dx
-	mov     al,0bh
-	out     dx,al
-	inc     dx
-	mov     ax,[WORD @@pos]
-	shl     ax,9
-	out     dx,ax
-
-	restoreIRQ
-@@exit:
-	LEAVEPROC
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Description : Sets the panning position
-; *
-; *     Input       : ax = @@channel
-; *                   ebx = panning value (-63 - 63)
-; *
-; ************************************************************************/
-
-PROC    __gusSetPan NEAR
-
-	mov     dl,al
-
-	saveIRQ
-
-	selectChannel dl
-
-	cmp     bl,-63
-	jge     @@1
-	mov     bl,-63
-@@1:
-	cmp     bl,63
-	jle     @@2
-	mov     bl,63
-@@2:
-	sar     bl,3
-	add     bl,8
-	and     bl,0Fh
-
-	mov     dx,[gusCmdAddr]
-	mov     al,0Ch
-	out     dx,al
-	add     dx,2
-	mov     al,bl
-	out     dx,al
-
-	restoreIRQ
-
-	ret
-ENDP
-
-CPROC   gusPoke @@addr, @@value
-
-        ENTERPROC
-	saveIRQ
-        mov     ax,[gusBaseAddr]
-        mov     ebx,[@@addr]
-        mov     cl,[byte @@value]
-        call    __gusPoke
-        restoreIRQ
-        LEAVEPROC
-        ret
-ENDP
-
-CPROC   gusPeek @@addr
-
-        ENTERPROC
-        saveIRQ
-        mov     ax,[gusBaseAddr]
-        mov     ebx,[@@addr]
-        call    __gusPeek
-        mov     cx,ax
-        restoreIRQ
-        mov     ax,cx
-        LEAVEPROC
-        ret
-ENDP
-
-PROC    __gusPoke NEAR ;ax=port, ebx=addr, cl=data
-
-        push    ax
-        mov     dx,ax
-        add     dx,103h
-        mov     al,43h
-        out     dx,al
-        inc     dx
-        mov     ax,bx
-        out     dx,ax
-        dec     dx
-        mov     al,44h
-	out     dx,al
-        add     dx,2
-        shr     ebx,16
-	mov     al,bl
-        out     dx,al
-	pop     dx
-        add     dx,107h
-        mov     al,cl
-        out     dx,al
-        ret
-ENDP
-
-PROC    __gusPeek NEAR ;ax=port, ebx=addr
-
-        push    ax
-        mov     dx,ax
-        add     dx,103h
-        mov     al,43h
-        out     dx,al
-        inc     dx
-        mov     ax,bx
-        out     dx,ax
-        dec     dx
-        mov     al,44h
-        out     dx,al
-        add     dx,2
-        shr     ebx,16
-        mov     al,bl
-        out     dx,al
-        pop     dx
-        add     dx,107h
-        in      al,dx
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Description : Init
-; *
-; *     Input       :   ax = @@channel count
-; *                     bx = base address
-; *
-; ************************************************************************/
-
-PROC    _gusReset NEAR
-
-        cmp     ax,14
-        jae     @@ok
-	mov     ax,14
-@@ok:
-	cmp     ax,32
-        ja      @@err
-        mov     [gusVoices],al
-        mov     [gusBaseAddr],bx
-        add     bx,102h
-        mov     [gusChannelAddr],bx
-        inc     bx
-        mov     [gusCmdAddr],bx
-
-        saveIRQ
-
-        mov     dx,[gusCmdAddr]         ; Pull reset
-        mov     al,4ch
-        out     dx,al
-        add     dx,2
-        sub     al,al
-        out     dx,al
-
-        REPT    10
-            DELAY
-        ENDM
-
-        mov     dx,[gusCmdAddr]         ; Release reset
-        mov     al,4ch
-        out     dx,al
-        add     dx,2
-        mov     al,1
-        out     dx,al
-
-        REPT    10
-            DELAY
-        ENDM
-
-        mov     dx,[gusBaseAddr]        ; Reset MIDI
-        add     dx,100h
-        mov     al,3
-        out     dx,al
-
-        REPT    10
-            DELAY
-	ENDM
-
-        mov     dx,[gusBaseAddr]
-	add     dx,100h
-        mov     al,0
-	out     dx,al
-
-        mov     dx,[gusCmdAddr]         ; Disable DMA
-        mov     al,41h
-        out     dx,al
-        add     dx,2
-        mov     al,0
-        out     dx,al
-        sub     dx,2
-
-        mov     al,45h                  ; Disable timers
-        out     dx,al
-        add     dx,2
-        mov     al,0
-        out     dx,al
-        sub     dx,2
-
-        mov     al,49h                  ; Disable sampling
-        out     dx,al
-        add     dx,2
-        mov     al,0
-        out     dx,al
-        sub     dx,2
-
-        DELAY
-
-        restoreIRQ
-        DELAY
-        saveIRQ
-
-        mov     dx,[gusBaseAddr]        ; Ack any IRQ
-        add     dx,6
-        in      al,dx
-
-        mov     dx,[gusCmdAddr]         ; Ack DMA IRQ
-        mov     al,41h
-        out     dx,al
-        add     dx,2
-        in      al,dx
-        sub     dx,2
-
-        mov     al,49h                  ; Ack sampling IRQ
-        out     dx,al
-	add     dx,2
-        in      al,dx
-	sub     dx,2
-
-        mov     al,8fh
-        out     dx,al
-        add     dx,2
-        in      al,dx
-
-        mov     dx,[gusCmdAddr]
-        mov     al,0eh                  ; Set the number of active voices
-        out     dx,al
-	add     dx,2
-	mov     al,31
-	or      al,0c0h
-	out     dx,al
-
-	mov     ecx,32
-@@resetloop:
-	push    ecx
-	dec     ecx
-	ecall   gusStopChannel ecx
-	pop     ecx
-
-	mov     dx,[gusChannelAddr]     ; Reset voices
-	mov     al,cl
-	dec     al
-	out     dx,al
-
-	inc     dx
-	mov     al,6
-	out     dx,al
-	add     dx,2
-	mov     al,0                    ; Volume ramp speed = 0
-	out     dx,al
-	sub     dx,2
-
-	mov     al,0Dh                  ; Turn ramp off
-	out     dx,al
-	add     dx,2
-	mov     al,11b
-	out     dx,al
-	DELAY
-	out	dx,al
-	sub     dx,2
-
-	mov     al,9
-	out     dx,al
-	inc     dx
-	sub     ax,ax
-	out     dx,ax
-	DELAY
-	out	dx,ax
-	dec     dx
-
-	mov     al,0
-	out     dx,al
-	add     dx,2
-	mov     al,11b                  ; Turn voice off
-	out     dx,al
-	DELAY
-	out	dx,al
-
-	loop    @@resetloop
-
-	restoreIRQ
-	DELAY
-	saveIRQ
-
-	mov     dx,[gusBaseAddr]        ; Ack any IRQ
-	add     dx,6
-	in      al,dx
-
-        mov     dx,[gusCmdAddr]         ; Ack DMA IRQ
-        mov     al,41h
-        out     dx,al
-        add     dx,2
-        in      al,dx
-        sub     dx,2
-
-        mov     al,49h                  ; Ack sampling IRQ
-        out     dx,al
-        add     dx,2
-        in      al,dx
-        sub     dx,2
-
-        mov     al,8fh
-	out     dx,al
-        add     dx,2
-        in      al,dx
-
-        mov     dx,[gusCmdAddr]
-	mov     al,0eh                  ; Set the number of active voices
-        out     dx,al
-        add     dx,2
-        mov     al,[byte gusVoices]
-        dec     al
-        or      al,0c0h
-        out     dx,al
-
-        mov     dx,[gusCmdAddr]         ; Reset
-        mov     al,4ch
-        out     dx,al
-        add     dx,2
-        mov     al,7
-        out     dx,al
-
-        mov     dx,[gusBaseAddr]
-        mov     al,00001001b            ; Enable output
-        out     dx,al
-
-        restoreIRQ
-
-        sub     _ax,_ax
-        jmp     @@eksitti
-@@err:
-        mov     _ax,-1
-@@eksitti:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void dma64(long gusStart,long start,unsigned length);
-; *
-; ************************************************************************/
-
-CPROC   dma64 @@gusStart, @@start, @@len
-
-        ENTERPROC
-        cmp     [gusDMA],4
-        jl      @@gus8
-	mov     eax,[@@gusStart]                ; Translate address for 16-bit DMA
-        mov     edx,eax
-        shr     eax,1
-	and     eax,0001FFFFh
-        and     edx,000c0000h
-	or      eax,edx
-        mov     [@@gusStart],eax
-@@gus8:
-        mov     eax,[@@start]
-        mov     edx,eax
-        shr     edx,16                  ; EDX = page
-        cmp     [gusDMA],4
-        jl      @@8bit
-        shr     eax,1                   ; 16-bit offset
-@@8bit:
-        mov     bx,ax                   ; Offset
-        mov     ah,dl                   ; Page
-
-        cli
-        mov     al,[gusDMA]
-        or      al,4
-        mov     dx,[curDMA.wrsmr]
-        out     dx,al                   ; Break On
-        mov     al,[gusDMA]
-        and     al,3
-        or      al,048h
-        mov     dx,[curDMA.wrmode]
-        out     dx,al
-        mov     dx,[curDMA.page]
-        mov     al,ah
-        out     dx,al                   ; Page
-        mov     al,0
-        mov     dx,[curDMA.clear]
-        out     dx,al                   ; Reset counter
-
-        mov     dx,[curDMA.addr]
-        mov     al,bl
-        out     dx,al                   ; Offset
-        mov     al,bh
-        out     dx,al
-
-        mov     al,0
-        mov     dx,[curDMA.clear]
-        out     dx,al                   ; Reset counter
-
-	mov     ecx,[@@len]
-        cmp     [gusDMA],4
-        jl      @@nodiv
-	shr     cx,1
-@@nodiv:
-	jcxz    @@zero
-        dec     cx
-@@zero:
-        mov     dx,[curDMA.count]
-        mov     al,cl
-        out     dx,al                   ; Count
-        mov     al,ch
-        out     dx,al
-
-        mov     al,[gusDMA]
-        and     al,3
-        mov     dx,[curDMA.wrsmr]
-        out     dx,al                   ; Break Off
-
-        shr     [@@gusStart],4
-
-        mov     [dmaActive],1
-
-        mov     dx,[gusCmdAddr]
-        mov     al,42h
-        out     dx,al
-        inc     dx
-        mov     ax,[WORD @@gusStart]
-        out     dx,ax
-        dec     dx
-
-        mov     al,41h
-        out     dx,al
-        add     dx,2
-        mov     al,10101001b            ; Invert MSB, 1/2 speed, 8-bit DATA, IRQ enable
-        cmp     [gusDMA],4
-        jl      @@not16
-        or      al,00000100b
-@@not16:
-        sti
-        out     dx,al                   ; Start transfer
-
-        mov     ecx,300000
-@@wait:
-        cmp     [dmaActive],1
-        loopde  @@wait
-
-IF 0
-	mov     al,[gusDMA]
-        or      al,4
-	mov     dx,[curDMA.wrsmr]
-        out     dx,al                   ; Break On
-        mov     dx,[gusCmdAddr]
-        mov     al,41h
-        out     dx,al
-        add     dx,2
-        mov     al,0                    ; Stop GUS DMA
-        out     dx,al
-ENDIF
-        LEAVEPROC
-        ret
-ENDP
-
-__OLD__ = 0
-
-;/*************************************************************************
-; *
-; *     Function : void gushmCopyTo(GUSH handle, void *ptr, long start, long length);
-; *
-; ************************************************************************/
-
-CPROC   gushmCopyTo @@handle,@@pptr,@@start,@@len
-
-        ENTERPROC _di _si
-
-IFNDEF __OLD__
-
-IF 0
-        saveIRQ
-
-        mov     dx,[gusBaseAddr]        ; Ack any IRQ
-        add     dx,6
-        in      al,dx
-
-        mov     dx,[gusCmdAddr]         ; Ack DMA IRQ
-        mov     al,41h
-        out     dx,al
-        add     dx,2
-        in      al,dx
-
-        restoreIRQ
-ENDIF
-        sub     edi,edi
-        LESDI   [@@pptr]
-        add     edi,[@@len]
-	mov     al,[ESDI-1]
-        mov     ah,al
-        mov     [ESDI],ax
-        mov     [ESDI+2],ax
-        movzx   eax,[WORD LOW @@pptr]
-        movzx   edx,[WORD HIGH @@pptr]
-        add     [@@len],4
-        shl     edx,4
-        add     eax,edx                 ; EAX = linear address
-        mov     dx,ax
-        add     dx,[WORD @@len]         ; DMA overrun?
-        jnc     @@normal
-	movzx   edx,ax
-        neg     edx
-        push    eax edx
-	ecall   dma64 [@@handle],eax,edx
-        pop     edx eax
-        add     [@@handle],edx
-        add     eax,edx
-        sub     [WORD @@len],dx
-@@normal:
-        ecall   dma64 [@@handle],eax,[@@len]
-
-ELSE
-;       saveIRQ
-
-        sub     edi,edi
-        LESDI   [@@pptr]
-        add     edi,[@@len]
-        mov     al,[ESDI-1]
-        mov     ah,al
-        mov     [ESDI],ax
-        mov     [ESDI+2],ax
-        mov     eax,[@@start]
-        add     [@@handle],eax
-        mov     si,[WORD HIGH @@handle]
-        mov     di,[WORD LOW @@handle]
-        mov     ecx,[@@len]
-        add     ecx,4
-        mov     dx,[gusCmdAddr]
-        mov     al,44h          ; Dump upper byte, only do it on carry from now
-        cli
-        out     dx,al           ; on.
-        add     dx,2
-        mov     ax,si
-	out     dx,al
-        sti
-        sub     dx,2
-        PUSHDS
-        LDSBX   [@@pptr]
-ALIGN 4
-@@MainLoop:
-        mov     al,43h
-        cli
-        out     dx,al
-        inc     dx
-        mov     ax,di
-	out     dx,ax           ; Set address
-        sti
-
-	add     dx,3
-        mov     al,[_bx]
-        xor     al,80h
-        inc     _bx
-        out     dx,al           ; Download byte
-        sub     dx,4
-        add     di,1
-	jc      @@DoLoop
-	loop    @@MainLoop
-	jmp     short @@exit
-@@DoLoop:
-	inc     si
-	mov     al,44h
-	cli
-	out     dx,al
-	add     dx,2
-	mov     ax,si
-	out     dx,al
-	sti
-	sub     dx,2
-	loop    @@MainLoop
-@@exit:
-	POPDS
-;       restoreIRQ
-ENDIF
-	LEAVEPROC _di _si
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function : void gusDownload(void *ptr, long ptag, long length);
-; *
-; ************************************************************************/
-
-CPROC   gusDownload @@pptr,@@ptag,@@len
-
-	ENTERPROC edi esi
-	ecall   gushmAlloc [@@len]
-IFDEF __32__
-	push    eax
-	ecall   gushmCopyTo eax,[@@pptr],<LARGE 0>,[@@len]
-	pop     eax
-	ecall   insertSample [@@ptag],eax
-ELSE
-	push    dx ax
-	ecall   gushmCopyTo <dx ax>,[@@pptr],<LARGE 0>,[@@len]
-	pop     ax dx
-	ecall   insertSample [@@ptag],<dx ax>
-ENDIF
-	LEAVEPROC edi esi
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function : void gusUnload(void *ptr);
-; *
-; ************************************************************************/
-
-CPROC   gusUnload @@pptr
-
-	ENTERPROC
-	ecall   findSample [@@pptr]
-	mov     [_bx+sampleList.origSample],0   ; Clear entry
-	ecall   gushmFree eax
-	LEAVEPROC
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function : void gusUnloadAll(void);
-; *
-; ************************************************************************/
-
-CPROC   gusUnloadAll
-
-	ENTERPROC _di _si
-	ecall   gushmFreeAll
-	PUSHDS                          ; Clear sample list
-	POPES
-	mov     _di,offset sampleList
-	sub     eax,eax
-	mov     _cx,(SIZE SAMPLELINK)*MAXSAMPLE/4
-	cld
-	rep     stosd
-	mov     [sampleListLength],0
-	LEAVEPROC _di _si
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function : long gusGetSamplingRate(void);
-; *
-; ************************************************************************/
-
-CPROC   gusGetSamplingRate
-
-	movzx   ebx,[gusVoices]
-	sub     ebx,14
-        shl     ebx,1
-        movzx   eax,[freqs+_bx]
-        cwd
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   ushort gusGetVolume(short @@channel);
-; *
-; *     Description :   Returns the current volume on '@@channel'
-; *
-; ************************************************************************/
-
-CPROC   gusGetVolume @@channel
-
-        ENTERPROC
-        mov     ebx,[@@channel]
-	shl     ebx,1
-        movzx   eax,[chVolume+_bx]
-        cwd
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   ulong gusGetRate(short @@channel);
-; *
-; *     Description :   Returns the current frequency on '@@channel'
-; *
-; ************************************************************************/
-
-CPROC   gusGetRate @@channel
-
-        ENTERPROC
-	mov     ebx,[@@channel]
-        shl     ebx,1
-        mov     eax,[chFreq+_bx]
-IF16    <shld   edx,eax,16>
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   ulong gusGetPosition(short @@channel);
-; *
-; *     Description :   Returns the current position on '@@channel'
-; *
-; ************************************************************************/
-
-CPROC   gusGetPosition @@channel
-LOCALVAR        _dword @@pos
-
-        ENTERPROC
-        saveIRQ
-
-        selectChannel <[byte @@channel]>
-
-        mov     dx,[gusCmdAddr]         ; Get position
-        mov     al,8ah
-        out     dx,al
-	inc     dx
-        sub     eax,eax
-        in      ax,dx
-        and     ax,01FFFh
-        shl     eax,7
-        mov     [@@pos],eax
-        dec     dx
-        mov     al,8bh
-        out     dx,al
-        inc     dx
-        in      ax,dx
-        shr     ax,9
-        or      [WORD @@pos],ax
-
-        restoreIRQ
-
-        mov     eax,[@@pos]             ; Absolute position
-        mov     ebx,[@@channel]         ; Convert it to relative
-	shl     ebx,2                   ; position
-	sub     eax,[chBase+_bx]
-IF16    <shld   edx,eax,16>
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   ushort gusGetPanning(short @@channel);
-; *
-; *     Description :   Returns the current pan value on '@@channel'
-; *
-; ************************************************************************/
-
-CPROC   gusGetPanning @@channel
-
-        ENTERPROC
-        saveIRQ
-
-        selectChannel <[byte @@channel]>
-
-        mov     dx,[gusCmdAddr]         ; Get Pan position
-        mov     al,8Ch
-        out     dx,al
-        add     dx,2
-        in      al,dx
-	sub     al,8
-        shl     al,3
-        sub     ah,ah
-        mov     bx,ax
-
-        restoreIRQ
-
-IF32    <movsx  eax,bx>
-IF16    <mov    ax,bx>
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   ulong gusGetSample(short @@channel);
-; *
-; *     Description :   Returns a pointer to the current sample on '@@channel'
-; *
-; ************************************************************************/
-
-CPROC   gusGetSample @@channel
-
-        ENTERPROC
-        mov     ebx,[@@channel]
-        shl     ebx,2
-	mov     eax,[chBase+_bx]
-IF16    <shld   edx,eax,16>
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   short gusSetupChannels(short count, ushort *volTable);
-; *
-; *     Description :   Sets a 'count' channels on GUS
-; *
-; ************************************************************************/
-
-CPROC   gusSetupChannels @@count,@@volTable
-
-	ENTERPROC
-	saveIRQ
-        mov     eax,[@@count]
-	cmp     ax,14
-        jg      @@10
-        mov     ax,14
-@@10:
-        mov     [gusVoices],al
-        mov     dx,[gusCmdAddr]
-        mov     al,0eh                  ; Set the number of active voices
-        out     dx,al
-        add     dx,2
-        mov     al,[gusVoices]
-        dec     al
-        or      al,0c0h
-        out     dx,al
-@@exit:
-	restoreIRQ
-	LEAVEPROC
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int gusGetChannelStatus(short @@channel);
-; *
-; *     Description :   Returns the status of the channel
-; *
-; ************************************************************************/
-
-CPROC   gusGetChannelStatus @@channel
-
-        ENTERPROC _si
-        sub       _si,_si
-        saveIRQ
-        mov     ebx,[@@channel]
-        shl     ebx,1
-        cmp     [_bx+chPaused],1
-        jne     @@1
-        or      _si,CH_PAUSED
-        jmp     @@exit
-@@1:
-        selectChannel <[byte @@channel]>
-
-        mov     dx,[gusCmdAddr]         ; Get voice status
-        mov     al,80h
-        out     dx,al
-        add     dx,2
-	in      al,dx
-	test    al,00000001b
-	jnz     @@2
-	or      _si,CH_PLAYING
-	test    al,00001000b
-	jz      @@2
-	or      _si,CH_LOOPING
-@@2:
-@@exit:
-	restoreIRQ
-	mov       _ax,_si           ; Return status in (E)AX
-	LEAVEPROC _si
-	ret
-ENDP
-
-ENDS
-
-END
diff --git a/dmp/gus.inc b/dmp/gus.inc
deleted file mode 100644
index 66fa3dc..0000000
--- a/dmp/gus.inc
+++ /dev/null
@@ -1,38 +0,0 @@
-MACRO   saveIRQ
-LOCAL   ll1,ll2
-        in      al,21h
-        mov     ah,al
-        in      al,0A1h
-        push    ax
-        push    cx
-        mov     cl,[gusIRQ]
-        mov     ah,1
-        test    cl,8
-        jnz     ll1
-        shl     ah,cl
-        in      al,21h
-        or      al,ah
-        out     21h,al
-        jmp     short ll2
-ll1:
-        and     cl,7
-        shl     ah,cl
-        in      al,0A1h
-        or      al,ah
-        out     0A1h,al
-ll2:
-        pop     cx
-ENDM
-
-MACRO   restoreIRQ
-LOCAL   ll1,ll2
-        pop     ax
-        out     0A1h,al
-        mov     al,ah
-        out     21h,al
-ENDM
-
-MACRO   DELAY
-        call    gusDelay
-ENDM
-
diff --git a/dmp/gus.pas b/dmp/gus.pas
deleted file mode 100644
index b5baf3c..0000000
--- a/dmp/gus.pas
+++ /dev/null
@@ -1,316 +0,0 @@
-{ -------------------------------------------------------------------------- }
-{                                                                            }
-{                                  GUS.PAS                                   }
-{                                  -------                                   }
-{                                                                            }
-{                         (C) 1993 Jussi Lahdenniemi                         }
-{        Original C files (C) 1993 Otto Chrons                               }
-{                                                                            }
-{ GUS interface for DSMI                                                     }
-{ and GUS heap manager                                                       }
-{                                                                            }
-{ -------------------------------------------------------------------------- }
-
-{$I-,R-,X+,F+}
-
-Unit gus;
-
-Interface
-uses mcp,cdi;
-
-const MAXSAMPLE = 128;
-
-Var sampleList       : array[0..MAXSAMPLE-1] of record
-      origSample     : longint;
-      gusSample      : longint;
-    end;
-    sampleListLength : longint;
-    gusDeltaTime     : longint;
-
-const   ID_GUS = 10;
-
-Function  gusInit(scard:PSoundCard):integer;
-Procedure gusClose;
-Function  gusStartVoice:integer;
-Function  gusStopVoice:integer;
-Function  gusPeek(addr:longint):byte;
-Procedure gusPoke(addr:longint;value:longint);
-Function  gusGetSamplingRate:word;
-
-Function  gusGetDelta:Longint;
-Procedure gusPoll(time:Longint);
-Function  gusPauseChannel(Channel:longint):Integer;
-Function  gusResumeChannel(Channel:longint):Integer;
-Function  gusStopChannel(Channel:longint):Integer;
-Function  gusPauseAll:Integer;
-Function  gusResumeAll:Integer;
-Function  gusSetSample(channel:longint;s:PSampleInfo):Integer;
-Function  gusPlaySample(channel:longint;rate:Longint;volume:longint):Integer;
-Function  gusSetVolume(channel:longint;Volume:longint):Integer;
-Function  gusSetRate(channel:longint;Rate:Longint):Integer;
-Function  gusSetPosition(channel:longint;Position:Longint):Integer;
-Procedure gusSetPanning(channel,panning:longint);
-Function  gusSetMasterVolume(Volume:longint):Integer;
-Procedure gusDownload(ptr:pointer;tag,length:longint);
-Procedure gusUnload(sample:pointer);
-Procedure gusUnloadAll;
-Function  gusGetVolume(channel:longint):integer;
-Function  gusGetRate(channel:longint):longint;
-Function  gusGetPosition(channel:longint):longint;
-Function  gusGetPanning(channel:longint):longint;
-Function  gusGetSample(channel:longint):pointer;
-Function  gusSetupChannels(count:longint;volTable:pointer):integer;
-
-Const CDI_GUS        : TCDIdevice = (
-    setsample        : @gusSetSample;
-    playsample       : @gusPlaySample;
-    setvolume        : @gusSetVolume;
-    setfrequency     : @gusSetRate;
-    setlinearrate    : @nullFunction;
-    setposition      : @gusSetPosition;
-    setpanning       : @gusSetPanning;
-    setmastervolume  : @gusSetMasterVolume;
-    pausechannel     : @gusPauseChannel;
-    resumechannel    : @gusResumeChannel;
-    stopchannel      : @gusStopChannel;
-    pauseall         : @gusPauseAll;
-    resumeall        : @gusResumeAll;
-    poll             : @gusPoll;
-    getdelta         : @gusGetDelta;
-    download         : @gusDownload;
-    unload           : @gusUnloadAll;
-    getvolume        : @gusGetVolume;
-    getfrequency     : @gusGetRate;
-    getposition      : @gusGetPosition;
-    getpan           : @gusGetPanning;
-    getsample        : @gusGetSample;
-    setupch          : @gusSetupChannels);
-
-     CDI_GUSDPMIV86  : TCDIdevice = (
-    setsample        : @gusSetSample;
-    playsample       : @gusPlaySample;
-    setvolume        : @gusSetVolume;
-    setfrequency     : @gusSetRate;
-    setlinearrate    : @nullFunction;
-    setposition      : @gusSetPosition;
-    setpanning       : @gusSetPanning;
-    setmastervolume  : @gusSetMasterVolume;
-    pausechannel     : @gusPauseChannel;
-    resumechannel    : @gusResumeChannel;
-    stopchannel      : @gusStopChannel;
-    pauseall         : @gusPauseAll;
-    resumeall        : @gusResumeAll;
-    poll             : @gusPoll;
-    getdelta         : @gusGetDelta;
-    download         : @gusDownload{V86};
-    unload           : @gusUnloadAll;
-    getvolume        : @gusGetVolume;
-    getfrequency     : @gusGetRate;
-    getposition      : @gusGetPosition;
-    getpan           : @gusGetPanning;
-    getsample        : @gusGetSample;
-    setupch          : @gusSetupChannels);
-
-{ GUS heap manager }
-
-type PGUSH              = ^TGUSH;
-     TGUSH              = longint;
-
-     PGHandle           = ^TGHandle;
-     TGHandle           = Record
-       handle           : TGUSH;
-       start,size       : longint;
-       next,prev        : PGHandle;
-     end;
-
-Const GUS_MEMORY = -1;
-
-function  gushmInit:integer;
-procedure gushmClose;
-procedure gushmFreeAll;
-function  gushmAlloc(size:longint):TGUSH;
-procedure gushmFree(handle:TGUSH);
-procedure gushmShowHeap;
-
-Implementation
-{$IFNDEF DPMI}
-uses csupport;
-{$ELSE}
-uses csupport,dpmiapi;
-{$ENDIF}
-
-Function  gusInit(scard:PSoundCard):integer; external;
-Procedure gusClose; external;
-Function  gusStartVoice:integer; external;
-Function  gusStopVoice:integer; external;
-Function  gusPeek(addr:longint):byte; external;
-Procedure gusPoke(addr:longint;value:longint); external;
-Function  gusGetSamplingRate:word; external;
-
-Function  gusGetDelta:Longint; external;
-Procedure gusPoll(time:Longint); external;
-Function  gusPauseChannel(channel:longint):Integer; external;
-Function  gusResumeChannel(channel:longint):Integer; external;
-Function  gusStopChannel(channel:longint):Integer; external;
-Function  gusPauseAll:Integer; external;
-Function  gusResumeAll:Integer; external;
-Function  gusSetSample(channel:longint;s:PSampleInfo):Integer; external;
-Function  gusPlaySample(channel:longint;rate:Longint;volume:longint):Integer; external;
-Function  gusSetVolume(channel:longint;Volume:longint):Integer; external;
-Function  gusSetRate(channel:longint;Rate:Longint):Integer; external;
-Function  gusSetPosition(channel:longint;Position:Longint):Integer; external;
-Procedure gusSetPanning(channel,panning:longint); external;
-Function  gusSetMasterVolume(Volume:longint):Integer; external;
-Procedure gusDownload(ptr:pointer;tag,length:longint); external;
-Procedure gusUnload(sample:pointer); external;
-Procedure gusUnloadAll; external;
-Function  gusGetVolume(channel:longint):integer; external;
-Function  gusGetRate(channel:longint):longint; external;
-Function  gusGetPosition(channel:longint):longint; external;
-Function  gusGetPanning(channel:longint):longint; external;
-Function  gusGetSample(channel:longint):pointer; external;
-Function  gusSetupChannels(count:longint;volTable:pointer):integer; external;
-
-{$L gus.obj}
-
-{ GUS Heap Manager }
-
-const first     : PGHandle = nil;
-      last      : PGHandle = nil;
-      locked    : PGHandle = nil;
-      status    : integer  = 0;
-      nextHandle: TGUSH    = 0;
-
-var   frame     : pointer;
-
-function findHandle(which:TGUSH):PGHandle;
-var handle:PGHandle;
-begin
-  handle:=first;
-  if which=0 then begin findHandle:=nil; exit end;
-  while handle^.next<>nil do begin
-    if handle^.handle=which then begin findHandle:=handle; exit end;
-    handle:=handle^.next;
-  end;
-  findHandle:=nil;
-end;
-
-function gushmInit:integer;
-var a    : word;
-begin
-  first:=malloc(sizeof(TGHandle));
-  last:=malloc(sizeof(TGHandle));
-  first^.handle:=32;
-  first^.start:=32;
-  first^.size:=0;
-  first^.next:=last;
-  first^.prev:=nil;
-  move(first^,last^,sizeof(TGHandle));
-  last^.next:=nil;
-  last^.prev:=first;
-  gusPoke(longint(257)*longint(1024),$55);
-  a:=256;
-  if gusPeek(longint(257)*longint(1024))=$55 then begin
-    a:=512;
-    gusPoke(longint(513)*longint(1024),$55);
-    if gusPeek(longint(513)*longint(1024))=$55 then a:=1024;
-  end;
-  last^.handle:=longint(1024)*longint(a);
-  last^.start:=last^.handle;
-  status:=1;
-  gushmInit:=0;
-end;
-
-procedure gushmClose;
-var handle,h : PGHandle;
-begin
-  handle:=first;
-  if status<>1 then exit;
-  status:=0;
-  while handle<>nil do begin
-    h:=handle^.next;
-    free(handle);
-    handle:=h;
-  end;
-end;
-
-procedure gushmFreeAll;
-var handle,h : PGHandle;
-begin
-  handle:=first^.next;
-  if status<>1 then exit;
-  while handle^.next<>nil do begin
-    h:=handle^.next;
-    free(handle);
-    handle:=h;
-  end;
-  first^.next:=last;
-  last^.prev:=first;
-end;
-
-function gushmAlloc(size:longint):TGUSH;
-var newHandle,handle,best : PGHandle;
-    bestSize,a,b          : longint;
-    align                 : integer;
-begin
-  if status<>1 then begin gushmAlloc:=-1; exit end;
-  handle:=first;
-  best:=first;
-  bestSize:=33554432; { 32 MB }
-  align:=0;
-  size:=(size+32) and not longint(31);
-  while handle^.next<>nil do begin
-    a:=handle^.next^.start-(handle^.start+handle^.size);
-    if (handle^.start+handle^.size) div 262144 <>
-       (handle^.start+handle^.size+size) div 262144 then begin
-      a:=handle^.next^.start-((handle^.start+handle^.size+size) and not longint(262143));
-      if (a>size) and (a<bestSize) then begin
-        bestSize:=a;
-        best:=handle;
-        align:=1;
-      end;
-    end else
-    if (a>size) and (a<bestSize) then begin
-      bestSize:=a;
-      best:=handle;
-      align:=0;
-    end;
-    handle:=handle^.next;
-  end;
-  newHandle:=malloc(sizeof(TGHandle));
-  if newHandle=nil then begin gushmAlloc:=GUS_MEMORY; exit end;
-  newHandle^.next:=best^.next;
-  best^.next:=newHandle;
-  newHandle^.prev:=best;
-  newHandle^.next^.prev:=newHandle;
-  if align>0 then newHandle^.start:=(best^.start+best^.size+size) and not longint(262143)
-    else newHandle^.start:=best^.start+best^.size;
-  newHandle^.size:=size;
-  newHandle^.handle:=newHandle^.start;
-  gushmAlloc:=newHandle^.start;
-end;
-
-procedure gushmFree(handle:TGUSH);
-var h:PGHandle;
-begin
-  if status<>1 then exit;
-  h:=findHandle(handle);
-  if h=nil then exit;
-  h^.prev^.next:=h^.next;
-  h^.next^.prev:=h^.prev;
-  free(h);
-end;
-
-procedure gushmShowHeap;                { Debugging function }
-var h:PGHandle;
-begin
-  if status<>1 then exit;
-  h:=first;
-  writeln('GUS Heap:');
-  while (h^.next<>nil) do with h^ do begin
-    writeln('Start: ',start,', size: ',size,', end: ',start+size,', handle: ',handle);
-    h:=next;
-  end;
-end;
-
-end.
diff --git a/dmp/gus.tpp b/dmp/gus.tpp
deleted file mode 100644
index c3d770c..0000000
Binary files a/dmp/gus.tpp and /dev/null differ
diff --git a/dmp/loaders.pas b/dmp/loaders.pas
index a458eb0..b9cddb8 100644
--- a/dmp/loaders.pas
+++ b/dmp/loaders.pas
@@ -1,73 +1,5 @@
-(***************************************************************************
-
-                                 LOADERS.PAS
-                                 -----------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-ampFreeModule function and order constants
-
-***************************************************************************)
-
-Unit Loaders;
-
-{$O+}
-
-Interface
-uses AMP, CSupport, crt
- {$IFDEF USE_EMS} ,emhm {$ENDIF};
-
-Var LoadOptions : Integer;
-
-const order4:array[0..3] of shortint = (PAN_Left,PAN_Right,PAN_Right,PAN_Left);
-      order6:array[0..5] of shortint = (PAN_Left,PAN_Right,PAN_Right,PAN_Left,PAN_Left,PAN_Right);
-      order8:array[0..7] of shortint = (PAN_Left,PAN_Right,PAN_Right,PAN_Left,PAN_Left,PAN_Right,PAN_Right,PAN_Left);
-
-Procedure ampFreeModule(var module:PModule);
-
-Implementation
-
-Procedure ampFreeModule;
-var t,i   : integer;
-    ptr   : pointer;
-Begin
-  if module=nil then exit;
-  if module^.modType<>0 then begin
-    if module^.patterns<>nil then free(pointer(module^.patterns));
-    if module^.instruments<>nil then begin
-      if module^.instrumentCount>0 then
-      for t:=0 to module^.instrumentCount-1 do
-        begin
-         ptr:=module^.instruments^[t].sample;
-{$IFDEF USE_EMS}
-         if seg(ptr^)=$FFFF then emsfree(ofs(ptr^))
-         else
-{$ENDIF} if ptr<>nil then
-          begin
-           if t>0 then
-            for i:=0 to t-1 do
-             if ptr=module^.instruments^[i].sample then begin ptr:=nil; i:=t-1 end;
-           if ptr<>nil then free(ptr);
-          end;
-        end;
-      free(pointer(module^.instruments));
-    end;
-    if module^.tracks<>nil then begin
-      for t:=1 to module^.trackCount do begin
-        ptr:=module^.tracks^[t];
-        if t>1 then
-        for i:=1 to t-1 do
-          if ptr=module^.tracks^[i] then begin
-            ptr:=nil;
-            i:=t-1;
-          end;
-        if ptr<>nil then free(ptr);
-      end;
-      free(pointer(module^.tracks));
-    end;
-  end;
-  free(module);
-  module:=nil;
-end;
-
-end.
+unit loaders;
+{$O+}
+interface
+implementation
+end.
diff --git a/dmp/loaders.tpp b/dmp/loaders.tpp
deleted file mode 100644
index bd66236..0000000
Binary files a/dmp/loaders.tpp and /dev/null differ
diff --git a/dmp/loadm.pas b/dmp/loadm.pas
deleted file mode 100644
index 44f0e92..0000000
--- a/dmp/loadm.pas
+++ /dev/null
@@ -1,157 +0,0 @@
-(***************************************************************************
-
-                                  LOADM.PAS
-                                  ---------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-ampLoadModule function
-Original C version by Otto Chrons
-
-***************************************************************************)
-
-Unit LoadM; {$I-}
-
-{$O+}
-
-Interface
-Uses AMP,Loaders,S3Mload,STMload,MODload,AMFload,_669load,MTMload,Csupport;
-
-Var moduleError:Integer;
-
-Function  ampLoadModule(Name:String;Options:longint):PModule;
-
-Implementation
-
-Function getType(var f:file; var module:PModule):Integer;
-var t  : integer;
-    l  : longint;
-begin
-  t:=0;
-  l:=0;
-  module^.modType:=MOD_NONE;
-  seek(f,0);
-  blockread(f,t,2);
-  if t=$6669 then begin
-    module^.modType:=MOD_669;
-    blockread(f,module^.name,32);
-    module^.name[31]:=#0;
-  end else begin
-  seek(f,0);
-  blockread(f,l,4);
-  if (l and $ffffff=$004D544D) then  begin
-    module^.modType:=MOD_MTM;
-    seek(f,0);
-    getType:=module^.modType;
-    exit;
-  end;
-  if (l and $ffffff=$00464D41) then begin
-    module^.modType:=MOD_AMF;
-    blockread(f,module^.name,20);
-    module^.name[20]:=#0;
-    module^.channelCount:=4;
-    move(order4,module^.channelPanning,4);
-  end else begin
-    seek(f,$2c);
-    blockread(f,l,4);
-    if l=$4D524353 then begin
-      module^.modType:=MOD_S3M;
-      seek(f,0);
-      blockread(f,module^.name,28);
-      module^.name[28]:=#0;
-    end else begin
-      seek(f,28);
-      blockread(f,t,2);
-      if t=$021A then begin
-        module^.modType:=MOD_STM;
-        seek(f,0);
-        blockread(f,module^.name,20);
-        module^.name[20]:=#0;
-        module^.channelCount:=4;
-        move(order4,module^.channelPanning,4);
-      end else begin
-        seek(f,1080);
-        blockread(f,l,4);
-        if (l=$2E4B2E4D) or (l=$34544C46) or (l=$214B214D) then begin
-          module^.modType:=MOD_MOD;
-          seek(f,0);
-          blockread(f,module^.name,20);
-          module^.name[20]:=#0;
-          module^.channelCount:=4;
-          move(order4,module^.channelPanning,4);
-        end else
-        if l=$38544C46 then begin
-          module^.modType:=MOD_TREK;
-          seek(f,0);
-          blockread(f,module^.name,20);
-          module^.name[20]:=#0;
-          module^.channelCount:=8;
-          move(order8,module^.channelPanning,8);
-        end else
-        if l=$4e484336 then begin
-          module^.modType:=MOD_MOD;
-          seek(f,0);
-          blockread(f,module^.name,20);
-          module^.name[20]:=#0;
-          module^.channelCount:=6;
-          move(order6,module^.channelPanning,6);
-        end else
-        if l=$4e484338 then begin
-          module^.modType:=MOD_MOD;
-          seek(f,0);
-          blockread(f,module^.name,20);
-          module^.name[20]:=#0;
-          module^.channelCount:=8;
-          move(order8,module^.channelPanning,8);
-        end else begin
-          module^.modType:=MOD_15;
-          seek(f,0);
-          blockread(f,module^.name,20);
-          module^.name[20]:=#0;
-          module^.channelCount:=4;
-          move(order4,module^.channelPanning,4);
-        end;
-      end;
-    end;
-  end;
-  end;
-  getType:=module^.modType;
-end;
-
-Function ampLoadModule;
-Var f       : file;
-    a,b,t,i : integer;
-    module  : PModule;
-    mem1    : Longint;
-begin
-  loadOptions:=options;
-  module:=malloc(sizeof(TModule));
-  if module=nil then begin
-    moduleError:=-1;
-    ampLoadModule:=nil;
-    exit;
-  end;
-  fillchar(module^,sizeof(TModule),0);
-  assign(f,name);
-  reset(f,1);
-  if IOresult<>0 then begin
-    moduleError:=-2;
-    ampLoadModule:=nil;
-    exit;
-  end;
-  a:=getType(f,module);
-  b:=-3;
-  if a=MOD_669 then b:=load669(f,module) else
-  if a=MOD_S3M then b:=loadS3M(f,module) else
-  if a=MOD_STM then b:=loadSTM(f,module) else
-  if (a=MOD_MOD) or (a=MOD_TREK) or (a=MOD_15) then b:=loadMOD(f,module) else
-  if a=MOD_AMF then b:=loadAMF(f,module) else
-  if a=MOD_MTM then b:=loadMTM(f,module) else
-  moduleError:=b;
-  if (b=MERR_NONE) or (b=MERR_CORRUPT) then module^.filesize:=filesize(f) else
-    ampFreeModule(module);
-  close(f);
-  ampLoadModule:=module;
-end;
-
-end.
diff --git a/dmp/loadm.tpp b/dmp/loadm.tpp
deleted file mode 100644
index 17112d1..0000000
Binary files a/dmp/loadm.tpp and /dev/null differ
diff --git a/dmp/masm.inc b/dmp/masm.inc
deleted file mode 100644
index 608fd09..0000000
--- a/dmp/masm.inc
+++ /dev/null
@@ -1,283 +0,0 @@
-
-;   /*\
-;---|*|----====< MASM.INC >====----
-;---|*|
-;---|*| Copyright (c) 1992, 1991, Media Vision, Inc.  All Rights Reserved.
-;---|*|
-;   \*/
-
-;---------------------------====< MASM Assembly >====--------------------------
-
-if @codesize
-  @ret equ 4
-  FFAR  equ     <far>
-else
-  @ret equ 2
-  FFAR  equ     <near>
-endif
-
-if @datasize
-  @ptr equ 4
-else
-  @ptr equ 2
-endif
-
-;
-; C convention stack parameters
-;
-wParm1          equ     [bp+2+@ret+00h]
-wParm2          equ     [bp+2+@ret+02h]
-wParm3          equ     [bp+2+@ret+04h]
-wParm4          equ     [bp+2+@ret+06h]
-wParm5          equ     [bp+2+@ret+08h]
-
-dParm1          equ     [bp+2+@ret+00h]
-dParm2          equ     [bp+2+@ret+04h]
-dParm3          equ     [bp+2+@ret+08h]
-dParm4          equ     [bp+2+@ret+0ch]
-
-;
-; miscellaneous equates & macros
-;
-; external data pointer
-;
-externPTR macro   nme           ;; this macro fixes a masm 5.10 bug that
-        if @datasize            ;; doesn't allow equate text replacement
-        extrn   nme:dword       ;; on the 'extrn' statements.
-        else
-        extrn   nme:word
-        endif
-        endm
-;
-; external code address
-;
-externADDR macro   nme          ;; this macro fixes a masm 5.10 bug that
-        if @codesize            ;; doesn't allow equate text replacement
-        extrn   nme:far         ;; on the 'extrn' statements.
-        else
-        extrn   nme:near
-        endif
-        endm
-
-bptr            equ     byte ptr
-wptr            equ     word ptr
-dptr            equ     dword ptr
-
-pause           equ     <jmp $+2>
-disable         equ     cli
-enable          equ     sti
-
-;
-; NEAR branches
-;
-jjnz    macro   addr
-        LOCAL   jjmp
-        jz      jjmp
-        jmp     addr
-jjmp:
-        endm
-
-jjz     macro   addr
-        LOCAL   jjmp
-        jnz     jjmp
-        jmp     addr
-jjmp:
-        endm
-
-jjc     macro   addr
-        LOCAL   jjmp
-        jnc     jjmp
-        jmp     addr
-jjmp:
-        endm
-
-jjnc    macro   addr
-        LOCAL   jjmp
-        jc      jjmp
-        jmp     addr
-jjmp:
-        endm
-
-jjb     macro   addr
-        LOCAL   jjmp
-        jae     jjmp
-        jmp     addr
-jjmp:
-        endm
-
-jjbe    macro   addr
-        LOCAL   jjmp
-        ja      jjmp
-        jmp     addr
-jjmp:
-        endm
-
-jja     macro   addr
-        LOCAL   jjmp
-        jbe     jjmp
-        jmp     addr
-jjmp:
-        endm
-
-bne     macro   label
-        LOCAL   jjmp
-        je      jjmp
-        jmp     label
-jjmp:
-        endm
-
-bnz     macro   label
-        LOCAL   jjmp
-        je      jjmp
-        jmp     label
-jjmp:
-        endm
-
-be      macro   label
-        LOCAL   jjmp
-        jne     jjmp
-        jmp     label
-jjmp:
-        endm
-
-bz      macro   label
-        LOCAL   jjmp
-        jne     jjmp
-        jmp     label
-jjmp:
-        endm
-
-bb      macro   label
-        LOCAL   jjmp
-        jae     jjmp
-        jmp     label
-jjmp:
-        endm
-
-ba      macro   label
-        LOCAL   jjmp
-        jbe     jjmp
-        jmp     label
-jjmp:
-        endm
-
-bbe     macro   label
-        LOCAL   jjmp
-        ja      jjmp
-        jmp     label
-jjmp:
-        endm
-
-bae     macro   label
-        LOCAL   jjmp
-        jb      jjmp
-        jmp     label
-jjmp:
-        endm
-
-bc      macro   label
-        LOCAL   jjmp
-        jnc     jjmp
-        jmp     label
-jjmp:
-        endm
-
-bnc     macro   label
-        LOCAL   jjmp
-        jc      jjmp
-        jmp     label
-jjmp:
-        endm
-
-bs      macro   label
-        LOCAL   jjmp
-        jns     jjmp
-        jmp     label
-jjmp:
-        endm
-
-;
-; multiple shift macro for 8088
-;
-shrm     macro   regmem,count
-        .errb   <count>
-        .errnz  count GT 16
-        rept    count
-        shr     regmem,1
-        endm
-        endm
-
-shlm     macro   regmem,count
-        .errb   <count>
-        .errnz  count GT 16
-        rept    count
-        shl     regmem,1
-        endm
-        endm
-
-;
-; push these registers
-;
-PUSHEM  MACRO   parm1,parm2,parm3,parm4,parm5,parm6,parm7,parm8,parm9
-        IFNB    <parm1>
-        push    parm1
-        ENDIF
-        IFNB    <parm2>
-        push    parm2
-        ENDIF
-        IFNB    <parm3>
-        push    parm3
-        ENDIF
-        IFNB    <parm4>
-        push    parm4
-        ENDIF
-        IFNB    <parm5>
-        push    parm5
-        ENDIF
-        IFNB    <parm6>
-        push    parm6
-        ENDIF
-        IFNB    <parm7>
-        push    parm7
-        ENDIF
-        IFNB    <parm8>
-        push    parm8
-        ENDIF
-        IFNB    <parm9>
-        push    parm9
-        ENDIF
-        ENDM
-;
-; pop these registers
-;
-POPEM   MACRO   parm1,parm2,parm3,parm4,parm5,parm6,parm7,parm8,parm9
-        IFNB    <parm9>
-        pop     parm9
-        ENDIF
-        IFNB    <parm8>
-        pop     parm8
-        ENDIF
-        IFNB    <parm7>
-        pop     parm7
-        ENDIF
-        IFNB    <parm6>
-        pop     parm6
-        ENDIF
-        IFNB    <parm5>
-        pop     parm5
-        ENDIF
-        IFNB    <parm4>
-        pop     parm4
-        ENDIF
-        IFNB    <parm3>
-        pop     parm3
-        ENDIF
-        IFNB    <parm2>
-        pop     parm2
-        ENDIF
-        IFNB    <parm1>
-        pop     parm1
-        ENDIF
-        ENDM
-
-
diff --git a/dmp/mcp.inc b/dmp/mcp.inc
deleted file mode 100644
index 60425bd..0000000
--- a/dmp/mcp.inc
+++ /dev/null
@@ -1,120 +0,0 @@
-; ************************************************************************
-; *
-; *     File        : MCP.INC
-; *
-; *     Description : Include file for assembly parts of MCP.
-; *
-; *     Copyright (C) 1992 Otto Chrons
-; *
-; ************************************************************************
-
-STRUC CHDATA
-    status      DW ?            ; bit 0 = playing status (1 = playing)
-                                ; bit 1 = looping
-                                ; bit 2 = paused
-                                ; bit 3 = valid sample loaded
-    sPtr        DD ?            ; sample's starting point
-    length      DD ?            ; sample's length in bytes
-    dLength     DD ?            ; how many bytes are played on each round
-    played      DD ?            ; how much of the sample is played
-    loopStart   DD ?            ;
-    loopEnd     DD ?            ; looping
-    volume      DB ?            ; 0 - 32
-    rate        DD ?            ; Real frequency
-    rateQuo     DW ?            ; relative frequency
-    rateRem     DW ?            ;   ( rate/sampling_rate )
-    saveQuo     DW ?
-    sampleID    DW ?
-    pan         DB ?
-ENDS
-
-STRUC   CARDINFO
-    ID          DB 0
-    ver         DW 0
-    cardname    DB 32 dup(0)
-    ioPort      DW 0
-    DMAIRQ      DB 0
-    DMAChannel  DB 0
-    minRate     DW 0
-    maxRate     DW 0
-    stereo      DB 0
-    mixer       DB 0
-    sampleSize  DB 0
-    extraField  DB 8
-ENDS
-
-STRUC SAMPLEINFO                        ; Same structure defined in MCP.H
-    voiceData   DD ?
-    length      DD ?
-    loopStart   DD ?
-    loopEnd     DD ?
-    mode        DB ?
-    sampleID    DW ?
-ENDS
-
-STRUC SOUNDDEVICE
-    initDevice  DD ?
-    initOutput  DD ?
-    initRate    DD ?
-    closeDevice DD ?
-    closeOutput DD ?
-    startOutput DD ?
-    stopOutput  DD ?
-    pauseOutput DD ?
-    resumeOutput DD ?
-    getBufferPos DD ?
-    speakerOn   DD ?
-    speakerOff  DD ?
-ENDS
-
-STRUC MCPSTRUC
-    samplingRate DW ?
-    options     DW ?
-    bufferSeg   DW ?
-IFDEF __32__
-    bufferBase	DD ?
-ENDIF
-    bufferLinear DD ?
-    bufferSize  DW ?
-    reqSize     DW ?
-ENDS
-
-        CH_PLAYING      = 1
-        CH_LOOPING      = 2
-        CH_PAUSED       = 4
-        CH_VALID        = 8
-
-        S_INIT          = 1
-        S_MCP           = 2
-        S_VOICE         = 4
-        S_PAUSE         = 8
-
-        ID_SOUNDBLASTER = 1
-        ID_SOUNDBLASTERPRO = 2
-
-        ID_SB           = 1
-        ID_SBPRO        = 2
-        ID_PAS          = 3
-        ID_PASPLUS      = 4
-        ID_PAS16        = 5
-        ID_SB16         = 6
-        ID_DAC          = 7
-        ID_ARIA         = 8
-        ID_WSS          = 9
-
-        MCP_QUALITY     = 1
-        MCP_486         = 2
-
-        SAMPLE_CONTINUE = 1
-
-        VOLUME_LINEAR   = 1
-        VOLUME_ANY      = 255
-
-        PAN_LEFT = -63
-        PAN_RIGHT = 63
-        PAN_MIDDLE = 0
-        PAN_SURROUND = 100
-
-        MAXCHANNEL      = 32
-        dataSize        = 2048+1024
-
diff --git a/dmp/mcp.pas b/dmp/mcp.pas
index f911d21..432d90c 100644
--- a/dmp/mcp.pas
+++ b/dmp/mcp.pas
@@ -1,243 +1,5 @@
-(****************************************************************************
-
-                                   MCP.PAS
-                                   -------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-Turbo/Borland pascal unit header file for MCP.
-Original C header by Otto Chrons
-
-****************************************************************************)
-
-Unit MCP;
-{$F+,R-}
-
-Interface
-uses CDI;
-
-Type PSampleinfo        = ^TSampleInfo;
-     TSampleInfo        = Record
-                            Sample      : Pointer;
-                            Length,
-                            Loopstart,
-                            Loopend     : Longint;
-                            Mode        : Byte;
-                            SampleID    : Word;
-                          End;
-
-      PSoundCard        = ^TSoundCard;
-      TSoundCard        = Record
-                            ID          : Byte;
-                            version     : Word;
-                            name        : Array[0..31] of char;
-                            IOPort      : Word;
-                            dmaIRQ      : Byte;
-                            dmaChannel  : Byte;
-                            minRate     : Word;
-                            maxRate     : Word;
-                            Stereo      : Boolean;
-                            mixer       : Boolean;
-                            sampleSize  : Byte;
-                            extraField  : array[0..7] of byte;
-                          End;
-
-      TSoundDevice      = Record
-                            InitDevice,
-                            InitOutput,
-                            InitRate,
-                            CloseDevice,
-                            CloseOutput,
-                            StopOutput,
-                            PauseOutput,
-                            ResumeOutput,
-                            GetBufferPos,
-                            SpeakerOn,
-                            SpeakerOff  : Pointer;
-                          End;
-
-      PMCPstruct        = ^TMCPstruct;
-      TMCPstruct        = Record
-                            SamplingRate: Word;
-                            Options     : Word;
-                            bufferSeg   : Word;
-                            bufferLinear: Longint;
-                            bufferSize  : Word;
-                            reqSize     : Word;
-                          End;
-
-      PMCPoutput        = ^TMCPoutput;
-      TMCPoutput        = Record
-                            position    : Word;
-                            start       : pointer;
-                            length      : Word;
-                          end;
-
-Const initStatus:BYTE=0;
-      channelCount:WORD=0;
-      dataBuf:WORD=0;
-
-Var SOUNDCARD:TSoundCard;
-    bufferSize:WORD;
-    mcpStatus:Byte;
-
-Type TSDI_Init          = Procedure;
-
-Const ID_SB               = 1;
-      ID_SBPRO            = 2;
-      ID_PAS              = 3;
-      ID_PASPLUS          = 4;
-      ID_PAS16            = 5;
-      ID_SB16             = 6;
-      ID_DAC              = 7;
-      ID_ARIA             = 8;
-      ID_WSS              = 9;
-      ID_GUS              = 10;
-
-      MCP_QUALITY         = 1;
-      MCP_486             = 2;
-      MCP_Mono            = 4;
-      MCP_TableSize       = 33*256*2+32;
-      MCP_QualitySize     = 2048*2+4096+16;
-
-      volume_Linear       = 1;
-      volume_Any          = 255;
-
-      sample_Continue     = 1;
-
-      CH_Playing          = 1;
-      CH_Looping          = 2;
-      CH_Paused           = 4;
-      CH_Valid            = 8;
-
-      PAN_Left            = -63;
-      PAN_Right           = 63;
-      PAN_Middle          = 0;
-      PAN_Surround        = 100;
-
-Function  mcpInit(MCPstruct:PMCPstruct):Integer;
-Function  mcpInitSoundDevice(sdi:TSDI_Init;SCard:PSoundCard):Integer;
-Procedure mcpClose;
-Procedure mcpOpenSpeaker;
-Procedure mcpCloseSpeaker;
-Function  mcpSetupChannels(Channels:longint;volTable:Pointer):Integer;
-Function  mcpStartVoice:Integer;
-Function  mcpStopVoice:Integer;
-Function  mcpPauseVoice:Integer;
-Function  mcpResumeVoice:Integer;
-Function  mcpGetDelta:Longint;
-Procedure mcpPoll(time:Longint);
-Procedure mcpClearBuffer;
-Function  mcpPauseChannel(Channel:longint):Integer;
-Function  mcpResumeChannel(Channel:longint):Integer;
-Function  mcpStopChannel(Channel:longint):Integer;
-Function  mcpPauseAll:Integer;
-Function  mcpResumeAll:Integer;
-Function  mcpGetChannelStatus(Channel:longint):Integer;
-Function  mcpGetChannelCount:Integer;
-Function  mcpSetSample(Channel:longint;s:PSampleInfo):Integer;
-Function  mcpPlaySample(channel:longint;rate:Longint;volume:longint):Integer;
-Function  mcpSetVolume(Channel:longint;Volume:longint):Integer;
-Function  mcpGetVolume(channel:longint):Word;
-Function  mcpGetPosition(channel:longint):Longint;
-Function  mcpGetSample(channel:longint):Pointer;
-Function  mcpGetRate(channel:longint):Longint;
-Function  mcpGetPanning(channel:longint):integer;
-Function  mcpSetRate(Channel:longint;Rate:Longint):Integer;
-Function  mcpSetPosition(Channel:longint;Position:Longint):Integer;
-Procedure mcpSetPanning(channel,panning:longint);
-Function  mcpSetSamplingRate(Sampling_Rate:longint):Integer;
-Function  mcpGetSamplingRate:Word;
-Function  mcpSetMasterVolume(Volume:longint):Integer;
-Procedure mcpConvertSample(Sample:Pointer;Length:Longint);
-Function  mcpGetOutput:PMCPoutput;
-
-Procedure mcpCalibrate; interrupt;
-Function  mcpCalibrateInit(delta,accuracy:longint):Integer;
-Procedure mcpCalibrateClose;
-
-Procedure nullfunction;
-Procedure mcpDownload;
-Procedure mcpUnloadAll;
-
-Const CDI_MCP : TCDIdevice = (
-    setsample        : @mcpSetSample;
-    playsample       : @mcpPlaySample;
-    setvolume        : @mcpSetVolume;
-    setfrequency     : @mcpSetRate;
-    setlinearrate    : @nullFunction;
-    setposition      : @mcpSetPosition;
-    setpanning       : @mcpSetPanning;
-    setmastervolume  : @mcpSetMasterVolume;
-    pausechannel     : @mcpPauseChannel;
-    resumechannel    : @mcpResumeChannel;
-    stopchannel      : @mcpStopChannel;
-    pauseall         : @mcpPauseAll;
-    resumeall        : @mcpResumeAll;
-    poll             : @mcpPoll;
-    getdelta         : @mcpGetDelta;
-    download         : @mcpDownload;
-    unload           : @mcpUnloadAll;
-    getvolume        : @mcpGetVolume;
-    getfrequency     : @mcpGetRate;
-    getposition      : @mcpGetPosition;
-    getpan           : @mcpGetPanning;
-    getsample        : @mcpGetSample;
-    setupch          : @mcpSetupChannels);
-
-Implementation
-{$IFDEF USE_EMS}
-uses mcpems;
-{$ELSE}
-uses mcpreala;
-{$ENDIF}
-
-{$L MCPlayer.OBJ}
-{$L CONVSAMP.OBJ}
-
-Function  mcpInit(MCPstruct:PMCPstruct):Integer; external;
-Function  mcpInitSoundDevice(sdi:TSDI_Init;SCard:PSoundCard):Integer; external;
-Procedure mcpClose; external;
-Procedure mcpOpenSpeaker; external;
-Procedure mcpCloseSpeaker; external;
-Function  mcpSetupChannels(Channels:longint;volTable:Pointer):Integer; external;
-Function  mcpStartVoice:Integer; external;
-Function  mcpStopVoice:Integer; external;
-Function  mcpPauseVoice:Integer; external;
-Function  mcpResumeVoice:Integer; external;
-Function  mcpGetDelta:Longint; external;
-Procedure mcpPoll(time:Longint); external;
-Procedure mcpClearBuffer; external;
-Function  mcpPauseChannel(Channel:longint):Integer; external;
-Function  mcpResumeChannel(Channel:longint):Integer; external;
-Function  mcpStopChannel(Channel:longint):Integer; external;
-Function  mcpPauseAll:Integer; external;
-Function  mcpResumeAll:Integer; external;
-Function  mcpGetChannelStatus(Channel:longint):Integer; external;
-Function  mcpGetChannelCount:Integer; external;
-Function  mcpSetSample(Channel:longint;s:PSampleInfo):Integer; external;
-Function  mcpPlaySample(channel:longint;rate:Longint;volume:longint):Integer; external;
-Function  mcpSetVolume(Channel:longint;Volume:longint):Integer; external;
-Function  mcpGetVolume(channel:longint):Word; external;
-Function  mcpGetPosition(channel:longint):Longint; external;
-Function  mcpGetSample(channel:longint):Pointer; external;
-Function  mcpGetRate(channel:longint):Longint; external;
-Function  mcpGetPanning(channel:longint):integer; external;
-Function  mcpSetRate(Channel:longint;Rate:Longint):Integer; external;
-Function  mcpSetPosition(Channel:longint;Position:Longint):Integer; external;
-Procedure mcpSetPanning(channel,panning:longint); external;
-Function  mcpSetSamplingRate(Sampling_Rate:longint):Integer; external;
-Function  mcpGetSamplingRate:Word; external;
-Function  mcpSetMasterVolume(Volume:longint):Integer; external;
-Procedure mcpConvertSample(Sample:Pointer;Length:Longint); external;
-Function  mcpGetOutput:PMCPoutput; external;
-
-Procedure mcpCalibrate; external;
-Function  mcpCalibrateInit(delta,accuracy:longint):Integer; external;
-Procedure mcpCalibrateClose; external;
-
-Procedure nullfunction; external;
-Procedure mcpDownload; external;
-Procedure mcpUnloadAll; external;
-
-end.
+unit MCP;
+
+interface
+implementation
+end.
diff --git a/dmp/mcp.tpp b/dmp/mcp.tpp
deleted file mode 100644
index ed4054d..0000000
Binary files a/dmp/mcp.tpp and /dev/null differ
diff --git a/dmp/mcpems.pas b/dmp/mcpems.pas
deleted file mode 100644
index 8b974d1..0000000
--- a/dmp/mcpems.pas
+++ /dev/null
@@ -1,39 +0,0 @@
-{ -------------------------------------------------------------------------- }
-{                                                                            }
-{                                 MCPEMS.PAS                                 }
-{                                 ----------                                 }
-{                                                                            }
-{                         (C) 1993 Jussi Lahdenniemi                         }
-{         Original C file (C) 1993 Otto Chrons                               }
-{                                                                            }
-{ MCP EMS handler                                                            }
-{                                                                            }
-{ -------------------------------------------------------------------------- }
-
-unit mcpems;
-
-interface
-
-function mcpSampleRealaddress(ID:longint;pos:longint):pointer;
-procedure mcpEnableVirtualSamples;
-procedure mcpDisableVirtualSamples;
-
-implementation
-uses emhm;
-
-function mcpSampleRealaddress(ID:longint;pos:longint):pointer;
-begin
-  mcpSampleRealaddress:=emsLock(ID,0,64000);
-end;
-
-procedure mcpEnableVirtualSamples;
-begin
-  emsSaveState;
-end;
-
-procedure mcpDisableVirtualSamples;
-begin
-  emsRestoreState;
-end;
-
-end.
diff --git a/dmp/mcpreala.asm b/dmp/mcpreala.asm
deleted file mode 100644
index 377174e..0000000
--- a/dmp/mcpreala.asm
+++ /dev/null
@@ -1,65 +0,0 @@
-;/************************************************************************
-; *
-; *     File        : MCPREALA.ASM
-; *
-; *     Description : Defines a null function mcpSampleRealAddress;
-; *
-; *     Copyright (C) 1992 Otto Chrons
-; *
-; ***********************************************************************
-;
-;       Revision history of MCPREAL.ASM
-;
-;       1.0     16.4.93
-;               First version. Returns a NULL pointer.
-;
-; ***********************************************************************/
-
-        IDEAL
-        JUMPS
-        P386
-
-        INCLUDE "MODEL.INC"
-
-CSEGMENTS MCPREALA
-
-CCODESEG MCPREALA
-
-        CPUBLIC  mcpSampleRealAddress
-        CPUBLIC  mcpEnableVirtualSamples
-        CPUBLIC  mcpDisableVirtualSamples
-
-
-;/*************************************************************************
-; *
-; *     Function    :   void far *mcpSampleRealAddress(int sampleID, long spos);
-; *
-; *     Description :   Null function you should override
-; *
-; *     Input       :   sampleID
-; *
-; *     Returns     :   pointer to real sample
-; *
-; ************************************************************************/
-
-CPROC    mcpSampleRealAddress @@sampleID, @@spos
-
-        sub     eax,eax                 ; Return NULL
-        mov     dx,ax
-
-        ret
-ENDP
-
-CPROC   mcpEnableVirtualSamples
-
-        ret
-ENDP
-
-CPROC   mcpDisableVirtualSamples
-
-        ret
-ENDP
-
-ENDS
-
-END
diff --git a/dmp/mcpreala.pas b/dmp/mcpreala.pas
deleted file mode 100644
index b6cf668..0000000
--- a/dmp/mcpreala.pas
+++ /dev/null
@@ -1,29 +0,0 @@
-{ -------------------------------------------------------------------------- }
-{                                                                            }
-{                                MCPREALA.PAS                                }
-{                                ------------                                }
-{                                                                            }
-{                         (C) 1993 Jussi Lahdenniemi                         }
-{                                                                            }
-{                                                                            }
-{ Pascal unit header for the null MCP real address functions                 }
-{                                                                            }
-{ -------------------------------------------------------------------------- }
-
-unit mcpreala;
-
-interface
-
-function mcpSampleRealAddress(id:longint;pos:longint):pointer;
-procedure mcpEnableVirtualSamples;
-procedure mcpDisableVirtualSamples;
-
-implementation
-
-function mcpSampleRealAddress(id:longint;pos:longint):pointer; external;
-procedure mcpEnableVirtualSamples; external;
-procedure mcpDisableVirtualSamples; external;
-
-{$L mcpreala.obj}
-
-end.
diff --git a/dmp/mcpreala.tpp b/dmp/mcpreala.tpp
deleted file mode 100644
index 388b335..0000000
Binary files a/dmp/mcpreala.tpp and /dev/null differ
diff --git a/dmp/mixer.asm b/dmp/mixer.asm
deleted file mode 100644
index fbbd841..0000000
--- a/dmp/mixer.asm
+++ /dev/null
@@ -1,645 +0,0 @@
-;/************************************************************************
-; *
-; *     File        : MIXER.ASM
-; *
-; *     Description : Mixer functions for sound cards
-; *
-; *     Copyright (C) 1992 Otto Chrons
-; *
-; ***********************************************************************
-;
-;       Revision history of MIXER.ASM
-;
-;       1.0     16.4.93
-;               First version. Mixer functions for SB Pro only.
-;
-; ***********************************************************************/
-
-                IDEAL
-                LOCALS
-                JUMPS
-                P386N
-
-;       L_PASCAL        = 1             ; Uncomment this for pascal-style
-
-IFDEF   L_PASCAL
-        LANG    EQU     PASCAL
-        MODEL TPASCAL
-ELSE
-        LANG    EQU     C
-        MODEL LARGE,C
-ENDIF
-        INCLUDE "MODEL.INC"
-
-        MIXER_SBPRO = 1
-
-        MIX_LEFT        = 40h
-        MIX_RIGHT       = 80h
-        MIX_BOTH        = MIX_LEFT OR MIX_RIGHT
-
-        MIX_IN_MIC      = 1
-        MIX_IN_CD       = 2
-        MIX_IN_LINE     = 3
-        MIX_FILTERHIGH  = 40h
-
-        MIX_FM_NORMAL   = 0
-        MIX_FM_LEFT     = 1
-        MIX_FM_RIGHT    = 2
-        MIX_FM_MUTE     = MIX_FM_RIGHT OR MIX_FM_LEFT
-
-        MIX_RESET       = 0
-        MIX_MASTERVOL   = 1
-        MIX_DACVOL      = 2
-        MIX_FMVOL       = 3
-        MIX_CDVOL       = 4
-        MIX_MICVOL      = 5
-        MIX_LINEVOL     = 6
-        MIX_STEREO      = 7
-        MIX_FILTEROUT   = 8
-        MIX_FILTERIN    = 9
-        MIX_INPUTLINE   = 10
-        MIX_FM_MODE     = 11
-
-        MIX_LASTFUNCT   = MIX_FM_MODE
-
-
-MACRO   checkInit
-
-        cmp     [mixerType],0
-        je      @@exit
-ENDM
-
-DATASEG
-
-        mixerType       DB ?
-        mixerBase       DW ?
-
-CODESEG
-
-        PUBLIC  mixerInit, mixerSet, mixerGet
-
-        LABEL SBMixerSet WORD
-            DW offset SBReset
-            DW offset SBMasterVolume
-            DW offset SBDACVolume
-            DW offset SBFMVolume
-            DW offset SBCDVolume
-            DW offset SBMicVolume
-            DW offset SBLineVolume
-            DW offset SBStereo
-            DW offset SBFilterOut
-            DW offset SBFilterIn
-            DW offset SBInputLine
-            DW offset SBFMMode
-
-        LABEL SBMixerGet WORD
-            DW offset NoFunc
-            DW offset SBGetMasterVolume
-            DW offset SBGetDACVolume
-            DW offset SBGetFMVolume
-            DW offset SBGetCDVolume
-            DW offset SBGetMicVolume
-            DW offset SBGetLineVolume
-            DW offset SBGetStereo
-            DW offset SBGetFilterOut
-            DW offset SBGetFilterIn
-            DW offset SBGetInputLine
-            DW offset SBGetFMMode
-
-;/*************************************************************************
-; *
-; *     Function    :   void mixerInit(uchar type, int ioBase);
-; *
-; *     Description :   Inits mixer functions
-; *
-; *     Input       :   type = sound card type; 1 = SB Pro
-; *                     ioBase = card's I/O base address; 220h or 240h for Pro
-; *
-; ************************************************************************/
-
-PROC    mixerInit FAR mixtype:BYTE,iobase:WORD
-
-        mov     bl,[mixtype]
-        cmp     bl,MIXER_SBPRO
-        je      @@sbpro
-        sub     bx,bx
-        sub     ax,ax
-        jmp     @@exit
-@@sbpro:
-        mov     ax,[iobase]
-        cmp     ax,220h
-        je      @@ok
-        cmp     ax,240h
-        je      @@ok
-        sub     ax,ax
-        jmp     @@exit
-@@ok:
-        add     ax,4                    ; Offset of mixer chip
-@@exit:
-        mov     [mixerType],bl
-        mov     [mixerBase],ax
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void mixerSet(int func, unsigned char value);
-; *
-; *     Description :   Sets mixer chip according to given values
-; *
-; *     Input       :   func = function number
-; *                     value = value to use
-; *
-; ************************************************************************/
-
-PROC    mixerSet FAR func:BYTE,value:BYTE
-
-        checkInit
-
-        cmp     [mixerType],MIXER_SBPRO
-        je      @@sbpro
-        jmp     @@exit
-@@sbpro:
-        sub     bh,bh
-        mov     bl,[func]
-        and     bl,03Fh                 ; mask out bits 6 & 7
-        cmp     bl,MIX_LASTFUNCT
-        jg      @@exit                  ; Is function valid
-        shl     bl,1
-        mov     al,[value]
-        mov     ah,[func]
-        call    [bx+SBMixerSet]  ; Call appropriate function
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   unsigned char mixerGet(int func);
-; *
-; *     Description :   Returns information about the mixer.
-; *
-; *     Input       :   func = function to read
-; *
-; *     Returns     :   Mixer chip value for given function.
-; *
-; ************************************************************************/
-
-PROC    mixerGet FAR func:BYTE
-
-        checkInit
-
-        sub     ax,ax
-        cmp     [mixerType],MIXER_SBPRO
-        je      @@sbpro
-        jmp     @@exit
-@@sbpro:
-        sub     bh,bh
-        mov     bl,[func]
-        and     bl,03Fh                 ; mask out bits 6 & 7
-        cmp     bl,MIX_LASTFUNCT
-        jg      @@exit                  ; Is function valid
-        shl     bl,1
-        mov     al,[value]
-        mov     ah,[func]
-        call    [bx+SBMixerGet] ; Call appropriate function
-@@exit:
-        ret
-ENDP
-
-
-;/*************************************************************************
-; *
-; *     Function    :   SBPset
-; *
-; *     Description :   Sets mixer chip
-; *
-; *     Input       :   AL = register port
-; *                     AH = data port
-; *
-; ************************************************************************/
-
-PROC    SBPset NEAR
-
-        push    dx
-        mov     dx,[mixerBase]
-        out     dx,al
-        inc     dx
-        mov     al,ah
-        out     dx,al
-        pop     dx
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   SBPget
-; *
-; *     Description :   Returns mixer chip value
-; *
-; *     Input       :   AL = register port
-; *
-; *     Returns     :   AL = data value
-; *
-; ************************************************************************/
-
-PROC    SBPget NEAR
-
-        push    dx
-        mov     dx,[mixerBase]
-        out     dx,al
-        inc     dx
-        in      al,dx
-        pop     dx
-
-        ret
-ENDP
-
-
-;/*************************************************************************
-; *
-; *     Function    :   SBReset
-; *
-; ************************************************************************/
-
-PROC    SBReset NEAR
-
-        mov     ax,0000                 ; Reset function is 0
-        call    SBPset
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   SBSetVolume
-; *
-; ************************************************************************/
-
-PROC    SBSetVolume NEAR
-
-SBMasterVolume:
-        mov     bh,22h                  ; Master vol
-        jmp     @@ok
-SBDACVolume:
-        mov     bh,04h                  ; VOC volume
-        jmp     @@ok
-SBFMVolume:
-        mov     bh,26h                  ; FM volume
-        jmp     @@ok
-SBLineVolume:
-        mov     bh,2Eh
-        jmp     @@ok
-SBCDVolume:
-        mov     bh,28h
-        or      ah,11000000b            ; Both channels
-        jmp     @@ok
-SBMicVolume:
-        mov     bh,0Ah
-        or      ah,11000000b            ; Both channels
-        shr     al,1                    ; Divide volume by 2
-        jmp     @@ok
-@@ok:
-        mov     cl,al                   ; Save AL
-        mov     al,bh
-        call    SBPget                  ; Get current volume
-        mov     bl,al                   ; BL = volume
-        test    ah,MIX_BOTH             ; Is either channel specified?
-        jnz     @@10
-        or      ah,MIX_BOTH             ; No, change both
-@@10:
-        test    ah,MIX_LEFT
-        jz      @@noleft
-        mov     al,cl                   ; CL = given volume
-        shl     al,4
-        and     bl,00001111b
-        or      bl,al                   ; Set left channel
-@@noleft:
-        test    ah,MIX_RIGHT
-        jz      @@noright
-        mov     al,cl
-        and     al,00001111b
-        and     bl,11110000b
-        or      bl,al
-@@noright:
-        mov     al,bh                   ; AL = function
-        mov     ah,bl                   ; AH = volume value
-        call    SBPset                  ; Set new volume
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   SBStereo
-; *
-; *     Description :   Sets stereo or mono mode
-; *
-; ************************************************************************/
-
-PROC    SBStereo NEAR
-
-        mov     bl,al
-        mov     al,0Eh
-        call    SBPget
-        and     al,11111101b            ; Set mono
-        cmp     bl,0
-        je      @@setMono
-        or      al,00000010b            ; Set stereo
-@@setMono:
-        mov     ah,al
-        mov     al,0Eh
-        call    SBPset
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   SBFilterOut
-; *
-; *     Description :   Enables/disables output filter
-; *
-; ************************************************************************/
-
-PROC    SBFilterOut NEAR
-
-        mov     bl,al
-        mov     al,0Eh
-        call    SBPget
-        and     al,11011111b            ; Enable filter
-        cmp     bl,1
-        je      @@enableFilter
-        or      al,00100000b            ; Disable filter
-@@enableFilter:
-        mov     ah,al
-        mov     al,0Eh
-        call    SBPset
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   SBFilterIn
-; *
-; *     Description :   Enables/disables input filter
-; *
-; ************************************************************************/
-
-PROC    SBFilterIn NEAR
-
-        mov     bl,al
-        mov     al,0Ch
-        call    SBPget
-        and     al,11011111b            ; Enable filter
-        cmp     bl,1
-        je      @@enableFilter
-        or      al,00100000b            ; Disable filter
-@@enableFilter:
-        mov     ah,al
-        mov     al,0Ch
-        call    SBPset
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   SBInputLine
-; *
-; *     Description :   Selects input line
-; *
-; ************************************************************************/
-
-PROC    SBInputLine NEAR
-
-        mov     bl,al
-        mov     bh,al
-        and     bl,3Fh                  ; Only the lower 6 bits
-        mov     al,0Ch
-        call    SBPget
-        and     al,11110000b
-        or      al,00000001b
-        cmp     bl,MIX_IN_MIC
-        je      @@done
-        or      al,00000010b
-        cmp     bl,MIX_IN_CD
-        je      @@done
-        or      al,00000100b            ; It must be MIX_IN_LINE
-@@done:
-        test    bh,MIX_FILTERHIGH
-        jz      @@filterLow
-        or      al,00001000b
-@@filterLow:
-        mov     ah,al
-        mov     al,0Ch
-        call    SBPset
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   SBFMMode
-; *
-; *     Description :   Sets FM chip's mode
-; *
-; ************************************************************************/
-
-PROC    SBFMMode NEAR
-
-        mov     bl,al
-        mov     al,26h
-        call    SBPget
-        push    ax                      ; Save FM volume
-        mov     al,06h
-        call    SBPget                  ; Get FM mode
-        and     al,10011111b
-        test    bl,MIX_FM_LEFT
-        jz      @@10
-        or      al,00100000b
-@@10:
-        test    bl,MIX_FM_RIGHT
-        jz      @@20
-        or      al,01000000b
-@@20:
-        mov     ah,al
-        mov     al,06h
-        call    SBPset                  ; Set FM mode
-        pop     ax
-        mov     ah,al
-        mov     al,26h
-        call    SBPset                  ; Restore FM volume
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   SBGetVolume
-; *
-; ************************************************************************/
-
-PROC    SBGetVolume NEAR
-
-SBGetMasterVolume:
-        mov     bh,22h                  ; Master vol
-        jmp     @@ok
-SBGetDACVolume:
-        mov     bh,04h                  ; VOC volume
-        jmp     @@ok
-SBGetFMVolume:
-        mov     bh,26h                  ; FM volume
-        jmp     @@ok
-SBGetLineVolume:
-        mov     bh,2Eh
-        jmp     @@ok
-SBGetCDVolume:
-        mov     bh,28h
-        or      ah,11000000b            ; Both channels
-        jmp     @@ok
-SBGetMicVolume:
-        mov     al,0Ah
-        call    SBPget
-        and     al,00001111b
-        shl     al,1
-        jmp     @@exit
-@@ok:
-        and     ah,11000000b
-        mov     cl,al
-        mov     al,bh
-        call    SBPget
-        cmp     ah,11000000b
-        jne     @@10
-        mov     ah,al
-        and     al,00001111b
-        shr     ah,4
-        add     al,ah
-        shr     al,1
-        jmp     @@exit
-@@10:
-        cmp     ah,10000000b
-        jne     @@20
-        and     al,00001111b
-        jmp     @@exit
-@@20:
-        shr     al,4
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   SBGetStereo
-; *
-; *     Description :   Is stereo or mono mode on?
-; *
-; ************************************************************************/
-
-PROC    SBGetStereo NEAR
-
-        mov     al,0Eh
-        call    SBPget
-        and     al,00000010b
-        shr     al,1
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   SBGetFilterOut
-; *
-; *     Description :   Returns output filter's status
-; *
-; ************************************************************************/
-
-PROC    SBGetFilterOut NEAR
-
-        mov     al,0Eh
-        call    SBPget
-        and     al,00100000b
-        rol     al,3                    ; AL = 1 if filter off
-        dec     al
-        neg     al                      ; AL = 0 if filter off
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   SBGetFilterIn
-; *
-; *     Description :   Returns input filter's status
-; *
-; ************************************************************************/
-
-PROC    SBGetFilterIn NEAR
-
-        mov     al,0Ch
-        call    SBPget
-        and     al,00100000b
-        rol     al,3                    ; AL = 1 if filter off
-        dec     al
-        neg     al                      ; AL = 0 if filter off
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   SBGetInputLine
-; *
-; *     Description :   Returns SB's input line selection
-; *
-; ************************************************************************/
-
-PROC    SBGetInputLine NEAR
-
-        mov     al,0Ch
-        call    SBPget
-        mov     ah,al
-        and     ah,01000000b            ; AH = filter high
-        mov     bl,3                    ; Assume line
-        test    al,4
-        jnz     @@exit
-        mov     bl,2
-        test    al,2
-        jnz     @@exit
-        mov     bl,1
-@@exit:
-        mov     al,bl
-        or      al,ah
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   SBGetFMMode
-; *
-; *     Description :   Returns FM chip's mode
-; *
-; ************************************************************************/
-
-PROC    SBGetFMMode NEAR
-
-        mov     al,06h
-        call    SBPget
-        rol     al,3
-        and     al,00000011b
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   NoFunc
-; *
-; *     Description :   Void function
-; *
-; ************************************************************************/
-
-PROC    NoFunc NEAR
-
-        ret
-ENDP
-
-
-END
diff --git a/dmp/mixer.pas b/dmp/mixer.pas
deleted file mode 100644
index 0ec1b87..0000000
--- a/dmp/mixer.pas
+++ /dev/null
@@ -1,60 +0,0 @@
-(****************************************************************************
-
-                                    MIXER.PAS
-                                    ---------
-
-                           (C) 1993 Jussi Lahdenniemi
-
-Turbo/Borland pascal unit header file for mixer routines.
-Original C header by Otto Chrons
-
-****************************************************************************)
-
-Unit mixer;
-
-Interface
-
-Procedure mixerinit(t:byte;ioBase:word);
-Procedure mixerset(func:integer;value:byte);
-Function  mixerget(func:integer):byte;
-
-Const   MIXER_SBPRO     = 1;
-
-	MIX_LEFT	= $40;
-	MIX_RIGHT	= $80;
-	MIX_BOTH	= MIX_LEFT OR MIX_RIGHT;
-
-	MIX_IN_MIC	= 1;
-	MIX_IN_CD	= 2;
-	MIX_IN_LINE	= 3;
-	MIX_FILTERHIGH	= $40;
-
-	MIX_FM_NORMAL	= 0;
-	MIX_FM_LEFT	= 1;
-	MIX_FM_RIGHT	= 2;
-	MIX_FM_MUTE	= MIX_FM_RIGHT OR MIX_FM_LEFT;
-
-	MIX_RESET	= 0;
-	MIX_MASTERVOL	= 1;
-	MIX_DACVOL 	= 2;
-	MIX_FMVOL 	= 3;
-	MIX_CDVOL	= 4;
-	MIX_MICVOL	= 5;
-	MIX_LINEVOL	= 6;
-	MIX_STEREO	= 7;
-	MIX_FILTEROUT	= 8;
-	MIX_FILTERIN	= 9;
-	MIX_INPUTLINE	= 10;
-	MIX_FM_MODE	= 11;
-
-	MIX_LASTFUNCT	= MIX_FM_MODE;
-
-Implementation
-
-Procedure mixerInit(t:byte;ioBase:word); External;
-Procedure mixerSet(func:integer;value:byte); External;
-Function  mixerGet(func:integer):byte; External;
-
-{$L MIXER.OBJ}
-
-End.
diff --git a/dmp/mixer.tpp b/dmp/mixer.tpp
deleted file mode 100644
index 56e277c..0000000
Binary files a/dmp/mixer.tpp and /dev/null differ
diff --git a/dmp/model.inc b/dmp/model.inc
deleted file mode 100644
index 9028e62..0000000
--- a/dmp/model.inc
+++ /dev/null
@@ -1,761 +0,0 @@
-;****************************************************************************;
-;*                                                                          *;
-;* File:        MODEL.INC                                                   *;
-;*                                                                          *;
-;****************************************************************************;
-
-IDEAL
-
-STRUC   _byte
-	b       DB      ?
-ENDS
-
-STRUC   _word
-	w       DW      ?
-ENDS
-
-STRUC   _dword
-	d       DD      ?
-ENDS
-
-
-IFDEF __C32__
-
-_FAR            EQU     NEAR
-_OFS            EQU     DWORD
-_OFSM           EQU     DD
-
-_char           EQU     _dword
-D_char          EQU     DD
-_short          EQU     _dword
-D_short         EQU     DD
-_int            EQU     _dword
-D_int           EQU     DD
-_long           EQU     _dword
-D_long          EQU     DD
-_ptr            EQU     _dword
-D_ptr           EQU     DD
-__32__ = 1
-_instack = 8
-locs = 0
-_AX             EQU     eax
-_BX             EQU     ebx
-_CX             EQU     ecx
-_DX             EQU     edx
-_SI             EQU     esi
-_DI             EQU     edi
-_SP             EQU     esp
-_BP             EQU     ebp
-
-MACRO   LDSSI   val
-        mov     esi,val
-ENDM
-
-MACRO   LDSDI   val
-        mov     edi,val
-ENDM
-
-MACRO   LDSBX   val
-        mov     ebx,val
-ENDM
-
-MACRO   LESSI   val
-        mov     esi,val
-ENDM
-
-MACRO   LESDI   val
-	mov     edi,val
-ENDM
-
-MACRO   LESBX   val
-        mov     ebx,val
-ENDM
-
-ESDI    equ     EDI
-ESSI    equ     ESI
-ESBX    equ     EBX
-
-MACRO   PUSHDS
-ENDM
-
-MACRO   POPDS
-ENDM
-
-MACRO   PUSHES
-ENDM
-
-MACRO   POPES
-ENDM
-
-MACRO   PUSHCS
-ENDM
-
-MACRO   _segcs
-ENDM
-
-MACRO   _segds
-ENDM
-
-MACRO   _segss
-ENDM
-
-MACRO   _seges
-ENDM
-
-MACRO   IF32    a1
-        &a1
-ENDM
-
-MACRO   IF16    a1
-ENDM
-
-ELSE
-; IFDEF  __C16__ OR __PASCAL__
-
-_FAR            EQU     FAR
-_OFS            EQU     WORD
-_OFSM           EQU     DW
-
-_char           EQU     _word
-D_char          EQU     DW
-_short          EQU     _word
-D_short         EQU     DW
-_int            EQU     _word
-D_int           EQU     DW
-_long           EQU     _dword
-D_long          EQU     DD
-_ptr            EQU     _dword
-D_ptr           EQU     DD
-__16__ = 1
-_instack = 6
-locs = 0
-_AX             EQU     ax
-_BX             EQU     bx
-_CX             EQU     cx
-_DX             EQU     dx
-_SI             EQU     si
-_DI             EQU     di
-_SP             EQU     sp
-_BP             EQU     bp
-
-MACRO   LDSSI   val
-        lds     si,val
-ENDM
-
-MACRO   LDSDI   val
-        lds     di,val
-ENDM
-
-MACRO   LDSBX   val
-        lds     bx,val
-ENDM
-
-MACRO   LESSI   val
-        les     si,val
-ENDM
-
-MACRO   LESDI   val
-        les     di,val
-ENDM
-
-MACRO   LESBX   val
-        les     bx,val
-ENDM
-
-ESDI    equ     ES:DI
-ESSI    equ     ES:SI
-ESBX    equ     ES:BX
-
-MACRO   PUSHDS
-        push    ds
-ENDM
-
-MACRO   POPDS
-        pop     ds
-ENDM
-
-MACRO   PUSHES
-        push    es
-ENDM
-
-MACRO   POPES
-        pop     es
-ENDM
-
-MACRO   PUSHCS
-        push    cs
-ENDM
-
-MACRO   _segcs
-        segcs
-ENDM
-
-MACRO   _segds
-        segds
-ENDM
-
-MACRO   _segss
-        segss
-ENDM
-
-MACRO   _seges
-        seges
-ENDM
-
-MACRO   IF32    a1
-ENDM
-
-MACRO   IF16    a1
-        &a1
-ENDM
-
-ELSE
-ERR "You must define a compiler (__C32__, __C16__ or __PASCAL__)"
-ENDIF
-
-
-MACRO   STACKARG        name
-LOCAL   a
-
-	a = args + _instack
-
-  IFDEF __32__
-	&name   EQU     <DWORD ebp+&a>
-  ENDIF
-
-  IFDEF __16__
-	&name   EQU     <DWORD bp+&a>
-  ENDIF
-	args = args + 4
-ENDM
-
-
-
-MACRO   CPROC   procname, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, ax
-LOCAL   an
-
-  IFNB <ax>
-    ERR "Too many arguments"
-  ENDIF
-
-  IFDEF __C32__
-        PROC    _&procname      NEAR
-  ELSE
-  IFDEF __PASCAL__
-      PROC      procname        FAR
-  ELSE
-      PROC      _&procname      FAR
-  ENDIF
-  ENDIF
-        args = 0
-        procargs = 0
-        locs = 0
-IFDEF __PASCAL__
-        IFNB <a10>
-          STACKARG  &a10
-          procargs = procargs + 4
-        ENDIF
-        IFNB <a9>
-          STACKARG  &a9
-          procargs = procargs + 4
-        ENDIF
-        IFNB <a8>
-          STACKARG  &a8
-          procargs = procargs + 4
-        ENDIF
-        IFNB <a7>
-          STACKARG  &a7
-          procargs = procargs + 4
-        ENDIF
-        IFNB <a6>
-          STACKARG  &a6
-          procargs = procargs + 4
-        ENDIF
-        IFNB <a5>
-	  STACKARG  &a5
-          procargs = procargs + 4
-        ENDIF
-        IFNB <a4>
-          STACKARG  &a4
-          procargs = procargs + 4
-        ENDIF
-        IFNB <a3>
-          STACKARG  &a3
-          procargs = procargs + 4
-        ENDIF
-        IFNB <a2>
-          STACKARG  &a2
-          procargs = procargs + 4
-        ENDIF
-        IFNB <a1>
-          STACKARG  &a1
-          procargs = procargs + 4
-        ENDIF
-ELSE
-        IFNB <a1>
-          STACKARG  &a1
-          procargs = procargs + 4
-        ENDIF
-        IFNB <a2>
-          STACKARG  &a2
-          procargs = procargs + 4
-        ENDIF
-        IFNB <a3>
-          STACKARG  &a3
-          procargs = procargs + 4
-        ENDIF
-        IFNB <a4>
-          STACKARG  &a4
-          procargs = procargs + 4
-        ENDIF
-        IFNB <a5>
-          STACKARG  &a5
-          procargs = procargs + 4
-        ENDIF
-        IFNB <a6>
-          STACKARG  &a6
-          procargs = procargs + 4
-        ENDIF
-	IFNB <a7>
-          STACKARG  &a7
-          procargs = procargs + 4
-        ENDIF
-        IFNB <a8>
-          STACKARG  &a8
-          procargs = procargs + 4
-        ENDIF
-        IFNB <a9>
-          STACKARG  &a9
-          procargs = procargs + 4
-        ENDIF
-        IFNB <a10>
-          STACKARG  &a10
-          procargs = procargs + 4
-        ENDIF
-ENDIF
-ENDM
-
-
-MACRO   ENTERPROC       r1,r2,r3,r4,r5,r6
-        enter   (locs+3)/4*4,0
-        IFNB <r1>
-        push    r1 r2 r3 r4 r5 r6
-        ENDIF
-ENDM
-
-
-MACRO   LEAVEPROC       r1,r2,r3,r4,r5,r6
-        IFNB <r1>
-        pop     r6 r5 r4 r3 r2 r1
-        ENDIF
-        leave
-IFDEF __PASCAL__
-        ret     procargs
-ELSE
-        ret
-ENDIF
-ENDM
-
-
-MACRO   CPUBLIC p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
-
-IFDEF   __PASCAL__
-	IFNB <p1>
-            PUBLIC      p1
-        ENDIF
-        IFNB <p2>
-            PUBLIC      p2
-        ENDIF
-        IFNB <p3>
-            PUBLIC      p3
-        ENDIF
-        IFNB <p4>
-            PUBLIC      p4
-        ENDIF
-        IFNB <p5>
-            PUBLIC      p5
-        ENDIF
-        IFNB <p6>
-            PUBLIC      p6
-        ENDIF
-        IFNB <p7>
-            PUBLIC      p7
-        ENDIF
-        IFNB <p8>
-            PUBLIC      p8
-        ENDIF
-        IFNB <p9>
-            PUBLIC      p9
-        ENDIF
-        IFNB <p10>
-            PUBLIC      p10
-        ENDIF
-ELSE
-        IFNB <p1>
-            PUBLIC      _&p1
-        ENDIF
-        IFNB <p2>
-            PUBLIC      _&p2
-        ENDIF
-        IFNB <p3>
-            PUBLIC      _&p3
-        ENDIF
-        IFNB <p4>
-            PUBLIC      _&p4
-        ENDIF
-	IFNB <p5>
-            PUBLIC      _&p5
-        ENDIF
-        IFNB <p6>
-            PUBLIC      _&p6
-        ENDIF
-        IFNB <p7>
-            PUBLIC      _&p7
-        ENDIF
-        IFNB <p8>
-            PUBLIC      _&p8
-        ENDIF
-        IFNB <p9>
-            PUBLIC      _&p9
-        ENDIF
-        IFNB <p10>
-            PUBLIC      _&p10
-        ENDIF
-ENDIF
-
-ENDM
-
-MACRO   CGLOBAL p1,p2,p3,p4,p5,p6,p7,p8,p9,p10
-
-IFDEF   __PASCAL__
-        IFNB <p1>
-            GLOBAL      p1
-        ENDIF
-        IFNB <p2>
-            GLOBAL      p2
-        ENDIF
-        IFNB <p3>
-            GLOBAL      p3
-        ENDIF
-        IFNB <p4>
-            GLOBAL      p4
-        ENDIF
-        IFNB <p5>
-            GLOBAL      p5
-        ENDIF
-        IFNB <p6>
-            GLOBAL      p6
-        ENDIF
-        IFNB <p7>
-	    GLOBAL      p7
-        ENDIF
-        IFNB <p8>
-            GLOBAL      p8
-        ENDIF
-        IFNB <p9>
-            GLOBAL      p9
-        ENDIF
-        IFNB <p10>
-            GLOBAL      p10
-        ENDIF
-ELSE
-        IFNB <p1>
-            GLOBAL      _&p1
-        ENDIF
-        IFNB <p2>
-            GLOBAL      _&p2
-        ENDIF
-        IFNB <p3>
-            GLOBAL      _&p3
-        ENDIF
-        IFNB <p4>
-            GLOBAL      _&p4
-        ENDIF
-        IFNB <p5>
-            GLOBAL      _&p5
-        ENDIF
-        IFNB <p6>
-            GLOBAL      _&p6
-        ENDIF
-	IFNB <p7>
-            GLOBAL      _&p7
-        ENDIF
-        IFNB <p8>
-            GLOBAL      _&p8
-        ENDIF
-        IFNB <p9>
-            GLOBAL      _&p9
-        ENDIF
-        IFNB <p10>
-            GLOBAL      _&p10
-        ENDIF
-ENDIF
-
-ENDM
-
-MACRO   ECALL   procname,p1,p2,p3,p4,p5,p6,p7,p8
-
-IFDEF   __PASCAL__
-        IFNB <p1>
-            PUSH    p1
-        ENDIF
-	IFNB <p2>
-	    PUSH    p2
-	ENDIF
-	IFNB <p3>
-	    PUSH    p3
-	ENDIF
-	IFNB <p4>
-	    PUSH    p4
-	ENDIF
-	IFNB <p5>
-	    PUSH    p5
-	ENDIF
-	IFNB <p6>
-	    PUSH    p6
-	ENDIF
-	IFNB <p7>
-	    PUSH    p7
-	ENDIF
-	IFNB <p8>
-	    PUSH    p8
-	ENDIF
-	CALL    FAR     procname
-ELSE
-        args = 0
-        IFNB <p8>
-            PUSH    p8
-            args = args + 4
-        ENDIF
-        IFNB <p7>
-            PUSH    p7
-            args = args + 4
-        ENDIF
-        IFNB <p6>
-            PUSH    p6
-            args = args + 4
-        ENDIF
-        IFNB <p5>
-            PUSH    p5
-            args = args + 4
-	ENDIF
-        IFNB <p4>
-            PUSH    p4
-            args = args + 4
-        ENDIF
-        IFNB <p3>
-            PUSH    p3
-            args = args + 4
-        ENDIF
-        IFNB <p2>
-            PUSH    p2
-            args = args + 4
-        ENDIF
-        IFNB <p1>
-            PUSH    p1
-            args = args + 4
-        ENDIF
-
-        IFDEF __C32__
-                CALL    NEAR _&procname
-        ELSE
-                CALL    FAR _&procname
-        ENDIF
-
-IF args NE 0
-        ADD     _SP,args
-ENDIF
-
-ENDIF
-
-ENDM
-
-
-MACRO   ECALLM  procname,p1,p2,p3,p4,p5,p6,p7,p8
-
-IFDEF   __PASCAL__
-        IFNB <p1>
-            PUSH    p1
-        ENDIF
-        IFNB <p2>
-            PUSH    p2
-        ENDIF
-        IFNB <p3>
-            PUSH    p3
-        ENDIF
-        IFNB <p4>
-            PUSH    p4
-        ENDIF
-        IFNB <p5>
-            PUSH    p5
-        ENDIF
-        IFNB <p6>
-            PUSH    p6
-        ENDIF
-        IFNB <p7>
-            PUSH    p7
-        ENDIF
-        IFNB <p8>
-            PUSH    p8
-        ENDIF
-        CALL    procname
-ELSE
-        args = 0
-        IFNB <p8>
-            PUSH    p8
-            args = args + 4
-        ENDIF
-        IFNB <p7>
-            PUSH    p7
-            args = args + 4
-        ENDIF
-	IFNB <p6>
-            PUSH    p6
-            args = args + 4
-        ENDIF
-        IFNB <p5>
-            PUSH    p5
-            args = args + 4
-        ENDIF
-        IFNB <p4>
-            PUSH    p4
-            args = args + 4
-        ENDIF
-        IFNB <p3>
-            PUSH    p3
-            args = args + 4
-        ENDIF
-        IFNB <p2>
-            PUSH    p2
-            args = args + 4
-        ENDIF
-        IFNB <p1>
-            PUSH    p1
-            args = args + 4
-        ENDIF
-
-	CALL    procname
-
-IF args NE 0
-        ADD     _SP,args
-ENDIF
-
-ENDIF
-
-ENDM
-
-
-MACRO   LOCALVAR        ssize, name
-LOCAL   a
-
-        locs = locs + (SIZE &ssize)
-	a = 0-locs
-
-  IFDEF __32__
-        &name   EQU     ebp+a
-  ENDIF
-  IFDEF __16__
-        &name   EQU     bp+a
-  ENDIF
-ENDM
-
-
-
-MACRO   LOCVARS         s1, n1, s2, n2, s3, n3, s4, n4, s5, n5, s6, n6,\
-                        s7, n7, s8, n8, s9, n9, s10, n10, sx, nx
-        IFNB <sx>
-          ERR "Too many local variables with single LOCVARS"
-        ENDIF
-
-
-        IFNB <s1>
-          LOCALVAR &s1, &n1
-        ENDIF
-        IFNB <s2>
-          LOCALVAR &s2, &n2
-        ENDIF
-        IFNB <s3>
-          LOCALVAR &s3, &n3
-        ENDIF
-        IFNB <s4>
-          LOCALVAR &s4, &n4
-        ENDIF
-        IFNB <s5>
-          LOCALVAR &s5, &n5
-        ENDIF
-        IFNB <s6>
-          LOCALVAR &s6, &n6
-        ENDIF
-        IFNB <s7>
-          LOCALVAR &s7, &n7
-        ENDIF
-        IFNB <s8>
-          LOCALVAR &s8, &n8
-	ENDIF
-	IFNB <s9>
-	  LOCALVAR &s9, &n9
-	ENDIF
-	IFNB <s10>
-	  LOCALVAR &s10, &n10
-	ENDIF
-ENDM
-
-
-
-
-MACRO   CSEGMENTS sname
-  IFDEF __C32__
-	SEGMENT _DATA   DWORD PUBLIC USE32 'DATA'
-	ENDS
-	GROUP   DGROUP _DATA
-  ELSE
-  IFDEF __C16__
-	SEGMENT _DATA   WORD PUBLIC USE16 'DATA'
-	ENDS
-	SEGMENT _BSS    WORD PUBLIC USE16 'BSS'
-	ENDS
-
-	GROUP   DGROUP  _DATA,_BSS
-
-	SEGMENT &sname&_TEXT PARA PUBLIC USE16 'CODE'
-	ENDS
-  ELSE
-	SEGMENT _DATA   WORD PUBLIC USE16 'DATA'
-	ENDS
-
-	GROUP   DGROUP  _DATA
-
-	SEGMENT &sname&_TEXT PARA PUBLIC USE16 'CODE'
-	ENDS
-  ENDIF
-  ENDIF
-ENDM
-
-
-
-MACRO   CDATASEG
-  IFDEF __C32__
-	SEGMENT _DATA   DWORD PUBLIC USE32 'DATA'
-  ELSE
-	SEGMENT _DATA   WORD PUBLIC USE16 'DATA'
-  ENDIF
-ENDM
-
-
-
-MACRO   CCODESEG sname
-  IFDEF __C32__
-	SEGMENT _TEXT   PARA PUBLIC USE32 'CODE'
-	ASSUME  cs:_TEXT, ds:DGROUP, es:DGROUP
-  ELSE
-	SEGMENT &sname&_TEXT PARA PUBLIC USE16 'CODE'
-	ASSUME  cs:&sname&_TEXT, ds:DGROUP, es:NOTHING
-  ENDIF
-ENDM
-
-
-
-MACRO   RETVAL value
-        mov     _ax,value
-ENDM
-
diff --git a/dmp/modload.pas b/dmp/modload.pas
index 441b7ea..a063777 100644
--- a/dmp/modload.pas
+++ b/dmp/modload.pas
@@ -1,586 +1,5 @@
-(***************************************************************************
-
-                                 MODLOAD.PAS
-                                 -----------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-loadMOD and ampLoadMOD functions
-Original C version by Otto Chrons
-
-***************************************************************************)
-
-
-Unit MODLoad; {$I-,X+}
-
-{$O+}
-
-Interface
-Uses MCP,AMP,Loaders,CSupport;
-
-Function LoadMOD(Var File_:File;Var Module:PModule):Integer;
-Function ampLoadMOD(name:String;options:longint):PModule;
-
-Const modNotes : Array[0..60] of word =
-        ( 1712,1616,1524,1440,1356,1280,1208,1140,1076,1016,960,912,
-          856,808,762,720,678,640,604,570,538,508,480,453,
-          428,404,381,360,339,320,302,285,269,254,240,226,
-          214,202,190,180,170,160,151,143,135,127,120,113,
-          107,101,95,90,85,80,75,71,67,63,60,56,0 );
-
-Implementation
-{$IFDEF USE_EMS}
-uses emhm;
-{$ENDIF}
-
-Var curTrack            : Integer;
-    patUsed             : Array[0..254] of byte;
-
-Const instrRates        : array[0..15] of word =
-                          (856,850,844,838,832,826,820,814,
-                           907,900,894,887,881,875,868,862);
-
-      Basic_Freq        = 8368;
-
-Type TMODinst           = Record
-                            Name        : Array[0..21] of char;
-                            Length      : Word;
-                            Finetune    : Byte;
-                            Volume      : byte;
-                            Loopstart   : Word;
-                            Looplength  : Word;
-                          End;
-
-Function swapb(w:word):word; Assembler;
-asm
-       Mov  ax,[w]
-       Xchg al,ah
-end;
-
-Function loadInstruments(Var f:File;Var Module:PModule):Integer;
-Var t,a          : Integer;
-    b            : word;
-    MODi         : TMODinst;
-    instr        : PInstrument;
-
-Begin
-  With Module^ do begin
-    if module^.modType=MOD_15 then instrumentCount:=15 else InstrumentCount:=31;
-    instruments:=calloc(31,sizeof(TInstrument));
-    If instruments=Nil then begin loadInstruments:=MERR_MEMORY; exit end;
-    Size:=Size+instrumentCount*sizeof(TInstrument);
-    Seek(f,20);
-    a:=1;
-    t:=0;
-    while (a=1) and (t<instrumentCount) do begin
-      Blockread(f,MODi,sizeof(TMODinst),a);
-      if a<>sizeOf(TMODinst) then a:=-1 else a:=1;
-      instr:=@instruments^[t];
-      instr^.insType:=0;
-      MODi.name[21]:=#0;
-      strcpy(instr^.name,MODi.name);
-      strncpy(instr^.filename,MODi.name,12);
-      instr^.filename[12]:=#0;
-      instr^.sample:=nil;
-      instr^.rate:=856*Basic_Freq div instrRates[MODi.finetune and $F];
-      instr^.volume:=MODi.volume;
-      if instr^.volume>64 then instr^.volume:=64;
-      instr^.size:=swapb(MODi.length)*2;
-      instr^.loopstart:=swapb(MODi.loopstart)*2;
-      b:=swapb(MODi.looplength)*2;
-      if b<3 then b:=0 else b:=b+instr^.loopstart;
-      instr^.loopend:=b;
-      if (instr^.loopend>instr^.size) and (instr^.loopend<>0) then
-         instr^.loopend:=instr^.size;
-      if instr^.loopstart>instr^.loopend then instr^.loopend:=0;
-      if instr^.loopend=0 then instr^.loopstart:=0;
-      inc(t);
-    end;
-  end;
-  if a<>1 then loadInstruments:=MERR_FILE else loadInstruments:=MERR_NONE;
-end;
-
-Function loadPatterns(Var f:file; module:PModule):Integer;
-Var orders       : Array[0..127] of byte;
-    ptr          : pointer;
-    a,t,i        : Integer;
-    pat          : PPattern;
-    count        : Integer;
-    lastPattern  : Integer;
-
-Begin
-  count:=0;
-  lastPattern:=0;
-  Fillchar(patUsed,255,0);
-  Seek(f,20+module^.instrumentCount*30);
-  Blockread(f,count,1);
-  Blockread(f,orders,1);
-  Blockread(f,orders,128);
-  for t:=0 to 127 do if lastPattern<orders[t] then lastPattern:=orders[t];
-  inc(lastPattern);
-  module^.patternCount:=count;
-  module^.trackCount:=lastPattern*module^.channelCount;
-  module^.patterns:=calloc(count,sizeof(TPattern));
-  loadPatterns:=MERR_MEMORY;
-  if module^.patterns=nil then exit;
-  inc(module^.size,count*sizeof(TPattern));
-  if count>0 then
-  for t:=0 to count-1 do begin
-    patUsed[orders[t]]:=1;
-    pat:=@module^.patterns^[t];
-    pat^.length:=64;
-    for i:=0 to module^.channelCount-1 do
-      pat^.tracks[i]:=pointer(orders[t]*module^.channelCount+1+i);
-  end;
-  loadPatterns:=MERR_NONE;
-end;
-
-Function MOD2AMF(buffer:pointer;trk:Integer; module:PModule):PTrack;
-Type b = Array[0..65519] of byte;
-Var tracks: PTrack;
-    i,t,pos,tick,a,rowAdd: Integer;
-    note,noNote,oldNote,ins,volume,command,data,curins,curvolume : Byte;
-    nvalue: Word;
-    Temptrack: Array[0..575] of byte;
-
-Procedure insertNote(a,b:integer);
-Begin
-  temptrack[pos*3]:=tick;
-  temptrack[pos*3+1]:=a;
-  temptrack[pos*3+2]:=b;
-  inc(pos);
-end;
-
-Procedure insertCmd(a,b:integer);
-Begin
-  temptrack[pos*3]:=tick;
-  temptrack[pos*3+1]:=a;
-  temptrack[pos*3+2]:=b;
-  inc(pos);
-end;
-
-Begin
-  pos:=0;
-  tick:=0;
-  ins:=0;
-  oldNote:=0;
-  curins:=$F0;
-  inc(longint(buffer),trk*4);
-  Fillchar(temptrack,576,$FF);
-  rowAdd:=4*module^.channelCount;
-  for t:=0 to 63 do begin
-    tick:=t;
-    note:=$FF;
-    noNote:=0;
-    nvalue:=(b(buffer^)[t*rowAdd] and $F)*256+b(buffer^)[t*rowAdd+1];
-    if nvalue<>0 then for i:=0 to 60 do
-      if (nvalue>=modNotes[i]) then
-       begin
-        note:=i+36;
-        i:=60;
-       end;
-    command:=(b(buffer^)[t*rowAdd+2] and $f);
-    data:=b(buffer^)[t*rowAdd+3];
-    volume:=255;
-    if command=$C then begin
-      volume:=data;
-      if volume>64 then volume:=64;
-    end;
-    ins:=(b(buffer^)[t*rowAdd+2] shr 4) or (b(buffer^)[t*rowAdd] and $10);
-    if ins<>0 then
-     begin
-      dec(ins);
-      if ins<>curIns then
-       begin
-        insertCmd(cmdInstr,ins);
-        module^.instruments^[ins].insType:=1;
-       end
-        else if (note=$ff) and (volume>64) then
-         begin
-          insertCmd(cmdVolumeAbs,module^.instruments^[ins].volume);
-          insertCmd(cmdOffset,0);
-         end;
-      curIns:=ins;
-      inc(ins);
-     end;
-    if (command=$e) and (data shr 4=$d) and (data and $f<>0) and (note<>$ff) then
-     begin
-      insertCmd(cmdNoteDelay,data and $f);
-      command:=$ff;
-     end;
-    if command=3 then
-     begin
-      insertCmd(cmdBenderTo,data);
-      command:=$ff;
-     end;
-    if note<>$FF then
-     begin
-      dec(ins);
-      if (ins<>$ff) and (command<>$c) then
-        volume:=module^.instruments^[ins].volume;
-      insertNote(note,volume);
-     end
-     else if volume<65 then insertCmd(cmdVolumeAbs,volume);
-    case command of
-      $f : if (data>0) and (data<32) then insertCmd(cmdTempo,data)
-             else insertCmd(cmdExtTempo,data);
-      $b : insertCmd(cmdGoto,data);
-      $d : insertCmd(cmdBreak,0);
-      $a : begin
-            if (data>15) then data:=data div 16 else data:=-data;
-            insertCmd(cmdVolume,data);
-           end;
-      $2 : if data<>0 then
-            begin
-             if (data>127) then data:=127;
-             insertCmd(cmdBender,data);
-            end;
-      $1 : if data<>0 then
-            begin
-             if (data>127) then data:=127;
-             insertCmd(cmdBender,-data);
-            end;
-      $4 : insertCmd(cmdVibrato,data);
-      $5 : begin
-             if data>15 then data:=data div 16 else data:=-data;
-             insertCmd(cmdToneVol,data);
-           end;
-      $6 : begin
-             if data>15 then data:=data div 16 else data:=-data;
-             insertCmd(cmdVibrVol,data);
-           end;
-      $7 : insertCmd(cmdTremolo,data);
-      $0 : if data<>0 then insertCmd(cmdArpeggio,data);
-      $8 : insertCmd(cmdPan,data-64);
-      $9 : insertCmd(cmdOffset,data);
-      $e : begin
-            i:=data shr 4;
-            data:= data and $f;
-            case i of
-             $9 : insertCmd(cmdRetrig,data);
-             $1 : insertCmd(cmdFinetune,-data);
-             $2 : insertCmd(cmdFinetune,data);
-             $a : insertCmd(cmdFinevol,data);
-             $b : insertCmd(cmdFinevol,-data);
-             $c : insertCmd(cmdNoteCut,data);
-             $d : insertCmd(cmdnotedelay,data);
-             $8 : insertCmd(cmdsync,data);
-            end;
-          end;
-    end;
-  end;
-  if pos=0 then tracks:=nil else begin
-    inc(pos);
-    if (loadOptions and LM_IML)>0 then
-      if curTrack>1 then
-       for i:=1 to curTrack-1 do
-        if module^.tracks^[i]<>nil then
-        if (module^.tracks^[i]^.size=pos) and
-           (memcmp(@temptrack,pointer(longint(module^.tracks^[i])+3),pos*3)=0) then begin
-             MOD2AMF:=module^.tracks^[i];
-             exit;
-           end;
-    tracks:=PTrack(malloc(pos*3+3));
-    if tracks<>nil then
-     begin
-      inc(module^.size,pos*3+3);
-      tracks^.size:=pos;
-      tracks^.trkType:=0;
-      move(temptrack,pointer(longint(tracks)+3)^,pos*3);
-     end;
-  end;
-  MOD2AMF:=tracks;
-end;
-
-Function loadTracks(Var f:file;var module:PModule):Integer;
-Var Count    : Byte;
-    t,i,a,c  : Integer;
-    Buffer   : Array[0..2047] of byte;
-
-Begin
-  a:=module^.channelCount;
-  count:=module^.trackCount div a;
-  module^.tracks:=calloc(count*a+4,sizeof(PTrack));
-  if module^.tracks=nil then begin loadTracks:=MERR_MEMORY; exit end;
-  inc(module^.size,(count*a+4)*sizeof(PTrack));
-  seek(f,20+30*module^.instrumentCount+128+2+byte(module^.instrumentCount<>15)*4);
-  module^.tracks^[0]:=nil;
-  curTrack:=1;
-  if count>0 then
-  for t:=0 to count-1 do begin
-    if ((loadOptions and LM_IML)>0) and (patUsed[t]=0) then begin
-      for i:=0 to module^.channelCount-1 do begin
-        module^.tracks^[curTrack]:=nil; inc(curTrack) end;
-      seek(f,filepos(f)+256*module^.channelCount);
-    end else
-      if (module^.modType=MOD_MOD) or (module^.modType=MOD_15) then begin
-        c:=module^.channelCount;
-        blockread(f,buffer,256*c,a);
-        if a=256*c then
-          for i:=0 to c-1 do begin
-            module^.tracks^[curTrack]:=MOD2AMF(@buffer,i,module);
-            inc(curTrack);
-          end else begin
-            loadTracks:=MERR_FILE;
-            exit;
-          end;
-      end else if (module^.channelCount=8) and (module^.modType=MOD_TREK) then begin
-        Blockread(f,buffer,1024);
-        if IOresult=0 then begin
-          module^.tracks^[curTrack]:=MOD2AMF(@buffer,0,module); inc(curTrack);
-          module^.tracks^[curTrack]:=MOD2AMF(@buffer,1,module); inc(curTrack);
-          module^.tracks^[curTrack]:=MOD2AMF(@buffer,2,module); inc(curTrack);
-          module^.tracks^[curTrack]:=MOD2AMF(@buffer,3,module); inc(curTrack);
-        end else begin
-          loadTracks:=MERR_FILE;
-          exit;
-        end;
-        Blockread(f,buffer,1024);
-        if IOresult=0 then begin
-          module^.tracks^[curTrack]:=MOD2AMF(@buffer,0,module); inc(curTrack);
-          module^.tracks^[curTrack]:=MOD2AMF(@buffer,1,module); inc(curTrack);
-          module^.tracks^[curTrack]:=MOD2AMF(@buffer,2,module); inc(curTrack);
-          module^.tracks^[curTrack]:=MOD2AMF(@buffer,3,module); inc(curTrack);
-        end else begin
-          loadTracks:=MERR_FILE;
-          exit;
-        end;
-      end;
-  end;
-  loadTracks:=MERR_NONE;
-end;
-
-Function loadSamples(var f:file; var module:PModule):integer;
-Var t,i,a,b,l     : Word;
-   c             : Longint;
-   instr         : PInstrument;
-   {temp          : Array[0..31] of byte;}
-   {$IFDEF USE_EMS}
-   handle        : TEMSH;
-   tempbuf       : Pointer;
-   offset        : Longint;
-   remaining     : Longint;
-   {$ENDIF}
-Begin
-   seek(f,20+30*module^.instrumentCount+128+2+4*byte(module^.instrumentCount<>15)+longint(module^.trackCount)*256);
-   for t:=0 to module^.instrumentCount-1 do
-   begin
-      instr:=@module^.instruments^[t];
-      if ((loadOptions and LM_IML)>0) and (instr^.insType=0) then
-      begin
-	 seek(f,filepos(f)+instr^.size);
-	 instr^.size:=0;
-      end;
-      if instr^.size>0 then
-      begin
-	 a:=instr^.loopend-instr^.loopstart;
-	 if (instr^.loopend<>0) and (a<crit_size) then
-	 begin
-	    b:=(Crit_Size div a)*a;
-	    instr^.loopend:=instr^.loopstart+b;
-	    loadSamples:=MERR_MEMORY;
-	    instr^.sample:=malloc(instr^.loopend);
-	    if instr^.sample=nil then exit;
-	    inc(module^.size,instr^.loopend);
-	    if instr^.size>instr^.loopend then
-	    begin
-	       loadSamples:=MERR_FILE;
-	       blockread(f,instr^.sample^,instr^.loopend);
-	       if IOresult<>0 then exit;
-	       seek(f,filepos(f)+instr^.size-instr^.loopend);
-	    end
-	    else
-	    begin
-	       loadSamples:=MERR_FILE;
-	       blockread(f,instr^.sample^,instr^.size);
-	       if IOresult<>0 then exit;
-	    end;
-	    instr^.size:=instr^.loopend;
-	    for i:=1 to (Crit_Size div a)-1 do
-	       move(pointer(longint(instr^.sample)+instr^.loopstart)^,
-		    pointer(longint(instr^.sample)+instr^.loopstart+a*i)^,a);
-	 end
-	 else
-	 begin
-	    {$IFNDEF USE_EMS}
-	    if instr^.size>65510 then a:=65510 else a:=instr^.size;
-	    instr^.sample:=malloc(a);
-	    loadSamples:=MERR_MEMORY;
-	    if instr^.sample=nil then exit;
-	    inc(module^.size,a);
-	    loadSamples:=MERR_CORRUPT;
-	    blockread(f,instr^.sample^,a);
-	    if IOresult<>0 then exit;
-	    if a<instr^.size then
-	    begin
-	       {blockread(f,temp,instr^.size-a);}
-	       Seek(f, FilePos(f) + instr^.size-a);
-	       instr^.size:=a;
-	    end;
-	    mcpConvertSample(instr^.sample,instr^.size);
-	    {$ELSE} {USE_EMS}
-	    handle:=emsAlloc(instr^.size);
-	    if handle <= 0 then
-	    begin
-	       loadSamples:=MERR_MEMORY;
-	       exit;
-	    end;
-	    tempbuf := malloc(1024);
-	    if tempbuf = nil then
-	    begin
-	       emsFree(handle);
-	       loadSamples:=MERR_MEMORY;
-	       exit;
-	    end;
-	    offset := 0;
-	    remaining := instr^.size;
-	    while remaining > 0 do
-	    begin
-	       if remaining > 1024 then begin a := 1024; end else begin a := remaining; end;
-	       blockread(f, tempbuf^, a);
-	       if IOresult<>0 then
-	       begin
-		  emsFree(handle);
-		  free(tempbuf);
-		  loadSamples:=MERR_FILE;
-		  exit;
-	       end;
-	       mcpConvertSample(tempbuf, a);
-	       emsCopyTo(handle, tempbuf, offset, a);
-	       inc(offset, a);
-	       dec(remaining, a);
-	    end;
-	    free(tempbuf);
-	    instr^.sample:=ptr($ffff,handle);
-	    {$ENDIF}
-	 end;
-      end else begin
-	 instr^.size:=0;
-	 instr^.sample:=nil;
-      end;
-   end;
-   loadSamples:=MERR_NONE;
-end;
-
-Procedure joinTracks2Patterns(var module:PModule);
-Var t,i     : Word;
-    pat     : PPattern;
-Begin
-  for t:=0 to module^.patternCount-1 do begin
-    pat:=@module^.patterns^[t];
-    for i:=0 to module^.channelCount-1 do
-      pat^.tracks[i]:=module^.tracks^[word(pat^.tracks[i])];
-  end;
-end;
-
-Function loadMOD;
-var a:integer;
-Begin
-  module^.tempo:=125;
-  module^.speed:=6;
-  a:=loadInstruments(file_,module);
-  loadMOD:=a;
-  if a<>MERR_NONE then exit;
-  a:=loadPatterns(file_,module);
-  loadMOD:=a;
-  if a<>MERR_NONE then exit;
-  a:=loadTracks(file_,module);
-  loadMOD:=a;
-  if a<>MERR_NONE then exit;
-  a:=loadSamples(file_,module);
-  loadMOD:=a;
-  if (a<>MERR_NONE) and (a<>MERR_CORRUPT) then exit;
-  joinTracks2Patterns(module);
-  if module^.modType=MOD_15 then module^.modType:=MOD_MOD;
-end;
-
-Function ampLoadMOD(name:String;options:longint):PModule;
-Var f:file;
-    l:longint;
-    module:PModule;
-    b:Integer;
-begin
-  loadOptions:=options;
-  module:=malloc(sizeof(TModule));
-  if module=nil then
-   begin
-    moduleError:=MERR_MEMORY;
-    ampLoadMOD:=nil;
-    exit;
-   end;
-  fillchar(module^,0,sizeof(module^));
-  assign(f,name);
-  reset(f,1);
-  if IOresult<>0 then
-   begin
-    moduleError:=MERR_FILE;
-    ampLoadMOD:=nil;
-    exit;
-   end;
-  module^.modType:=MOD_NONE;
-  seek(f,1080);
-  blockread(f,l,4);
-  if (l=$2E4B2E4D) or (l=$34544C46) then
-   begin
-    module^.modType:=MOD_MOD;
-    seek(f,0);
-    blockread(f,module^.name,20);
-    module^.name[20]:=#0;
-    module^.channelCount:=4;
-    move(order4,module^.channelPanning,4);
-   end
-  else if l=$38544C46 then
-   begin
-    module^.modType:=MOD_TREK;
-    seek(f,0);
-    blockread(f,module^.name,20);
-    module^.name[20]:=#0;
-    module^.channelCount:=8;
-    move(order8,module^.channelPanning,8);
-   end
-  else if l=$4e484336 then
-   begin
-    module^.modType:=MOD_MOD;
-    seek(f,0);
-    blockread(f,module^.name,20);
-    module^.name[20]:=#0;
-    module^.channelCount:=6;
-    move(order6,module^.channelPanning,6);
-   end
-  else if l=$4e484338 then
-   begin
-    module^.modType:=MOD_MOD;
-    seek(f,0);
-    blockread(f,module^.name,20);
-    module^.name[20]:=#0;
-    module^.channelCount:=8;
-    move(order8,module^.channelPanning,8);
-   end
-  else
-   begin
-    module^.modType:=MOD_15;
-    seek(f,0);
-    blockread(f,module^.name,20);
-    module^.name[20]:=#0;
-    module^.channelCount:=4;
-    move(order4,module^.channelPanning,4);
-   end;
-  if module^.modType=MOD_NONE then
-   begin
-    moduleError:=MERR_TYPE;
-    ampLoadMOD:=nil;
-    exit;
-   end;
-  b:=loadMOD(f,module);
-  moduleError:=b;
-  if b=MERR_NONE then module^.filesize:=filesize(f) else
-   begin
-    ampFreeModule(module);
-    free(module);
-    module:=nil;
-   end;
-  close(f);
-  ampLoadMOD:=module;
-end;
-
-end.
+unit modload;
+{$O+}
+interface
+implementation
+end.
diff --git a/dmp/mtmload.pas b/dmp/mtmload.pas
deleted file mode 100644
index 316a0d2..0000000
--- a/dmp/mtmload.pas
+++ /dev/null
@@ -1,525 +0,0 @@
-{  ************************************************************************
-   *
-   *    File        : MTMLOAD.PAS
-   *
-   *    Description : Module loader for AMP
-   *
-   *    Copyright (C) 1993 Jussi Lahdenniemi
-   *    Original C version (C) 1993 Otto Chrons
-   *
-   ************************************************************************ }
-
-{$I+,R-,X+}
-
-Unit MTMLoad;
-
-{$O+}
-
-interface
-uses mcp,amp,loaders,csupport;
-
-function loadMTM(var f:file;var module:PModule):longint;
-function ampLoadMTM(name:string;options:longint):PModule;
-
-implementation
-{$IFDEF USE_EMS}
-uses emhm;
-{$ENDIF}
-
-const BASIC_FREQ = 8368;
-
-      instrRates : array[0..15] of word = ( 856,850,844,838,832,826,820,814,
-                                            907,900,894,887,881,875,868,862 );
-
-var curTrack:integer;
-    patUsed:array[0..255] of byte;
-    insc:byte;
-
-type TMTMHeader         = Record
-       ID               : array[0..2] of char;
-       version          : byte;
-       songname         : array[0..19] of char;
-       trackCount       : word;
-       patCount         : byte;
-       orderCount       : byte;
-       commentLength    : word;
-       sampleCount      : byte;
-       attribute        : byte;
-       bpt              : byte;
-       channelCount     : byte;
-       pan              : array[0..31] of shortint;
-     end;
-
-     TMTMInstrument     = Record
-       sampleName       : array[0..21] of char;
-       sampleLength     : longint;
-       loopStart,
-       loopEnd          : longint;
-       finetune         : byte;
-       volume           : byte;
-       attribute        : byte;
-     end;
-
-var mtmhdr:TMTMHeader;
-
-Function loadInstruments(var f:file;module:PModule):integer;
-var t,a:integer;
-    b:word;
-    mtmi:TMTMInstrument;
-    instr:PInstrument;
-begin
-  blockread(f,mtmhdr,sizeof(TMTMHeader));
-  move(mtmhdr.songname,module^.name,20);
-  module^.name[20]:=#0;
-  module^.channelCount:=mtmhdr.channelCount;
-  for t:=0 to 31 do begin
-    a:=mtmhdr.pan[t];
-    if a in [7,8] then module^.channelPanning[t]:=0 else
-      if a<7 then module^.channelPanning[t]:=(a-7)*9 else
-        module^.channelPanning[t]:=(a-8)*9;
-  end;
-  insc:=mtmhdr.sampleCount;
-  module^.instrumentCount:=insc;
-  module^.instruments:=calloc(mtmhdr.sampleCount,sizeof(TInstrument));
-  loadInstruments:=MERR_MEMORY;
-  if module^.instruments=nil then exit;
-  inc(module^.size,insc*sizeof(TInstrument));
-  for t:=0 to mtmhdr.sampleCount-1 do begin
-    blockread(f,mtmi,sizeof(TMTMInstrument));
-    loadInstruments:=MERR_FILE;
-    if ioresult<>0 then exit;
-    instr:=@module^.instruments^[t];
-    instr^.insType:=0;
-    move(mtmi.sampleName,instr^.name,22);
-    instr^.name[22]:=#0;
-    instr^.sample:=nil;
-    instr^.rate:=856*BASIC_FREQ div instrRates[MTMi.finetune and $f];
-    if mtmi.volume>64 then instr^.volume:=64 else instr^.volume:=mtmi.volume;
-    instr^.size:=mtmi.sampleLength;
-    instr^.loopstart:=mtmi.loopStart;
-    b:=mtmi.loopend;
-    if b<3 then b:=0;
-    instr^.loopend:=b;
-    if instr^.loopend>instr^.size then instr^.loopend:=instr^.size;
-    if instr^.loopstart>instr^.loopend then instr^.loopend:=0;
-    if instr^.loopend=0 then instr^.loopstart:=0;
-  end;
-  loadInstruments:=MERR_NONE;
-end;
-
-Function loadPatterns(var f:file;module:PModule):integer;
-type ta=array[0..0] of word;
-var orders:array[0..127] of byte;
-    ptr:pointer;
-    a,t,i,count,lastPattern:integer;
-    pat:PPattern;
-    trackPtrs:^ta;
-begin
-  lastPattern:=0;
-  blockread(f,orders,128);
-  loadPatterns:=MERR_FILE;
-  if IOresult<>0 then exit;
-  count:=mtmhdr.orderCount+1;
-  module^.patternCount:=count;
-  module^.trackCount:=mtmhdr.trackCount;
-  module^.patterns:=calloc(count,sizeof(TPattern));
-  loadPatterns:=MERR_MEMORY;
-  if module^.patterns=nil then exit;
-  for t:=0 to module^.patternCount-1 do begin
-    pat:=@module^.patterns^[t];
-    for i:=0 to 31 do pat^.tracks[i]:=pointer(trackptrs^[orders[t]*32+i]);
-  end;
-  free(trackptrs);
-  loadPatterns:=MERR_NONE;
-end;
-
-type ta=array[0..0] of byte;
-     pa=^ta;
-
-Function mtm2amf(buffer:pa;module:PModule):PTrack;
-var track:PTrack;
-    i,t,pos,tick,a,rowadd:integer;
-    note,ins,volume,command,data,curins,curvolume:byte;
-    nvalue:word;
-    temptrack:array[0..575] of byte;
-
-Procedure insertNote(a,b:integer);
-Begin
-  temptrack[pos*3]:=tick;
-  temptrack[pos*3+1]:=a;
-  temptrack[pos*3+2]:=b;
-  inc(pos);
-end;
-
-Procedure insertCmd(a,b:integer);
-Begin
-  temptrack[pos*3]:=tick;
-  temptrack[pos*3+1]:=a;
-  temptrack[pos*3+2]:=b;
-  inc(pos);
-end;
-
-begin
-  pos:=0;
-  tick:=0;
-  ins:=0;
-  curins:=$f0;
-  fillchar(temptrack,576,$ff);
-  for t:=0 to 63 do begin
-    tick:=t;
-    note:=$ff;
-    nvalue:=buffer^[t*3] shr 2;
-    if nvalue>0 then note:=nvalue+36;
-    command:=buffer^[t*3+1] and $f;
-    data:=buffer^[t*3+2];
-    volume:=255;
-    if command=$c then if data>64 then volume:=64 else volume:=data;
-    ins:=((buffer^[t*3+1] and $f0) shr 4) or ((buffer^[t*3] and 3) shl 4);
-    if ins<>0 then begin
-      dec(ins);
-      if ins<>curins then begin
-        insertCmd(cmdInstr,ins);
-        module^.instruments^[ins].insType:=1;
-      end else begin
-        if (note=$ff) and (volume>64) then begin
-          insertCmd(cmdVolumeAbs,module^.instruments^[ins].volume);
-          insertCmd(cmdOffset,0);
-        end;
-      end;
-      curIns:=ins;
-      inc(ins);
-    end;
-    if (command=$e) and ((data shr 4)=$d) and ((data and $f)<>0) and (note<>$ff) then begin
-      insertCmd(cmdNoteDelay,data and $f);
-      command:=$ff;
-    end;
-    if command=3 then begin
-      insertCmd(cmdBenderTo,data);
-      command:=$ff;
-    end;
-    if note<>$ff then begin
-      dec(ins);
-      if (ins<>$ff) and (command<>$c) then volume:=module^.instruments^[ins].volume;
-      insertNote(note,volume);
-    end else if volume<65 then insertCmd(cmdVolumeAbs,volume);
-    case command of
-      $f : if (data in [1..31]) and (loadOptions and LM_OLDTEMPO>0) then
-             insertCmd(cmdTempo,data) else insertCmd(cmdExtTempo,data);
-      $b : insertCmd(cmdGoto,data);
-      $d : insertCmd(cmdBreak,0);
-      $a : begin
-             if data>=16 then data:=data div 16 else data:=-data;
-             insertCmd(cmdVolume,data);
-           end;
-      2  : if data<>0 then begin
-             if data>127 then data:=127;
-             insertCmd(cmdBender,-data);
-           end;
-      1  : if data<>0 then begin
-             if data>127 then data:=127;
-             insertCmd(cmdBender,-data);
-           end;
-      4  : insertCmd(cmdVibrato,data);
-      5  : begin
-             if data>=16 then data:=data div 16 else data:=-data;
-             insertCmd(cmdToneVol,data);
-           end;
-      6  : begin
-             if data>=16 then data:=data div 16 else data:=-data;
-             insertCmd(cmdVibrVol,data);
-           end;
-      7  : insertCmd(cmdTremolo,data);
-      0  : if data<>0 then insertCmd(cmdArpeggio,data);
-      9  : insertCmd(cmdOffset,data);
-      8  : insertCmd(cmdPan,data-64);
-      $e : begin
-             i:=data shr 4;
-             data:=data and $f;
-             case i of
-               9  : insertCmd(cmdRetrig,data);
-               1  : insertCmd(cmdFinetune,-data);
-               2  : insertCmd(cmdFinetune,data);
-               $a : insertCmd(cmdFinevol,data);
-               $b : insertCmd(cmdFinevol,-data);
-               $c : insertCmd(cmdNoteCut,data);
-               $d : insertCmd(cmdNoteDelay,data);
-               8  : if data in [7,8] then insertCmd(cmdPan,0) else
-                    if data<7 then insertCmd(cmdPan,(data-7)*9) else
-                    insertCmd(cmdPan,(data-8)*9);
-             end;
-           end;
-    end;
-  end;
-  if pos=0 then track:=nil else begin
-    inc(pos);
-    track:=malloc(pos*3+3);
-    if track<>nil then begin
-      inc(module^.size,pos*3+3);
-      track^.size:=pos;
-      track^.trkType:=0;
-      move(temptrack,pointer(longint(track)+3)^,pos*3);
-    end;
-  end;
-  mtm2amf:=track;
-end;
-
-Function loadTracks(var f:file;module:PModule):integer;
-var count:byte;
-    t,i,a,c:integer;
-    buffer:array[0..191] of shortint;
-begin
- count:=module^.trackCount;
- module^.tracks:=calloc(count+4,sizeof(PTrack));
- loadTracks:=MERR_MEMORY;
- if module^.tracks=nil then exit;
- inc(module^.size,(count+4)*sizeof(PTrack));
- module^.tracks^[0]:=nil;
- curTrack:=1;
- seek(f,sizeof(TMTMHeader)+mtmhdr.sampleCount*sizeof(TMTMInstrument)+128);
- for t:=0 to mtmhdr.trackCount-1 do
-  begin
-   blockread(f,buffer,192);
-   module^.tracks^[curTrack]:=mtm2amf(@buffer,module);
-  end;
- loadTracks:=MERR_NONE;
-end;
-
-Function loadSamples(var f:file; var module:PModule):integer;
-Var t,i,a,b,l     : Word;
-    c             : Longint;
-    instr         : PInstrument;
-    temp          : Array[0..31] of byte;
-    {$IFDEF USE_EMS}
-    handle        : TEMSH;
-    {$ENDIF}
-Begin
-  seek(f,sizeof(TMTMHeader)+mtmhdr.sampleCount*sizeof(TMTMInstrument)+128+
-    mtmhdr.trackCount*192+(mtmhdr.patCount+1)*32*2+mtmhdr.commentLength);
-  for t:=0 to module^.instrumentCount-1 do begin
-    instr:=@module^.instruments^[t];
-    if ((loadOptions and LM_IML)>0) and (instr^.insType=0) then begin
-      seek(f,filepos(f)+instr^.size);
-      instr^.size:=0;
-    end;
-    if instr^.size>4 then begin
-      a:=instr^.loopend-instr^.loopstart;
-      if (instr^.loopend<>0) and (a<crit_size) then begin
-        b:=(Crit_Size div a)*a;
-        instr^.loopend:=instr^.loopstart+b;
-        loadSamples:=MERR_MEMORY;
-        instr^.sample:=malloc(instr^.loopend);
-        if instr^.sample=nil then exit;
-        inc(module^.size,instr^.loopend);
-        if instr^.size>instr^.loopend then begin
-          loadSamples:=MERR_FILE;
-          blockread(f,instr^.sample^,instr^.loopend);
-          if IOresult<>0 then exit;
-          seek(f,filepos(f)+instr^.size-instr^.loopend);
-        end else begin
-          loadSamples:=MERR_FILE;
-          blockread(f,instr^.sample^,instr^.size);
-          if IOresult<>0 then exit;
-        end;
-        instr^.size:=instr^.loopend;
-        for i:=1 to (Crit_Size div a)-1 do
-          move(pointer(longint(instr^.sample)+instr^.loopstart)^,
-               pointer(longint(instr^.sample)+instr^.loopstart+a*i)^,a);
-      end else begin
-        if instr^.size>65510 then a:=65510 else a:=instr^.size;
-        instr^.sample:=malloc(a);
-        loadSamples:=MERR_MEMORY;
-        if instr^.sample=nil then exit;
-        inc(module^.size,a);
-        loadSamples:=MERR_CORRUPT;
-        blockread(f,instr^.sample^,a);
-        if IOresult<>0 then exit;
-        if a<instr^.size then begin
-          blockread(f,temp,instr^.size-a);
-          instr^.size:=a;
-        end;
-{$IFDEF USE_EMS}
-        handle:=0;
-        if instr^.size>2048 then begin
-          handle:=emsAlloc(instr^.size);
-          if handle>0 then begin
-            emsCopyTo(handle,instr^.sample,0,instr^.size);
-            free(instr^.sample);
-            instr^.sample:=ptr($ffff,handle);
-          end;
-        end;
-{$ENDIF}
-      end;
-    end else begin
-      instr^.size:=0;
-      instr^.sample:=nil;
-    end;
-  end;
-  loadSamples:=MERR_NONE;
-end;
-
-(*
-              static int loadSamples(FILE *file, MODULE *module)
-              {
-                  ushort      t,i,a,b,l;
-                  long        c;
-                  INSTRUMENT  *instr;
-                  char        temp[32];
-              #ifdef _USE_EMS
-                  EMSH        handle;
-              #endif
-
-
-                  fseek(file,sizeof(MTMHEADER)+MTMhdr.sampleCount*sizeof(MTMINSTRUMENT)+128+\
-                             MTMhdr.trackCount*192+(MTMhdr.patCount+1)*32*2+MTMhdr.commentLength,SEEK_SET);
-                  for( t = 0; t < module->instrumentCount; t++ )
-                  {
-                      instr = &(*module->instruments)[t];
-                      if((loadOptions & LM_IML) && (instr->type == 0 ))
-                      {
-                          fseek(file,instr->size,SEEK_CUR);
-                          instr->size = 0;
-                          instr->sample = NULL;
-                          continue;
-                      }
-                      if( instr->size > 4 )
-                      {
-                          if( instr->loopend != 0 && (a = instr->loopend - instr->loopstart) < CRIT_SIZE )
-                          {
-                              b = (CRIT_SIZE/a)*a;
-                              instr->loopend = instr->loopstart + b;
-                              if((instr->sample = malloc(instr->loopend+16)) == NULL) return MERR_MEMORY;
-                              module->size += instr->loopend;
-                              if( instr->size > instr->loopend )
-                              {
-                                  if(fread(instr->sample,instr->loopend,1,file) == 0) return MERR_FILE;
-                                  fseek(file,instr->size - instr->loopend,SEEK_CUR);
-                              }
-                              else
-                                  if(fread(instr->sample,instr->size,1,file) == 0) return MERR_FILE;
-                              instr->size = instr->loopend;
-                              for( i = 1; i < CRIT_SIZE/a; i++)
-                              {
-                                  memcpy((char*) (*instr->sample+instr->loopstart+a*i,\
-                                         (char*) (*instr->sample+instr->loopstart,a);
-                              }
-                          }
-                          else
-                          {
-                              a = (instr->size > 65510) ? 65510 : instr->size;
-                              if((instr->sample = malloc(a+16)) == NULL) return MERR_MEMORY;
-                              module->size += a;
-                              memset(instr->sample,0,a+16);
-                              if( fread(instr->sample,a,1,file ) == 0)
-                              {
-                                  return MERR_CORRUPT;
-                              }
-                              if( a < instr->size )
-                              {
-                                  fread(temp,instr->size - a,1,file);
-                                  instr->size = a;
-                              }
-              #ifdef _USE_EMS
-                              handle = 0;
-                              if( instr->size > 2048 )
-                              {
-                                  if((handle = emsAlloc(instr->size+16)) > 0)
-                                  {
-                                      emsCopyTo(handle,instr->sample,0,instr->size);
-                                      free(instr->sample);
-                                      instr->sample = MK_FP(0xFFFF,handle);
-                                  }
-                              }
-              #endif
-                          }
-                      }
-                      else { instr->size = 0; instr->sample = 0; }
-                  }
-                  return MERR_NONE;
-              }
-
-*)
-
-Procedure joinTracks2Patterns(var module:PModule);
-Var t,i     : Word;
-    pat     : PPattern;
-Begin
-  for t:=0 to module^.patternCount-1 do begin
-    pat:=@module^.patterns^[t];
-    for i:=0 to module^.channelCount-1 do
-      pat^.tracks[i]:=module^.tracks^[word(pat^.tracks[i])];
-  end;
-end;
-
-Function loadMTM;
-var a:integer;
-begin
-  module^.tempo:=125;
-  module^.speed:=6;
-  a:=loadInstruments(f,module);
-  loadMTM:=a;
-  if a<MERR_NONE then exit;
-  a:=loadPatterns(f,module);
-  loadMTM:=a;
-  if a<MERR_NONE then exit;
-  a:=loadSamples(f,module);
-  loadMTM:=a;
-  if a<MERR_NONE then exit;
-  a:=loadTracks(f,module);
-  loadMTM:=a;
-  if a<MERR_NONE then exit;
-  joinTracks2Patterns(module);
-  loadMTM:=a;
-end;
-
-Function ampLoadMTM;
-var f: file;
-    l: longint;
-    module: PModule;
-    b: integer;
-    ID: string[3];
-begin
-  loadOptions:=options;
-  module:=malloc(sizeof(TModule));
-  if module=nil then begin
-    moduleError:=MERR_MEMORY;
-    ampLoadMTM:=nil;
-    exit
-  end;
-  fillchar(module^,sizeof(TModule),0);
-  assign(f,name);
-  reset(f,1);
-  if ioresult<>0 then begin
-    moduleError:=MERR_FILE;
-    ampLoadMTM:=nil;
-    free(module);
-    exit
-  end;
-  module^.modType:=MOD_NONE;
-  blockread(f,id[1],3);
-  id[0]:=#3;
-  if id='MTM' then module^.modType:=MOD_MTM;
-  if module^.modType=MOD_NONE then
-   begin
-    moduleError:=MERR_TYPE;
-    ampLoadMTM:=nil;
-    free(module);
-    exit
-   end;
-  b:=loadMTM(f,module);
-  moduleError:=b;
-  if b=MERR_NONE then
-   begin
-    seek(f,0);
-    module^.filesize:=filepos(f);
-   end
-  else
-   begin
-    ampFreeModule(module);
-    free(module);
-    module:=nil;
-   end;
-  close(f);
-  ampLoadMTM:=module;
-end;
-
-end.
diff --git a/dmp/mtmload.tpp b/dmp/mtmload.tpp
deleted file mode 100644
index 97e0bff..0000000
Binary files a/dmp/mtmload.tpp and /dev/null differ
diff --git a/dmp/pmp.pas b/dmp/pmp.pas
deleted file mode 100644
index 95f0f0a..0000000
--- a/dmp/pmp.pas
+++ /dev/null
@@ -1,1608 +0,0 @@
-Program PMP; { Protected Module Player, (C) 1993 Jussi Lahdenniemi }
-
-Uses MCP,GUS,AMP,CDI,Timeserv,Mixer,
-     SDI__SB,SDI__PAS,SDI__SB1{,SDI__SB16},SDI__ARI{,SDI__ARIA},SDI__WSS,
-     Det_SB,Det_PAS,Det_Aria,DetGUS,
-     LoadM,Loaders,
-     DOS,Memory,CRT,
-     GetCPU,Csupport,dpmiApi;
-
-{$f+,i-}
-
-{ $define debug}
-
-Const PMPversion : String = 'HGH';
-
-var fil           : file;
-    Scard         : TSoundCard;
-    i             : integer;
-    mcps          : TMCPstruct;
-    playBuf       : Pointer;
-    r             : registers;
-    temps         : word;
-    ch            : char;
-    pollTag       : integer;
-    modiTag       : integer;
-
-Procedure hideCursor;
-begin
-  r.ah:=3;
-  r.bh:=0;
-  intr($10,r);
-  r.cx:=r.cx or 8192;
-  r.ah:=1;
-  intr($10,r);
-end;
-
-Procedure showCursor;
-begin
-  r.ah:=3;
-  r.bh:=0;
-  intr($10,r);
-  r.cx:=r.cx and (65535-8192);
-  r.ah:=1;
-  intr($10,r);
-end;
-
-Procedure disableBlink;
-var b:byte;
-begin
-  b:=port[$3da];
-  port[$3c0]:=$10+32;
-  b:=port[$3c1];
-  b:=b and (not 8);
-  port[$3c0]:=b;
-end;
-
-Procedure enableBlink;
-Var b:byte;
-begin
-  b:=port[$3da];
-  port[$3c0]:=$10+32;
-  b:=port[$3c1];
-  b:=b or 8;
-  port[$3c0]:=b;
-end;
-
-Procedure bkgrnd(cl:byte);
-var b:byte;
-begin
-  {$ifdef debug}
-  b:=port[$3da];
-  port[$3c0]:=$11+32;
-  port[$3c0]:=cl;
-  {$endif}
-end;
-
-Procedure bkgrndABS(cl:byte);
-var b:byte;
-begin
-  b:=port[$3da];
-  port[$3c0]:=$11+32;
-  port[$3c0]:=cl;
-end;
-
-Const palette:array[0..47] of byte = (00,00,20, 00,00,26, 00,00,40, 00,00,58,
-                                      59,59,30, 00,57,30, 00,00,00, 17,17,17,
-                                      23,23,23, 42,42,42, 61,00,27, 00,00,20,
-                                      00,00,20, 00,00,20, 00,00,20, 60,60,63);
-
-      paletteMap:array[0..15] of byte = (0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15);
-      palRemOrder:array[0..15] of byte = (11,12,13,14,7,8,6,5,9,10,4,1,2,3,15,0);
-      palRemRepl:array[0..15] of byte = (0,0,3,15,15,4,0,8,9,15,15,15,15,15,15,0);
-
-      colorMask:array[0..3999] of byte =
-( 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1,
-  1,1,1,1,1,1,1,1,1,1, 1,1,1,1,1,1,1,1,1,1, 1,1,1,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0,
-  0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0, 0,0,0,0,0,0,0,0,0,0);
-
-Const yellow=4;
-      lightgreen=5;
-      lightred=10;
-      green=9;
-
-Var screenbuf:word;
-    fakescreen:pointer;
-
-Procedure setCorrectPalette;
-var b,b2:byte;
-begin
-  b:=port[$3da];
-  port[$3c0]:=0;
-  b:=port[$3da];
-  port[$3c0]:=$14;
-  port[$3c0]:=0;
-  for b:=0 to 15 do begin
-    port[$3c0]:=b;
-    port[$3c0]:=b;
-  end;
-  port[$3c8]:=0;
-  for b:=0 to 47 do port[$3c9]:=palette[b];
-  b:=port[$3da];
-  port[$3c0]:=$20;
-end;
-
-Procedure makePaletteMap(barNr:integer);
-var w,w2:integer;
-begin
-  for w:=0 to 15 do paletteMap[w]:=w;
-  for w:=0 to barNr-1 do
-    for w2:=0 to 15 do if paletteMap[w2]=palRemOrder[w] then
-      paletteMap[w2]:=palRemRepl[paletteMap[w2]];
-  w:=port[$3da];
-  for w:=0 to barNr-1 do begin
-    port[$3c0]:=palRemOrder[w];
-    port[$3c0]:=0;
-  end;
-  for w:=barNr to 15 do begin
-    port[$3c0]:=palRemOrder[w];
-    port[$3c0]:=palRemOrder[w];
-  end;
-  port[$3c0]:=$20;
-end;
-
-const whereAmI:word=0; { offset }
-
-Procedure updateScreen(count:word); external;
-{$L PMPSCRN.OBJ}
-
-Procedure headerPic(offs:word); Forward;
-
-Procedure Break(s:String);         { Break if an error occurs }
-Begin
-  asm mov ax,3; int 10h end;
-  textmode(co80);
-  textbackground(black);
-  clrScr;
-  textcolor(blink+12);
-  Write('* ERROR! * ');
-  textcolor(12);
-  Writeln(s);
-  halt(1);
-end;
-
-Function getDVversion:Word; assembler;
-asm
- mov cx,'DE'
- mov dx,'SQ'
- mov ax,2b01h
- int 21h
- cmp al,0ffh
- je @GV1
- mov ax,bx
- jmp @GV2
-@GV1:
- sub ax,ax
-@GV2:
-end;
-
-Function getWindowsVersion:Word;
-begin
-  r.ax:=$1600;
-  intr($2f,r);
-  case r.al of
-    0,$80 : getWindowsVersion:=byte((getEnv('WINDIR')<>'') or (getEnv('windir')<>''));
-    1,$ff : getWindowsVersion:=2;
-  else getWindowsVersion:=r.ax;
-  end;
-end;
-
-const hexs:string='0123456789ABCDEF';
-Function hex(w:word):String;
-var s:string;
-begin
-  s[0]:=#4;
-  s[1]:=hexs[w shr 12+1];
-  s[2]:=hexs[w shr 8 and 15+1];
-  s[3]:=hexs[w shr 4 and 15+1];
-  s[4]:=hexs[w and 15+1];
-  while s[1]='0' do delete(s,1,1);
-  hex:=s;
-end;
-Function decm(s:string):word;
-var w,w2:word;
-begin
-  w:=0;
-  for w2:=1 to length(s) do w:=w+(pos(upcase(s[length(s)-w2+1]),hexs)-1) shl (4*w2-4);
-  decm:=w;
-end;
-
-const horizLine : string =
-      '';
-      hlpKeys    = 1;
-      hlpOpt     = 2;
-
-Procedure helpThem(which:word);
-const opts=13;
-      optss:array[1..opts] of string[80]=(
-      ' /Sn                - Set sampling rate n',
-      ' /M                 - Force mono mode',
-      ' /O                 - Scramble module orders',
-      ' /L                 - Turn looping off',
-      ' /Q                 - Quality mode playing on (8-bit cards)',
-      ' /Bn                - Volume bar type:0=off,1=mid,2=top,3=bot',
-      ' /H, /?             - This help screen',
-      ' /V                 - Force V86 support',
-      ' /Fn                - Force PMP to leave at least n kB of',
-      '                      memory free for DOS shell',
-      ' /Tn                - Force PMP to use a buffer of n bytes',
-      ' /Pp, /Ii, /Dd, /Cc - Force PMP to use card c, IO p, IRQ i,',
-      '                      DMA d (see PMP.DOC for details)'
-      );
-
-      keys=15;
-      keyss:array[1..keys] of string[80]=(
-      ' P, alt-F11         - Pause / resume module',
-      ' N, alt-F12         - Next module',
-      ' -/+, shift-F11/12  - Decrease / increase master volume',
-      ' F1 - F10           - Set master volume quickly',
-      ' H, ?               - This help screen',
-      ' I                  - Help about command line parameters',
-      ' S                  - Toggle SB Pro stereo mode on / off',
-      ' B                  - Toggle the volume bars on/off',
-      ' C                  - Clear the information screen',
-      ' D                  - DOS shell',
-      ' , , ctrl-F11/12  - Previous / next pattern',
-      ' ,                - Scroll the module list window',
-      ' 1, 2, 3, 4, ...    - Turn channel on/off',
-      ' <, >               - Slower / faster update rate (see docs)',
-      ' (, )               - Dec./inc. number of volume bars'
-      );
-
-var w:word;
-begin
-  textbackground(black);
-  textcolor(lightgray);
-  write(copy(horizLine,1,63));
-  if which=hlpOpt then begin
-    textColor(3);
-    write('                    Command line options :'); clrEol; writeln;
-    write('                    ~~~~~~~~~~~~~~~~~~~~~~'); clrEol; writeln;
-    textColor(9);
-    write(' PMP modulename [modulename] @listfile [/opt] [/opt]'); clrEol; writeln;
-    clrEol; writeln;
-    for w:=1 to opts do begin
-      textcolor(yellow);
-      write(copy(optss[w],1,20));
-      textcolor(white);
-      write(copy(optss[w],21,length(optss[w])-20)); clrEol; writeln;
-    end;
-  end else begin
-    textColor(3);
-    write('                     Keys while playing :'); clrEol; writeln;
-    write('                     ~~~~~~~~~~~~~~~~~~~~'); clrEol; writeln;
-    for w:=1 to keys do begin
-      textcolor(yellow);
-      write(copy(keyss[w],1,20));
-      textcolor(white);
-      write(copy(keyss[w],21,length(keyss[w])-20)); clrEol; writeln;
-    end;
-    clrEol; writeln;
-    textcolor(lightgreen);
-    write(' Commands with F11 and F12 are available also in the DOS shell ');
-  end;
-  textColor(lightgray);
-  write(copy(horizLine,1,63));
-end;
-
-Const eyellow=14;
-      elightgreen=10;
-      elightred=12;
-      egreen=2;
-
-Procedure endScreen;
-begin
-  asm mov ax,3; int 10h end;
-  textmode(co80);
-  window(1,1,80,25);
-  textcolor(lightgray);
-  textbackground(black);
-  clrScr;
-  textColor(elightred);
-  write(horizLine);
-  textColor(eyellow);
-  writeln(' Thanks for using PMP '+char(122-ord(PMPversion[1]))+'.'+char(122-ord(PMPversion[2]))+char(122-ord(PMPversion[3]))+
-          '                         How to contact the authors :');
-  textColor(elightred);
-  write(horizLine);
-  textColor(lightcyan);
-  write(' Contact Jussi Lahdenniemi, if you     ');
-  textColor(white);write('');textColor(lightcyan);
-  writeln(' Contact Otto Chrons, if you have some-');
-  write(' have something to ask or comment      ');
-  textColor(white);write('');textColor(lightcyan);
-  writeln(' thing to ask about DSMI generally or');
-  write(' about PMP, or the Pascal version      ');
-  textColor(white);write('');textColor(lightcyan);
-  writeln(' the C/ASM version of it.');
-  write(' of DSMI.                              ');
-  textColor(white);writeln('');
-  writeln('                                       ');
-  textColor(lightMagenta);
-  write(' Jussi Lahdenniemi                     ');
-  textColor(white);write('');textColor(lightmagenta);
-  writeln(' Otto Chrons');
-  write(' Rautia                                ');
-  textColor(white);write('');textColor(lightmagenta);
-  writeln(' Pyydyspolku 5');
-  write(' SF-36420 Sahalahti                    ');
-  textColor(white);write('');textColor(lightmagenta);
-  writeln(' SF-36200 Kangasala');
-  write(' Finland                               ');
-  textColor(white);write('');textColor(lightmagenta);
-  writeln(' Finland');
-  write(' tel. (voice) +358-31-3763273          ');
-  textColor(white);write('');textColor(lightmagenta);
-  writeln;
-  write(' Fidonet 2:221/105.7                   ');
-  textColor(white);write('');textColor(lightmagenta);
-  writeln(' Fidonet 2:221/105.10');
-{  write(' CABiNET 112:911/320.7                 ');}
-  write('                                       ');
-  textColor(white);write('');textColor(lightmagenta);
-{  writeln(' CABiNET 112:911/320.10');}
-  writeln('                       ');
-  write(' Internet jlahd@clinet.fi              ');
-  textColor(white);write('');textColor(lightmagenta);
-  writeln(' Internet c142092@cc.tut.fi');
-  write('                                       ');
-  textColor(white);write('');textColor(lightmagenta);
-  writeln;
-  textColor(elightred);
-  write(horizLine);
-  textColor(elightgreen);
-  writeln(' Read the documentation for information about the DSMI programming interface!');
-  textColor(elightred);
-  write(horizLine);
-end;
-
-Procedure interpolate(sam:PInstrument);
-var s2:pointer;
-    w,w2:word;
-begin
-  if (sam^.sample=nil) or (sam^.size>32700) then exit;
-  s2:=malloc(sam^.size*2-1);
-  if s2=nil then exit;
-  mem[seg(s2^):ofs(s2^)]:=mem[seg(sam^.sample^):ofs(sam^.sample^)];
-  for w:=1 to sam^.size-1 do begin
-    mem[seg(s2^):ofs(s2^)+w*2]:=
-      mem[seg(sam^.sample^):ofs(sam^.sample^)+w];
-    w2:=mem[seg(sam^.sample^):ofs(sam^.sample^)+w]+
-        mem[seg(sam^.sample^):ofs(sam^.sample^)+w-1];
-    w2:=w2 div 2;
-    mem[seg(s2^):ofs(s2^)+w*2-1]:=w2;
-  end;
-  sam^.rate:=sam^.rate*2;
-  sam^.size:=sam^.size*2;
-  sam^.loopStart:=sam^.rate*2;
-  sam^.loopEnd:=sam^.size*2;
-  free(sam^.sample);
-  sam^.sample:=s2;
-end;
-
-Procedure headerPic(offs:word);
-{$I PMPHDR.PAS}
-begin
-  move(header,mem[segb800:offs],header_Length);
-  mem[segb800:42*2+4*160+offs]:=122-ord(PMPversion[1]);
-  mem[segb800:43*2+4*160+offs]:=ord('.');
-  mem[segb800:44*2+4*160+offs]:=122-ord(PMPversion[2]);
-  mem[segb800:45*2+4*160+offs]:=122-ord(PMPversion[3]);
-  window(1,2,80,28);
-end;
-
-Const Srate      : word    = 21000;
-      Scramble   : boolean = false;
-      LoopIt     : boolean = true;
-      frcMono    : boolean = false;
-      bufferSiz  : word    = 2048;
-      bufferCh   : boolean = false;
-      quality    : boolean = false;
-      vol        : byte    = 64;
-      forceV86   : boolean = false;
-
-      cstIO      : word    = 0;
-      cstIRQ     : byte    = 0;
-      cstDMA     : byte    = 16;
-      cstCard    : byte    = 0;
-
-      maxNames   = 512;
-      modNameCnt : word    = 0;
-      modPointer : word    = 0;
-
-      cursor     : byte    = 1;
-      oldRow     : word    = 0;
-      curChar    : char    = '';
-
-      multitask  : word    = 0;
-
-      memmodcnt  : word    = 0;
-      modbplayed : word    = 0;
-
-      nextMod    : boolean = false;
-
-      quit       : boolean = false;
-
-      reqWriteP  : word    = 0;
-      resStereo  : boolean = false;
-      reqUpdAll  : boolean = true;
-      reqUpdIns  : boolean = true;
-      reqUpdMod  : boolean = true;
-      reqUpdBar  : boolean = true;
-
-      mwStart    : word    = 1;
-
-      len        : array[1..16] of byte = (0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);
-
-      drawBars   : word    = 1;
-
-      barRow     : word    = 0;
-
-      updRate    : word    = 3;
-
-      chn10p     : boolean = false;
-
-Type  TMemMod     = Record
-        name      : String[63];
-        module    : PModule;
-      end;
-
-      TModArr     = Array[1..maxNames] of ^TMemMod;
-
-Var   modn       : string;
-      modNames   : TModArr;
-      mn         : TMemMod;
-      w,w2,w3    : word;
-      tet        : text;
-      s          : string;
-      d          : dirstr;
-      e          : namestr;
-      g          : extstr;
-      processor  : byte;
-      V86        : boolean;
-      maxSize    : word;
-      oldKeyb    : pointer;
-      oldExit    : pointer;
-      proStereo  : boolean;
-      oldStereo  : boolean;
-      cl1,cl2,cl3: shortint;
-      dl1,dl2,dl3: shortint;
-      tc1,tc2,tc3: shortint;
-      td1,td2,td3: shortint;
-      dispBarC   : word;
-      old21      : byte;
-      olda1      : byte;
-
-Function f(w:integer):word;
-begin
-  if (w mod 1000)<1 then f:=w+modNameCnt else
-  if (w mod 1000)>modNameCnt then f:=w-modNameCnt else f:=w;
-end;
-
-Procedure moduleIntProc; forward;
-
-Procedure moduleInt; interrupt;
-begin
-  moduleIntProc;
-end;
-
-Procedure loadModules;
-var ch:char;
-
-Procedure removeCurrent;
-var w:word;
-begin
-  for w:=modPointer to modNameCnt-1 do modNames[w]:=modNames[w+1];
-  dec(modNameCnt);
-  modPointer:=f(modPointer-1);
-end;
-
-var tmpmod:PModule;
-    w:word;
-
-begin
-  if f(modPointer+1)=modBPlayed then exit;
-  if (modPointer>=1000) and (modPointer<2000) then exit;
-  if modPointer<1000 then begin
-    modPointer:=f(modPointer+1);
-    if modNames[modPointer]^.module<>nil then exit;
-    pollTag:=tsAddRoutine(@ampInterrupt,AMP_TIMER);
-    modiTag:=tsAddRoutine(@moduleInt,1193180 div 100);
-    tmpmod:=ampLoadModule(modNames[modPointer]^.name,LM_IML);
-    textColor(lightgreen);
-    if tmpmod<>nil then begin
-{      if tmpMod^.instrumentCount>0 then
-        for w:=0 to tmpmod^.instrumentCount-1 do interpolate(@tmpmod^.instruments^[w]);}
-      writeln('Loaded ',modNames[modPointer]^.name,' (size ',tmpmod^.size div 1024,'k, ',
-              memAvail div 1024,'k left)');
-      reqUpdMod:=true;
-      if f(modPointer+1)=modBPlayed then begin
-        textColor(3);
-        writeln('All modules reside in the memory!');
-      end;
-    end else begin
-      if moduleError=MERR_FILE then begin
-        textColor(lightRed);
-        writeln('File error loading module! Module will be removed from the play list.');
-        removeCurrent;
-      end else begin
-        textColor(3);
-        writeln('Module loading suspended due to low memory');
-      end;
-    end;
-    if moduleError=MERR_MEMORY then inc(modPointer,999) else begin
-      if moduleError=MERR_CORRUPT then begin
-        write('Module was corrupted! Play anyway or remove from the playing list (P/R) ?');
-        repeat
-          ch:=readkey;
-        until upcase(ch) in ['P','R'];
-        writeln(upcase(ch));
-        if upcase(ch)='P' then moduleError:=MERR_NONE else begin
-          removeCurrent;
-          tsRemoveRoutine(pollTag);
-          tsRemoveRoutine(modiTag);
-          exit;
-        end;
-      end;
-      modNames[modPointer]^.module:=tmpMod;
-      if (modBPlayed>=1000) and (modBPlayed<2000) then inc(modBPlayed,1000);
-    end;
-    tsRemoveRoutine(pollTag);
-    tsRemoveRoutine(modiTag);
-  end else begin
-    dec(modPointer,2000);
-    loadModules;
-  end;
-end;
-
-Procedure moduleIntProc;
-var old21:byte;
-    w:word;
-begin
-  inline($66/$60);   { PUSHAD }
-  old21:=port[$21];
-  port[$21]:=old21 or 1;
-  for w:=1 to dispBarC do if len[w]>0 then dec(len[w]);
-  if _curModule.patternCount>0 then
-  if (ampGetPattern=_curModule.patternCount-1) and (modNameCnt>1) then
-    cdiSetMasterVolume(0,vol*(64-ampGetRow) div 64) else cdiSetMasterVolume(0,vol);
-  if ((ampGetModuleStatus and MD_PLAYING=0) or nextMod) and (modBPlayed<1000) then begin
-    if (ampGetModuleStatus and MD_PLAYING)>0 then ampStopModule;
-    if (modPointer>=1000) and (modPointer<2000) then inc(modPointer,1000);
-    if modBPlayed<>0 then
-      if (f(modPointer+1)<>ModBPlayed) and (modNameCnt>1) then
-        ampFreeModule(modNames[modBPlayed]^.module)
-      else modPointer:=f(modPointer+1);
-    modBPlayed:=f(modBPlayed+1);
-    reqUpdIns:=true;
-    if modNames[modBPlayed]^.module<>nil then begin
-      cdiSetupChannels(0,modNames[modBPlayed]^.module^.channelCount,nil);
-      if dispBarC<>modNames[modBPlayed]^.module^.channelCount then begin
-        dispBarC:=modNames[modBPlayed]^.module^.channelCount;
-        reqUpdBar:=true;
-      end;
-      ampPlayModule(modNames[modBPlayed]^.module,PM_Loop*byte(loopIt and (modNameCnt=1)));
-      reqWriteP:=modBPlayed;
-    end else begin
-      inc(modBPlayed,1000);
-      reqWriteP:=0;
-    end;
-  end else if modBPlayed>=2000 then begin
-    dec(modBPlayed,2000);
-    if modNames[modBPlayed]^.module<>nil then begin
-      cdiSetupChannels(modNames[modBPlayed]^.module^.channelCount,1,nil);
-      if dispBarC<>modNames[modBPlayed]^.module^.channelCount then begin
-        dispBarC:=modNames[modBPlayed]^.module^.channelCount;
-        reqUpdBar:=true;
-      end;
-      ampPlayModule(modNames[modBPlayed]^.module,PM_Loop*byte(loopIt and (modNameCnt=1)));
-      reqWriteP:=modBPlayed;
-      reqUpdIns:=true;
-    end else begin
-      inc(modBPlayed,1000);
-      reqWriteP:=0;
-    end;
-  end;
-  nextMod:=false;
-  port[$21]:=old21;
-  inline($66/$61); { POPAD }
-end;
-
-Procedure updateStatus;
-
-Procedure writeL(ofs:word;w:word;n:byte);
-var s:string;
-begin
-  str(w,s);
-  asm
-    push   ds
-    mov    cl,[n]
-    sub    cl,byte ptr [s[0]]
-    mov    ax,segb800
-    mov    es,ax
-    mov    di,[ofs]
-    mov    ax,32+blue*256*16+lightgreen*256
-    rep    stosw
-    mov    cl,byte ptr [s[0]]
-    mov    ax,ss
-    mov    ds,ax
-    lea    si,s
-    inc    si
-    mov    ah,16*blue+lightgreen
-@1: lodsb
-    stosw
-    loop   @1
-    pop    ds
-  end;
-end;
-
-Procedure writeR(ofs:word;w:word;n:byte);
-var s:string;
-begin
-  str(w,s);
-  asm
-    push   ds
-    mov    ax,segb800
-    mov    es,ax
-    mov    di,[ofs]
-    mov    cl,byte ptr [s[0]]
-    mov    ax,ss
-    mov    ds,ax
-    lea    si,s
-    inc    si
-    mov    ah,16*blue+lightgreen
-@1: lodsb
-    stosw
-    loop   @1
-    mov    cl,[n]
-    sub    cl,byte ptr [s[0]]
-    mov    ax,32+blue*256*16+lightgreen*256
-    rep    stosw
-    pop    ds
-  end;
-end;
-
-var oldx,oldy:word;
-    w,w2:word;
-begin
-  if _curModule.patternCount=0 then exit;
-  writeL(9*2,ampGetPattern,3);
-  writeR(15*2,_curModule.patternCount-1,3);
-  writeL(25*2,ampGetRow,2);
-  writeL(37*2,vol,2);
-end;
-
-const mwx1=63;
-      mwy1=1;
-      mwx2=79;
-      mwy2=43;
-
-Procedure moduleWindow;
-var w,w2:word;
-    b:dirStr;
-    c:nameStr;
-    d:extStr;
-    ta:byte;
-    xx,yy:word;
-
-begin
-  ta:=textAttr;
-  xx:=whereX;
-  yy:=whereY;
-  textbackground(blue);
-  window(mwx1+2,mwy1+2,mwx2,mwy2);
-  for w:=0 to mwy2-mwy1-2 do begin
-    gotoxy(1,w+1);
-    if modNameCnt>=w+mwStart then begin
-      textColor(lightred);
-      if modNames[w+mwStart]^.module<>nil then write(' ') else write('  ');
-      if reqUpdAll then begin
-        fsplit(modNames[w+mwStart]^.name,b,c,d);
-        textColor(5);
-        write(c+d);
-      end;
-    end;
-    if reqUpdAll then clrEol;
-  end;
-  window(1,2,63,28);
-  textAttr:=ta;
-  gotoxy(xx,yy);
-  reqUpdAll:=false;
-  reqUpdMod:=false;
-end;
-
-Procedure instWindow;
-var w,w2:word;
-    ta:byte;
-    xx,yy:word;
-    s:string;
-begin
-  ta:=textAttr;
-  xx:=whereX;
-  yy:=whereY;
-  window(1,29,63,44);
-  textbackground(1);
-  textcolor(3);
-  clrScr;
-  for w:=0 to 15 do memw[segb800:28*160+31*2+w*160]:=179+256*(1*16+2);
-  for w:=0 to 15 do begin
-    fillchar(s[1],32,' ');
-    if _curModule.instrumentCount>=w+1 then strcpy(s[1],_curModule.instruments^[w].name);
-    for w2:=0 to 30 do mem[segb800:28*160+w*160+w2*2]:=ord(s[w2+1]);
-    fillchar(s[1],32,' ');
-    if _curModule.instrumentCount>=w+17 then strcpy(s[1],_curModule.instruments^[w+16].name);
-    for w2:=0 to 30 do mem[segb800:28*160+32*2+w*160+w2*2]:=ord(s[w2+1]);
-  end;
-  textAttr:=ta;
-  window(1,2,63,28);
-  gotoxy(xx,yy);
-  reqUpdIns:=false;
-end;
-
-Procedure FindMods(name:String);
-Var sr:SearchRec;
-    ps:dirStr;
-    ns:nameStr;
-    es:extStr;
-begin
-  Fsplit(name,ps,ns,es);
-  FindFirst(name,ReadOnly+Archive,sr);
-  while dosError=0 do begin
-    if modNameCnt<maxNames then begin
-      inc(modNameCnt);
-      modNames[modNameCnt]:=malloc(sizeof(TMemMod));
-      modNames[modNameCnt]^.name:=fexpand(ps+sr.name);
-      modNames[modNameCnt]^.module:=nil;
-    end;
-    FindNext(sr);
-  end;
-end;
-
-Procedure fadeAway;
-Procedure waitsc;
-var w:word;
-begin
-  for w:=0 to 100 do begin
-    while port[$3da] and 1=0 do;
-    while port[$3da] and 1=1 do;
-  end;
-end;
-var w:word;
-begin
-  for w:=63 downto 0 do begin cdiSetMasterVolume(0,w*vol div 64); ampPoll; waitsc end;
-  if scard.id<>ID_GUS then mcpClearBuffer;
-end;
-
-const keyDecVol = $8700;
-      keyIncVol = $8800;
-      keyDecPat = $8900;
-      keyIncPat = $8a00;
-      keyPause  = $8b00;
-      keyNxtMod = $8c00;
-
-Procedure newKeyb; Interrupt;
-var ptt,ptc:word;
-begin
-  inline($9c/$ff/$1e/oldKeyb);
-  if memw[seg0040:$1a]<>memw[seg0040:$1c] then begin
-    ptt:=memw[seg0040:$1c];
-    dec(ptt,2);
-    if ptt<memw[seg0040:$80] then ptt:=ptt+memw[seg0040:$82]-memw[seg0040:$80];
-    ptc:=memw[seg0040:ptt];
-    if ptc=keyDecVol then if vol>0 then dec(vol) else else
-    if ptc=keyIncVol then if vol<64 then inc(vol) else else
-    if ptc=keyDecPat then ampBreakPattern(-1) else
-    if ptc=keyIncPat then ampBreakPattern(1) else
-    if ptc=keyPause  then if (ampGetModuleStatus and MD_Paused)>0 then ampResumeModule else ampPauseModule;
-    if ptc=keyNxtMod then nextMod:=true else
-      exit;
-    memw[seg0040:$1c]:=ptt;
-  end;
-end;
-
-Procedure myExit;
-begin
-  exitProc:=oldExit;
-  setIntVec(9,oldKeyb);
-  if resStereo then mixerSet(MIX_Stereo,byte(oldStereo));
-  ampClose;
-  if scard.id<>ID_GUS then mcpClose else gusClose;
-  tsClose;
-  showCursor;
-  enableBlink;
-end;
-
-const clrRowCount = 64;
-
-(*Procedure clrBars(iR,iG,iB,dR,dG,dB,c1,c2,r1,r2,r3,r4:shortint;sRow:Word); external;
-{$L pmpbar.obj}*)
-
-type PColorStruct = ^TColorStruct;
-     TColorStruct = Record
-       barCount   : byte;
-       emptyColor : byte;
-       startRow   : word;
-       exitRow    : word;
-       barColor   : array[0..15] of byte;
-       barStart   : array[0..15] of word;
-       barEnd     : array[0..15] of word;
-       startRed   : byte;
-       startGreen : byte;
-       startBlue  : byte;
-       endRed     : byte;
-       endGreen   : byte;
-       endBlue    : byte;
-       dacEntry   : byte;
-       status     : array[0..15] of byte;
-     end;
-
-Procedure drawColorBars(p:PColorStruct;gus:boolean;ports:word); external;
-{$L pmpbar2.obj}
-
-const envCnt:word=0;
-var envs:array[1..100] of string[63];
-
-Procedure clipEnv(s:string);
-var ss:string;
-begin
-  ss:=s;
-  if pos(' ',ss)>0 then begin
-    clipEnv(copy(ss,1,pos(' ',s)-1));
-    delete(ss,1,pos(' ',s));
-    clipEnv(ss);
-  end else begin
-    inc(envCnt);
-    envs[envCnt]:=s;
-  end;
-end;
-
-var bkLn:array[0..62] of word;
-
-Procedure changeBarScreen(barcount:word);
-var r,r2,r3:real;
-    w,w2:word;
-begin
-  fillchar(bkLn,126,0);
-  if barcount=0 then exit;
-  r:=64/barcount-1;
-  r2:=0;
-  for w:=0 to barcount-1 do begin
-    r3:=r2+r;
-    for w2:=round(r2) to round(r3) do bkLn[w2]:=palRemOrder[w]*16*256;
-    r2:=r3+1;
-  end;
-end;
-
-Procedure fillbk(stRow:word);
-begin
-  asm
-       push    ds
-       mov     ax,segb800
-       mov     es,ax
-       mov     di,1*160
-       mov     ax,[stRow]
-       mov     bx,160
-       mul     bx
-       add     di,ax
-       mov     ax,seg bkLn
-       mov     ds,ax
-       lea     si,bkLn
-       mov     dx,2
-@out:  mov     cx,63
-@in:   mov     ax,[es:di]
-       and     ax,0fffh
-       or      ax,[ds:si]
-       stosw
-       add     si,2
-       loop    @in
-       sub     si,63*2
-       add     di,17*2
-       dec     dx
-       jnz     @out
-       pop     ds
-  end;
-end;
-
-Function paramCount:word;
-begin
-  paramCount:=system.paramCount+envCnt;
-end;
-
-Function paramStr(w:word):string;
-begin
-  if w=0 then paramStr:=system.paramstr(0) else
-  if w<=envCnt then paramstr:=envs[w] else
-  paramstr:=system.paramstr(w-envCnt);
-end;
-
-var trackData:PTrackData;
-    trackTime:Array[1..16] of word;
-    cs:TColorStruct;
-
-begin
-{  getmem(fakescreen,160*50+16);}
-  screenbuf:=dpmiSeg2slc($b9f4);
-{  getmem(modNames,sizeof(TModArr));}
-{  segb800:=seg(fakescreen^);}
-  getintvec(9,oldKeyb);
-  setintvec(9,@newKeyb);
-  oldExit:=exitProc;
-  exitProc:=@myExit;
-  r.ax:=3;
-  intr($10,r);
-  textMode(co80+font8x8);
-  portw[$3d4]:=16*256+$c;
-  portw[$3d4]:=0*256+$d;
-  setCorrectPalette;
-  hideCursor;
-  disableBlink;
-  clrScr;
-  window(1,1,80,1);
-  textbackground(blue);
-  textcolor(white);
-  clrScr;
-  write(' Pattern    /       Row      Volume                         Press H/I for help');
-  headerPic(44*160);
-  textbackground(black);
-  clipEnv(getEnv('PMP'));
-  if paramcount=0 then begin
-    textColor(lightgreen);
-    writeln('Use the switch /? or /h for the help screen.');
-    halt(0);
-  end;
-  mem[segb800:mwx1*2+mwy1*160]:=218;
-  mem[segb800:mwx2*2+mwy1*160]:=191;
-  mem[segb800:mwx1*2+mwy2*160]:=192;
-  mem[segb800:mwx2*2+mwy2*160]:=217;
-  for w:=mwx1+1 to mwx2-1 do begin
-    mem[segb800:w*2+mwy1*160]:=196;
-    mem[segb800:w*2+mwy2*160]:=196;
-  end;
-  for w:=mwy1+1 to mwy2-1 do begin
-    mem[segb800:mwx1*2+w*160]:=179;
-    mem[segb800:mwx2*2+w*160]:=179;
-  end;
-  for w:=mwy1 to mwy2 do
-    for w2:=mwx1 to mwx2 do
-      mem[segb800:w*160+w2*2+1]:=1*16+2;
-  window(1,2,63,28);
-  modn:='';
-  for w:=1 to paramcount do begin
-    s:=paramstr(w);
-    if (s[1]='-') or (s[1]='/') then
-      case upcase(s[2]) of
-        'S' : begin
-                delete(s,1,2);
-                val(s,r.bx,integer(r.cx));
-                if (r.bx>=4) and (r.bx<=44) then r.bx:=r.bx*1000;
-                if (r.bx<4000) or (r.bx>44100) then Break('Sampling rate must be between 4000 and 44100.');
-                srate:=r.bx;
-              end;
-        'M' : frcMono:=true;
-        'O' : Scramble:=true;
-        'L' : LoopIt:=False;
-        'Q' : quality:=True;
-        '?',
-        'H' : begin
-            textmode(co80);
-            textbackground(black);
-            clrScr;
-            headerPic(0);
-            window(1,7,63,25);
-            HelpThem(hlpOpt);
-            halt(0)
-          end;
-        'F' : begin
-                delete(s,1,2);
-                val(s,r.bx,integer(r.cx));
-                mallocMinLeft:=longint(r.bx)*1024;
-              end;
-        'T' : begin
-                delete(s,1,2);
-                val(s,r.bx,integer(r.cx));
-                if (r.bx<=0) or (r.bx>32000) then Break('Buffer size must be between 1 and 30000.');
-                bufferSiz:=r.bx;
-                bufferCh:=true;
-                multitask:=2;
-              end;
-        'P' : begin
-                delete(s,1,2);
-                cstIO:=decm(s);
-              end;
-        'I' : begin
-                delete(s,1,2);
-                val(s,cstIRQ,integer(r.cx));
-              end;
-        'D' : begin
-                delete(s,1,2);
-                val(s,cstDMA,integer(r.cx));
-              end;
-        'C' : begin
-                delete(s,1,2);
-                val(s,cstCard,integer(r.cx));
-                if not cstCard in [1..8] then Break('Soundcard number must be between 1 and 5.');
-              end;
-        'V' : forceV86:=true;
-        'B' : begin
-                delete(s,1,2);
-                val(s,drawBars,integer(r.cx));
-              end;
-      end
-    else begin
-      modn:=paramstr(w);
-      if (modn[1]='@') and (length(modn)>1) then begin
-        delete(modn,1,1);
-        assign(tet,modn);
-        reset(tet);
-        while not eof(tet) do begin
-          readln(tet,modn);
-          fsplit(modn,d,e,g);
-          r.bx:=modNameCnt;
-          FindMods(modn);
-          if (g='') and (r.bx=modNameCnt) then begin
-            g:='.AMF';
-            FindMods(d+e+g);
-            g:='.MOD';
-            FindMods(d+e+g);
-            g:='.STM';
-            FindMods(d+e+g);
-            g:='.S3M';
-            FindMods(d+e+g);
-            g:='.669';
-            FindMods(d+e+g);
-          end;
-        end;
-        close(tet);
-      end else begin
-        fsplit(modn,d,e,g);
-        r.bx:=modNameCnt;
-        FindMods(modn);
-        if (g='') and (r.bx=modNameCnt) then begin
-          g:='.AMF';
-          FindMods(d+e+g);
-          g:='.MOD';
-          FindMods(d+e+g);
-          g:='.STM';
-          FindMods(d+e+g);
-          g:='.S3M';
-          FindMods(d+e+g);
-          g:='.669';
-          FindMods(d+e+g);
-        end;
-      end;
-    end;
-  end;
-  if modNameCnt=0 then Break('No files found!');
-  randomize;
-  if Scramble then
-    for r.ax:=0 to modNameCnt*100 do begin
-      r.cx:=random(modNameCnt)+1;
-      r.dx:=random(modNameCnt)+1;
-      if r.cx<>r.dx then begin
-        longint(modNames[r.cx]):=longint(modNames[r.cx]) xor longint(modNames[r.dx]);
-        longint(modNames[r.dx]):=longint(modNames[r.dx]) xor longint(modNames[r.cx]);
-        longint(modNames[r.cx]):=longint(modNames[r.cx]) xor longint(modNames[r.dx]);
-      end;
-{      mn:=modNames[r.cx];
-      modNames[r.cx]:=modNames[r.dx];
-      modNames[r.dx]:=mn;}
-    end;
-
-  textcolor(magenta);
-  if paramcount=0 then begin
-    Writeln('Please specify the module name on the command line!');
-    halt(1);
-  end;
-  if (cstIO<>0) or (cstIRQ<>0) or (cstDMA<>16) or (cstCard<>0) then begin
-    if cstDMA=16 then scard.dmaChannel:=1 else scard.dmaChannel:=cstDMA;
-    scard.sampleSize:=1;
-    scard.stereo:=not frcMono;
-    case cstCard of
-      1 : scard.ID:=ID_SB;
-      2 : scard.ID:=ID_SBPro;
-      3 : begin
-            scard.ID:=ID_PASPLUS;
-            if cstIO=0 then cstIO:=$388;
-          end;
-      4 : begin
-            scard.ID:=ID_PAS16;
-            scard.samplesize:=2;
-            if cstIO=0 then cstIO:=$388;
-            if cstDMA=16 then scard.dmaChannel:=5;
-          end;
-      5 : begin
-            scard.ID:=ID_SB16;
-            scard.samplesize:=2;
-            if cstIRQ=0 then cstIRQ:=5;
-          end;
-      6 : begin
-            scard.ID:=ID_ARIA;
-          end;
-      7 : begin
-            scard.ID:=ID_WSS;
-          end;
-      8 : begin
-            scard.ID:=ID_GUS;
-          end;
-    else Break('You have to specify the soundcard with the option -c.');
-    end;
-    if cstIRQ=0 then cstIRQ:=7;
-    if cstIO=0 then cstIO:=$220;
-    scard.IOport:=cstIO;
-    scard.dmaIRQ:=cstIRQ;
-  end else begin
-    if detectGUS(@Scard)<>0 then
-    if detectPAS(@Scard)<>0 then
-    if detectSB16(@Scard)<>0 then
-    if detectAria(@Scard)<>0 then
-    if detectSBpro(@Scard)<>0 then
-    if detectSB(@Scard)<>0 then Break('No soundcard found!');
-    textcolor(yellow);
-    with scard do begin
-      writeln(' Using ',name,' found at ',hex(IOport),'h,');
-      writeln('  DMA IRQ number ',dmaIRQ,', DMA channel ',dmaChannel);
-    end;
-  end;
-  processor:=getCpuType;
-  r.ax:=$400;
-  intr($31,r);
-  V86:=(r.bx and 2)<>2;
-  textcolor(yellow);
-  write(' Processor : ');
-  case processor of
-    0 : writeln('8086/80186');
-    1 : writeln('80286');
-    3 : write('80386, ');
-    7 : write('80486, ');
-  end;
-  if processor<3 then Break('You need at least a 386sx to run this program!');
-  if not V86 then write('not ');
-  writeln('in the V86 mode.');
-  if forceV86 then begin
-    writeln(' Forced to V86 mode!');
-    V86:=true;
-  end;
-  writeln(' Free memory ',memAvail div 1024,' kilobytes.');
-  w:=getDVversion;
-  if w<>0 then begin
-    writeln(' Detected DesqView ',w div 256,'.',w and $ff);
-    multitask:=multitask or 1;
-  end else begin
-    w:=getWindowsVersion;
-    if w>0 then
-    if w=1 then writeln(' Detected Windows 3.xx in standard or real mode') else
-    if w=2 then writeln(' Detected Windows/386 2.xx') else
-                writeln(' Detected Windows ',w and $ff,'.',w div 256,' in enhanced mode');
-    if w>1 then multitask:=multitask or 1;
-  end;
-  i:=1;
-  if frcMono then scard.Stereo:=false;
-  case Scard.id of
-    ID_SB    : i:=mcpInitSoundDevice(SDI_SB,@Scard);
-    ID_SBPRO : i:=mcpInitSoundDevice(SDI_SBPro,@Scard);
-    ID_ARIA  : i:=mcpInitSoundDevice(SDI_ARIA,@Scard);
-    ID_PAS,
-    ID_PASPLUS,
-    ID_PAS16 : i:=mcpInitSoundDevice(SDI_PAS,@Scard);
-    ID_SB16  : i:=mcpInitSoundDevice(SDI_SB16,@Scard);
-    ID_GUS   : i:=0;
-  end;
-  If i<>0 then Break('Unable to initialize the soundcard!');
-
-  if Scard.id<>ID_GUS then begin
-    if multitask=1 then bufferSiz:=16384 else
-    if (multitask=0) and not bufferCh then
-      bufferSiz:=(srate div 30)*(2*(1+byte(scard.stereo)))*scard.sampleSize;
-    with mcps do begin
-      samplingRate:=srate;
-      Options:=mcp_Quality*byte(quality)+mcp_486*byte(processor>=7);
-      bufferSize:=bufferSiz*2;
-      reqSize:=bufferSiz;
-      if V86 then begin
-        maxSize:=4096;
-        while dpmiAllocDOS(maxSize,w3,temps)<>0 do dec(maxSize);
-  {      if maxSize<>3760 then begin
-          w3:=textAttr;
-          textcolor(white+blink);
-          textbackground(red);
-          writeln('PMP debug :                                          ');
-          writeln('Please report this number to Jussi Lahdenniemi : ',maxSize);
-          writeln('Report also your system configuration, drivers etc.  ');
-          writeln('Press any key..                                      ');
-          readkey;
-          textAttr:=w3;
-        end;}
-        dpmiFreeDOS(temps);
-        dec(maxSize,1);
-        w2:=(bufferSize+MCP_TableSize+MCP_QualitySize) div 16+1;
-        dpmiAllocDOS(maxSize-w2,w3,temps);
-        dpmiAllocDOS(w2,w3,bufferSeg);
-        bufferLinear:=dpmiGetLinearAddr(bufferSeg);
-        dpmiFreeDOS(temps);
-      end else begin
-        getmem(playBuf,bufferSize+816+MCP_TableSize+MCP_QualitySize);
-        bufferSeg:=seg(playBuf^);
-        bufferLinear:=dpmiGetLinearAddr(bufferSeg);
-      end;
-    end;
-    i:=0;
-    i:=i or tsInit;
-    i:=i or mcpInit(mcps);
-    i:=i or cdiInit;
-    i:=i or cdiRegister(@CDI_MCP,0,31);
-  end else begin
-    drawBars:=0;
-    i:=tsInit;
-    i:=i or gusInit(@Scard);
-    i:=i or gushmInit;
-    i:=i or cdiInit;
-{    if V86 then i:=i or cdiRegister(@CDI_GUSDPMIV86,0,31) else}
-                i:=i or cdiRegister(@CDI_GUS,0,31);
-  end;
-  i:=i or ampInit(0);
-  if scard.id<>ID_GUS then begin
-    mcpStartVoice;
-    if scard.id=ID_SBPro then begin
-      mixerInit(MIXER_SBPro,scard.IOport);
-      byte(oldStereo):=mixerGet(MIX_STEREO);
-      proStereo:=not frcMono;
-      mixerSet(MIX_Stereo,byte(proStereo));
-      resStereo:=true;
-    end;
-  end else gusStartVoice;
-  if i<>0 then break('Could not initialize the player!');
-  for w:=1 to 16 do trackTime[w]:=65535;
-  randomize;
-  cl1:=0;
-  cl2:=0;
-  cl3:=20;
-  dl1:=0;
-  dl2:=0;
-  dl3:=20;
-  tc1:=random(48);
-  tc2:=random(48);
-  tc3:=16+random(48);
-  td1:=random(48);
-  td2:=random(48);
-  td3:=16+random(48);
-  with cs do begin
-    emptyColor:=0;
-    startRow:=0;
-    exitRow:=215;
-    for w:=0 to 15 do barColor[w]:=palRemOrder[w];
-    barStart[0]:=0;
-    barStart[1]:=0;
-    barStart[2]:=0;
-    barStart[3]:=0;
-    barEnd[0]:=400;
-    barEnd[1]:=400;
-    barEnd[2]:=400;
-    barEnd[3]:=400;
-    dacEntry:=11;
-  end;
-  for w:=0 to 24 do fillbk(w);
-  updateScreen(160*50);
-
-  repeat
-    bkgrnd(0);
-    if (drawBars>0) and (dispBarC>0) then begin
-      with cs do begin
-
-        case drawBars of
-          1 : for w:=0 to dispBarC-1 do begin
-                barStart[w]:=111-round(len[w+1]*1.625);
-                barEnd[w]:=round(len[w+1]*1.625)+111;
-              end;
-          2 : for w:=0 to dispBarC-1 do begin
-                barStart[w]:=0;
-                barEnd[w]:=round(len[w+1]*3.25)+4;
-              end;
-          3 : for w:=0 to dispBarC-1 do begin
-                barStart[w]:=215-round(len[w+1]*3.25);
-                barEnd[w]:=400;
-              end;
-        end;
-
-        barCount:=dispBarC;
-        startRed:=cl1;
-        startGreen:=cl2;
-        startBlue:=cl3;
-        endRed:=dl1;
-        endGreen:=dl2;
-        endBlue:=dl3;
-      end;
-      old21:=port[$21]; olda1:=port[$a1];
-      drawColorBars(@cs,scard.id=ID_GUS,(not (1 shl scard.dmairq)) and (not 4));
-
-      fillbk(barRow);
-      inc(barRow,2);
-      if barRow=26 then barRow:=0;
-      if cl1<tc1 then inc(cl1) else if cl1>tc1 then dec(cl1) else tc1:=random(48);
-      if cl2<tc2 then inc(cl2) else if cl2>tc2 then dec(cl2) else tc2:=random(48);
-      if cl3<tc3 then inc(cl3) else if cl3>tc3 then dec(cl3) else tc3:=16+random(48);
-      if dl1<td1 then inc(dl1) else if dl1>td1 then dec(dl1) else td1:=random(48);
-      if dl2<td2 then inc(dl2) else if dl2>td2 then dec(dl2) else td2:=random(48);
-      if dl3<td3 then inc(dl3) else if dl3>td3 then dec(dl3) else td3:=16+random(48);
-    end else {if scard.id<>ID_GUS then} begin
-      if scard.id<>ID_GUS then asm cli end
-                          else begin
-                            old21:=port[$21];
-                            olda1:=port[$a1];
-                            w:=(not (1 shl scard.dmairq)) and (not 4);
-                            port[$21]:=lo(w);
-                            port[$a1]:=hi(w);
-                          end;
-      while port[$3da] and 8=0 do;
-      while port[$3da] and 8=8 do;
-      while port[$3da] and 1=1 do;
-      while port[$3da] and 1=0 do;
-    end;
-    if scard.id<>ID_GUS then bkgrndABS(63);
-    ampPoll;
-    {$IFDEF DEBUG}
-    bkgrnd(10);
-    {$ELSE}
-    if scard.id<>ID_GUS then bkgrndABS(0);
-    {$ENDIF}
-    moduleIntProc;
-    updateScreen(160*updRate);
-    if scard.id<>ID_GUS then asm sti end
-                        else begin
-                          port[$21]:=old21;
-                          port[$a1]:=olda1;
-                        end;
-    if dispBarC>0 then
-    for w:=0 to dispBarC-1 do begin
-      w2:=w;
-      trackData:=ampGetTrackData(w2);
-      if (trackData^.playTime<trackTime[w2+1]) and
-         (ampGetTrackStatus(w2) and TR_Paused=0) then len[w+1]:=trackData^.volume;
-      if trackData^.playTime>0 then trackTime[w2+1]:=trackData^.playTime;
-    end;
-    loadModules;
-    updateStatus;
-    if reqUpdBar then begin
-      if drawBars>0 then makePaletteMap(dispBarC) else makePaletteMap(0);
-      if drawBars>0 then changeBarScreen(dispBarC) else changeBarScreen(0);
-      for w:=0 to 24 do fillbk(w);
-      updateScreen(160*50);
-      reqUpdBar:=false;
-    end;
-    if reqUpdMod then moduleWindow;
-    if reqUpdIns then instWindow;
-    if reqWriteP>0 then begin
-      textcolor(green);
-      writeln('Playing ',modNames[reqWriteP]^.module^.name);
-      reqWriteP:=0;
-    end;
-    if ampGetRow<>oldRow then begin
-      oldRow:=ampGetRow;
-      textcolor(10+blink);
-      textbackground(11);
-      write(curChar,#13);
-      textbackground(0);
-    end;
-    if keypressed then ch:=upcase(readkey) else ch:=#255;
-    if ch<>#255 then
-    case ch of
-      'P' : if (ampGetModuleStatus and MD_Paused)=0 then begin
-              ampPauseModule;
-              textcolor(green);
-              writeln('Module paused');
-            end else begin
-              ampResumeModule;
-              textcolor(green);
-              writeln('Module resumed');
-            end;
-      '+' : if vol<64 then inc(vol);
-      '-' : if vol>0 then dec(vol);
-      '<' : if updRate>1 then dec(updRate);
-      '>' : if updRate<25 then inc(updRate);
-      '(' : if dispBarC>1 then begin dec(dispBarC); reqUpdBar:=true end;
-      ')' : if dispBarC<16 then begin inc(dispBarC); reqUpdBar:=true end;
-      'H',
-      '?' : helpThem(hlpKeys);
-      'I' : helpThem(hlpOpt);
-      'C' : clrScr;
-      'N' : begin fadeAway; ampStopModule; nextMod:=true; end;
-      'S' : if scard.ID=ID_SBPro then begin
-              proStereo:=not proStereo;
-              mixerSet(MIX_Stereo,byte(proStereo));
-            end;
-      'B' : {if scard.id<>ID_GUS then} begin
-              if drawBars=3 then drawBars:=0 else inc(drawBars);
-              reqUpdBar:=true;
-            end;
-      'D' : begin
-              pollTag:=tsAddRoutine(@ampInterrupt,AMP_Timer);
-              modiTag:=tsAddRoutine(@moduleInt,1193180 div 100);
-              asm mov ax,3; int 10h end;
-              textmode(co80);
-              gotoxy(1,2);
-              showCursor;
-              textcolor(lightmagenta);
-              writeln('Shelling to DOS..');
-              swapvectors;
-              exec(getenv('COMSPEC'),'');
-              swapvectors;
-              r.ax:=3;
-              intr($10,r);
-              textMode(co80+font8x8);
-              hideCursor;
-              setCorrectPalette;
-              clrScr;
-              window(1,1,80,1);
-              textbackground(blue);
-              textcolor(white);
-              clrScr;
-              write(' Pattern    /       Row      Volume                         Press H/I for help');
-              headerPic(44*160);
-              mem[segb800:mwx1*2+mwy1*160]:=218;
-              mem[segb800:mwx2*2+mwy1*160]:=191;
-              mem[segb800:mwx1*2+mwy2*160]:=192;
-              mem[segb800:mwx2*2+mwy2*160]:=217;
-              for w:=mwx1+1 to mwx2-1 do begin
-                mem[segb800:w*2+mwy1*160]:=196;
-                mem[segb800:w*2+mwy2*160]:=196;
-              end;
-              for w:=mwy1+1 to mwy2-1 do begin
-                mem[segb800:mwx1*2+w*160]:=179;
-                mem[segb800:mwx2*2+w*160]:=179;
-              end;
-              for w:=mwy1 to mwy2 do
-                for w2:=mwx1 to mwx2 do
-                  mem[segb800:w*160+w2*2+1]:=blue*16+white;
-              window(1,2,63,28);
-              textbackground(black);
-              textcolor(2);
-              if dosError<>0 then begin
-                textColor(lightred);
-                writeln('Unable to shell! Probably not enough memory.');
-              end else
-              writeln('Returned from the DOS shell');
-              textcolor(green);
-              if (modBPlayed<1000) and (modNames[modBPlayed]^.module<>nil) then
-              writeln('Playing ',modNames[modBPlayed]^.module^.name,' ...');
-              disableBlink;
-              reqWriteP:=0;
-              reqUpdIns:=true;
-              reqUpdAll:=true;
-              reqUpdMod:=true;
-              tsRemoveRoutine(pollTag);
-              tsRemoveRoutine(modiTag);
-            end;
-      'Z' : begin
-              textcolor(15);
-              writeln('Congratulations! You have found the secret key! Be proud of it!');
-            end;
-      'G' : if scard.id=ID_GUS then gushmShowHeap;
-      #0  : begin
-              ch:=readkey;
-              case ch of
-                #59..#68 : vol:=round((ord(ch)-58)*6.4);
-                #75      : ampBreakPattern(-1);
-                #77      : ampBreakPattern(1);
-                #72      : begin if mwStart>1 then dec(mwStart); reqUpdAll:=true end;
-                #80      : if mwStart+mwy2-mwy1-2<modNameCnt then begin inc(mwStart); reqUpdAll:=true end;
-                #120..
-                #129     : chn10p:=true;
-              end;
-            end;
-    end;
-    if (_curModule.patternCount>0) and (ch in ['0'..'9']) then begin
-      if ch='0' then ch:=char(byte('9')+1);
-      if ch in ['1'..char(_curModule.channelCount+ord('0'))] then begin
-        r.ax:=ord(ch)-ord('1'); {curModule.channelPanning[ord(ch)-ord('1')];}
-        if (ampGetTrackStatus(r.ax) and TR_Paused)>0 then ampResumeTrack(r.ax)
-                                                     else ampPauseTrack(r.ax);
-      end;
-    end;
-    if chn10p and (_curModule.patternCount>10) then
-      if ch in [#120..char(_curModule.channelCount+109)] then begin
-        r.ax:=ord(ch)-110; {curModule.channelPanning[ord(ch)-ord('1')];}
-        if (ampGetTrackStatus(r.ax) and TR_Paused)>0 then ampResumeTrack(r.ax)
-                                                     else ampPauseTrack(r.ax);
-      end;
-    chn10p:=false;
-  until (ch in [#27]) or quit;
-  fadeAway;
-  ampStopModule;
-  endScreen;
-end.
diff --git a/dmp/pmpbar.asm b/dmp/pmpbar.asm
deleted file mode 100644
index 7f63eaa..0000000
--- a/dmp/pmpbar.asm
+++ /dev/null
@@ -1,287 +0,0 @@
-; ***************************************************************************
-;
-;                                 PMPBAR.ASM
-;                                 ----------
-;
-;                         (C) 1993 Jussi Lahdenniemi
-;
-; Color bar routine for PMP 2.20+
-;
-; You can use this routine and/or it's idea in your own products, but
-; you must mention me somewhere.
-;
-; NOTICE! The routine disables the interrupts, but DOES NOT enable them!
-;
-; ***************************************************************************
-
-                   IDEAL
-                   MODEL TPASCAL
-                   JUMPS
-                   P386
-
-;DEFINE             DEBUG
-
-                   CODESEG
-
-                   PUBLIC clrBars
-
-                   MACRO waitRetr
-                   Mov      dx,3dah
-                   In       al,dx         ; WaitDisp:
-                   test     al,1
-                   DB       74h,-5        ; jz waitDisp
-                   In       al,dx         ; WaitRetr:
-                   test     al,1
-                   DB       75h,-5        ; jnz waitRetr
-                   ENDM
-
-                   MACRO bkclr X
-IFDEF              DEBUG
-                   mov   dx,3dah
-                   in    al,dx
-                   mov   dx,3c0h
-                   mov   al,17+32
-                   out   dx,al
-                   mov   al,x
-                   out   dx,al
-ENDIF
-                   ENDM
-
-                   MACRO setcol X,Z
-                   mov      bl,[de&X&]
-                   mov      ah,bl
-                   and      ah,80h
-                   shr      ah,5
-                   mov      dl,[q&X&Z&]
-                   xchg     ax,bx
-                   cbw
-                   xor      al,ah
-                   sub      al,ah
-                   xchg     ax,bx
-                   add      dl,bl
-                   mov      [q&X&Z&],dl
-                   test     dl,128+64
-                   jz       @@noChange&X&Z&
-                   mov      al,dl
-                   and      dl,00111111b
-                   mov      [q&X&Z&],dl
-                   shr      al,6
-                   or       al,ah
-                   sub      ah,ah
-                   mov      bx,ax
-                   mov      al,[byte ptr clrTable+bx]
-                   add      [n&X&Z&],al
-@@noChange&X&Z&:
-                   ENDM
-
-                   MACRO scrlcol Y
-                   setcol R,&Y&
-                   setcol G,&Y&
-                   setcol B,&Y&
-                   ENDM
-
-clrTable:          DB       0,1,2,3,0,-1,-2,-3
-
-PROC               clrBars FAR iR:Byte,iG:Byte,iB:Byte,deR:Byte,deG:Byte,deB:Byte,c1:Byte,c2:Byte,r1:Byte,r2:Byte,r3:Byte,r4:Byte,sr:Word
-
-                   LOCAL    nR1:Byte,nG1:Byte,nB1:Byte
-                   LOCAL    nR2:Byte,nG2:Byte,nB2:Byte
-                   LOCAL    nR3:Byte,nG3:Byte,nB3:Byte
-                   LOCAL    nR4:Byte,nG4:Byte,nB4:Byte
-                   LOCAL    qR1:Byte,qG1:Byte,qB1:Byte
-                   LOCAL    qR2:Byte,qG2:Byte,qB2:Byte
-                   LOCAL    qR3:Byte,qG3:Byte,qB3:Byte
-                   LOCAL    qR4:Byte,qG4:Byte,qB4:Byte
-                   LOCAL    status:Byte
-                   LOCAL    linenr:Word
-
-                   Push     ds
-                   Push     es
-                   cli
-                   Mov      [linenr],0
-                   Mov      [status],0ffh
-                   Mov      dx,3dah
-@@waitRetrace:     In       al,dx
-                   test     al,8
-                   jz       @@waitRetrace
-@@waitDisplay:     In       al,dx
-                   test     al,8
-                   jnz      @@waitDisplay
-                   mov      cx,[sr]
-                   dec      cx
-@@emptyRows:       waitRetr
-                   loop     @@emptyRows
-
-                   bkclr 3
-
-                   mov      [qR1],0
-                   mov      [qG1],0
-                   mov      [qB1],0
-                   mov      [qR2],0
-                   mov      [qG2],0
-                   mov      [qB2],0
-                   mov      [qR3],0
-                   mov      [qG3],0
-                   mov      [qB3],0
-                   mov      [qR4],0
-                   mov      [qG4],0
-                   mov      [qB4],0
-                   sub      cx,cx
-                   mov      al,[iR]
-                   mov      [nR1],al
-                   mov      [nR2],al
-                   mov      [nR3],al
-                   mov      [nR4],al
-                   mov      al,[iG]
-                   mov      [nG1],al
-                   mov      [nG2],al
-                   mov      [nG3],al
-                   mov      [nG4],al
-                   mov      al,[iB]
-                   mov      [nB1],al
-                   mov      [nB2],al
-                   mov      [nB3],al
-                   mov      [nB4],al
-@@bigLoop:
-                   mov      dx,3c8h
-                   mov      al,[c1]
-                   out      dx,al
-                   inc      dx
-                   mov      al,[nR1]
-                   out      dx,al
-                   mov      al,[nG1]
-                   out      dx,al
-                   mov      bl,[nB1]
-                   mov      bh,[nR3]
-                   mov      ah,[nG3]
-                   waitRetr
-                   waitRetr
-                   mov      al,bl
-                   mov      dx,3c9h
-                   out      dx,al
-                   mov      al,bh
-                   out      dx,al
-                   mov      al,ah
-                   out      dx,al
-                   mov      al,[nB3]
-                   out      dx,al
-                   cmp      cl,[r1]
-                   jae      @@zeroCols1
-;                   mov      al,[deR]
-;                   add      [nR1],al
-;                   mov      al,[deG]
-;                   add      [nG1],al
-;                   mov      al,[deB]
-;                   add      [nB1],al
-
-                   scrlcol 1
-
-                   jmp      @@nonzero1
-@@zeroCols1:       mov      [nR1],0
-                   mov      [nG1],0
-                   mov      [nB1],20
-                   test     [status],1
-                   jz       @@alr1
-                   and      [status],not 1
-                   jmp      @@nonzero1
-@@alr1:            and      [status],not 16
-@@nonzero1:        cmp      cl,[r3]
-                   jae      @@zeroCols3
-;                   mov      al,[deR]
-;                   add      [nR3],al
-;                   mov      al,[deG]
-;                   add      [nG3],al
-;                   mov      al,[deB]
-;                   add      [nB3],al
-
-                   scrlcol 3
-
-                   jmp      @@nonzero3
-@@zeroCols3:       mov      [nR3],0
-                   mov      [nG3],0
-                   mov      [nB3],20
-                   test     [status],4
-                   jz       @@alr3
-                   and      [status],not 4
-                   jmp      @@nonzero3
-@@alr3:            and      [status],not 64
-@@nonzero3:
-
-                   mov      dx,3c8h
-                   mov      al,[c2]
-                   out      dx,al
-                   inc      dx
-                   mov      al,[nR2]
-                   out      dx,al
-                   mov      al,[nG2]
-                   out      dx,al
-                   mov      bl,[nB2]
-                   mov      bh,[nR4]
-                   mov      ah,[nG4]
-                   waitRetr
-                   mov      al,bl
-                   mov      dx,3c9h
-                   out      dx,al
-                   mov      al,bh
-                   out      dx,al
-                   mov      al,ah
-                   out      dx,al
-                   mov      al,[nB4]
-                   out      dx,al
-                   cmp      cl,[r2]
-                   jae      @@zeroCols2
-;                   mov      al,[deR]
-;                   add      [nR2],al
-;                   mov      al,[deG]
-;                   add      [nG2],al
-;                   mov      al,[deB]
-;                   add      [nB2],al
-
-                   scrlcol 2
-
-                   jmp      @@nonzero2
-@@zeroCols2:       mov      [nR2],0
-                   mov      [nG2],0
-                   mov      [nB2],20
-                   test     [status],2
-                   jz       @@alr2
-                   and      [status],not 2
-                   jmp      @@nonzero2
-@@alr2:            and      [status],not 32
-@@nonzero2:        cmp      cl,[r4]
-                   jae      @@zeroCols4
-;                   mov      al,[deR]
-;                   add      [nR4],al
-;                   mov      al,[deG]
-;                   add      [nG4],al
-;                   mov      al,[deB]
-;                   add      [nB4],al
-
-                   scrlcol 4
-
-                   jmp      @@nonzero4
-@@zeroCols4:       mov      [nR4],0
-                   mov      [nG4],0
-                   mov      [nB4],20
-                   test     [status],8
-                   jz       @@alr4
-                   and      [status],not 8
-                   jmp      @@nonzero4
-@@alr4:            and      [status],not 128
-@@nonzero4:
-
-                   inc      [linenr]
-                   cmp      [linenr],72
-                   jz       @@outtaHere
-                   inc      cx
-                   jmp      @@bigLoop
-@@outtaHere:       Pop      es
-                   Pop      ds
-
-                   bkclr  1
-
-;                   Sti
-                   Ret
-ENDP
-
-END
diff --git a/dmp/pmpbar2.asm b/dmp/pmpbar2.asm
deleted file mode 100644
index 192312d..0000000
--- a/dmp/pmpbar2.asm
+++ /dev/null
@@ -1,330 +0,0 @@
-; ***************************************************************************
-;
-;                              PMPBAR2.ASM
-;                              -----------
-;
-;                Color bar routine version 2, for PMP 2.31+
-;
-;                     (C) 1993 Jussi Lahdenniemi
-;
-; You may freely use this source in your own products, modified or
-; unmodified, as long as you give credits to me.
-;
-; ***************************************************************************
-
-        MODEL TPASCAL
-        IDEAL
-        JUMPS
-        P386N
-
-        tcstrbarCount   =       0
-        tcstremptyColor =       tcstrbarCount+1
-        tcstrstartRow   =       tcstremptyColor+1
-        tcstrexitRow    =       tcstrstartRow+2
-        tcstrbarColor   =       tcstrexitRow+2
-        tcstrbarStart   =       tcstrbarColor+16
-        tcstrbarEnd     =       tcstrbarStart+16*2
-        tcstrstartRed   =       tcstrbarEnd+16*2
-        tcstrstartGreen =       tcstrstartRed+1
-        tcstrstartBlue  =       tcstrstartGreen+1
-        tcstrendRed     =       tcstrstartBlue+1
-        tcstrendGreen   =       tcstrendRed+1
-        tcstrendBlue    =       tcstrendGreen+1
-        tcstrdacEntry   =       tcstrendBlue+1
-        tcstrstatus     =       tcstrdacEntry+1
-
-CODESEG
-
-        Public  drawColorBars
-
-
-; Status byte:
-; bit 0 : If set, the bar is visible at the moment
-; bit 1 : If set, the bar should be set to visible in the next retrace
-; bit 2 : If set, the bar should be set to invisible in the next retrace
-
-PROC    drawColorBars FAR uses ecx esi edi,cstr:DWORD,gus:BYTE,ports:WORD
-        local   w:word,w2:word,redInc:dword,greenInc:dword,blueInc:dword
-        local   cRed:dword,cGreen:dword,cBlue:dword
-        local   currentRow:word,mustChange:byte,tempcl:byte
-
-        push    ds
-        sub     esi,esi
-        lds     si,[cstr]
-        cmp     [byte ptr esi+tcstrbarCount],0
-        jnz     notZero
-        pop     ds
-        ret
-notZero:
-        mov     [dword ptr si+tcstrstatus],0          ; Set status to zero
-        mov     [dword ptr si+tcstrstatus+4],0
-        mov     [dword ptr si+tcstrstatus+8],0
-        mov     [dword ptr si+tcstrstatus+12],0
-        mov     ax,[esi+tcstrexitRow]
-        sub     ax,[esi+tcstrstartRow]
-        mov     [w],ax
-        sub     ax,ax
-        mov     dx,1
-        div     [w]
-        mov     [w2],ax
-        mov     al,[esi+tcstrendRed]                   ; Calculate delta
-        sub     al,[esi+tcstrstartRed]                 ; red for each row
-        cbw
-        xor     al,ah
-        sub     al,ah
-        mov     bl,ah
-        mov     bh,ah
-        sub     ah,ah
-        sub     dx,dx
-        div     [w]
-        sub     ah,ah
-        xor     ax,bx
-;        sub     ax,bx
-        mov     [word ptr redInc+2],ax
-        mov     ax,dx
-        mul     [w2]
-        xor     ax,bx
-;        sub     ax,bx
-        mov     [word ptr redInc],ax                    ; Saved into redInc
-        mov     al,[esi+tcstrendGreen]
-        sub     al,[esi+tcstrstartGreen]               ; Do the same to green
-        cbw
-        xor     al,ah
-        sub     al,ah
-        mov     bl,ah
-        mov     bh,ah
-        sub     ah,ah
-        sub     dx,dx
-        div     [w]
-        sub     ah,ah
-        xor     ax,bx
-;        sub     ax,bx
-        mov     [word ptr greenInc+2],ax
-        mov     ax,dx
-        mul     [w2]
-        xor     ax,bx
-;        sub     ax,bx
-        mov     [word ptr greenInc],ax
-        mov     al,[esi+tcstrendBlue]                  ; and blue
-        sub     al,[esi+tcstrstartBlue]
-        cbw
-        xor     al,ah
-        sub     al,ah
-        mov     bl,ah
-        mov     bh,ah
-        sub     ah,ah
-        sub     dx,dx
-        div     [w]
-        sub     ah,ah
-        xor     ax,bx
-;        sub     ax,bx
-        mov     [word ptr blueInc+2],ax
-        mov     ax,dx
-        mul     [w2]
-        xor     ax,bx
-;        sub     ax,bx
-        mov     [word ptr blueInc],ax
-
-        sub     eax,eax
-        mov     al,[esi+tcstrstartRed]
-        shl     eax,16
-        mov     [cRed],eax
-        mov     al,[esi+tcstrstartGreen]
-        shl     eax,16
-        mov     [cGreen],eax
-        mov     al,[esi+tcstrstartBlue]
-        shl     eax,16
-        mov     [cBlue],eax
-
-        cmp     [gus],1
-        je      wasgus
-        cli
-        jmp     wasntgus
-wasgus:
-        mov     al,[byte ptr ports]
-        out     21h,al
-        mov     al,[byte ptr ports+2]
-        out     0a1h,al
-wasntgus:
-        mov     dx,3dah
-vr:
-        in      al,dx
-        test    al,8
-        jz      vr
-        mov     dx,3c0h
-        sub     al,al
-        out     dx,al
-        sub     ecx,ecx
-lp1:
-        mov     ax,[word ptr esi+tcstrbarStart+ecx*2]
-        mov     bl,[esi+tcstremptyColor]
-        or      ax,ax
-        jnz     empty
-        mov     bl,[esi+tcstrdacEntry]
-        or      [byte ptr esi+tcstrstatus+ecx],1
-empty:
-        mov     dx,3dah
-        in      al,dx
-        mov     dx,3c0h
-        mov     al,[byte ptr esi+tcstrbarColor+ecx]
-        out     dx,al
-        mov     al,bl
-        out     dx,al
-        inc     cl
-        cmp     cl,[esi+tcstrbarCount]
-        jne     lp1
-        mov     al,20h
-        out     dx,al
-
-        mov     dx,3c8h
-        mov     al,[esi+tcstrdacEntry]
-        out     dx,al
-        inc     dx
-        mov     al,[esi+tcstrstartRed]
-        out     dx,al
-        mov     al,[esi+tcstrstartGreen]
-        out     dx,al
-        mov     al,[esi+tcstrstartBlue]
-        out     dx,al
-
-        mov     cx,[esi+tcstrstartRow]
-        mov     [currentRow],cx
-        mov     dx,3dah                         ; Wait for display
-dsp:
-        in      al,dx
-        test    al,1
-        jnz     dsp
-        dec     cx
-        js      mainLoop
-dsp2:
-        in      al,dx
-        test    al,1
-        jz      dsp2
-        jmp     dsp
-
-mainLoop:
-        mov     dx,3c8h
-        mov     al,[esi+tcstrdacEntry]
-        out     dx,al
-        inc     dx
-        mov     eax,[cRed]
-        add     eax,[redInc]
-        mov     [cRed],eax
-        shr     eax,16
-        out     dx,al
-        mov     eax,[cGreen]
-        add     eax,[greenInc]
-        mov     [cGreen],eax
-        shr     eax,16
-        out     dx,al
-        mov     eax,[cBlue]
-        add     eax,[blueInc]
-        mov     [cBlue],eax
-        shr     eax,16
-        mov     [tempcl],al
-
-        sub     ecx,ecx
-checkbars:
-        mov     ax,[currentRow]
-        test    [byte ptr esi+tcstrstatus+ecx],1
-        jz      nowInv
-
-        cmp     [word ptr esi+tcstrbarEnd+ecx*2],ax
-        jnz     noChange
-        mov     [byte ptr esi+tcstrstatus+ecx],100b
-        inc     [mustChange]
-        jmp     noChange
-nowInv:
-        cmp     [word ptr esi+tcstrbarStart+ecx*2],ax
-        jnz     noChange
-        cmp     [word ptr esi+tcstrbarEnd+ecx*2],ax
-        jz      noChange
-        mov     [byte ptr esi+tcstrstatus+ecx],11b
-        inc     [mustChange]
-noChange:
-        inc     cx
-        cmp     cl,[esi+tcstrbarCount]
-        jne     checkBars
-
-        cmp     [mustChange],0
-        jz      noMust
-        mov     dx,3c0h
-        sub     cx,cx
-mustLoop:
-        test    [byte ptr esi+tcstrstatus+ecx],10b
-        jz      noSet
-        mov     bl,[esi+tcstrbarColor+ecx]
-        mov     bh,[esi+tcstrDacEntry]
-        mov     dx,3dah
-waitHR1:
-        in      al,dx
-        test    al,1
-        jnz     waitHR1
-waitHR12:
-        in      al,dx
-        test    al,1
-        jz      waitHR12
-        mov     dx,3c0h
-        mov     al,bl
-        out     dx,al
-        mov     al,bh
-        out     dx,al
-        mov     al,20h
-        out     dx,al
-        mov     [byte ptr esi+tcstrstatus+ecx],1b
-        dec     [mustChange]
-        jmp     mustOut
-noSet:
-        test    [byte ptr esi+tcstrstatus+ecx],100b
-        jz      must1
-        mov     bl,[esi+tcstrbarColor+ecx]
-        mov     bh,[esi+tcstremptyColor]
-        mov     dx,3dah
-waitHR2:
-        in      al,dx
-        test    al,1
-        jnz     waitHR2
-waitHR22:
-        in      al,dx
-        test    al,1
-        jz      waitHR22
-        mov     dx,3c0h
-        mov     al,bl
-        out     dx,al
-        mov     al,bh
-        out     dx,al
-        mov     al,20h
-        out     dx,al
-        mov     [byte ptr esi+tcstrstatus+ecx],0b
-        dec     [mustChange]
-        jmp     mustOut
-must1:
-        inc     cx
-        cmp     cx,[esi+tcstrbarCount]
-        jne     mustLoop
-
-noMust:
-        mov     dx,3dah
-waitHR3:
-        in      al,dx
-        test    al,1
-        jnz     waitHR3
-waitHR32:
-        in      al,dx
-        test    al,1
-        jz      waitHR32
-mustOut:
-        mov     dx,3c9h
-        mov     al,[tempcl]
-        out     dx,al
-
-        inc     [currentRow]
-        mov     ax,[esi+tcstrexitRow]
-        cmp     [currentRow],ax
-        jb      mainLoop
-
-        pop     ds
-        ret
-ENDP
-
-END
diff --git a/dmp/pmphdr.pas b/dmp/pmphdr.pas
deleted file mode 100644
index 10cadc5..0000000
--- a/dmp/pmphdr.pas
+++ /dev/null
@@ -1,75 +0,0 @@
-{ TheDraw Pascal Screen Image }
-const
-  HEADER_WIDTH=80;
-  HEADER_DEPTH=6;
-  HEADER_LENGTH=960;
-  HEADER : array [1..960] of Char = (
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'P' ,#31 ,'M' ,#31 ,'P' ,#31 ,' ' ,#31 ,
-    '-' ,#31 ,' ' ,#31 ,'P' ,#31 ,'r' ,#31 ,'o' ,#31 ,'t' ,#31 ,'e' ,#31 ,
-    'c' ,#31 ,'t' ,#31 ,'e' ,#31 ,'d' ,#31 ,' ' ,#31 ,'M' ,#31 ,'o' ,#31 ,
-    'd' ,#31 ,'u' ,#31 ,'l' ,#31 ,'e' ,#31 ,' ' ,#31 ,'P' ,#31 ,'l' ,#31 ,
-    'a' ,#31 ,'y' ,#31 ,'e' ,#31 ,'r' ,#31 ,' ' ,#31 ,'(' ,#31 ,'C' ,#31 ,
-    ')' ,#31 ,' ' ,#31 ,'1' ,#31 ,'9' ,#31 ,'9' ,#31 ,'3' ,#31 ,' ' ,#31 ,
-    'J' ,#31 ,'u' ,#31 ,'s' ,#31 ,'s' ,#31 ,'i' ,#31 ,' ' ,#31 ,'L' ,#31 ,
-    'a' ,#31 ,'h' ,#31 ,'d' ,#31 ,'e' ,#31 ,'n' ,#31 ,'n' ,#31 ,'i' ,#31 ,
-    'e' ,#31 ,'m' ,#31 ,'i' ,#31 ,' ' ,#31 ,'a' ,#31 ,'n' ,#31 ,'d' ,#31 ,
-    ' ' ,#31 ,'O' ,#31 ,'t' ,#31 ,'t' ,#31 ,'o' ,#31 ,' ' ,#31 ,'C' ,#31 ,
-    'h' ,#31 ,'r' ,#31 ,'o' ,#31 ,'n' ,#31 ,'s' ,#31 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,'' ,#20 ,
-    '' ,#20 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,
-    ' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,
-    ' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,
-    ' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,
-    ' ' ,#19 ,' ' ,#19 ,'' ,#25 ,' ' ,#25 ,'V' ,#25 ,'e' ,#25 ,'r' ,#25 ,
-    's' ,#25 ,'i' ,#25 ,'o' ,#25 ,'n' ,#25 ,' ' ,#25 ,' ' ,#25 ,' ' ,#25 ,
-    ' ' ,#25 ,' ' ,#25 ,' ' ,#25 ,'' ,#25 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,
-    ' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,
-    ' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,
-    ' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,
-    ' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,' ' ,#19 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 ,
-    '' ,#18 ,'' ,#18 ,'' ,#18 ,'' ,#18 );
diff --git a/dmp/pmpscrn.asm b/dmp/pmpscrn.asm
deleted file mode 100644
index f618efc..0000000
--- a/dmp/pmpscrn.asm
+++ /dev/null
@@ -1,68 +0,0 @@
-; ***************************************************************************
-;
-;                                 PMPSCRN.ASM
-;                                 -----------
-;
-;                         (C) 1993 Jussi Lahdenniemi
-;
-; Screen buffer copier for PMP 2.31+
-;
-; I doubt you'll ever have any use for this routine, but if you do, please
-; feel free to use it anyway you want.
-;
-; ***************************************************************************
-
-        MODEL TPASCAL
-        IDEAL
-        JUMPS
-        P386N
-
-DATASEG
-
-        Extrn whereAmI:WORD,paletteMap:BYTE,segb800:WORD,colorMask:BYTE
-
-CODESEG
-
-        Public updateScreen
-
-PROC    updateScreen FAR count:WORD
-        local seg1:WORD,seg2:WORD,colorMoffs:WORD
-
-        mov     es,[segb800]
-        sub     esi,esi
-        sub     edi,edi
-        mov     si,[whereAmI]
-        mov     di,si
-        add     di,8192
-        mov     cx,[count]
-        shr     cx,1
-        sub     ebx,ebx
-        sub     edx,edx
-        push    ebp
-        sub     ebp,ebp
-        mov     bp,offset paletteMap
-loop1:
-        mov     ax,[es:esi*2]
-        mov     dl,ah
-        mov     bl,ah
-        and     ah,11110000b
-        test    [byte ptr ds:si+colorMask],1
-        jnz     donotchange
-        shr     dl,4
-        mov     ah,[ds:ebp+edx]
-        shl     ah,4
-donotchange:
-        and     bl,15
-        or      ah,[ds:ebp+ebx]
-        mov     [es:edi*2],ax
-        inc     si
-        and     si,4095
-        lea     di,[si+4096]
-        dec     cx
-        jnz     loop1
-        mov     [whereAmI],si
-        pop     ebp
-        ret
-ENDP
-
-END
diff --git a/dmp/s3mload.pas b/dmp/s3mload.pas
deleted file mode 100644
index ecdb341..0000000
--- a/dmp/s3mload.pas
+++ /dev/null
@@ -1,494 +0,0 @@
-Unit S3MLoad;
-
-{$I-,R-,X+}
-
-{$O+}
-
-interface
-Uses MCP,AMP,Loaders,CSupport;
-
-Function loadS3M(var fl:file;modl:PModule):integer;
-
-implementation
-{$IFDEF USE_EMS}
-uses emhm;
-{$ENDIF}
-
-Type TS3Mheader = Record
-       name     : Array[0..27] of char;
-       e,t      : byte;
-       d1       : array[0..1] of byte;
-       orders,
-       ins,pats,
-       flags,cwt,
-       ffv      : word;
-       magic    : array[0..3] of char;
-       mv,is,
-       it,mm    : byte;
-       d2       : array[0..11] of char;
-       channels : array[0..31] of byte;
-     end;
-
-     TS3Minst   = Record
-       t        : byte;
-       dosname  : array[0..12] of char;
-       memseg   : word;
-       length,loopstart,
-       loopend  : longint;
-       volume,dsk,pack,
-       flag     : byte;
-       c2spd,d1 : longint;
-       d2,d3    : word;
-       d4       : longint;
-       name     : array[0..27] of char;
-       magic    : longint;
-     end;
-
-var patUsed     : array[0..255] of byte;
-    module      : PModule;
-    f           : file;
-    insPtr,
-    patPtr      : array[0..255] of word;
-    hdr         : TS3Mheader;
-    lastChan    : integer;
-    order16     : array[0..15] of byte;
-
-Function loadHeader:Integer;
-var orders     : array[0..255] of byte;
-    ptr        : pointer;
-    a,t,i,cnt  : integer;
-    pat        : PPattern;
-begin
-  with module^ do begin
-    cnt:=0;
-    seek(f,0);
-    blockread(f,hdr,sizeof(hdr));
-    tempo:=hdr.it;
-    speed:=hdr.is;
-    instrumentCount:=hdr.ins;
-    patternCount:=hdr.orders;
-    cnt:=hdr.orders;
-    channelCount:=0;
-    for t:=0 to 15 do
-      if hdr.channels[t]<>$ff then begin
-        inc(channelCount);
-{        module^.channelPanning[t]:=PAN_Left+byte(hdr.channels[t]>7)*(PAN_Right-PAN_Left);}
-        if hdr.channels[t]>7 then module^.channelPanning[t]:=PAN_Right else
-                                  module^.channelPanning[t]:=PAN_Left;
-      end else module^.channelPanning[t]:=PAN_Middle;
-    patterns:=calloc(cnt,sizeof(TPattern));
-    if patterns=nil then begin
-      loadHeader:=MERR_MEMORY;
-      exit;
-    end;
-    blockread(f,orders,hdr.orders);
-    blockread(f,insPtr,hdr.ins*2);
-    blockread(f,patPtr,hdr.pats*2);
-    inc(size,cnt*sizeof(TPattern));
-    fillchar(patUsed,256,0);
-    for t:=0 to cnt-1 do begin
-      patUsed[orders[t]]:=1;
-      pat:=addr(patterns^[t]);
-      pat^.length:=64;
-      for i:=0 to channelCount-1 do
-        pat^.tracks[i]:=pointer(word(orders[t]<>$FF)*(word(orders[t])*word(channelCount)+1+i));
-    end;
-  end;
-  loadHeader:=MERR_NONE;
-end;
-
-Function loadInstruments:integer;
-var t,i,a,b    : Word;
-    instr      : PInstrument;
-    sins       : TS3Minst;
-begin
-  with module^ do begin
-    instrumentCount:=hdr.ins;
-    instruments:=calloc(hdr.ins,sizeof(TInstrument));
-    if instruments=nil then begin
-      loadInstruments:=MERR_MEMORY;
-      exit;
-    end;
-    inc(size,hdr.ins*sizeof(TInstrument));
-    for t:=0 to hdr.ins-1 do begin
-      seek(f,longint(insPtr[t])*16);
-      blockread(f,sins,sizeof(sins));
-      if (sins.magic<>$53524353) and (sins.magic<>0) then begin
-        loadInstruments:=MERR_TYPE;
-        exit;
-      end;
-      instr:=addr(instruments^[t]);
-      with instr^ do begin
-        move(sins.name,name,sizeof(sins.name));
-        move(sins.dosname,filename,sizeof(sins.dosname));
-        rate:=sins.c2spd;
-        volume:=sins.volume;
-        size:=sins.length;
-        loopstart:=sins.loopstart;
-        loopend:=sins.loopend;
-        if sins.flag and 1=0 then begin
-          loopstart:=0;
-          loopend:=0;
-        end;
-        sample:=pointer(sins.memseg);
-      end;
-    end;
-  end;
-  loadInstruments:=MERR_NONE;
-end;
-
-Function loadPatterns:integer;
-
-type TArray                                       = Array[0..65519] of byte;
-var pos,row,t,j,a,i,bufSize,chan,tick,curTrack    : integer;
-    buffer                                        : ^TArray;
-    c                                             : byte;
-    patSize                                       : word;
-    note,ins,volume,command,data,curins,curvolume : byte;
-    nvalue,count,volsld                           : integer;
-    track                                         : PTrack;
-    temptrack                                     : Array[0..1199] of byte;
-
-Procedure insertNote(a,b:integer);
-Begin
-  temptrack[pos*3]:=tick;
-  temptrack[pos*3+1]:=a;
-  temptrack[pos*3+2]:=b;
-  inc(pos);
-end;
-
-Procedure insertCmd(a,b:integer);
-Begin
-  temptrack[pos*3]:=tick;
-  temptrack[pos*3+1]:=a;
-  temptrack[pos*3+2]:=b;
-  inc(pos);
-end;
-
-Label nopat;
-
-begin
-  bufSize:=1024;
-  curTrack:=1;
-  buffer:=malloc(bufSize);
-  with module^ do begin
-    count:=hdr.pats*channelCount;
-    trackCount:=count;
-    tracks:=calloc(count+4,sizeof(pointer));
-    if tracks=nil then begin
-      loadPatterns:=MERR_MEMORY;
-      exit;
-    end;
-    inc(size,(count+4)*sizeof(pointer));
-    for t:=0 to hdr.pats-1 do begin
-      if patUsed[t]=0 then begin
-        for j:=0 to channelCount-1 do tracks^[curTrack+j]:=nil;
-        inc(curTrack,channelCount);
-        goto nopat;
-      end;
-      seek(f,longint(patPtr[t])*16);
-      blockread(f,patSize,2);
-      if patSize>bufSize then begin
-        bufSize:=patSize;
-        free(buffer);
-        buffer:=malloc(bufSize);
-        if buffer=nil then begin
-          loadPatterns:=MERR_MEMORY;
-          exit;
-        end;
-      end;
-      blockread(f,buffer^,patSize);
-      if IOresult<>0 then begin
-        loadPatterns:=MERR_FILE;
-        exit;
-      end;
-      for j:=0 to channelCount-1 do begin
-        fillchar(temptrack,800,$ff);
-        pos:=0;
-        ins:=0;
-        curins:=$f0;
-        i:=0;
-        row:=0;
-        volsld:=0;
-        while row<64 do begin
-          c:=buffer^[i];
-          inc(i);
-          tick:=row;
-          if c=0 then inc(row) else begin
-            a:=c and $1f;
-            if a>lastChan then lastChan:=a;
-            if (c and $1f)=j then begin
-              note:=0;
-              ins:=0;
-              volume:=0;
-              command:=0;
-              data:=0;
-              if c and $20>0 then begin
-                note:=buffer^[i];
-                inc(i);
-                if note<>254 then
-                  note:=(note shr 4)*12+(note and $f)+12;
-                ins:=buffer^[i];
-                inc(i);
-              end;
-              if c and $40>0 then begin volume:=buffer^[i]; inc(i) end;
-              if c and $80>0 then begin
-                command:=buffer^[i]+ord('A')-1; inc(i);
-                data:=buffer^[i]; inc(i);
-                if command=ord('G') then begin
-                  if data>127 then data:=127;
-                  insertCmd(cmdBenderTo,data);
-                end;
-              end;
-              if (command=ord('S')) and ((data shr 4)=$d) and ((data and $f)<>0) and (note<>$ff) then
-                insertCmd(cmdNoteDelay,data and $f);
-              if c and $20>0 then begin
-                if (ins<>0) and (ins<>curIns) and (ins<=hdr.ins) then begin
-                  curins:=ins;
-                  insertCmd(cmdInstr,ins-1);
-                  instruments^[ins-1].insType:=1;
-                end;
-                if (c and $40=0) and (note<>0) and (note<>254) then
-                  if ins=0 then insertNote(note,255) else
-                    if ins<=hdr.ins then insertNote(note,instruments^[ins-1].volume);
-                if (note=254) then insertNote(0,0);
-              end;
-              if c and $40>0 then
-                if note=0 then insertCmd(cmdVolumeAbs,volume) else
-                               insertNote(note,volume);
-              if c and $80>0 then
-                case chr(command) of
-                  'A' : insertCmd(cmdTempo,data);
-                  'B' : insertCmd(cmdGoto,data);
-                  'C' : insertCmd(cmdBreak,0);
-                  'D' : begin
-                          if data>0 then volsld:=data else data:=volsld;
-                          if (data and $f0)=$f0 then begin
-                            if data=$f0 then data:=volsld;
-                            insertCmd(cmdFinevol,-(data and $f));
-                          end else
-                          if (data and $f=$f) and (data>$f) then begin
-                            if data=$f then data:=volsld;
-                            insertCmd(cmdFineVol,data shr 4);
-                          end else begin
-                            if data>=16 then data:=data shr 4 else data:=-data;
-                            insertCmd(cmdVolume,data);
-                          end;
-                        end;
-                  'E' : begin
-                          if data and $f0=$f0 then insertCmd(cmdExtraFineBender,data and $f) else
-                          if data and $e0=$e0  then insertCmd(cmdExtraFineBender,data and $f) else begin
-                            if data>127 then data:=127;
-                            insertCmd(cmdBender,data);
-                          end;
-                        end;
-                  'F' : begin
-                          if data and $f0=$f0 then insertCmd(cmdFinetune,-(data and $f)) else
-                          if data and $e0=$e0  then insertCmd(cmdExtraFineBender,-(data and $f)) else begin
-                            if data>127 then data:=127;
-                            if data=0 then insertCmd(cmdBender,-128) else
-                              insertCmd(cmdBender,-data);
-                          end;
-                        end;
-                  'H' : insertCmd(cmdVibrato,data);
-                  'I',
-                  'R' : insertCmd(cmdTremolo,data);
-                  'J' : insertCmd(cmdArpeggio,data);
-                  'K' : begin
-                          if data>=16 then data:=data shr 4 else data:=-data;
-                          if data>0 then volsld:=data else data:=volsld;
-                          insertCmd(cmdToneVol,data);
-                        end;
-                  'L' : begin
-                          if data>=16 then data:=data shr 4 else data:=-data;
-                          if data>0 then volsld:=data else data:=volsld;
-                          insertCmd(cmdVibrVol,data);
-                        end;
-                  'O' : insertCmd(cmdSync,data);
-                  'T' : insertCmd(cmdExtTempo,data);
-                  'Q' : insertCmd(cmdRetrig,data and $f);
-                  'Z' : insertCmd(cmdSync,data);
-                  'G' : ;
-                  'S' : begin
-                          a:=data shr 4;
-                          data:=data and $f;
-                          case a of
-                            $c : insertCmd(cmdNoteCut,data);
-                          end;
-                        end;
-                  '@' : ;
-               {   else writeln('Command ',command,' data ',data,' ',j); }
-                end;
-            end else
-              inc(i,((c and $20) shr 4)+((c and $c0) shr 6)); { skip note }
-          end;
-        end;
-        if pos=0 then track:=nil else begin
-          inc(pos);
-          if (loadOptions and LM_IML)>0 then
-            for i:=1 to curTrack-2 do
-              if module^.tracks^[i]<>nil then
-              if (module^.tracks^[i]^.size=pos) and
-                 (memcmp(@temptrack,pointer(longint(module^.tracks^[i])+3),pos*3)=0) then begin
-                   track:=tracks^[i];
-                   pos:=0;
-                   i:=curTrack-2;
-                 end;
-          if pos>0 then begin
-            track:=PTrack(malloc(pos*3+3));
-            if track<>nil then begin
-              inc(module^.size,pos*3+3);
-              track^.size:=pos;
-              track^.trkType:=0;
-              move(temptrack,pointer(longint(track)+3)^,pos*3);
-            end else begin
-              loadPatterns:=MERR_MEMORY;
-              exit;
-            end;
-          end;
-        end;
-        tracks^[curTrack]:=track;
-        inc(curTrack);
-      end;
-    nopat:
-    end;
-  end;
-  free(buffer);
-  loadPatterns:=MERR_NONE;
-end;
-
-Function loadSamples:integer;
-Var t,i           : Word;
-    instr         : Pinstrument;
-    length,a,b    : Longint;
-    sample        : Pointer;
-    {$IFDEF USE_EMS}
-    handle        : TEmsh;
-    {$ENDIF}
-Begin
-  for t:=0 to hdr.ins-1 do begin
-    instr:=@module^.instruments^[t];
-    seek(f,longint(word(instr^.sample))*16);
-    length:=instr^.size;
-    if (instr^.size>0) and (instr^.insType=1) then begin
-      a:=instr^.loopend-instr^.loopstart;
-      if (instr^.loopend<>0) and (a<crit_size) then begin
-        b:=(Crit_Size div a)*a;
-        instr^.loopend:=instr^.loopstart+b;
-        loadSamples:=-1;
-        instr^.sample:=malloc(instr^.loopend+16);
-        if instr^.sample=nil then exit;
-        inc(module^.size,instr^.loopend);
-        loadSamples:=-2;
-        blockread(f,instr^.sample^,instr^.size);
-        if IOresult<>0 then exit;
-        instr^.size:=instr^.loopend;
-        for i:=1 to (Crit_Size div a)-1 do
-          move(pointer(longint(instr^.sample)+instr^.loopstart)^,
-               pointer(longint(instr^.sample)+instr^.loopstart+a*i)^,a);
-      end else begin
-        instr^.sample:=malloc(instr^.size);
-        loadSamples:=-1;
-        if instr^.sample=nil then exit;
-        inc(module^.size,instr^.size);
-        loadSamples:=-2;
-        blockread(f,instr^.sample^,instr^.size);
-        if IOresult<>0 then exit;
-{$IFDEF USE_EMS}
-        handle:=0;
-        if instr^.size>2048 then begin
-          write(emsHeapFree,' - ');
-          handle:=emsAlloc(instr^.size);
-          writeln(instr^.size,' = ',emsHeapFree);
-          if handle>0 then begin
-            emsCopyTo(handle,instr^.sample,0,instr^.size);
-            free(instr^.sample);
-            instr^.sample:=ptr($ffff,handle);
-          end;
-        end;
-{$ENDIF}
-      end;
-    end else begin
-      instr^.size:=0;
-      instr^.sample:=nil;
-    end;
-  end;
-  loadSamples:=MERR_NONE;
-end;
-
-Procedure joinTracks2Patterns;
-Var t,i     : Word;
-    pat     : PPattern;
-Begin
-  for t:=0 to module^.patternCount-1 do begin
-    pat:=@module^.patterns^[t];
-    for i:=0 to module^.channelCount-1 do
-      pat^.tracks[i]:=module^.tracks^[word(pat^.tracks[i])];
-  end;
-end;
-
-Function loadS3M(var fl:file;modl:PModule):integer;
-var a:integer;
-begin
-  move(fl,f,sizeof(f));
-  module:=modl;
-  module^.size:=0;
-  lastChan:=0;
-  a:=loadHeader; if a<MERR_NONE then begin loadS3M:=a; exit end;
-  a:=loadInstruments; if a<MERR_NONE then begin loadS3M:=a; exit end;
-  a:=loadPatterns; if a<MERR_NONE then begin loadS3M:=a; exit end;
-  a:=loadSamples; if a<MERR_NONE then begin loadS3M:=a; exit end;
-  joinTracks2Patterns;
-  if module^.channelCount>lastChan+1 then module^.channelCount:=lastChan+1;
-  loadS3M:=a;
-end;
-
-end.
-
-MODULE far *ampLoadS3M(const char far *name, short options)
-{
-    FILE	*file;
-    ulong	l;
-    MODULE	*module;
-    int		b;
-
-    loadOptions = options;
-    if((module = (MODULE*)malloc(sizeof(MODULE)))==NULL)
-    {
-	moduleError = MERR_MEMORY;
-	return NULL;
-    }
-    memset(module,0,sizeof(MODULE));
-    if((file = fopen(name,"rb")) == NULL)
-    {
-	moduleError = MERR_FILE;
-	free(module);
-	return NULL;
-    }
-    module->type = MOD_NONE;
-    fseek(file,0x2C,SEEK_SET);
-    fread(&l,4,1,file);
-    if( l != 0x4D524353 ) // 'SCRM'
-    {
-	moduleError = MERR_TYPE;
-	free(module);
-	return NULL;
-    }
-    rewind(file);
-    fread(module->name,28,1,file);
-    module->name[28] = 0;
-    moduleError = loadS3M(file,module);
-    if( moduleError == MERR_NONE )
-    {
-	fseek(file,0,SEEK_END);
-	module->filesize = ftell( file );
-    }
-    else
-    {
-	ampFreeModule(module);
-	free(module);
-	module = NULL;
-    }
-    fclose(file);
-    return module;
-}
diff --git a/dmp/s3mload.tpp b/dmp/s3mload.tpp
deleted file mode 100644
index bc66bcb..0000000
Binary files a/dmp/s3mload.tpp and /dev/null differ
diff --git a/dmp/sdi__ari.pas b/dmp/sdi__ari.pas
deleted file mode 100644
index fae614b..0000000
--- a/dmp/sdi__ari.pas
+++ /dev/null
@@ -1,13 +0,0 @@
-unit sdi__ari;{sdi__aria;}
-
-interface
-
-Procedure sdi_aria;
-
-implementation
-uses mcp;
-
-Procedure sdi_aria; external;
-{$L SDI_ARIA.OBJ}
-
-end.
diff --git a/dmp/sdi__ari.tpp b/dmp/sdi__ari.tpp
deleted file mode 100644
index b47a509..0000000
Binary files a/dmp/sdi__ari.tpp and /dev/null differ
diff --git a/dmp/sdi__dac.pas b/dmp/sdi__dac.pas
deleted file mode 100644
index 6c2aae5..0000000
--- a/dmp/sdi__dac.pas
+++ /dev/null
@@ -1,31 +0,0 @@
-(***************************************************************************
-
-                                SDI__DAC.PAS
-                                ------------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-Turbo/Borland pascal unit header file for SDI_DAC.
-Original C header by Otto Chrons
-
-***************************************************************************)
-
-unit SDI__DAC;
-
-{$IFDEF DPMI}
-'DAC does not work properly in the protected mode.'
-{$ENDIF}
-
-interface
-
-procedure SDI_DAC;
-procedure setDACTimer(rate:Word);
-
-implementation
-uses mcp;
-
-procedure SDI_DAC; external;
-procedure setDACTimer(rate:Word); external;
-{$L SDI_DAC.OBJ}
-
-end.
diff --git a/dmp/sdi__pas.pas b/dmp/sdi__pas.pas
deleted file mode 100644
index 77425d0..0000000
--- a/dmp/sdi__pas.pas
+++ /dev/null
@@ -1,27 +0,0 @@
-(****************************************************************************
-
-                                SDI__PAS.PAS
-                                ------------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-Turbo/Borland pascal unit header file for SDI_PAS.
-Original C header by Otto Chrons
-
-****************************************************************************)
-
-Unit SDI__PAS;
-{$F+}
-
-Interface
-Uses MCP;
-
-Procedure SDI_PAS;
-
-Implementation
-
-Procedure SDI_PAS; External;
-
-{$L SDI_PAS.OBJ}
-
-End.
diff --git a/dmp/sdi__pas.tpp b/dmp/sdi__pas.tpp
deleted file mode 100644
index dc0224f..0000000
Binary files a/dmp/sdi__pas.tpp and /dev/null differ
diff --git a/dmp/sdi__sb.pas b/dmp/sdi__sb.pas
deleted file mode 100644
index 8a1fda0..0000000
--- a/dmp/sdi__sb.pas
+++ /dev/null
@@ -1,29 +0,0 @@
-(****************************************************************************
-
-                                 SDI__SB.PAS
-                                 -----------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-Turbo/Borland pascal unit header file for SDI_SB.
-Original C header by Otto Chrons
-
-****************************************************************************)
-
-Unit SDI__SB;
-{$F+}
-
-Interface
-Uses MCP;
-
-Procedure SDI_SB;
-Procedure SDI_SBPro;
-
-Implementation
-
-{$L SDI_SB.OBJ}
-
-Procedure SDI_SB; External;
-Procedure SDI_SBPro; External;
-
-End.
diff --git a/dmp/sdi__sb.tpp b/dmp/sdi__sb.tpp
deleted file mode 100644
index f4f5d3b..0000000
Binary files a/dmp/sdi__sb.tpp and /dev/null differ
diff --git a/dmp/sdi__sb1.pas b/dmp/sdi__sb1.pas
deleted file mode 100644
index 4a01086..0000000
--- a/dmp/sdi__sb1.pas
+++ /dev/null
@@ -1,27 +0,0 @@
-(****************************************************************************
-
-                                 SDI__SB16.PAS
-                                 -------------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-Turbo/Borland pascal unit header file for SDI_SB16.
-Original C header by Otto Chrons
-
-****************************************************************************)
-
-Unit SDI__SB1;{SDI__SB16;}
-{$F+}
-
-Interface
-Uses MCP;
-
-Procedure SDI_SB16;
-
-Implementation
-
-Procedure SDI_SB16; External;
-
-{$L SDI_SB16.OBJ}
-
-End.
diff --git a/dmp/sdi__sb1.tpp b/dmp/sdi__sb1.tpp
deleted file mode 100644
index 2585146..0000000
Binary files a/dmp/sdi__sb1.tpp and /dev/null differ
diff --git a/dmp/sdi__wss.pas b/dmp/sdi__wss.pas
deleted file mode 100644
index 7632a76..0000000
--- a/dmp/sdi__wss.pas
+++ /dev/null
@@ -1,17 +0,0 @@
-Unit SDI__WSS; { (C) 1993 Jussi Lahdenniemi,
-                 Original C version (C) 1993 Otto Chrons
-
-                 Windows Sound System SDI }
-
-Interface
-
-procedure SDI_WSS;
-
-Implementation
-uses mcp;
-
-procedure SDI_WSS; External;
-
-{$L SDI_WSS.OBJ}
-
-end.
diff --git a/dmp/sdi_aria.asm b/dmp/sdi_aria.asm
deleted file mode 100644
index c33c825..0000000
--- a/dmp/sdi_aria.asm
+++ /dev/null
@@ -1,947 +0,0 @@
-;/************************************************************************
-; *
-; *	File	    : SDI_ARIA.ASM
-; *
-; *	Description : SDI for sound cards based on Aria chipset
-; *
-; *	Copyright (C) 1993 Otto Chrons
-; *
-; ***********************************************************************
-;
-;	Revision history of SDI_ARIA.ASM
-;
-;	1.0	17.5.93
-;		First version.
-;
-; ***********************************************************************/
-
-	IDEAL
-	JUMPS
-	P386N
-
-;	L_PASCAL	= 1		; Uncomment this for pascal-style
-
-IFDEF	L_PASCAL
-	LANG	EQU	PASCAL
-	MODEL TPASCAL
-ELSE
-	LANG	EQU	C
-	MODEL LARGE,C
-ENDIF
-
-        INCLUDE "MODEL.INC"
-        INCLUDE "MCP.INC"
-
-STRUC	DMAPORT
-
-	addr	DW ?
-	count	DW ?
-	page	DW ?
-	wcntrl	DW ?
-	wreq	DW ?
-	wrsmr	DW ?
-	wrmode	DW ?
-	clear	DW ?
-	wrclr	DW ?
-	clrmask	DW ?
-	wrall	DW ?
-ENDS
-
-	PACKET_SIZE = 512
-
-	DSP_DATA = 0
-	DSP_STATUS = 2
-	DSP_CONTROL = 2
-	DSP_DMA_ADDRESS = 4
-	DSP_DMA_DATA = 6
-
-	INTPC_DSPRD     EQU  0001h      ; Interrupt PC on DSP read
-	INTPC_DSPWR     EQU  0002h      ; Interrupt PC on DSP write
-	INTDSP_PCRD     EQU  0004h      ; Interrupt DSP on PC read
-	INTDSP_PCWR     EQU  0008h      ; Interrupt DSP on PC write
-	INTPC_DMADONE   EQU  0010h      ; Interrupt PC on DMA completion
-	SAMP_RATE       EQU  0060h      ; Sample rate mask
-	 SAMP_44K       EQU  0000h      ;    44.10 kHz
-	 SAMP_32K       EQU  0020h      ;    31.50 kHz
-	 SAMP_22K       EQU  0040h      ;    22.05 kHz
-	 SAMP_16K       EQU  0060h      ;    15.75 kHz
-	C2MODE          EQU  0080h      ; Aria Wave Synthesis select
-	DSP_RESET       EQU  0100h      ; Reset DSP
-	DMA_DSPTOPC     EQU  0200h      ; DMA direction - DSP to PC
-	DMA_XFR         EQU  0400h      ; Initiate DMA transfer
-	ADC_SRC_AUX     EQU  0800h      ; ADC record source select
-	ADC_STEREO      EQU  1000h      ; ADC mono/stereo select
-	ADC_SRC_RIGHT   EQU  2000h      ; ADC monophonic source
-	ADC_DISABLE     EQU  4000h      ; ADC enable/disable
-	PORT0_BUSY      EQU  8000h      ; Data port busy flag
-
-DATASEG
-
-	EXTRN	mcpStatus:BYTE
-	EXTRN	bufferSize:WORD
-	EXTRN	dataBuf:WORD
-	EXTRN	SoundCard:CARDINFO
-
-	DMApage		DB ?
-	DMAoffset	DW ?
-	ioPort		DW ?
-	saveDMAvector	DD ?
-	samplingRate	DW ?
-	curDMA		DMAPORT <>
-	audioRate	DW ?
-	flipflop	DW ?
-	playing		DB ?
-	bufcount	DW ?
-
-CODESEG
-
-	PUBLIC	SDI_ARIA
-
-	copyrightText	DB "SDI for Aria v1.0 - (C) 1993 Otto Chrons",0,1Ah
-
-	Aria		CARDINFO <8,0,"Aria sound card",290h,10,5,4000,44100,1,1,2>
-
-	LABEL DMAports	DMAPORT
-
-	    DMAPORT <0,1,87h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-	    DMAPORT <2,3,83h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-	    DMAPORT <4,5,81h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-	    DMAPORT <6,7,82h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-	    DMAPORT <0,0,0,0,0,0,0,0,0,0,0>
-	    DMAPORT <0C4h,0C6h,8Bh,0D0h,0D2h,0D4h,0D6h,0D8h,0DAh,0DCH,0DEh>
-	    DMAPORT <0C8h,0CAh,89h,0D0h,0D2h,0D4h,0D6h,0D8h,0DAh,0DCH,0DEh>
-	    DMAPORT <0CCh,0CEh,8Ah,0D0h,0D2h,0D4h,0D6h,0D8h,0DAh,0DCH,0DEh>
-
-	SoundDeviceAria	SOUNDDEVICE < \
-		far ptr initAria,\
-		far ptr initDMA,\
-		far ptr initRate,\
-		far ptr closeAria,\
-		far ptr closeDMA,\
-		far ptr startVoice,\
-		far ptr stopVoice,\
-		far ptr pauseVoice,\
-		far ptr resumeVoice\
-		far ptr getDMApos,\
-		far ptr speakerOn,\
-		far ptr speakerOff\
-		>
-
-;************************************************************************
-;
-; Macro to select digital audio FIFO buffer location
-;
-; Input:  di = audio channel number (word index 0, 2, 4 or 6)
-;         ax = DSP FIFO flag address (6100h or 6101h)
-;
-; Output: ax = buffer location (DSP address)
-;         dx = DMA address port
-;
-; Destroys:  bx, si
-;
-;************************************************************************
-
-MACRO	setFIFOaddr
-	LOCAL   get1
-
-	mov     dx, [ioPort]
-	add     dx, DSP_DMA_ADDRESS
-	out     dx, ax          ; select address in DSP RAM
-	inc     dx
-	inc     dx
-	in      ax, dx          ; read value
-	mov     bx, ax          ; offset in bx
-
-	push    cx              ; compute offset to FIFO
-	mov     cx, di          ; channel number in cx
-	shr     cx, 1
-	inc     cx              ; channel + 1
-	shl     cx, 1           ; channel * 2
-	xor     ax, ax
-	mov     si, PACKET_SIZE
-get1:
-	add     ax, si
-	loop    get1
-	pop     cx
-
-	mov     si, ax
-	mov     ax, 8000h
-	sub     ax, si
-	add     ax, bx
-
-	dec     dx
-	dec     dx
-	out     dx, ax          ; set the FIFO address for DSP RAM
-ENDM
-
-;/*************************************************************************
-; *
-; *	Function    :	void SDI_ARIA(SOUNDDEVICE far *sdi);
-; *
-; *	Description :	Registers Aria as a sound device
-; *
-; *	Input       :	Pointer to SD structure
-; *
-; *	Returns     :	Fills SD structure accordingly
-; *
-; ************************************************************************/
-
-PROC	SDI_ARIA FAR USES di si,sdi:DWORD
-
-	cld
-	LESDI	[sdi]
-	mov	si,offset SoundDeviceAria
-	mov	cx,SIZE SOUNDDEVICE
-	cli
-	segcs
-	rep movsb			; Copy structure
-	sti
-	sub	ax,ax			; indicate successful init
-	ret
-ENDP
-
-
-;/*************************************************************************
-; *
-; *	Function    :	AriaCMD
-; *
-; *	Description :  	Sends a command to Aria's DSP
-; *
-; *	Input       :	AX = cmd to send
-; *
-; ************************************************************************/
-
-PROC	NOLANGUAGE AriaCMD NEAR
-
-	push	ax
-	mov	dx,[ioPort]
-	add	dx,DSP_STATUS
-	mov	cx,20000
-@@wait:
-	in	ax,dx
-	test	ax,8000h
-	loopnz	@@wait
-
-	mov	dx,[ioPort]
-	pop	ax
-	out	dx,ax
-
-	ret
-ENDP
-
-
-;/*************************************************************************
-; *
-; *	Function    :	putMem16
-; *
-; *	Description :	Puts a word into DSP's memory
-; *
-; *	Input       :	BX = address, AX = value
-; *
-; ************************************************************************/
-
-PROC	putMem16 NEAR
-
-	push	ax
-	mov	dx,[ioPort]
-	add	dx,DSP_DMA_ADDRESS
-	mov	ax,bx
-	out	dx,ax
-	mov	dx,[ioPort]
-	add	dx,DSP_DMA_DATA
-	pop	ax
-	out	dx,ax
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	getMem16
-; *
-; *	Description :	Gets a word into DSP's memory
-; *
-; *	Input       :	BX = address
-; *
-; *	Returns	    :	AX = value
-; *
-; ************************************************************************/
-
-PROC	getMem16 NEAR
-
-	mov	dx,[ioPort]
-	add	dx,DSP_DMA_ADDRESS
-	mov	ax,bx
-	out	dx,ax
-	mov	dx,[ioPort]
-	add	dx,DSP_DMA_DATA
-	in	ax,dx
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	playDMA
-; *
-; *	Description :	Plays current buffer through DMA
-; *
-; ************************************************************************/
-
-PROC	playDMA NEAR
-
-	cli
-	pusha
-	mov	dx,[ioPort]		; Was this interrupt generated
-	in	ax,dx			; by Aria DSP?
-	cmp	ax,1
-	jne	@@exit
-
-	xor	[flipflop],1
-	jnz	@@notrans
-
-	mov	ax,10h
-	call	AriaCMD			; Start transfer
-	mov	ax,0FFFFh
-	call	AriaCMD
-	jmp	@@exit
-@@notrans:
-	mov	ah,[DMApage]		; Load correct DMA page and offset
-	mov	bx,[DMAoffset]		; values
-	add	bx,[bufcount]
-	mov	cx,PACKET_SIZE
-	add	[bufcount],PACKET_SIZE
-	mov	dx,[bufcount]
-	shl	dx,1
-	cmp	dx,[buffersize]
-	jl	@@bok
-	mov	[bufcount],0
-@@bok:
-	dec	cx			; Set the DMA up and running
-	mov	al,[SoundCard.DMAChannel]
-	or	al,4
-	mov	dx,[curDMA.wrsmr]
-	out	dx,al			; Break On
-	mov	al,0
-	mov	dx,[curDMA.clear]
-	out	dx,al			; Reset counter
-	mov	al,[SoundCard.DMAChannel]
-	and	al,3
-	or	al,048h
-	mov	dx,[curDMA.wrmode]
-	out	dx,al
-	mov	dx,[curDMA.page]
-	mov	al,ah
-	out	dx,al			; Page
-
-	mov	dx,[curDMA.addr]
-	mov	al,bl
-	out	dx,al			; Offset
-	mov	al,bh
-	out	dx,al
-
-	mov	dx,[curDMA.count]
-	mov	al,cl
-	out	dx,al			; Count
-	mov	al,ch
-	out	dx,al
-	mov	al,[SoundCard.DMAChannel]
-	and	al,3
-	mov	dx,[curDMA.wrsmr]
-	out	dx,al			; Break Off
-
-	mov	di,0
-	mov	ax,6100h		; Set address...
-	setFIFOaddr
-
-	mov	ax,INTPC_DSPWR OR INTDSP_PCWR OR C2MODE OR INTPC_DMADONE OR DMA_XFR
-	or	ax,[audioRate]
-	mov	dx,[ioPort]
-	add	dx,DSP_CONTROL
-	out	dx,ax
-
-@@exit:
-	popa
-	sti
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    : 	interruptDMA
-; *
-; *	Description :	DMA interrupt routine for continuos playing.
-; *
-;/************************************************************************/
-
-PROC	NOLANGUAGE interruptDMA
-
-	sti
-	push	ax
-	push	dx
-	push	ds
-	mov	ax,@data
-	mov	ds,ax			; DS = data segment
-
-	cmp	[mcpStatus],111b	; Inited and playing
-	jne	@@exit
-	call	playDMA			; Output current buffer
-@@exit:
-	mov	al,20h			; End Of Interrupt (EOI)
-	cmp	[SoundCard.dmaIRQ],7
-	jle	@@10
-	out	0A0h,al
-@@10:
-	out	20h,al
-	pop	ds
-	pop	dx
-	pop	ax
-	iret				; Interrupt return
-ENDP
-
-
-;/*************************************************************************
-; *
-; *	Function    : int initAria(CARDINFO *scard);
-; *
-; *	Description : Initializes a Aria card.
-; *
-; *	Input       : Pointer to CARDINFO structure
-; *
-; *	Returns     : 0 no error
-; *		      other = error
-; *
-; *************************************************************************/
-
-PROC	initAria FAR USES si di, scard:FAR PTR CARDINFO
-	LOCAL	retvalue:WORD
-
-	mov	[retvalue],-1
-	LESSI	[scard]
-	mov	al,[ESSI+CARDINFO.ID]
-	mov	si,offset Aria		; SI = source
-	cmp	al,ID_ARIA		; Check for valid ID
-	jne	@@exit
-@@idOK:
-	mov	ax,ds
-	mov	es,ax
-	mov	di,offset SoundCard	; ESDI = destination
-	mov	cx,SIZE CARDINFO
-	cld
-	cli
-	segcs
-	rep	movsb			; Copy information
-	sti
-
-	LESSI	[scard]
-	mov	ax,[ESSI+CARDINFO.ioPort]
-	mov	[SoundCard.ioPort],ax
-	mov	al,[ESSI+CARDINFO.DMAIRQ]
-	cmp	al,16 			; Is it > 15?
-	jae	@@exit
-	mov	[SoundCard.DMAIRQ],al
-	mov	al,[ESSI+CARDINFO.DMAchannel]
-	cmp	al,4			; Channel 4 is invalid
-	je	@@exit
-	cmp	al,8
-	jae	@@exit			; So are > 7
-	mov	[SoundCard.DMAchannel],al
-
-	mov	bh,[ESSI+CARDINFO.stereo]
-	cmp	bh,1
-	ja	@@exit
-
-	mov	al,2			; Assume 16-bit sample
-	cmp	[ESSI+CARDINFO.sampleSize],2
-	je	@@sizeOK
-	mov	al,1			; No, it's 8-bit
-@@sizeOK:
-	mov	bl,[ESSI+CARDINFO.sampleSize]
-
-	mov	[SoundCard.sampleSize],bl	; Save values
-	mov	[SoundCard.stereo],bh
-
-	mov	bl,[ESSI+CARDINFO.DMAchannel]
-	sub	bh,bh
-	imul	bx,bx,SIZE DMAPORT
-	lea	si,[bx+DMAports]	; SI = DMAports[DMAchannel]
-	mov	ax,ds
-	mov	es,ax
-	mov	di,offset curDMA	; ESDI = curDMA
-	mov	cx,SIZE DMAPORT
-	cli
-	segcs
-	rep	movsb			; Copy structure
-	sti
-
-	mov	dx,[SoundCard.ioPort]
-	mov	[ioPort],dx
-
-	mov	ax,00C8h		; Init Aria
-	add	dx,DSP_CONTROL
-	out	dx,ax
-
-	mov	ax,0
-	mov	bx,6102h		; DSP init
-	call	putMem16
-
-	cli
-	mov	ax,0			; System init
-	call	AriaCMD
-	mov	ax,0			; Add new task
-	call	AriaCMD
-	mov	ax,0			; Aria Synthesizer mode, ROM module
-	call	AriaCMD
-	mov	ax,0			; No address
-	call	AriaCMD
-	mov	ax,0FFFFh		; End of command
-	call	AriaCMD
-	sti
-	mov	cx,2000
-@@loop:
-	mov	dx,[ioPort]
-	add	dx,DSP_STATUS
-	in	ax,dx			; Delay
-	mov	bx,6102h
-	call	getMem16		; Get value from DSP's memory
-	cmp	ax,1
-	loopne	@@loop
-
-;	jne	@@exit
-
-	mov	dx,[ioPort]
-	add	dx,DSP_CONTROL
-	mov	ax,00CAh		; Init Aria mode..
-	out	dx,ax
-
-	or	[mcpStatus],S_INIT	; indicate successful initialization
-	mov	[flipflop],0
-	mov	[retvalue],0
-@@exit:
-	mov	ax,[retvalue]
-	ret
-ENDP
-
-;/***********************************************************************
-; *
-; *	Function    :	int getDMApos():
-; *
-; *	Description :	Returns the position of DMA transfer
-; *
-; **********************************************************************/
-
-PROC	getDMApos FAR
-
-	mov	ax,[bufcount]
-	shl	ax,1
-	sub	ax,PACKET_SIZE*2
-	jns	@@pos_ok
-	add	ax,[bufferSize]
-@@pos_ok:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	initDMA(void far *buffer,int maxsize, int required);
-; *
-; *	Description :   Init DMA for output
-; *
-; ************************************************************************/
-
-PROC    initDMA FAR buffer:DWORD,linear:DWORD,maxSize:DWORD,required:DWORD
-
-        mov     cx,[word maxSize]
-	mov	[bufferSize],cx
-	mov	ax,[WORD HIGH buffer]
-	mov	bx,[WORD LOW buffer]
-	add	bx,4
-	and	bx,NOT 3
-	mov	[dataBuf],bx		; Check if DMA buffers are on
-	mov	eax,[linear]		; a segment boundary
-	neg	ax
-	cmp	ax,cx			; Is buffer size >= data size
-	ja	@@bufOK
-	dec	ax
-	and	ax,NOT 3
-	mov	[bufferSize],ax
-	shr	cx,1
-	cmp	ax,cx			; Is it even half of it?
-	ja	@@bufOK
-	shl	cx,1
-	add	[dataBuf],ax
-	add	[dataBuf],4
-	and	[dataBuf],NOT 3
-	neg	ax
-	add	ax,cx			; AX = dataSize - AX
-	sub	ax,32
-	and	ax,NOT 3
-	mov	[bufferSize],ax
-@@bufOK:
-	cmp	[required],0
-	je	@@sizeok
-        cmp     ax,[word required]
-	jbe	@@sizeok
-        mov     ax,[word required]
-	mov	[bufferSize],ax
-@@sizeok:
-	and	[bufferSize],NOT (PACKET_SIZE*2-1)
-	jnz	@@bufsizeok
-	mov	[bufferSize],PACKET_SIZE*2
-@@bufsizeok:
-	sub	ebx,ebx
-	mov	eax,[linear]		; Calculate DMA page and offset values
-	mov	bx,[dataBuf]
-	sub	bx,[WORD LOW buffer]	; Relative offset
-	add	eax,ebx
-	mov	ebx,eax
-	shr	ebx,16
-	cmp	[SoundCard.DMAChannel],4
-	jb	@@8bitDMA
-	push	bx
-	shr	bl,1
-	rcr	ax,1			; For word addressing
-	pop	bx
-@@8bitDMA:
-	mov	[DMApage],bl
-	mov	[DMAoffset],ax
-
-	cli
-	mov	ax,5
-	call	AriaCMD			; Set packet size
-	mov	ax,PACKET_SIZE
-	call	AriaCMD			; to PACKET_SIZE
-	mov	ax,0FFFFh
-	call	AriaCMD
-	sti
-
-	mov	al,[SoundCard.DMAIRQ]
-	test	al,8			; Is IRQ > 7
-	jz	@@01
-	add	al,60h			; Yes, base is 70h
-@@01:
-	add	al,8			; AL = DMA interrupt number
-	push	ax
-	mov	ah,35h			; Get interrupt vector
-	int	21h
-	mov	[WORD LOW saveDMAvector],bx	; Save it
-	mov	[WORD HIGH saveDMAvector],es
-	pop	ax			; Replace vector with the address
-	mov	ah,25h			; of own interrupt routine
-	PUSHDS
-	push	cs
-	pop	ds
-	mov	dx,offset interruptDMA	; Set interrupt vector
-	int	21h
-	pop	ds
-
-	mov	cl,[SoundCard.DMAIRQ]
-	mov	ah,1
-	test	cl,8			; Is IRQ > 7
-	jnz	@@15
-	shl	ah,cl
-	not	ah
-	in	al,21h
-	and	al,ah
-	out	21h,al			; Allow DMA interrupt
-	jmp	@@20
-@@15:
-	and	cl,7
-	shl	ah,cl
-	not	ah
-	in	al,0A1h
-	and	al,ah
-	out	0A1h,al			; Allow DMA interrupt
-@@20:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	initRate
-; *
-; *	Description :   Inits sound card's sampling rate
-; *
-; ************************************************************************/
-
-PROC    initRate FAR USES di,sample_rate:DWORD
-
-	mov	ax,44100		; Find best match
-	mov	cx,00h
-	mov	di,20h
-        mov     bx,[word sample_rate]
-	cmp	bx,38000
-	jae	@@ok
-	mov	cx,40h
-	mov	ax,22050
-	mov	di,10h
-	cmp	bx,16000
-	jae	@@ok
-	mov	ax,11025
-	mov	di,0h
-@@ok:
-	mov	[audioRate],cx
-	mov	[samplingRate],ax
-	mov	dx,[ioPort]
-	add	dx,DSP_CONTROL
-	mov	ax,INTPC_DSPWR OR INTDSP_PCWR OR INTPC_DMADONE OR C2MODE
-	or	ax,cx
-	out	dx,ax			; Set new one
-
-	cli
-	mov	ax,6
-	call	AriaCMD			; Set Playback mode
-	mov	ax,0
-	call	AriaCMD
-	mov	ax,0FFFFh
-	call	AriaCMD
-
-	mov	ax,3
-	call	AriaCMD			; Set digital audio format
-	mov	ax,0
-	add	al,[SoundCard.stereo]	; Set stereo
-	cmp	[SoundCard.samplesize],2
-	jne	@@8bit
-	add	al,2			; Set 16-bit
-@@8bit:
-	or	ax,di
-	call	AriaCMD
-	mov	ax,0FFFFh
-	call	AriaCMD
-	sti
-@@exit:
-	mov	ax,[samplingRate]
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	speakerOn
-; *
-; *	Description :	Connects Aria speaker
-; *
-; ************************************************************************/
-
-PROC	speakerOn FAR
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	speakerOff
-; *
-; *	Description :	Disconnects speaker from Aria
-; *
-; ************************************************************************/
-
-PROC	speakerOff FAR
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	startVoice
-; *
-; *	Description :	Starts to output voice.
-; *
-; ************************************************************************/
-
-PROC	startVoice FAR USES di
-
-	mov	di,0
-	mov	ax,6100h		; Set address...
-	setFIFOaddr
-
-	mov	ah,[DMApage]		; Load correct DMA page and offset
-	mov	bx,[DMAoffset]		; values
-	mov	cx,PACKET_SIZE
-	dec	cx
-	cli				; Set the DMA up and running
-	mov	al,[SoundCard.DMAChannel]
-	or	al,4
-	mov	dx,[curDMA.wrsmr]
-	out	dx,al			; Break On
-	mov	al,0
-	mov	dx,[curDMA.clear]
-	out	dx,al			; Reset counter
-	mov	al,[SoundCard.DMAChannel]
-	and	al,3
-	or	al,048h
-	mov	dx,[curDMA.wrmode]
-	out	dx,al
-	mov	dx,[curDMA.page]
-	mov	al,ah
-	out	dx,al			; Page
-
-	mov	dx,[curDMA.addr]
-	mov	al,bl
-	out	dx,al			; Offset
-	mov	al,bh
-	out	dx,al
-
-	mov	dx,[curDMA.count]
-	mov	al,cl
-	out	dx,al			; Count
-	mov	al,ch
-	out	dx,al
-	mov	al,[SoundCard.DMAChannel]
-	and	al,3
-	mov	dx,[curDMA.wrsmr]
-	out	dx,al			; Break Off
-
-	mov	[flipflop],0
-	mov	[bufcount],PACKET_SIZE
-
-
-	mov	ax,INTPC_DSPWR OR INTDSP_PCWR OR INTPC_DMADONE OR C2MODE OR DMA_XFR
-	or	ax,[audioRate]
-	mov	dx,[ioPort]
-	add	dx,DSP_CONTROL
-	out	dx,ax
-
-	mov	ax,11h
-	call	AriaCMD			; Start audio playback
-	mov	ax,0
-	call	AriaCMD			; On channel 0
-	mov	ax,0FFFFh
-	call	AriaCMD
-
-;	mov	ax,10h
-;	call	AriaCMD			; Start transfer
-;	mov	ax,0FFFFh
-;	call	AriaCMD
-	sti
-@@exit:
-	ret
-ENDP
-
-
-;/*************************************************************************
-; *
-; *	Function    :	stopVoice
-; *
-; *	Description :	Stops voice output.
-; *
-; ************************************************************************/
-
-PROC	stopVoice FAR USES di
-
-	cli
-	mov	ax,12h
-	call	AriaCMD			; Stop audio playback
-	mov	ax,0
-	call	AriaCMD			; on channel 0
-	mov	ax,0FFFFh
-	call	AriaCMD
-	sti
-
-	mov	cx,0
-@@wait:
-	loop	@@wait
-	mov	al,[SoundCard.DMAChannel] ; Reset DMA
-	or	al,4
-	mov	dx,[curDMA.wrsmr]
-	out	dx,al
-	mov	al,0
-	mov	dx,[curDMA.clear]
-	out	dx,al
-
-	mov	cl,[SoundCard.DMAIRQ]		; Disable DMA interrupt
-	mov	ah,1
-	test	cl,8
-	jnz	@@10
-	shl	ah,cl
-	in	al,21h
-	or	al,ah
-	out	21h,al
-	jmp	@@20
-@@10:
-	and	cl,7
-	shl	ah,cl
-	in	al,0A1h
-	or	al,ah
-	out	0A1h,al
-@@20:
-	mov	al,0
-	out	0Ch,al
-	mov	al,[SoundCard.DMAChannel] ; Reset DMA
-	or	al,4
-	out	0Ah,al
-@@exit:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	closeDMA
-; *
-; *	Description :   Returns DMA's IRQ vector
-; *
-; ************************************************************************/
-
-PROC closeDMA FAR
-	PUSHDS
-	mov	al,[SoundCard.DMAIRQ]
-	test	al,8			; Is IRQ > 7
-	jz	@@01
-	add	al,60h			; Yes, base is 70h
-@@01:
-	add	al,8
-	mov	dx,[WORD LOW saveDMAvector]
-	mov	ds,[WORD HIGH saveDMAvector]
-	mov	ah,25h
-	int	21h			; Restore DMA vector
-	POPDS
-	ret
-ENDP
-
-PROC closeAria FAR
-
-	mov	dx,[ioPort]
-	add	dx,DSP_CONTROL		; Set Aria mode in control register
-	mov	ax,0C8h
-	out	dx,ax
-
-	mov	ax,0
-	mov	bx,6102h
-	call	putMem16
-
-	mov	ax,0
-	call	AriaCMD
-	mov	ax,0
-	call	AriaCMD
-	mov	ax,1			; Set SB mode
-	call	AriaCMD
-	mov	ax,0
-	call	AriaCMD
-	mov	ax,0FFFFh
-	call	AriaCMD
-	mov	cx,2000
-@@loop:
-	mov	dx,[ioPort]
-	add	dx,DSP_STATUS
-	in	ax,dx			; Delay
-	mov	bx,6102h
-	call	getMem16		; Get value from DSP's memory
-	cmp	ax,1			; Is DSP ready?
-	loopne	@@loop
-
-	mov	dx,[ioPort]
-	add	dx,DSP_CONTROL		; Set SB mode in control register
-	mov	ax,040h
-	out	dx,ax
-	ret
-ENDP
-
-PROC pauseVoice FAR
-	ret
-ENDP
-
-PROC resumeVoice FAR
-	ret
-ENDP
-
-
-END
diff --git a/dmp/sdi_dac.asm b/dmp/sdi_dac.asm
deleted file mode 100644
index 839aea4..0000000
--- a/dmp/sdi_dac.asm
+++ /dev/null
@@ -1,783 +0,0 @@
-;/************************************************************************
-; *
-; *     File        : SDI_DAC.ASM
-; *
-; *     Description : Sound Device Interface for interruptdriven DACs
-; *
-; *     Copyright (C) 1993 Otto Chrons
-; *
-; ************************************************************************
-;
-;       Revision history of SDI_DAC.ASM
-;
-;       1.0     16.4.93
-;               First version. Works well, but is not optimized
-;
-;       1.5     3.10.93
-;               Support for stereo DACs
-;
-; ***********************************************************************/
-
-        IDEAL
-        JUMPS
-        LOCALS
-        P286N
-
-       L_PASCAL        = 1             ; Uncomment this for pascal-style
-
-IFDEF   L_PASCAL
-        LANG    EQU     PASCAL
-        MODEL TPASCAL
-ELSE
-        LANG    EQU     C
-        MODEL LARGE,C
-ENDIF
-
-        INCLUDE "MCP.INC"
-
-DATASEG
-
-        EXTRN   mcpStatus:BYTE
-        EXTRN   bufferSize:WORD
-        EXTRN   dataBuf:WORD
-        EXTRN   SoundCard:CARDINFO
-
-CODESEG
-
-        PUBLIC  SDI_DAC, setDACTimer
-
-        copyrightText   DB "SDI for DACs v1.5 - (C) 1992,1993 Otto Chrons",0,1Ah
-
-        DACdevice CARDINFO <7,0,"Simple DAC",0,0,0,4000,60000,0,0,1>
-        SoundDeviceDAC  SOUNDDEVICE < \
-                far ptr initDAC,\
-                far ptr initOutput,\
-                far ptr initRate,\
-                far ptr closeDAC,\
-                far ptr closeOutput,\
-                far ptr startVoice,\
-                far ptr stopVoice,\
-                far ptr pauseVoice,\
-                far ptr resumeVoice\
-                far ptr getDACpos,\
-                far ptr speakerOn,\
-                far ptr speakerOff\
-                >
-
-        TSrate          DW ?
-
-        bufferPos       DW ?
-        bufferSize2     DW ?
-        DACbuffer       DD ?
-        DACport         DW ?
-        DACport2        DW ?
-        DACmode         DB ?
-        timerCount      DW ?
-        oldint          DD ?
-        oldrate         DW 65535
-        nextByte        DB 0
-        nextByte2       DB 0
-        spkrTable       DB 256 dup(0)
-        spkrBaseTable   DB 40h,40h,40h,40h,40h,40h,40h,40h,40h,40h,3Fh,3Fh,3Fh,3Fh,3Fh,3Fh
-                        DB 3Fh,3Fh,3Fh,3Fh,3Fh,3Fh,3Eh,3Eh,3Eh,3Eh,3Eh,3Eh,3Eh,3Eh,3Eh,3Eh
-                        DB 3Dh,3Dh,3Dh,3Dh,3Dh,3Dh,3Dh,3Dh,3Dh,3Ch,3Ch,3Ch,3Ch,3Ch,3Ch,3Ch
-                        DB 3Ch,3Ch,3Ch,3Bh,3Bh,3Bh,3Bh,3Bh,3Bh,3Bh,3Bh,3Bh,3Bh,3Ah,3Ah,3Ah
-                        DB 3Ah,3Ah,3Ah,3Ah,3Ah,3Ah,3Ah,39h,39h,39h,39h,39h,39h,39h,39h,39h
-                        DB 39h,38h,38h,38h,38h,38h,38h,38h,38h,37h,37h,37h,37h,37h,36h,36h
-                        DB 36h,36h,35h,35h,35h,35h,34h,34h,34h,33h,33h,32h,32h,31h,31h,30h
-                        DB 30h,2Fh,2Eh,2Dh,2Ch,2Bh,2Ah,29h,28h,27h,26h,25h,24h,23h,22h,21h
-                        DB 20h,1Fh,1Eh,1Dh,1Ch,1Bh,1Ah,19h,18h,17h,16h,15h,14h,13h,12h,11h
-                        DB 11h,10h,10h,0Fh,0Fh,0Eh,0Eh,0Dh,0Dh,0Dh,0Ch,0Ch,0Ch,0Ch,0Bh,0Bh
-                        DB 0Bh,0Bh,0Ah,0Ah,0Ah,0Ah,0Ah,09h,09h,09h,09h,09h,09h,09h,09h,09h
-                        DB 08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,08h,07h,07h,07h,07h
-                        DB 07h,07h,07h,06h,06h,06h,06h,06h,06h,06h,06h,06h,06h,06h,05h,05h
-                        DB 05h,05h,05h,05h,05h,05h,05h,05h,04h,04h,04h,04h,04h,04h,04h,04h
-                        DB 04h,04h,03h,03h,03h,03h,03h,03h,03h,03h,03h,03h,02h,02h,02h,02h
-                        DB 02h,02h,02h,02h,02h,01h,01h,01h,01h,01h,01h,01h,01h,01h,01h,01h
-
-;/*************************************************************************
-; *
-; *     Function    :   setTimerRate
-; *
-; *     Description :   Set low-level timer rate
-; *
-; *     Input       :   AX = new timer rate
-; *
-; ************************************************************************/
-
-PROC    setTimerRate NEAR
-
-        pushf
-        cli
-        mov     bx,ax
-        mov     al,00110100b            ; Set timer rate
-        out     43h,al
-        mov     ax,bx
-        out     40h,al
-        mov     al,ah
-        out     40h,al
-        popf
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   timerDAC
-; *
-; *     Description :   Interrupt routine for outputting data from buffer
-; *
-; ************************************************************************/
-
-PROC    timerDAC FAR
-
-        cli
-        push    ax
-        push    dx
-
-        mov     dx,[DACport]
-        mov     al,[nextByte]
-        out     dx,al                   ; Output data byte
-
-        push    di
-        push    es
-
-        les     di,[DACbuffer]          ; Get next data
-        sub     di,[bufferPos]
-        mov     al,[es:di]
-        mov     [nextByte],al
-
-        dec     [bufferPos]
-        jz      @@notOK
-
-        mov     ax,[oldrate]
-        add     [timerCount],ax
-        jc      @@callold
-@@notyet:
-        pop     es
-        pop     di
-        pop     dx
-
-        mov     al,20h                  ; EOI
-        out     20h,al
-
-        pop     ax
-        iret
-@@notOK:
-        mov     ax,[bufferSize2]
-        mov     [bufferPos],ax
-
-        mov     ax,[oldrate]
-        add     [timerCount],ax
-        jc      @@callold
-
-        pop     es
-        pop     di
-        pop     dx
-
-        mov     al,20h                  ; EOI
-        out     20h,al
-
-        pop     ax
-        iret
-@@callold:
-        sti
-        pop     es
-        pop     di
-        pop     dx
-        pop     ax
-        jmp     [oldint]
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   timerDACStereo1
-; *
-; *     Description :   Interrupt routine for outputting data from buffer
-; *
-; ************************************************************************/
-
-PROC    timerDACStereo1 FAR
-
-        cli
-        push    ax
-        push    dx
-
-        mov     dx,[DACport]
-        mov     al,[nextByte]
-        out     dx,al                   ; Output data byte for left
-
-        mov     dx,[DACport2]
-        mov     al,[nextByte2]
-        out     dx,al                   ; Output data byte for right
-
-        push    di
-        push    es
-
-        les     di,[DACbuffer]          ; Get next data
-        sub     di,[bufferPos]
-        mov     ax,[es:di]
-        mov     [nextByte],al
-        mov     [nextByte2],ah
-
-        sub     [bufferPos],2
-        jle     @@notOK
-
-        mov     ax,[oldrate]
-        add     [timerCount],ax
-        jc      @@callold
-@@notyet:
-        pop     es
-        pop     di
-        pop     dx
-
-        mov     al,20h                  ; EOI
-        out     20h,al
-
-        pop     ax
-        iret
-@@notOK:
-        mov     ax,[bufferSize2]
-        mov     [bufferPos],ax
-
-        mov     ax,[oldrate]
-        add     [timerCount],ax
-        jc      @@callold
-
-        pop     es
-        pop     di
-        pop     dx
-
-        mov     al,20h                  ; EOI
-        out     20h,al
-
-        pop     ax
-        iret
-@@callold:
-        sti
-        pop     es
-        pop     di
-        pop     dx
-        pop     ax
-        jmp     [oldint]
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   timerDACStereo2
-; *
-; *     Description :   Interrupt routine for outputting data from buffer
-; *
-; ************************************************************************/
-
-PROC    timerDACStereo2 FAR
-
-        cli
-        push    ax
-        push    dx
-
-        mov     dx,[DACport]
-        add     dx,2
-        mov     al,1
-        out     dx,al
-        sub     dx,2
-
-        mov     al,[nextByte]
-        out     dx,al                   ; Output data byte for left
-
-        add     dx,2
-        mov     al,2
-        out     dx,al
-        sub     dx,2
-
-        mov     al,[nextByte2]
-        out     dx,al                   ; Output data byte for right
-
-        push    di
-        push    es
-
-        les     di,[DACbuffer]          ; Get next data
-        sub     di,[bufferPos]
-        mov     ax,[es:di]
-        mov     [nextByte],al
-        mov     [nextByte2],ah
-
-        sub     [bufferPos],2
-        jle     @@notOK
-
-        mov     ax,[oldrate]
-        add     [timerCount],ax
-        jc      @@callold
-@@notyet:
-        pop     es
-        pop     di
-        pop     dx
-
-        mov     al,20h                  ; EOI
-        out     20h,al
-
-        pop     ax
-        iret
-@@notOK:
-        mov     ax,[bufferSize2]
-        mov     [bufferPos],ax
-
-        mov     ax,[oldrate]
-        add     [timerCount],ax
-        jc      @@callold
-
-        pop     es
-        pop     di
-        pop     dx
-
-        mov     al,20h                  ; EOI
-        out     20h,al
-
-        pop     ax
-        iret
-@@callold:
-        sti
-        pop     es
-        pop     di
-        pop     dx
-        pop     ax
-        jmp     [oldint]
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   timerSpkr
-; *
-; *     Description :   Interrupt routine for outputting data from buffer
-; *
-; ************************************************************************/
-
-PROC    timerSpkr FAR
-
-        cli
-        push    ax
-        push    dx
-
-        mov     dx,[DACport]
-        mov     al,[nextByte]
-        out     dx,al
-
-        mov     al,20h                  ; EOI
-        out     20h,al
-
-        push    di
-        push    es
-
-        les     di,[DACbuffer]
-        sub     di,[bufferPos]
-        mov     al,[es:di]
-        sub     ah,ah
-        mov     di,ax
-        mov     al,[di+spkrTable]
-        mov     [nextByte],al
-
-        dec     [bufferPos]
-        jz      @@notOK
-
-        mov     ax,[oldrate]
-        add     [timerCount],ax
-        jc      @@callold
-@@notyet:
-        pop     es
-        pop     di
-        pop     dx
-        pop     ax
-        iret
-@@notOK:
-        mov     ax,[bufferSize2]
-        mov     [bufferPos],ax
-
-        mov     ax,[oldrate]
-        add     [timerCount],ax
-        jc      @@callold
-
-        pop     es
-        pop     di
-        pop     dx
-        pop     ax
-        iret
-@@callold:
-        sti
-        pop     es
-        pop     di
-        pop     dx
-        pop     ax
-        jmp     [oldint]
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void SDI_DAC(SOUNDDEVICE far *sdi);
-; *
-; *     Description :   Registers DAC as a sound device
-; *
-; *     Input       :   Pointer to SD structure
-; *
-; *     Returns     :   Fills SD structure accordingly
-; *
-; ************************************************************************/
-
-PROC    SDI_DAC FAR USES di si,sdi:DWORD
-
-        cld
-        les     di,[sdi]
-        mov     si,offset SoundDeviceDAC
-        mov     cx,SIZE SOUNDDEVICE
-        cli
-        segcs
-        rep movsb                       ; Copy structure
-        sti
-        sub     ax,ax                   ; indicate successful init
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int initDAC(CARDINFO *sCard);
-; *
-; *     Description :   Initializes DAC using given 'port' value
-; *
-; *     Input       :   port    = DAC's I/O address
-; *
-; *     Returns     :    0      = success
-; *                     -1      = error
-; *
-; ************************************************************************/
-
-PROC    initDAC FAR USES si di,sCard:DWORD
-
-        local   retval:WORD
-
-        mov     [retval],-1             ; assume error
-        mov     si,offset DACdevice     ; DS:SI = source
-        mov     ax,ds
-        mov     es,ax
-        mov     di,offset SoundCard     ; ES:DI = destination
-        mov     cx,SIZE CARDINFO
-        cld
-        cli
-        segcs
-        rep     movsb                   ; Copy information
-        sti
-
-        les     si,[sCard]
-        mov     al,[es:si+CARDINFO.DMAChannel]
-        cmp     al,1
-        je      @@stereo1
-        cmp     al,2
-        je      @@stereo2
-
-        mov     [DACmode],0             ; Normal DAC at xxx
-        mov     dx,[es:si+CARDINFO.ioPort]
-        mov     [SoundCard.ioPort],dx
-        mov     [DACport],dx
-        jmp     @@done
-@@stereo1:                              ; Two DACs on LPT1 & LPT2
-        mov     [DACmode],1
-        mov     [SoundCard.stereo],1
-        mov     ax,40h
-        mov     es,ax
-        mov     dx,[es:08h]             ; LPT1 address
-        mov     [SoundCard.ioPort],dx
-        mov     [DACport],dx
-        mov     dx,[es:0Ah]             ; LPT2 address
-        mov     [DACport2],dx
-        jmp     @@done
-@@stereo2:                              ; Stereo-on-1 at xxx
-        mov     [DACmode],2
-        mov     [SoundCard.stereo],1
-        mov     dx,[es:si+CARDINFO.ioPort]
-        mov     [SoundCard.ioPort],dx
-        mov     [DACport],dx
-@@done:
-        or      [mcpStatus],S_INIT      ; indicate successful initialization
-        mov     [retval],0              ; return 0 = OK
-@@exit:
-        mov     ax,[retval]
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   initOutput(void far *buffer,int maxsize, int required);
-; *
-; *     Description :   Init DAC timer routine for output
-; *
-; ************************************************************************/
-
-PROC    initOutput FAR buffer:DWORD,linear:DWORD,maxSize:DWORD,required:DWORD
-
-        mov     ax,[word required]           ; Is size valid?
-        or      ax,ax
-        je      @@getmax
-        cmp     [word maxSize],ax
-        jge     @@sizeOK
-@@getmax:
-        mov     ax,[word maxSize]
-@@sizeOK:
-        and     ax,NOT 3                ; 32-bit alignment
-        les     bx,[buffer]
-        add     bx,4
-        and     bx,NOT 3
-        mov     [WORD HIGH DACbuffer],es        ; Copy buffer location
-        mov     [dataBuf],bx
-        add     bx,ax
-        mov     [WORD LOW DACbuffer],bx
-
-        mov     [bufferSize],ax         ; Set buffer size
-        mov     [bufferSize2],ax
-        mov     [bufferPos],ax
-
-        mov     ax,3508h
-        int     21h                     ; Get old routine
-        mov     [WORD HIGH oldint],es
-        mov     [WORD LOW oldint],bx
-
-        mov     [timerCount],65535
-
-        mov     [TSrate],65535
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int initRate();
-; *
-; *     Description :   Inits sound card's sampling rate
-; *
-; *     Returns     :   Real sampling rate
-; *
-; ************************************************************************/
-
-PROC    initRate FAR USES di si,sample_rate:DWORD
-
-        mov     ax,[SoundCard.minRate]
-        cmp     [word sample_rate],ax        ; Check for valid rates
-        jae     @@rateok
-        mov     [word sample_rate],ax
-        jmp     @@rateok
-        mov     ax,[SoundCard.maxRate]
-        cmp     [word sample_rate],ax
-        jbe     @@rateok
-        mov     [word sample_rate],ax
-@@rateok:
-        mov     dx,12h
-        mov     ax,34DCh
-        div     [word sample_rate]           ; Calculate timer counter
-        mov     [TSrate],ax
-@@exit:
-        cmp     [SoundCard.ioPort],42h
-        jne     @@notSpeaker
-
-        cld
-        mov     ax,cs
-        mov     es,ax
-        mov     di,offset spkrTable
-        mov     si,offset spkrBaseTable
-        mov     cx,256
-@@loop:
-        mov     bx,[TSrate]
-        shr     bx,1
-        mov     al,[cs:si]
-        inc     si
-        sub     ah,ah
-        dec     ax
-        mul     bx
-        mov     bx,039h
-        div     bx
-        inc     ax
-        stosb
-        loop    @@loop
-
-@@notSpeaker:
-        mov     [oldrate],ax            ; AX = relative rate
-
-        mov     dx,12h
-        mov     ax,34DCh
-        div     [TSrate]                ; Return real rate
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   speakerOn
-; *
-; *     Description :   Does nothing currently
-; *
-; ************************************************************************/
-
-PROC    speakerOn FAR
-
-        cmp     [SoundCard.ioPort],42h
-        jne     @@exit
-
-        in      al,61h
-        or      al,3
-        out     61h,al                  ; // Turn on PC speaker
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   speakerOff
-; *
-; *     Description :   Does nothing currently
-; *
-; ************************************************************************/
-
-PROC    speakerOff FAR
-
-        cmp     [SoundCard.ioPort],42h
-        jne     @@exit
-
-        in      al,61h
-        and     al,NOT 3
-        out     61h,al                  ; // Turn off PC speaker
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   startVoice
-; *
-; *     Description :   Starts to output voice.
-; *
-; ************************************************************************/
-
-PROC    startVoice FAR
-
-        mov     dx,offset timerDACStereo1
-        cmp     [DACmode],1
-        je      @@addrOK
-        mov     dx,offset timerDACStereo2
-        cmp     [DACmode],2
-        je      @@addrOK
-        mov     dx,offset timerDAC
-@@addrOK:
-
-        cmp     [SoundCard.ioPort],42h
-        jne     @@notSpkr
-
-        mov     al,0B6h
-        out     43h,al
-        mov     al,0B0h
-        out     43h,al
-        mov     al,34h
-        out     43h,al
-
-        sub     al,al
-        out     42h,al
-        out     42h,al
-        mov     al,10010000b
-        out     43h,al
-
-        mov     dx,offset timerSpkr
-@@notSpkr:
-        mov     ax,2508h
-        push    ds
-        push    cs
-        pop     ds
-        int     21h
-        pop     ds
-
-@@exit:
-        mov     ax,[TSrate]
-        call    setTimerRate
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   stopVoice
-; *
-; *     Description :   Stops voice output.
-; *
-; ************************************************************************/
-
-PROC    stopVoice FAR USES ds
-
-        mov     ax,65535
-        call    setTimerRate
-
-        lds     dx,[oldint]
-        mov     ax,2508h                ; Return interrupt
-        int     21h
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   closeOutput
-; *
-; *     Description :   Closes timer service
-; *
-; ************************************************************************/
-
-PROC closeOutput FAR USES ds
-
-        mov     ax,65535
-        call    setTimerRate
-
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int getDACpos();
-; *
-; *     Description :   Returns DAC's current position
-; *
-; ************************************************************************/
-
-PROC    getDACpos FAR
-
-        mov     ax,[bufferSize]
-        sub     ax,[bufferPos]
-        ret
-ENDP
-
-PROC closeDAC FAR
-
-        ret
-ENDP
-
-PROC pauseVoice FAR
-
-        ret
-ENDP
-
-PROC resumeVoice FAR
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void setDACTimer( ushort new_timer );
-; *
-; *     Description :   Sets new old-timer rate
-; *
-; ************************************************************************/
-
-PROC    setDACTimer FAR newtimer:DWORD
-
-        mov     dx,[TSrate]
-        sub     ax,ax                   ; DX:AX = timer rate * 65536
-        mov     cx,[word newtimer]           ; CX = new rate for old timer
-        div     cx
-        mov     [oldrate],ax            ; AX = relative rate
-
-        ret
-ENDP
-
-END
diff --git a/dmp/sdi_pas.asm b/dmp/sdi_pas.asm
deleted file mode 100644
index 9198025..0000000
--- a/dmp/sdi_pas.asm
+++ /dev/null
@@ -1,842 +0,0 @@
-;/************************************************************************
-; *
-; *	File	    : SDI_PAS.ASM
-; *
-; *	Description : SDI for MediaVision cards
-; *
-; *	Copyright (C) 1993 Otto Chrons
-; *
-; ***********************************************************************
-;
-;	Revision history of SDI_PAS.ASM
-;
-;	1.0	16.4.93
-;		First version. Works with all PAS cards. There were some
-;		troubles with 8-bit DMA but they are now fixed.
-;
-; ***********************************************************************/
-
-	IDEAL
-	JUMPS
-	P386N
-
-;	L_PASCAL	= 1		; Uncomment this for pascal-style
-
-IFDEF	L_PASCAL
-	LANG	EQU	PASCAL
-	MODEL TPASCAL
-ELSE
-	LANG	EQU	C
-	MODEL LARGE,C
-ENDIF
-
-        INCLUDE "MODEL.INC"
-        MASM
-	QUIRKS
-	INCLUDE COMMON.INC
-	INCLUDE STATE.INC
-	INCLUDE MASM.INC
-	IDEAL
-	INCLUDE "MCP.INC"
-
-STRUC	DMAPORT
-
-	addr	DW ?
-	count	DW ?
-	page	DW ?
-	wcntrl	DW ?
-	wreq	DW ?
-	wrsmr	DW ?
-	wrmode	DW ?
-	clear	DW ?
-	wrclr	DW ?
-	clrmask	DW ?
-	wrall	DW ?
-ENDS
-
-DATASEG
-
-	EXTRN	mcpStatus:BYTE
-	EXTRN	bufferSize:WORD
-	EXTRN	dataBuf:WORD
-	EXTRN	SoundCard:CARDINFO
-
-	DMApage		DB ?
-	DMAoffset	DW ?
-	ioPort		DW ?
-	saveDMAvector	DD ?
-	samplingRate	DW ?
-	curDMA		DMAPORT <>
-;
-; This pointer points to a state table of hardware variables
-;
-	mvhwShadowPointer	DD	?	; points to the start of the data table
-
-	HardwareShadowTable	DB	(size MVState) dup (?)
-
-
-CODESEG
-
-	PUBLIC	SDI_PAS
-
-	copyrightText	DB "SDI for PAS,PAS+ and PAS 16 v1.0 - (C) 1993 Otto Chrons",0,1Ah
-
-	PASnorm 	CARDINFO <3,0,"Pro Audio Spectrum",388h,0,0,3000,44100,1,1,1>
-	PASplus		CARDINFO <4,0,"Pro Audio Spectrum+",388h,0,0,3000,44100,1,1,1>
-	PAS16		CARDINFO <5,0,"Pro Audio Spectrum 16",388h,0,0,3000,44100,1,1,2>
-
-	LABEL DMAports	DMAPORT
-
-	    DMAPORT <0,1,87h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-	    DMAPORT <2,3,83h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-	    DMAPORT <4,5,81h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-	    DMAPORT <6,7,82h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-	    DMAPORT <0,0,0,0,0,0,0,0,0,0,0>
-	    DMAPORT <0C4h,0C6h,8Bh,0D0h,0D2h,0D4h,0D6h,0D8h,0DAh,0DCH,0DEh>
-	    DMAPORT <0C8h,0CAh,89h,0D0h,0D2h,0D4h,0D6h,0D8h,0DAh,0DCH,0DEh>
-	    DMAPORT <0CCh,0CEh,8Ah,0D0h,0D2h,0D4h,0D6h,0D8h,0DAh,0DCH,0DEh>
-
-	SoundDevicePAS	SOUNDDEVICE < \
-		far ptr initPAS,\
-		far ptr initDMA,\
-		far ptr initRate,\
-		far ptr closePAS,\
-		far ptr closeDMA,\
-		far ptr startVoice,\
-		far ptr stopVoice,\
-		far ptr pauseVoice,\
-		far ptr resumeVoice\
-		far ptr getDMApos,\
-		far ptr speakerOn,\
-		far ptr speakerOff\
-		>
-
-;/*************************************************************************
-; *
-; *	Function    :	void SDI_PAS(SOUNDDEVICE far *sdi);
-; *
-; *	Description :	Registers Pro Audio Spectrum as a sound device
-; *
-; *	Input       :	Pointer to SD structure
-; *
-; *	Returns     :	Fills SD structure accordingly
-; *
-; ************************************************************************/
-
-PROC	SDI_PAS FAR USES di si,sdi:DWORD
-
-	cld
-	LESDI	[sdi]
-	mov	si,offset SoundDevicePAS
-	mov	cx,SIZE SOUNDDEVICE
-	cli
-	segcs
-	rep movsb			; Copy structure
-	sti
-	sub	ax,ax			; indicate successful init
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	playDMA
-; *
-; *	Description :	Plays current buffer through DMA
-; *
-; ************************************************************************/
-
-PROC	playDMA NEAR
-
-	PUSHES
-	push	di
-
-	mov	ax,60000
-MASM
-	LESDI	[mvhwShadowPointer]
-
-	push	ax
-
-	disable
-
-	mov     al,01110100b            ; 74h Timer 1 & rate generator
-	mov	dx,TMRCTLR
-	xor	dx,[ioPort]		; xlate the board address
-
-
-	out     dx,al
-	mov	[ESDI._tmrctlr],al	; local timer control register
-
-	pop	ax
-
-	mov     dx,SAMPLECNT
-	xor	dx,[ioPort]		; xlate the board address
-	mov	[ESDI._samplecnt],ax
-
-	out     dx,al
-	pause
-	xchg	ah,al
-	out	dx,al
-
-	enable
-IDEAL
-@@exit:
-	pop	di
-	POPES
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    : 	interruptDMA
-; *
-; *	Description :	DMA interrupt routine for continuos playing.
-; *
-;/************************************************************************/
-
-PROC	NOLANGUAGE interruptDMA NEAR
-
-;	sti
-;	push	ax
-;	push	dx
-;	push	ds
-;	mov	ax,@data
-;	mov	ds,ax			; DS = data segment
-;
-;	mov	dx,INTRCTLRST		; clear the interrupt
-;	xor     dx,[ioPort]		; xlate the board address
-;	in	al,dx
-;
-;	cmp	[mcpStatus],111b	; Inited and playing
-;	jne	@@exit
-;	call	playDMA			; Output current buffer
-;@@exit:
-;	mov	al,20h			; End Of Interrupt (EOI)
-;	out	20h,al
-;	cmp	[SoundCard.dmaIRQ],7
-;	jle	@@10
-;	out	0A0h,al
-;@@10:
-;	pop	ds
-;	pop	dx
-;	pop	ax
-	iret				; Interrupt return
-ENDP
-
-
-;/*************************************************************************
-; *
-; *	Function    : calcsamplerate
-; *
-; *	Description : Calculates new sampling rate
-; *
-; *	Input       : EAX sampling rate
-; *
-; ************************************************************************/
-
-PROC	calcsamplerate NEAR
-MASM
-	push	es
-	push	di
-	LESDI	[mvhwShadowPointer]
-
-;
-; make sure sample rate does not exceed 88200
-;
-	mov	ecx,eax
-	cmp	ecx,88200
-	ja	CaSaRa_bad
-;
-; load 1193180 in bx:cx for 32x32 bit division
-;
-	mov	eax,001234DCh
-	sub	edx,edx
-	div	ecx
-	mov	[ESDI._samplerate],ax	; save just the low order
-	sub	ecx,ecx
-	mov	cx,ax
-	mov	eax,001234DCh
-	sub	edx,edx
-	div	ecx
-	jmp	short CaSaRa_exit
-;
-CaSaRa_bad:
-;
-CaSaRa_exit:
-
-	pop     di
-	pop	es
-	ret
-IDEAL
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    : int initPAS(CARDINFO *scard);
-; *
-; *	Description : Initializes a PAS card.
-; *
-; *	Input       : Pointer to CARDINFO structure
-; *
-; *	Returns     : 0 no error
-; *		      other = error
-; *
-; *************************************************************************/
-
-PROC	initPAS FAR USES si di, scard:FAR PTR CARDINFO
-	LOCAL	retvalue:WORD
-
-	mov	[retvalue],-1
-	les	si,[scard]
-	mov	al,[ESSI+CARDINFO.ID]
-	mov	si,offset PASnorm	; SI = source
-	cmp	al,ID_PAS		; Check for valid ID
-	je	@@idOK
-	mov	si,offset PASplus	; SI = source
-	cmp	al,ID_PASPLUS
-	je	@@idOK
-	mov	si,offset PAS16		; SI = source
-	cmp	al,ID_PAS16
-	jne	@@exit
-@@idOK:
-	mov	ax,ds
-	mov	es,ax
-	mov	di,offset SoundCard	; ES:DI = destination
-	mov	cx,SIZE CARDINFO
-	cld
-	cli
-	segcs
-	rep	movsb			; Copy information
-	sti
-
-	les	si,[scard]
-	mov	ax,[ESSI+CARDINFO.ioPort]
-	mov	[SoundCard.ioPort],ax
-	mov	al,[ESSI+CARDINFO.DMAIRQ]
-	cmp	al,16 			; Is it > 15?
-	jae	@@exit
-	mov	[SoundCard.DMAIRQ],al
-	mov	al,[ESSI+CARDINFO.DMAchannel]
-	cmp	al,4			; Channel 4 is invalid
-	je	@@exit
-	cmp	al,8
-	jae	@@exit			; So are > 7
-	mov	[SoundCard.DMAchannel],al
-
-	mov	bh,[ESSI+CARDINFO.stereo]
-	cmp	bh,1
-	ja	@@exit
-
-	mov	bl,[ESSI+CARDINFO.sampleSize]
-
-	mov	[SoundCard.sampleSize],bl	; Save values
-	mov	[SoundCard.stereo],bh
-
-	mov	bl,[ESSI+CARDINFO.DMAchannel]
-	sub	bh,bh
-	imul	bx,bx,SIZE DMAPORT
-	lea	si,[bx+DMAports]	; SI = DMAports[DMAchannel]
-	mov	ax,ds
-	mov	es,ax
-	mov	di,offset curDMA	; ES:DI = curDMA
-	mov	cx,SIZE DMAPORT
-	cli
-	segcs
-	rep	movsb			; Copy structure
-	sti
-MASM
-;
-; setup a pointer to our local hardware state table
-;
-	lea	bx,[HardwareShadowTable]
-	mov	wptr [mvhwShadowPointer+0],bx
-	mov	wptr [mvhwShadowPointer+2],ds
-	push	ds
-	pop	es
-	mov	di,bx
-	mov	cx,SIZE MVState		; Clear state table
-	sub	al,al
-	rep	stosb
-	mov	[bx._crosschannel],9	; cross channel l-2-l, r-2-r
-	mov	[bx._audiofilt],31h	; lowest filter setting
-;
-; find the int 2F interface and if found, use it's state table pointer
-
-	mov	ax,0BC00h		; MVSOUND.SYS ID check
-	mov	bx,'??'
-	sub	cx,cx
-	sub	dx,dx
-
-	int	2fh			; will return something if loaded
-
-	xor	bx,cx
-	xor	bx,dx
-	cmp	bx,'MV'                 ; is the int 2F interface here?
-	jnz	imvsp_done		; no, exit home
-
-	mov	ax,0BC02H		; get the pointer
-	int     2fh
-	cmp	ax,'MV'                 ; busy or intercepted
-	jnz	imvsp_done
-
-	mov	wptr [mvhwShadowPointer+0],bx
-	mov	wptr [mvhwShadowPointer+2],dx
-
-imvsp_done:
-IDEAL
-
-	mov	dx,[SoundCard.ioPort]
-	xor	dx,DEFAULT_BASE
-	mov	[ioPort],dx
-
-	mov	dx,INTRCTLRST			; flush any pending PCM irq
-	xor	dx,[ioPort]			; xlate the board address
-	out	dx,al
-
-	or	[mcpStatus],S_INIT	; indicate successful initialization
-	mov	[retvalue],0
-@@exit:
-	mov	ax,[retvalue]
-	ret
-ENDP
-
-;/***********************************************************************
-; *
-; *	Function    :	int getDMApos():
-; *
-; *	Description :	Returns the position of DMA transfer
-; *
-; **********************************************************************/
-
-PROC	getDMApos FAR
-
-	cli
-@@05:
-	mov	al,0FFh
-	mov	dx,[curDMA.clear]
-	out	dx,al
-	mov	dx,[curDMA.count]
-	in	al,dx
-	mov	ah,al
-	in	al,dx
-	xchg	ah,al
-	mov	bx,ax
-	in	al,dx
-	mov	ah,al
-	in	al,dx
-	xchg	ah,al
-	sub	bx,ax
-	cmp	bx,64
-	jg	@@05
-	cmp	bx,-64
-	jl	@@05
-	neg	ax
-	cmp	[SoundCard.DMAChannel],4
-	jb	@@dma8
-	shl	ax,1			; 16-bit to 8-bit
-@@dma8:
-	add	ax,[bufferSize]		; AX = DMA position
-	sti
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	initDMA(void far *buffer,int maxsize, int required);
-; *
-; *	Description :   Init DMA for output
-; *
-; ************************************************************************/
-
-PROC	initDMA FAR buffer:DWORD,linear:DWORD,maxSize:DWORD,required:DWORD
-
-	mov	cx,[word maxSize]
-	mov	[bufferSize],cx
-	mov	ax,[WORD HIGH buffer]
-	mov	bx,[WORD LOW buffer]
-	add	bx,3
-	and	bx,NOT 3
-	mov	[dataBuf],bx		; Check if DMA buffers are on
-	mov	eax,[linear]		; a segment boundary
-	add	eax,3
-	and	eax,NOT 3
-	neg	ax
-	cmp	ax,cx			; Is buffer size >= data size
-	ja	@@bufOK
-	dec	ax
-	and	ax,NOT 3
-	mov	[bufferSize],ax
-	shr	cx,1
-	cmp	ax,cx			; Is it even half of it?
-	ja	@@bufOK
-	shl	cx,1
-	add	[dataBuf],ax
-	add	[dataBuf],7
-	and	[dataBuf],NOT 3
-	neg	ax
-	add	ax,cx			; AX = dataSize - AX
-	sub	ax,32
-	and	ax,NOT 3
-	mov	[bufferSize],ax
-@@bufOK:
-	cmp	[required],0
-	je	@@sizeok
-	cmp	ax,[word required]
-	jbe	@@sizeok
-	mov	ax,[word required]
-	mov	[bufferSize],ax
-@@sizeok:
-	and	[bufferSize],NOT 3
-	sub	ebx,ebx
-	mov	eax,[linear]		; Calculate DMA page and offset values
-	mov	bx,[dataBuf]
-	sub	bx,[WORD LOW buffer]	; Relative offset
-	add	eax,ebx
-	mov	ebx,eax
-	shr	ebx,16
-	cmp	[SoundCard.DMAChannel],4
-	jb	@@8bitDMA
-	push	bx
-	shr	bl,1
-	rcr	ax,1			; For word addressing
-	pop	bx
-@@8bitDMA:
-	mov	[DMApage],bl
-	mov	[DMAoffset],ax
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	initRate
-; *
-; *	Description :   Inits sound card's sampling rate
-; *
-; ************************************************************************/
-
-PROC	initRate FAR USES di,sample_rate:DWORD
-
-	sub	eax,eax
-	mov	ax,[SoundCard.minRate]
-	cmp	[word sample_rate],ax
-	jae	@@rateok
-	mov	[word sample_rate],ax
-	jmp	@@rateok
-	mov	ax,[SoundCard.maxRate]
-	cmp	[word sample_rate],ax
-	jbe	@@rateok
-	mov	[word sample_rate],ax
-@@rateok:
-	mov	ax,[word sample_rate]
-	cmp	[SoundCard.stereo],0
-	je	@@mono
-	shl	eax,1
-@@mono:
-	call	calcsamplerate
-	mov	cl,[SoundCard.stereo]
-	shr	eax,cl
-	mov	[samplingRate],ax
-MASM
-	les     di,[mvhwShadowPointer]
-	mov     al,00110110b            ; 36h Timer 0 & square wave
-	mov	dx,TMRCTLR
-	xor	dx,[ioPort]		; xlate the board address
-
-	cli
-
-	out	dx,al			; setup the mode, etc
-	mov     [ESDI._tmrctlr],al
-
-	mov	ax,[ESDI._samplerate]	; pre-calculated & saved in prior code
-	mov	dx,SAMPLERATE
-	xor	dx,[ioPort]		; xlate the board address
-	out	dx,al			; output the timer value
-
-	pause
-
-	xchg    ah,al
-	out	dx,al
-	sti
-IDEAL
-@@exit:
-	movzx	eax,[samplingRate]
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	speakerOn
-; *
-; *	Description :	Connects PAS speaker
-; *
-; ************************************************************************/
-
-PROC	speakerOn FAR
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	speakerOff
-; *
-; *	Description :	Disconnects speaker from PAS
-; *
-; ************************************************************************/
-
-PROC	speakerOff FAR
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	startVoice
-; *
-; *	Description :	Starts to output voice.
-; *
-; ************************************************************************/
-
-PROC	startVoice FAR USES di
-
-	mov	ah,[DMApage]		; Load correct DMA page and offset
-	mov	bx,[DMAoffset]		; values
-	mov	cx,[bufferSize]
-	cmp	[SoundCard.DMAchannel],4
-	jb	@@bufByte
-	shr	cx,1			; Word count for 16-bit DMA
-@@bufByte:
-	dec	cx
-	cli				; Set the DMA up and running
-	mov	al,[SoundCard.DMAChannel]
-	or	al,4
-	mov	dx,[curDMA.wrsmr]
-	out	dx,al			; Break On
-	mov	al,[SoundCard.DMAChannel]
-	and	al,3
-	or	al,058h
-	mov	dx,[curDMA.wrmode]
-	out	dx,al
-	mov	dx,[curDMA.page]
-	mov	al,ah
-	out	dx,al			; Page
-	mov	al,0FFh
-	mov	dx,[curDMA.clear]
-	out	dx,al			; Reset counter
-
-	mov	dx,[curDMA.addr]
-	mov	al,bl
-	out	dx,al			; Offset
-	mov	al,bh
-	out	dx,al
-
-	mov	dx,[curDMA.count]
-	mov	al,cl
-	out	dx,al			; Count
-	mov	al,ch
-	out	dx,al
-	mov	al,[SoundCard.DMAChannel]
-	and	al,3
-	mov	dx,[curDMA.wrsmr]
-	out	dx,al			; Break Off
-	sti
-IF 0
-	mov	ah,[DMApage]		; Load correct DMA page and offset
-	mov	bx,[DMAoffset]		; values
-	mov	cx,[bufferSize]
-	cmp	[SoundCard.DMAchannel],4
-	jb	@@bufByte2
-	shr	cx,1			; Word count for 16-bit DMA
-@@bufByte2:
-	dec	cx
-	cli				; Set the DMA up and running
-	mov	al,[SoundCard.DMAChannel]
-	or	al,4
-	mov	dx,[curDMA.wrsmr]
-	out	dx,al			; Break On
-	mov	al,[SoundCard.DMAChannel]
-	and	al,3
-	or	al,058h
-	mov	dx,[curDMA.wrmode]
-	out	dx,al
-	mov	dx,[curDMA.page]
-	mov	al,ah
-	out	dx,al			; Page
-	mov	al,0FFh
-	mov	dx,[curDMA.clear]
-	out	dx,al			; Reset counter
-
-	mov	dx,[curDMA.addr]
-	mov	al,bl
-	out	dx,al			; Offset
-	mov	al,bh
-	out	dx,al
-
-	mov	dx,[curDMA.count]
-	mov	al,cl
-	out	dx,al			; Count
-	mov	al,ch
-	out	dx,al
-	mov	al,[SoundCard.DMAChannel]
-	and	al,3
-	mov	dx,[curDMA.wrsmr]
-	out	dx,al			; Break Off
-	sti
-ENDIF
-
-	les     di,[mvhwShadowPointer]
-	cmp	[SoundCard.sampleSize],2
-	jne	@@no16bit
-	mov	cx,(((NOT(bSC216bit+bSC212bit) AND 0FFh)*256) + bSC216bit)
-	mov	dx,SYSCONFIG2
-	xor	dx,[ioPort]		; xlate the board address
-	in	al,dx
-	and	al,ch			; clear the bits
-	or	al,cl			; set the appropriate bits
-	out	dx,al
-@@no16bit:
-	mov	al,bCCmono		; get the stereo/mono mask bit
-	cmp	[SoundCard.stereo],0
-	je	@@mono
-	sub	al,al
-@@mono:
-	or	al,bCCdac		; get the direction bit mask
-	or	al,bCCenapcm		; enable the PCM state machine
-	mov     dx,CROSSCHANNEL
-	xor	dx,[ioPort]	; xlate the board address
-
-MASM
-	mov	ah,0fh + bCCdrq 	; get a mask to load non PCM bits
-	and	ah,[ESDI._crosschannel]; grab all but PCM/DRQ/MONO/DIRECTION
-	or	al,ah			; merge the two states
-	xor	al,bCCenapcm		; disable the PCM bit
-	out	dx,al			; send to the hardware
-	pause
-	xor	al,bCCenapcm		; enable the PCM bit
-	out	dx,al			; send to the hardware
-	mov	[ESDI._crosschannel],al; and save the new state
-;
-; Setup the audio filter sample bits
-;
-	mov	al,[ESDI._audiofilt]
-	or	al,(bFIsrate+bFIsbuff)	; enable the sample count/buff counters
-	mov	dx,AUDIOFILT
-	xor	dx,[ioPort]	; xlate the board address
-	out	dx,al
-	mov	[ESDI._audiofilt],al
-
-	mov	al,[ESDI._crosschannel]; get the state
-	mov     dx,CROSSCHANNEL
-	xor     dx,[ioPort]		; xlate the board address
-	or	al,bCCdrq		; set the DRQ bit to control it
-	out	dx,al
-	mov	[ESDI._crosschannel],al; and save the new state
-IDEAL
-@@exit:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	stopVoice
-; *
-; *	Description :	Stops voice output.
-; *
-; ************************************************************************/
-
-PROC	stopVoice FAR USES di
-
-
-MASM
-	LESDI	[mvhwShadowPointer]
-;
-; clear the audio filter sample bits
-;
-	mov	dx,AUDIOFILT
-	xor	dx,[ioPort]	; xlate the board address
-	disable 			; drop dead...
-	mov	al,[ESDI._audiofilt]	; get the state
-	and	al,not (bFIsrate+bFIsbuff) ; flush the sample timer bits
-	mov	[ESDI._audiofilt],al	; save the new state
-	out	dx,al
-IDEAL
-;	mov	cx,0
-@@wait:
-;	loop	@@wait
-	mov	al,[SoundCard.DMAChannel] ; Reset DMA
-	or	al,4
-	mov	dx,[curDMA.wrsmr]
-	out	dx,al
-	mov	al,0
-	mov	dx,[curDMA.clear]
-	out	dx,al
-
-	cmp	[SoundCard.ID],ID_PAS16
-	jne	@@no16bit
-;
-; disable the 16 bit stuff
-;
-	mov	dx,SYSCONFIG2
-	xor	dx,[ioPort]	   ; xlate the board address
-	in	al,dx
-	and	al,not bSC216bit+bSC212bit ; flush the 16 bit stuff
-	out	dx,al
-;
-@@no16bit:
-MASM
-stpc02:
-;
-; clear the appropriate Interrupt Control Register bit
-;
-	mov	ah,bICsampbuff
-	and	ah,bICsamprate+bICsampbuff
-	not	ah
-	mov	dx,INTRCTLR
-	xor	dx,[ioPort]	; xlate the board address
-	in	al,dx
-	and	al,ah			; kill sample timer interrupts
-	out	dx,al
-	mov	[ESDI._intrctlr],al
-
-	mov     al,[ESDI._crosschannel]; get the state
-	mov     dx,CROSSCHANNEL
-	xor     dx,[ioPort]		; xlate the board address
-	and	al,not bCCdrq		; clear the DRQ bit
-	and	al,not bCCenapcm	; clear the PCM enable bit
-	or	al,bCCdac
-	out	dx,al
-
-	mov     [ESDI._crosschannel],al; and save the new state
-IDEAL
-@@exit:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	closeDMA
-; *
-; *	Description :   Returns DMA's IRQ vector
-; *
-; ************************************************************************/
-
-PROC closeDMA FAR
-	ret
-ENDP
-
-PROC closePAS FAR
-	ret
-ENDP
-
-PROC pauseVoice FAR
-	ret
-ENDP
-
-PROC resumeVoice FAR
-	ret
-ENDP
-
-
-END
diff --git a/dmp/sdi_sb.asm b/dmp/sdi_sb.asm
deleted file mode 100644
index f7da8d5..0000000
--- a/dmp/sdi_sb.asm
+++ /dev/null
@@ -1,1024 +0,0 @@
-;/************************************************************************
-; *
-; *     File        :   SDI_SB.ASM
-; *
-; *     Description :   Sound Blaster (Pro) specific routines for MCP
-; *
-; *     Copyright (C) 1992 Otto Chrons
-; *
-; ************************************************************************
-;
-;       Revision history of SDI_SB.ASM
-;
-;       1.0     16.4.93
-;               First version. SB and SB Pro routines.
-;
-; ***********************************************************************/
-
-	IDEAL
-	JUMPS
-	P386N
-
-       L_PASCAL        = 1             ; Uncomment this for pascal-style
-
-IFDEF   L_PASCAL
-	LANG    EQU     PASCAL
-	MODEL TPASCAL
-ELSE
-	LANG    EQU     C
-	MODEL LARGE,C
-ENDIF
-
-	INCLUDE "MODEL.INC"
-	INCLUDE "MCP.INC"
-
-MACRO   waitSB
-	local   l1
-l1:
-	in      al,dx
-	or      al,al
-	js      l1
-ENDM
-
-MACRO   waitSBport
-	local   l1
-
-	mov     dx,[SoundBlaster.ioPort]
-	add     dx,0Ch
-l1:
-	in      al,dx
-	or      al,al
-	js      l1
-ENDM
-
-MACRO   waitSBPROport
-	local   l1
-
-	mov     dx,[SoundBlasterPro.ioPort]
-	add     dx,0Ch
-l1:
-	in      al,dx
-	or      al,al
-	js      l1
-ENDM
-
-DATASEG
-
-	EXTRN   mcpStatus:BYTE
-	EXTRN   bufferSize:WORD
-	EXTRN   dataBuf:WORD
-	EXTRN   SoundCard:CARDINFO
-
-	DMApage         DB ?
-	DMAoffset       DW ?
-	saveDMAvector   DD ?
-	samplingRate    DW ?
-	SBrate          DB ?
-
-CODESEG
-
-	PUBLIC  SDI_SB
-	PUBLIC  SDI_SBPro
-
-	copyrightText   DB "SDI for SB & SB Pro v1.0 - (C) 1992 Otto Chrons",0,1Ah
-	SoundBlaster    CARDINFO <1,0,"Sound Blaster",220h,7,1,4000,22050,0,0,1>
-	SoundBlasterPro CARDINFO <2,0,"Sound Blaster Pro",220h,7,1,4000,22050,1,1,1>
-	SoundDeviceSB   SOUNDDEVICE < \
-		far ptr initSB,\
-		far ptr initDMA,\
-		far ptr initRate,\
-		far ptr closeSB,\
-		far ptr closeDMA,\
-		far ptr startVoice,\
-		far ptr stopVoice,\
-		far ptr pauseVoice,\
-		far ptr resumeVoice\
-		far ptr getDMApos,\
-		far ptr speakerOn,\
-		far ptr speakerOff\
-		>
-
-	SoundDeviceSBPro        SOUNDDEVICE < \
-		far ptr initSBPro,\
-		far ptr initDMA,\
-		far ptr initRate,\
-		far ptr closeSB,\
-		far ptr closeDMA,\
-		far ptr startVoice,\
-		far ptr stopVoice,\
-		far ptr nullFunc,\
-		far ptr nullFunc\
-		far ptr getDMApos,\
-		far ptr speakerOn,\
-		far ptr speakerOff\
-		>
-
-
-;/*************************************************************************
-; *
-; *     Function    :   void SDI_SB(SOUNDDEVICE far *sdi);
-; *
-; *     Description :   Registers SB as a sound device
-; *
-; *     Input       :   Pointer to SD structure
-; *
-; *     Returns     :   Fills SD structure accordingly
-; *
-; ************************************************************************/
-
-PROC    SDI_SB FAR USES di si,sdi:DWORD
-
-	cld
-	LESDI   [sdi]
-	mov     si,offset SoundDeviceSB
-	mov     cx,SIZE SOUNDDEVICE
-	cli
-	segcs
-	rep movsb                       ; Copy structure
-	sti
-	sub     ax,ax                   ; indicate successful init
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void SDI_SBPro(SOUNDDEVICE far *sdi);
-; *
-; *     Description :   Registers SBPro as a sound device
-; *
-; *     Input       :   Pointer to SD structure
-; *
-; *     Returns     :   Fills SD structure accordingly
-; *
-; ************************************************************************/
-
-PROC    SDI_SBPro FAR USES di si, sdi:DWORD
-
-	cld
-	LESDI   [sdi]
-	mov     si,offset SoundDeviceSBPro
-	mov     cx,SIZE SOUNDDEVICE
-	cli
-	segcs
-	rep movsb                       ; Copy structure
-	sti
-	sub     ax,ax                   ; indicate successful init
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   checkPort_SB
-; *
-; *     Description :   Checks if given address is SB's I/O address
-; *
-; *     Input       :   DX = port to check
-; *
-; *     Returns     :   AX = 0  succesful
-; *                     AX = 1  unsuccesful
-; *
-; ************************************************************************/
-
-PROC    NOLANGUAGE checkPort_SB NEAR
-
-	push    dx
-	add     dl,6                    ; Init Sound Blaster
-	mov     al,1
-	out     dx,al
-	in      al,dx                   ; Wait for awhile
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	mov     al,0
-	out     dx,al
-	sub     dl,6
-
-	add     dl,0Eh                  ; DSP data available status
-	mov     cx,1000
-@@loop:
-	in      al,dx                   ; port 22Eh
-	or      al,al
-	js      @@10
-	loop    @@loop
-
-	mov     ax,1
-	jmp     @@exit
-@@10:
-	sub     dl,4
-	in      al,dx                   ; port 22Ah
-	cmp     al,0AAh                 ; Is ID 0AAh?
-	mov     ax,0
-	je      @@exit
-	mov     ax,1
-@@exit:
-	pop     dx
-	or      ax,ax                   ; Set zero-flag accordingly
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   cmdSB
-; *
-; *     Description :   Sends a command to Sound Blaster
-; *
-; *     Input       :   AL = Command to send
-; *
-; ************************************************************************/
-
-PROC    cmdSB NEAR
-
-	push    ecx
-	mov     ecx,500000
-	push    ax
-	mov     dx,[SoundCard.ioPort]
-	add     dl,0Ch
-@@1:
-	in      al,dx
-	or      al,al
-	jns     @@2
-	loopd   @@1
-@@2:
-	pop     ax
-	out     dx,al
-	pop     ecx
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   playDMA
-; *
-; *     Description :   Plays current buffer through DMA
-; *
-; ************************************************************************/
-
-PROC    playDMA NEAR USES cx
-
-	mov     cx,65500
-	cmp     [SoundCard.ID],ID_SOUNDBLASTER
-	jne     @@10
-	mov     al,14h                  ; SB's command for output
-	call    cmdSB
-	mov     al,cl                   ; Count
-	call    cmdSB
-	mov     al,ch
-	call    cmdSB
-	jmp     @@exit
-@@10:
-	cmp     [SoundCard.ID],ID_SOUNDBLASTERPRO
-	jne     @@exit
-	mov     al,91h                  ; Start transfer
-	call    cmdSB
-@@exit:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   interruptDMA
-; *
-; *     Description :   DMA interrupt routine for continous playing.
-; *
-; ************************************************************************/
-
-PROC    NOLANGUAGE interruptDMA NEAR
-
-	push    ax
-	push    dx
-	push    ds
-	mov     ax,@data
-	mov     ds,ax                   ; DS = data segment
-
-	mov     dx,[SoundCard.ioPort]   ; Reset SB for next DMA
-	add     dl,0Eh
-	in      al,dx
-	call    playDMA                 ; Output current buffer
-	mov     al,20h                  ; End Of Interrupt (EOI)
-	out     20h,al
-	cmp     [SoundCard.dmaIRQ],7
-	jle     @@10
-	out     0A0h,al
-@@10:
-	pop     ds
-	pop     dx
-	pop     ax
-	iret                            ; Interrupt return
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int getDMApos():
-; *
-; *     Description :   Returns the position of DMA transfer
-; *
-; ************************************************************************/
-
-PROC    getDMApos FAR
-
-	cli
-	sub     dh,dh
-	mov     dl,[SoundCard.dmaChannel]
-	shl     dx,1
-	inc     dx
-@@05:
-	mov     al,0FFh
-	out     0Ch,al
-	in      al,dx
-	mov     ah,al
-	in      al,dx
-	xchg    ah,al
-	mov     bx,ax
-	in      al,dx
-	mov     ah,al
-	in      al,dx
-	xchg    ah,al
-	sub     bx,ax
-	cmp     bx,64
-	jg      @@05
-	cmp     bx,-64
-	jl      @@05
-	neg     ax
-	add     ax,[bufferSize]         ; AX = DMA position
-	sti
-
-	ret
-ENDP
-
-
-;/*************************************************************************
-; *
-; *     Function    :   int initSB(CARDINFO *sCard);
-; *
-; *     Description :   Initializes Sound Blaster using given 'port' and
-; *                     'DMA_int' values
-; *
-; *     Input       :   port    = Sound Blaster's I/O address (210h-260h)
-; *                     DMA_int = DMA interrupt value (2,3,5 or 7)
-; *
-; *     Returns     :    0      = success
-; *                     -1      = error
-; *
-; ************************************************************************/
-
-PROC    initSB FAR USES di si,sCard:DWORD
-	local   retvalue:WORD
-
-	LESSI   [sCard]
-	mov     [retvalue],-1           ; assume error
-	mov     dx,[ESSI+CARDINFO.ioPort]
-	ror     dx,4
-	cmp     dx,21h                  ; check for valid addresses
-	jb      @@exit
-	cmp     dx,26h
-	ja      @@exit
-
-	cmp     [ESSI+CARDINFO.DMAIRQ],2        ; check for legal inteerupt values
-	jz      @@DMA_OK
-	cmp     [ESSI+CARDINFO.DMAIRQ],3
-	jz      @@DMA_OK
-	cmp     [ESSI+CARDINFO.DMAIRQ],5
-	jz      @@DMA_OK
-	cmp     [ESSI+CARDINFO.DMAIRQ],7
-	jnz     @@exit
-@@DMA_OK:
-	mov     si,offset SoundBlaster          ; DS:SI = source
-	mov     ax,ds
-	mov     es,ax
-	mov     di,offset SoundCard     ; ESDI = destination
-	mov     cx,SIZE CARDINFO
-	cld
-	cli
-	segcs
-	rep     movsb                   ; Copy information
-	sti
-
-	LESSI   [sCard]
-	mov     bx,[ESSI+CARDINFO.ioPort]
-	mov     [SoundCard.ioPort],bx
-	mov     bl,[ESSI+CARDINFO.DMAIRQ]
-	mov     [SoundCard.DMAIRQ],bl
-	mov     [SoundCard.DMAchannel],1        ; Channel is always 1
-
-	mov     dx,[SoundCard.ioPort]   ; initialize Sound Blaster
-	add     dx,6
-	mov     al,1
-	out     dx,al
-	in      al,dx                   ; Wait for awhile
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	mov     al,0
-	out     dx,al
-
-	or      [mcpStatus],S_INIT      ; indicate successful initialization
-	mov     [retvalue],0            ; return 0 = OK
-@@exit:
-	mov     ax,[retvalue]
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int initSBpro(CARDINFO *sCard);
-; *
-; *     Description :   Initializes Sound Blaster Pro using values for
-; *                     ioPort,dmaIRQ & dmaChannel in sCard
-; *
-; *     Input       :   sCard   = pointer to CARDINFO-structure
-; *
-; *     Returns     :    0      = success
-; *                     -1      = error
-; *
-; ************************************************************************/
-
-PROC    initSBpro FAR USES di si,sCard:DWORD
-	local   retryCount:WORD,retvalue:WORD
-
-	LESSI   [sCard]
-	mov     [retvalue],-1           ; assume error
-	mov     dx,[ESSI+CARDINFO.ioPort]
-	cmp     dx,220h                 ; check for valid addresses
-	je      @@OK
-	cmp     dx,240h
-	jne     @@exit
-@@OK:
-	cmp     [ESSI+CARDINFO.DMAIRQ],2        ; check for legal interrupt values
-	je      @@DMA_OK
-	cmp     [ESSI+CARDINFO.DMAIRQ],5
-	je      @@DMA_OK
-	cmp     [ESSI+CARDINFO.DMAIRQ],7
-	je      @@DMA_OK
-	cmp     [ESSI+CARDINFO.DMAIRQ],10
-	jne     @@exit
-@@DMA_OK:
-	cmp     [ESSI+CARDINFO.DMAChannel],0    ; check for legal channel values
-	je      @@channelOK
-	cmp     [ESSI+CARDINFO.DMAChannel],1
-	je      @@channelOK
-	cmp     [ESSI+CARDINFO.DMAChannel],3
-	jne     @@exit
-@@channelOK:
-	mov     si,offset SoundBlasterPro       ; DS:SI = source
-	mov     ax,ds
-	mov     es,ax
-	mov     di,offset SoundCard     ; ESDI = destination
-	mov     cx,SIZE CARDINFO
-	cld
-	cli
-	segcs
-	rep     movsb                   ; Copy information
-	sti
-
-	LESSI   [sCard]
-	mov     bx,[ESSI+CARDINFO.ioPort]
-	mov     [SoundCard.ioPort],bx
-	mov     bl,[ESSI+CARDINFO.DMAIRQ]
-	mov     [SoundCard.DMAIRQ],bl
-	mov     bl,[ESSI+CARDINFO.DMAChannel]
-	mov     [SoundCard.DMAchannel],bl
-
-MASM
-COMMENT #
-/*
-	mov     dx,[SoundCard.ioPort]   ; initialize Sound Blaster
-	call    checkPort_SB
-
-	mov     [retrycount],10
-@@retry:
-	dec     [retrycount]
-	jnz     @@continue
-	mov     ax,0                    ; not found
-	jmp     @@done
-@@continue:
-	mov     al,0E1h                 ; Read version number
-	call    cmdSB
-
-	add     dl,2                    ; DX = 22Eh
-	sub     al,al
-	mov     cx,1000
-@@10:
-	in      al,dx                   ; Read version high
-	or      al,al
-	js      @@10ok
-	loop    @@10
-	jmp     @@retry
-@@10ok:
-	mov     cx,1000
-	sub     dl,4
-	in      al,dx
-	mov     ah,al
-
-	add     dl,4
-	sub     al,al
-@@20:
-	in      al,dx                   ; Read version low
-	or      al,al
-	js      @@20ok
-	loop    @@20
-	jmp     @@retry
-@@20ok:
-	sub     dl,4
-	in      al,dx
-@@done:
-	cmp     ax,0300h                ; Is version 3.00 or higher?
-	jl      @@exit                  ; No --> exit
-*/
-#
-IDEAL
-
-	mov     dx,[SoundCard.ioPort]   ; initialize Sound Blaster
-	add     dx,6
-	mov     al,1
-	out     dx,al
-	in      al,dx                   ; Wait for awhile
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	mov     al,0
-	out     dx,al
-	or      [mcpStatus],S_INIT      ; indicate successful initialization
-	mov     [retvalue],0            ; return 0 = OK
-@@exit:
-	mov     ax,[retvalue]
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   initDMA(void far *buffer,int maxsize, int required);
-; *
-; *     Description :   Init DMA for output
-; *
-; ************************************************************************/
-
-PROC    initDMA FAR buffer:DWORD,linear:DWORD,maxSize:DWORD,required:DWORD
-
-	mov     ecx,[maxSize]
-	mov     [bufferSize],cx
-	mov     ax,[WORD HIGH buffer]
-	mov     bx,[WORD LOW buffer]
-	mov     [dataBuf],bx            ; Check if DMA buffers are on
-	mov     eax,[linear]            ; a segment boundary
-	neg     ax
-	cmp     ax,cx                   ; Is buffer size >= data size
-	ja      @@bufOK
-	dec     ax
-	and     ax,NOT 3
-	mov     [bufferSize],ax
-	shr     cx,1
-	cmp     ax,cx                   ; Is it even half of it?
-	ja      @@bufOK
-	shl     cx,1
-	add     [dataBuf],ax
-	add     [dataBuf],7
-	and     [dataBuf],NOT 3
-	neg     ax
-	add     ax,cx                   ; AX = dataSize - AX
-	sub     ax,32
-	and     ax,NOT 3
-	mov     [bufferSize],ax
-@@bufOK:
-	cmp     [required],0
-	je      @@sizeok
-	cmp     ax,[word required]
-	jbe     @@sizeok
-	mov     ax,[word required]
-	mov     [bufferSize],ax
-@@sizeok:
-	and     [bufferSize],NOT 3
-	sub     ebx,ebx
-	mov     eax,[linear]            ; Calculate DMA page and offset values
-	mov     bx,[dataBuf]
-	sub     bx,[WORD LOW buffer]    ; Relative offset
-	add     eax,ebx
-	mov     ebx,eax
-	shr     ebx,16
-	cmp     [SoundCard.DMAChannel],4
-	jb      @@8bitDMA
-	push    bx
-	shr     bl,1
-	rcr     ax,1                    ; For word addressing
-	pop     bx
-@@8bitDMA:
-	mov     [DMApage],bl
-	mov     [DMAoffset],ax
-
-	mov     al,[SoundCard.DMAIRQ]
-	test    al,8                    ; Is IRQ > 7
-	jz      @@01
-	add     al,60h                  ; Yes, base is 70h
-@@01:
-	add     al,8                    ; AL = DMA interrupt number
-	push    ax
-	mov     ah,35h                  ; Get interrupt vector
-	int     21h
-	mov     [WORD LOW saveDMAvector],bx     ; Save it
-	mov     [WORD HIGH saveDMAvector],es
-	pop     ax                      ; Replace vector with the address
-	mov     ah,25h                  ; of own interrupt routine
-	PUSHDS
-	push    cs
-	POPDS
-	mov     dx,offset interruptDMA  ; Set interrupt vector
-	int     21h
-	POPDS
-
-	mov     cl,[SoundCard.DMAIRQ]
-	mov     ah,1
-	test    cl,8                    ; Is IRQ > 7
-	jnz     @@15
-	shl     ah,cl
-	not     ah
-	in      al,21h
-	and     al,ah
-	out     21h,al                  ; Allow DMA interrupt
-	jmp     @@20
-@@15:
-	and     cl,7
-	shl     ah,cl
-	not     ah
-	in      al,0A1h
-	and     al,ah
-	out     0A1h,al                 ; Allow DMA interrupt
-@@20:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   initRate
-; *
-; *     Description :   Inits sound card's sampling rate
-; *
-; ************************************************************************/
-
-PROC    initRate FAR sample_rate:DWORD
-
-	mov     ax,[SoundCard.minRate]
-	cmp     [word sample_rate],ax
-	jae     @@rateok
-	mov     [word sample_rate],ax
-	jmp     @@rateok
-	mov     ax,[SoundCard.maxRate]
-	cmp     [word sample_rate],ax
-	jbe     @@rateok
-	mov     [word sample_rate],ax
-@@rateok:
-	cmp     [SoundCard.ID],ID_SOUNDBLASTER
-	je      @@10
-	cmp     [SoundCard.ID],ID_SOUNDBLASTERPRO
-	jne     @@exit
-@@10:
-	mov     eax,0F4240h             ; Calculate sampling rate for SB
-	sub     edx,edx                 ; EDX:EAX = 1000000
-	mov     ecx,[sample_rate]
-	cmp     [SoundCard.ID],ID_SOUNDBLASTERPRO
-	jne     @@20
-	shl     ecx,1
-@@20:
-	div     ecx
-	push    ax
-	neg     al                      ; AL = 256 - 1000000/rate
-	mov     [SBrate],al
-	mov     ah,al
-	mov     al,40h                  ; Set SB's sampling rate
-	call    cmdSB
-	mov     al,ah
-	call    cmdSB
-	pop     ax
-
-	cmp     [SoundCard.ID],ID_SOUNDBLASTERPRO
-	jne     @@30
-	shl     ax,1
-@@30:
-
-	mov     bx,ax                   ; Calculate real sampling rate
-	sub     bh,bh
-	mov     ax,4240h
-	mov     dx,0Fh
-	div     bx                      ; Save sampling rate into AX
-@@exit:
-	mov     [samplingRate],ax       ; and save it for future use
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   speakerOn
-; *
-; *     Description :   Connects SB's Digital Signal Processor to speaker
-; *
-; ************************************************************************/
-
-PROC    speakerOn FAR
-
-	mov     al,0D1h
-	call    cmdSB
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   speakerOff
-; *
-; *     Description :   Disconnects speaker from DSP
-; *
-; ************************************************************************/
-
-PROC    speakerOff FAR
-
-	mov     al,0D3h
-	call    cmdSB
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   setStereo
-; *
-; *     Description :   Sets SB Pro into stereo mode
-; *
-; ************************************************************************/
-
-PROC    setStereo NEAR
-
-	mov     al,0Eh
-	mov     dx,[SoundCard.ioPort]
-	add     dx,4
-	out     dx,al
-	inc     dx
-	in      al,dx
-	or      al,00000010b            ; Set stereo
-
-	mov     ah,al
-	mov     al,0Eh
-	mov     dx,[SoundCard.ioPort]
-	add     dx,4
-	out     dx,al
-	inc     dx
-	mov     al,ah
-	out     dx,al
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   startVoice
-; *
-; *     Description :   Starts to output voice.
-; *
-; ************************************************************************/
-
-PROC    startVoice FAR USES di
-
-	mov     cl,[SoundCard.DMAIRQ]           ; Enable DMA interrupt
-	mov     ah,1
-	test    cl,8
-	jnz     @@10
-	shl     ah,cl
-	not     ah
-	in      al,21h
-	and     al,ah
-	out     21h,al
-	jmp     @@20
-@@10:
-	and     cl,7
-	shl     ah,cl
-	not     ah
-	in      al,0A1h
-	and     al,ah
-	out     0A1h,al
-@@20:
-	mov     ah,[DMApage]            ; Load correct DMA page and offset
-	mov     bx,[DMAoffset]          ; values
-	mov     cx,[bufferSize]
-	dec     cx
-
-	cli                             ; Set the DMA up and running
-	mov     al,[SoundCard.DMAChannel]
-	add     al,4
-	out     0Ah,al                  ; Break On
-	mov     al,[SoundCard.DMAChannel]
-	or      al,58h
-	out     0Bh,al
-	mov     dx,83h
-	cmp     [SoundCard.DMAChannel],1 ; Is DMA channel 1?
-	je      @@30
-	mov     dx,87h
-	cmp     [SoundCard.DMAChannel],0 ; Is DMA channel 0?
-	je      @@30
-	mov     dx,82h                  ; DMA channel is 3
-@@30:
-	mov     al,ah
-	out     dx,al                   ; Page
-
-	mov     al,0FFh
-	out     0Ch,al
-
-	sub     dx,dx
-	mov     dl,[SoundCard.DMAChannel]
-	shl     dx,1
-	mov     al,bl
-	out     dx,al                   ; Offset
-	mov     al,bh
-	out     dx,al
-	inc     dx
-	mov     al,cl
-	out     dx,al                   ; Count
-	mov     al,ch
-	out     dx,al
-	mov     al,[SoundCard.DMAChannel]
-	out     0Ah,al                  ; Break Off
-
-	mov     dx,[SoundCard.ioPort]
-	add     dl,6                    ; Init Sound Blaster
-	mov     al,1
-	out     dx,al
-	in      al,dx                   ; Wait for awhile
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	mov     al,0
-	out     dx,al
-
-	mov     al,40h                  ; Set SB's sampling rate
-	call    cmdSB
-	mov     al,[SBrate]
-	call    cmdSB
-
-        mov     al,0D1h
-	call    cmdSB
-
-	mov     cx,65500
-	cmp     [SoundCard.ID],ID_SOUNDBLASTERPRO
-	jne     @@normSB
-	mov     al,48h                  ; SB's command for stereo output
-	call    cmdSB
-	mov     al,cl                   ; Count
-	call    cmdSB
-	mov     al,ch
-	call    cmdSB
-@@normSB:
-	call    playDMA
-
-	call    setStereo
-
-	sti
-@@exit:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   stopVoice
-; *
-; *     Description :   Stops voice output.
-; *
-; ************************************************************************/
-
-PROC    stopVoice FAR
-
-	cli
-	mov     dx,[SoundCard.ioPort]
-	add     dl,6                    ; Init Sound Blaster
-	mov     al,1
-	out     dx,al
-	in      al,dx                   ; Wait for awhile
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	in      al,dx
-	mov     al,0
-	out     dx,al
-
-	mov     dx,[SoundCard.ioPort]
-	add     dx,0Eh
-	in      al,dx
-
-
-	mov     cl,[SoundCard.DMAIRQ]           ; Disable DMA interrupt
-	mov     ah,1
-	test    cl,8
-	jnz     @@10
-	shl     ah,cl
-	in      al,21h
-	or      al,ah
-	out     21h,al
-	jmp     @@20
-@@10:
-	and     cl,7
-	shl     ah,cl
-	in      al,0A1h
-	or      al,ah
-	out     0A1h,al
-@@20:
-	mov     al,0
-	out     0Ch,al
-	mov     al,[SoundCard.DMAChannel] ; Reset DMA
-	or      al,4
-	out     0Ah,al
-	sti
-
-@@exit:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   closeDMA
-; *
-; *     Description :   Returns DMA's IRQ vector
-; *
-; ************************************************************************/
-
-PROC closeDMA FAR
-	PUSHDS
-	mov     al,[SoundCard.DMAIRQ]
-	test    al,8                    ; Is IRQ > 7
-	jz      @@01
-	add     al,60h                  ; Yes, base is 70h
-@@01:
-	add     al,8
-	mov     dx,[WORD LOW saveDMAvector]
-	mov     ds,[WORD HIGH saveDMAvector]
-	mov     ah,25h
-	int     21h                     ; Restore DMA vector
-	POPDS
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   closeSB
-; *
-; *     Description :   Does nothing currently :)
-; *
-; ************************************************************************/
-
-PROC    closeSB FAR
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   pauseVoice
-; *
-; *     Description :   Pauses voice output
-; *
-; ************************************************************************/
-
-PROC    pauseVoice FAR
-       mov     al,0D0h
-       call    cmdSB
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   resumeVoice
-; *
-; *     Description :   Resumes voice output
-; *
-; ************************************************************************/
-
-PROC    resumeVoice FAR
-       mov     al,0D4h
-       call    cmdSB
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   nullFunc
-; *
-; *     Description :   Does nothing...
-; *
-; ************************************************************************/
-
-PROC    nullFunc FAR
-
-	ret
-ENDP
-
-
-END
diff --git a/dmp/sdi_sb16.asm b/dmp/sdi_sb16.asm
deleted file mode 100644
index e637d14..0000000
--- a/dmp/sdi_sb16.asm
+++ /dev/null
@@ -1,827 +0,0 @@
-;/************************************************************************
-; *
-; *	File        :	SDI_SB16.ASM
-; *
-; *	Description :	Sound Blaster 16 specific routines for MCP
-; *
-; *	Copyright (C) 1993 Otto Chrons
-; *
-; ***********************************************************************
-;
-;	Revision history of SDI_SB16.ASM
-;
-;	1.0	16.4.93
-;		First version. SB 16 routines. Works with 8- and 16-bit DMA
-;
-; ***********************************************************************/
-
-	IDEAL
-	JUMPS
-	P386N
-
-;	L_PASCAL	= 1		; Uncomment this for pascal-style
-
-IFDEF	L_PASCAL
-	LANG	EQU	PASCAL
-	MODEL TPASCAL
-ELSE
-	LANG	EQU	C
-	MODEL LARGE,C
-ENDIF
-
-        INCLUDE "MODEL.INC"
-        INCLUDE "MCP.INC"
-
-STRUC	DMAPORT
-
-	addr	DW ?
-	count	DW ?
-	page	DW ?
-	wcntrl	DW ?
-	wreq	DW ?
-	wrsmr	DW ?
-	wrmode	DW ?
-	clear	DW ?
-	wrclr	DW ?
-	clrmask	DW ?
-	wrall	DW ?
-ENDS
-
-DATASEG
-
-	EXTRN	mcpStatus:BYTE
-	EXTRN	bufferSize:WORD
-	EXTRN	dataBuf:WORD
-	EXTRN	SoundCard:CARDINFO
-
-	DMApage		DB ?
-	DMAoffset	DW ?
-	saveDMAvector	DD ?
-	samplingRate	DW ?
-	curDMA		DMAPORT <>
-
-CODESEG
-
-	PUBLIC	SDI_SB16
-
-	copyrightText	DB "SDI for SB16 v1.0 - (C) 1993 Otto Chrons",0,1Ah
-
-	SoundBlaster16	CARDINFO <6,0,"Sound Blaster 16 ASP",220h,5,5,4000,44100,1,1,2>
-
-	LABEL DMAports	DMAPORT
-
-	    DMAPORT <0,1,87h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-	    DMAPORT <2,3,83h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-	    DMAPORT <4,5,81h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-	    DMAPORT <6,7,82h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-	    DMAPORT <0,0,0,0,0,0,0,0,0,0,0>
-	    DMAPORT <0C4h,0C6h,8Bh,0D0h,0D2h,0D4h,0D6h,0D8h,0DAh,0DCH,0DEh>
-	    DMAPORT <0C8h,0CAh,89h,0D0h,0D2h,0D4h,0D6h,0D8h,0DAh,0DCH,0DEh>
-	    DMAPORT <0CCh,0CEh,8Ah,0D0h,0D2h,0D4h,0D6h,0D8h,0DAh,0DCH,0DEh>
-
-	SoundDeviceSB16	SOUNDDEVICE < \
-		far ptr initSB16,\
-		far ptr initDMA,\
-		far ptr initRate,\
-		far ptr closeSB,\
-		far ptr closeDMA,\
-		far ptr startVoice,\
-		far ptr stopVoice,\
-		far ptr pauseVoice,\
-		far ptr resumeVoice\
-		far ptr getDMApos,\
-		far ptr speakerOn,\
-		far ptr speakerOff\
-		>
-
-;/*************************************************************************
-; *
-; *	Function    :	void SDI_SB16(SOUNDDEVICE far *sdi);
-; *
-; *	Description :	Registers SB as a sound device
-; *
-; *	Input       :	Pointer to SD structure
-; *
-; *	Returns     :	Fills SD structure accordingly
-; *
-; ************************************************************************/
-
-PROC	SDI_SB16 FAR USES di si,sdi:DWORD
-
-	cld
-	LESDI	[sdi]
-	mov	si,offset SoundDeviceSB16
-	mov	cx,SIZE SOUNDDEVICE
-	cli
-	segcs
-	rep movsb			; Copy structure
-	sti
-	sub	ax,ax			; indicate successful init
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	cmdSB
-; *
-; *	Description :   Sends a command to Sound Blaster
-; *
-; *	Input       :	AL = Command to send
-; *
-; ************************************************************************/
-
-PROC	cmdSB NEAR
-
-	push	cx
-	mov	cx,65535
-	push	ax
-	mov	dx,[SoundCard.ioPort]
-	add	dl,0Ch
-@@1:
-	in	al,dx
-	or	al,al
-	jns	@@2
-	loop	@@1
-@@2:
-	pop	ax
-	out	dx,al
-	pop	cx
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	playDMA
-; *
-; *	Description :	Plays current buffer through DMA
-; *
-; ************************************************************************/
-
-PROC	playDMA NEAR USES cx
-
-	mov	cx,60000
-	mov	al,0B6h			; SB's command for 16 bit stereo output
-	call	cmdSB
-	mov	al,10h
-	cmp	[SoundCard.stereo],0
-	je	@@mono
-	or	al,20h
-@@mono:
-	call	cmdSB
-	mov	al,cl			; Count
-	call	cmdSB
-	mov	al,ch
-	call	cmdSB
-@@exit:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    : 	interruptDMA
-; *
-; *	Description :	DMA interrupt routine for continuos playing.
-; *
-; ************************************************************************/
-
-PROC	NOLANGUAGE interruptDMA FAR
-
-	cli
-	push	ax
-	push	dx
-	push	ds
-	mov	ax,@data
-	mov	ds,ax			; DS = data segment
-
-	mov	al,[mcpStatus]
-	and	al,111b
-	cmp	al,111b			; Inited and playing
-	jne	@@exit
-	mov	dx,[SoundCard.ioPort]
-	add	dx,4
-	mov	al,82h
-	out	dx,al
-	inc	dx
-	in	al,dx
-	test	al,1
-	jz	@@exit
-	test	al,2
-	jz	@@exit
-	mov	al,0D9h
-	call	cmdSB
-	mov	al,0D5h
-	call	cmdSB
-	call	playDMA
-@@exit:
-	mov	dx,[SoundCard.ioPort]	; Reset SB for next DMA
-	add	dl,0Fh
-	in	al,dx
-	mov	al,20h			; End Of Interrupt (EOI)
-	out	20h,al
-	cmp	[SoundCard.dmaIRQ],7
-	jle	@@10
-	out	0A0h,al
-@@10:
-	pop	ds
-	pop	dx
-	pop	ax
-	iret				; Interrupt return
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    : 	checkPort_SB
-; *
-; *	Description :   Checks if given address is SB's I/O address
-; *
-; *	Input       : 	DX = port to check
-; *
-; *	Returns     :	AX = 0	succesful
-; *		      	AX = 1	unsuccesful
-; *
-; ************************************************************************/
-
-PROC	NOLANGUAGE checkPort_SB NEAR
-
-	push	dx
-	add	dl,6			; Init Sound Blaster
-	mov	al,1
-	out	dx,al
-	in	al,dx			; Wait for awhile
-	in	al,dx
-	in	al,dx
-	in	al,dx
-	in	al,dx
-	mov	al,0
-	out	dx,al
-	sub	dl,6
-
-	add	dl,0Eh          	; DSP data available status
-	mov	cx,1000
-@@loop:
-	in	al,dx			; port 22Eh
-	or	al,al
-	js	@@10
-	loop	@@loop
-
-	mov	ax,1
-	jmp	@@exit
-@@10:
-	sub	dl,4
-	in	al,dx			; port 22Ah
-	cmp	al,0AAh			; Is ID 0AAh?
-	mov	ax,0
-	je	@@exit
-	mov	ax,1
-@@exit:
-	pop	dx
-	or	ax,ax			; Set zero-flag accordingly
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	int getDMApos():
-; *
-; *	Description :	Returns the position of DMA transfer
-; *
-; ************************************************************************/
-
-PROC	getDMApos FAR
-
-	cli
-@@05:
-	mov	al,0FFh
-	mov	dx,[curDMA.clear]
-	out	dx,al
-	mov	dx,[curDMA.count]
-	in	al,dx
-	mov	ah,al
-	in	al,dx
-	xchg	ah,al
-	mov	bx,ax
-	in	al,dx
-	mov	ah,al
-	in	al,dx
-	xchg	ah,al
-	sub	bx,ax
-	cmp	bx,64
-	jg	@@05
-	cmp	bx,-64
-	jl	@@05
-	neg	ax
-	cmp	[SoundCard.DMAChannel],4
-	jb	@@dma8
-	shl	ax,1			; 16-bit to 8-bit
-@@dma8:
-	add	ax,[bufferSize]		; AX = DMA position
-	sti
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	int initSB16(CARDINFO *sCard);
-; *
-; *	Description : 	Initializes Sound Blaster 16 using values for
-; *		      	ioPort,dmaIRQ & dmaChannel in sCard
-; *
-; *	Input       : 	sCard   = pointer to CARDINFO-structure
-; *
-; *	Returns     : 	 0	= success
-; *			-1	= error
-; *
-; ************************************************************************/
-
-PROC	initSB16 FAR USES di si,sCard:DWORD
-	local	retryCount:WORD,retvalue:WORD
-
-	LESSI	[sCard]
-	mov	[retvalue],-1		; assume error
-	mov	dx,[ESSI+CARDINFO.ioPort]
-	cmp	dx,220h			; check for valid addresses
-	je	@@OK
-	cmp	dx,240h			; check for valid addresses
-	je	@@OK
-	cmp	dx,260h			; check for valid addresses
-	je	@@OK
-	cmp	dx,280h
-	jne	@@exit
-@@OK:
-	cmp	[ESSI+CARDINFO.DMAIRQ],2	; check for legal interrupt values
-	je	@@DMA_OK
-	cmp	[ESSI+CARDINFO.DMAIRQ],5
-	je	@@DMA_OK
-	cmp	[ESSI+CARDINFO.DMAIRQ],7
-	je	@@DMA_OK
-	cmp	[ESSI+CARDINFO.DMAIRQ],10
-	jne	@@exit
-@@DMA_OK:
-	cmp	[ESSI+CARDINFO.DMAChannel],0	; check for legal channel values
-	je	@@channelOK
-	cmp	[ESSI+CARDINFO.DMAChannel],1
-	je	@@channelOK
-	cmp	[ESSI+CARDINFO.DMAChannel],3
-	je	@@channelOK
-	cmp	[ESSI+CARDINFO.DMAChannel],5
-	je	@@channelOK
-	cmp	[ESSI+CARDINFO.DMAChannel],6
-	je	@@channelOK
-	cmp	[ESSI+CARDINFO.DMAChannel],7
-	jne	@@exit
-@@channelOK:
-	mov	si,offset SoundBlaster16	; DS:SI = source
-	mov	ax,ds
-	mov	es,ax
-	mov	di,offset SoundCard	; ESDI = destination
-	mov	cx,SIZE CARDINFO
-	cld
-	cli
-	segcs
-	rep	movsb			; Copy information
-	sti
-
-	LESSI	[sCard]
-	mov	bl,[ESSI+CARDINFO.DMAchannel]
-	sub	bh,bh
-	imul	bx,SIZE DMAPORT
-	lea	si,[bx+DMAports]	; SI = DMAports[DMAchannel]
-	mov	ax,ds
-	mov	es,ax
-	mov	di,offset curDMA	; ESDI = curDMA
-	mov	cx,SIZE DMAPORT
-	cli
-	segcs
-	rep	movsb			; Copy structure
-	sti
-
-	LESSI	[sCard]
-	mov	bx,[ESSI+CARDINFO.ioPort]
-	mov	[SoundCard.ioPort],bx
-	mov	bl,[ESSI+CARDINFO.DMAIRQ]
-	mov	[SoundCard.DMAIRQ],bl
-	mov	bl,[ESSI+CARDINFO.DMAChannel]
-	mov	[SoundCard.DMAchannel],bl
-	mov	bl,[ESSI+CARDINFO.stereo]
-	mov	[SoundCard.stereo],bl
-
-	mov	dx,[SoundCard.ioPort]	; initialize Sound Blaster
-	call	checkPort_SB
-
-	mov	[retrycount],10
-@@retry:
-	dec	[retrycount]
-	jnz	@@continue
-	mov	ax,0			; not found
-	jmp	@@done
-@@continue:
-	mov	al,0E1h			; Read version number
-	call	cmdSB
-
-	add	dl,2			; DX = 22Eh
-	sub	al,al
-	mov	cx,1000
-@@10:
-	in	al,dx			; Read version high
-	or	al,al
-	js	@@10ok
-	loop	@@10
-	jmp	@@retry
-@@10ok:
-	mov	cx,1000
-	sub	dl,4
-	in	al,dx
-	mov	ah,al
-
-	add	dl,4
-	sub	al,al
-@@20:
-	in	al,dx			; Read version low
-	or	al,al
-	js	@@20ok
-	loop	@@20
-	jmp	@@retry
-@@20ok:
-	sub	dl,4
-	in	al,dx
-@@done:
-	cmp	ax,0400h		; Is version 4.00 or higher?
-	jl	@@exit			; No --> exit
-
-	mov	dx,[SoundCard.ioPort]	; initialize Sound Blaster
-	add	dx,6
-	mov	al,1
-	out	dx,al
-	in	al,dx			; Wait for awhile
-	in	al,dx
-	in	al,dx
-	in	al,dx
-	in	al,dx
-	mov	al,0
-	out	dx,al
-
-
-	or	[mcpStatus],S_INIT	; indicate successful initialization
-	mov	[retvalue],0		; return 0 = OK
-@@exit:
-	mov	ax,[retvalue]
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	initDMA(void far *buffer,int maxsize, int required);
-; *
-; *	Description :   Init DMA for output
-; *
-; ************************************************************************/
-
-PROC    initDMA FAR buffer:DWORD,linear:DWORD,maxSize:DWORD,required:DWORD
-
-        mov     cx,[word maxSize]
-	mov	[bufferSize],cx
-	mov	ax,[WORD HIGH buffer]
-	mov	bx,[WORD LOW buffer]
-	add	bx,3
-	and	bx,NOT 3
-	mov	[dataBuf],bx		; Check if DMA buffers are on
-	mov	eax,[linear]		; a segment boundary
-	add	eax,3
-	and	eax,NOT 3
-	neg	ax
-	cmp	ax,cx			; Is buffer size >= data size
-	ja	@@bufOK
-	dec	ax
-	and	ax,NOT 3
-	mov	[bufferSize],ax
-	shr	cx,1
-	cmp	ax,cx			; Is it even half of it?
-	ja	@@bufOK
-	shl	cx,1
-	add	[dataBuf],ax
-	add	[dataBuf],7
-	and	[dataBuf],NOT 3
-	neg	ax
-	add	ax,cx			; AX = dataSize - AX
-	sub	ax,32
-	and	ax,NOT 3
-	mov	[bufferSize],ax
-@@bufOK:
-	cmp	[required],0
-	je	@@sizeok
-        cmp     ax,[word required]
-	jbe	@@sizeok
-        mov     ax,[word required]
-	mov	[bufferSize],ax
-@@sizeok:
-	and	[bufferSize],NOT 3
-	sub	ebx,ebx
-	mov	eax,[linear]		; Calculate DMA page and offset values
-	mov	bx,[dataBuf]
-	sub	bx,[WORD LOW buffer]	; Relative offset
-	add	eax,ebx
-	mov	ebx,eax
-	shr	ebx,16
-	cmp	[SoundCard.DMAChannel],4
-	jb	@@8bitDMA
-	push	bx
-	shr	bl,1
-	rcr	ax,1			; For word addressing
-	pop	bx
-@@8bitDMA:
-	mov	[DMApage],bl
-	mov	[DMAoffset],ax
-
-	; Init DMA
-
-	mov	al,[SoundCard.DMAIRQ]
-	test	al,8			; Is IRQ > 7
-	jz	@@01
-	add	al,60h			; Yes, base is 70h
-@@01:
-	add	al,8			; AL = DMA interrupt number
-	push	ax
-	mov	ah,35h			; Get interrupt vector
-	int	21h
-	mov	[WORD LOW saveDMAvector],bx	; Save it
-	mov	[WORD HIGH saveDMAvector],es
-	pop	ax			; Replace vector with the address
-	mov	ah,25h			; of own interrupt routine
-	PUSHDS
-	push	cs
-	pop	ds
-	mov	dx,offset interruptDMA	; Set interrupt vector
-	int	21h
-	pop	ds
-
-	mov	cl,[SoundCard.DMAIRQ]
-	mov	ah,1
-	test	cl,8			; Is IRQ > 7
-	jnz	@@15
-	shl	ah,cl
-	not	ah
-	in	al,21h
-	and	al,ah
-	out	21h,al			; Allow DMA interrupt
-	jmp	@@20
-@@15:
-	and	cl,7
-	shl	ah,cl
-	not	ah
-	in	al,0A1h
-	and	al,ah
-	out	0A1h,al			; Allow DMA interrupt
-@@20:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	initRate
-; *
-; *	Description :   Inits sound card's sampling rate
-; *
-; ************************************************************************/
-
-PROC    initRate FAR sample_rate:DWORD
-
-	mov	ax,[SoundCard.minRate]
-        cmp     [word sample_rate],ax
-	jae	@@rateok
-        mov     [word sample_rate],ax
-	jmp	@@rateok
-	mov	ax,[SoundCard.maxRate]
-        cmp     [word sample_rate],ax
-	jbe	@@rateok
-        mov     [word sample_rate],ax
-@@rateok:
-	mov	eax,0F4240h		; Calculate sampling rate for SB
-	sub	edx,edx			; EDX:EAX = 256000000
-        movzx   ecx,[word sample_rate]
-	div	ecx
-	sub	ecx,ecx
-	mov	cx,ax			; Calculate real sampling rate
-	mov	eax,0F4240h
-	sub	edx,edx
-	div	ecx			; Save sampling rate into AX
-	push	ax
-	mov	cx,ax
-	mov	al,42h			; Set SB's sampling rate
-	call	cmdSB
-	mov	al,ch
-	call	cmdSB
-	mov	al,cl
-	call	cmdSB
-	pop	ax
-@@exit:
-	mov	[samplingRate],ax	; and save it for future use
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	speakerOn
-; *
-; *	Description :	Connects SB's Digital Signal Processor to speaker
-; *
-; ************************************************************************/
-
-PROC	speakerOn FAR
-
-	mov	al,0D1h
-	call	cmdSB
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	speakerOff
-; *
-; *	Description :	Disconnects speaker from DSP
-; *
-; ************************************************************************/
-
-PROC	speakerOff FAR
-
-	mov	al,0D3h
-	call	cmdSB
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	startVoice
-; *
-; *	Description :	Starts to output voice.
-; *
-; ************************************************************************/
-
-PROC	startVoice FAR
-
-	mov	cl,[SoundCard.DMAIRQ]		; Enable DMA interrupt
-	mov	ah,1
-	test	cl,8
-	jnz	@@10
-	shl	ah,cl
-	not	ah
-	in	al,21h
-	and	al,ah
-	out	21h,al
-	jmp	@@20
-@@10:
-	and	cl,7
-	shl	ah,cl
-	not	ah
-	in	al,0A1h
-	and	al,ah
-	out	0A1h,al
-@@20:
-	mov	ah,[DMApage]		; Load correct DMA page and offset
-	mov	bx,[DMAoffset]		; values
-	mov	cx,[bufferSize]
-	cmp	[SoundCard.DMAchannel],4
-	jb	@@bufByte
-	shr	cx,1			; Word count for 16-bit DMA
-@@bufByte:
-	dec	cx
-	cli				; Set the DMA up and running
-	mov	al,[SoundCard.DMAChannel]
-	or	al,4
-	mov	dx,[curDMA.wrsmr]
-	out	dx,al			; Break On
-	mov	al,[SoundCard.DMAChannel]
-	and	al,3
-	or	al,58h
-	mov	dx,[curDMA.wrmode]
-	out	dx,al
-	mov	dx,[curDMA.page]
-	mov	al,ah
-	out	dx,al			; Page
-	mov	al,0FFh
-	mov	dx,[curDMA.clear]
-	out	dx,al			; Reset counter
-	mov	dx,[curDMA.addr]
-	mov	al,bl
-	out	dx,al			; Offset
-	mov	al,bh
-	out	dx,al
-	mov	dx,[curDMA.count]
-	mov	al,cl
-	out	dx,al			; Count
-	mov	al,ch
-	out	dx,al
-
-	mov	al,[SoundCard.DMAChannel]
-	and	al,3
-	mov	dx,[curDMA.wrsmr]
-	out	dx,al			; Break Off
-	sti
-
-	call	playDMA
-@@exit:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	stopVoice
-; *
-; *	Description :	Stops voice output.
-; *
-; ************************************************************************/
-
-PROC	stopVoice FAR
-
-	cli
-	mov	dx,[SoundCard.ioPort]
-	add	dl,6			; Init Sound Blaster
-	mov	al,1
-	out	dx,al
-	in	al,dx			; Wait for awhile
-	in	al,dx
-	in	al,dx
-	in	al,dx
-	in	al,dx
-	in	al,dx
-	in	al,dx
-	in	al,dx
-	mov	al,0
-	out	dx,al
-
-	mov	dx,[SoundCard.ioPort]
-	add	dx,0Eh
-	in	al,dx
-
-	mov	cl,[SoundCard.DMAIRQ]		; Disable DMA interrupt
-	mov	ah,1
-	test	cl,8
-	jnz	@@10
-	shl	ah,cl
-	in	al,21h
-	or	al,ah
-	out	21h,al
-	jmp	@@20
-@@10:
-	and	cl,7
-	shl	ah,cl
-	in	al,0A1h
-	or	al,ah
-	out	0A1h,al
-@@20:
-	mov	al,[SoundCard.DMAChannel] ; Reset DMA
-	or	al,4
-	mov	dx,[curDMA.wrsmr]
-	out	dx,al
-	mov	al,0
-	mov	dx,[curDMA.clear]
-	out	dx,al
-
-	sti
-
-@@exit:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	closeDMA
-; *
-; *	Description :   Returns DMA's IRQ vector
-; *
-; ************************************************************************/
-
-PROC closeDMA FAR
-	PUSHDS
-	mov	al,[SoundCard.DMAIRQ]
-	test	al,8			; Is IRQ > 7
-	jz	@@01
-	add	al,60h			; Yes, base is 70h
-@@01:
-	add	al,8
-	mov	dx,[WORD LOW saveDMAvector]
-	mov	ds,[WORD HIGH saveDMAvector]
-	mov	ah,25h
-	int	21h			; Restore DMA vector
-	POPDS
-	ret
-ENDP
-
-PROC closeSB FAR
-	ret
-ENDP
-
-PROC pauseVoice FAR
-;	mov	al,0D0h
-;	call	cmdSB
-	ret
-ENDP
-
-PROC resumeVoice FAR
-;	mov	al,0D4h
-;	call	cmdSB
-	ret
-ENDP
-
-END
diff --git a/dmp/sdi_wss.asm b/dmp/sdi_wss.asm
deleted file mode 100644
index 8d65d6b..0000000
--- a/dmp/sdi_wss.asm
+++ /dev/null
@@ -1,726 +0,0 @@
-;/************************************************************************
-; *
-; *	File	    : SDI_WSS.ASM
-; *
-; *	Description : SDI for Windows Sound System
-; *
-; *	Copyright (C) 1993 Otto Chrons
-; *
-; ***********************************************************************
-;
-;	Revision history of SDI_WSS.ASM
-;
-;	1.0	20.6.93
-;		First version.
-;
-; ***********************************************************************/
-
-	IDEAL
-	JUMPS
-	P386N
-
-;	L_PASCAL	= 1		; Uncomment this for pascal-style
-
-IFDEF	L_PASCAL
-	LANG	EQU	PASCAL
-	MODEL TPASCAL
-ELSE
-	LANG	EQU	C
-	MODEL LARGE,C
-ENDIF
-
-        INCLUDE "MODEL.INC"
-        INCLUDE "MCP.INC"
-
-STRUC	DMAPORT
-
-	addr	DW ?
-	count	DW ?
-	page	DW ?
-	wcntrl	DW ?
-	wreq	DW ?
-	wrsmr	DW ?
-	wrmode	DW ?
-	clear	DW ?
-	wrclr	DW ?
-	clrmask	DW ?
-	wrall	DW ?
-ENDS
-
-DATASEG
-
-	EXTRN	mcpStatus:BYTE
-	EXTRN	bufferSize:WORD
-	EXTRN	dataBuf:WORD
-	EXTRN	SoundCard:CARDINFO
-
-	DMApage		DB ?
-	DMAoffset	DW ?
-	ioPort		DW ?
-	saveDMAvector	DD ?
-	samplingRate	DW ?
-	curDMA		DMAPORT <>
-
-CODESEG
-
-	PUBLIC	SDI_WSS
-
-	copyrightText	DB "SDI for Windows Sound System v1.0 - (C) 1993 Otto Chrons",0,1Ah
-
-	WSSnorm		CARDINFO <9,0,"Windows Sound System",530h,0,0,4000,48000,1,1,2>
-
-	LABEL DMAports	DMAPORT
-
-	    DMAPORT <0,1,87h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-	    DMAPORT <2,3,83h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-	    DMAPORT <4,5,81h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-	    DMAPORT <6,7,82h,8,9,0Ah,0Bh,0Ch,0Dh,0Eh,0Fh>
-	    DMAPORT <0,0,0,0,0,0,0,0,0,0,0>
-	    DMAPORT <0C4h,0C6h,8Bh,0D0h,0D2h,0D4h,0D6h,0D8h,0DAh,0DCH,0DEh>
-	    DMAPORT <0C8h,0CAh,89h,0D0h,0D2h,0D4h,0D6h,0D8h,0DAh,0DCH,0DEh>
-	    DMAPORT <0CCh,0CEh,8Ah,0D0h,0D2h,0D4h,0D6h,0D8h,0DAh,0DCH,0DEh>
-
-	WSS_IRQ	DB 0,0,0,0,0,0,0,8h,0,10h,18h,20h,0,0,0,0
-	WSS_DMA DB 1,2,0,3,0,0,0,0
-
-	LABEL WSS_rates	WORD
-
-	    DW 8000,0
-	    DW 5513,1
-	    DW 16000,2
-	    DW 11025,3
-	    DW 27429,4
-	    DW 18900,5
-	    DW 32000,6
-	    DW 22050,7
-	    DW 0,8
-	    DW 37800,9
-	    DW 0,0Ah
-	    DW 44100,0Bh
-	    DW 48000,0Ch
-	    DW 33075,0Dh
-	    DW 9600,0Eh
-	    DW 6615,0Fh
-
-	SoundDeviceWSS	SOUNDDEVICE < \
-		far ptr initWSS,\
-		far ptr initDMA,\
-		far ptr initRate,\
-		far ptr closeWSS,\
-		far ptr closeDMA,\
-		far ptr startVoice,\
-		far ptr stopVoice,\
-		far ptr pauseVoice,\
-		far ptr resumeVoice\
-		far ptr getDMApos,\
-		far ptr speakerOn,\
-		far ptr speakerOff\
-		>
-
-;/*************************************************************************
-; *
-; *	Function    :	void SDI_WSS(SOUNDDEVICE far *sdi);
-; *
-; *	Description :	Registers Windows Sound System as a sound device
-; *
-; *	Input       :	Pointer to SD structure
-; *
-; *	Returns     :	Fills SD structure accordingly
-; *
-; ************************************************************************/
-
-PROC	SDI_WSS FAR USES di si,sdi:DWORD
-
-	cld
-	LESDI	[sdi]
-	mov	si,offset SoundDeviceWSS
-	mov	cx,SIZE SOUNDDEVICE
-	cli
-	segcs
-	rep movsb			; Copy structure
-	sti
-	sub	ax,ax			; indicate successful init
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    : 	interruptDMA
-; *
-; *	Description :	DMA interrupt routine for continuos playing.
-; *
-;/************************************************************************/
-
-PROC	NOLANGUAGE interruptDMA NEAR
-
-	sti
-	push	ax
-	push	dx
-	push	ds
-	mov	ax,@data
-	mov	ds,ax			; DS = data segment
-
-	mov	al,[mcpStatus]
-	and	al,111b
-	cmp	al,111b			; Inited and playing
-	jne	@@exit
-	mov	dx,[ioPort]
-	add	dx,6
-	mov	al,0
-	out	dx,al			; Acknowledge interrupt
-@@exit:
-	mov	al,20h			; End Of Interrupt (EOI)
-	out	20h,al
-	cmp	[SoundCard.dmaIRQ],7
-	jle	@@10
-	out	0A0h,al
-@@10:
-	pop	ds
-	pop	dx
-	pop	ax
-	iret				; Interrupt return
-ENDP
-
-
-;/*************************************************************************
-; *
-; *	Function    : int initWSS(CARDINFO *scard);
-; *
-; *	Description : Initializes a WSS card.
-; *
-; *	Input       : Pointer to CARDINFO structure
-; *
-; *	Returns     : 0 no error
-; *		      other = error
-; *
-; *************************************************************************/
-
-PROC	initWSS FAR USES si di, scard:FAR PTR CARDINFO
-	LOCAL	retvalue:WORD
-
-	mov	[retvalue],-1
-	LESSI	[scard]
-	mov	al,[ESSI+CARDINFO.ID]
-	mov	si,offset WSSnorm	; SI = source
-	cmp	al,ID_WSS		; Check for valid ID
-	jne	@@exit
-@@idOK:
-	mov	ax,ds
-	mov	es,ax
-	mov	di,offset SoundCard	; ES:DI = destination
-	mov	cx,SIZE CARDINFO
-	cld
-	cli
-	segcs
-	rep	movsb			; Copy information
-	sti
-
-	LESSI	[scard]
-	mov	ax,[ESSI+CARDINFO.ioPort]
-	mov	[SoundCard.ioPort],ax
-	mov	[ioPort],ax
-	mov	al,[ESSI+CARDINFO.DMAIRQ]
-	cmp	al,16 			; Is it > 15?
-	jae	@@exit
-	mov	[SoundCard.DMAIRQ],al
-	mov	al,[ESSI+CARDINFO.DMAchannel]
-	cmp	al,4			; Channel 4 is invalid
-	je	@@exit
-	cmp	al,8
-	jae	@@exit			; So are > 7
-	mov	[SoundCard.DMAchannel],al
-
-	mov	bh,[ESSI+CARDINFO.stereo]
-	cmp	bh,1
-	ja	@@exit
-
-	mov	bl,[ESSI+CARDINFO.sampleSize]
-
-	mov	[SoundCard.sampleSize],bl	; Save values
-	mov	[SoundCard.stereo],bh
-
-	mov	bl,[ESSI+CARDINFO.DMAchannel]
-	sub	bh,bh
-	imul	bx,bx,SIZE DMAPORT
-	lea	si,[bx+DMAports]	; SI = DMAports[DMAchannel]
-	mov	ax,ds
-	mov	es,ax
-	mov	di,offset curDMA	; ES:DI = curDMA
-	mov	cx,SIZE DMAPORT
-	cli
-	segcs
-	rep	movsb			; Copy structure
-	sti
-
-	mov	dx,[ioPort]
-	mov	bl,[SoundCard.DMAIRQ]
-	sub	bh,bh
-	mov	al,[WSS_IRQ+bx]
-	mov	bl,[SoundCard.DMAchannel]
-	or	al,[WSS_DMA+bx]
-	out	dx,al			; Setup IRQ and DMA
-
-	mov	al,[SoundCard.DMAIRQ]
-	test	al,8			; Is IRQ > 7
-	jz	@@01
-	add	al,60h			; Yes, base is 70h
-@@01:
-	add	al,8			; AL = DMA interrupt number
-	push	ax
-	mov	ah,35h			; Get interrupt vector
-	int	21h
-	mov	[WORD LOW saveDMAvector],bx	; Save it
-	mov	[WORD HIGH saveDMAvector],es
-	pop	ax			; Replace vector with the address
-	mov	ah,25h			; of own interrupt routine
-	PUSHDS
-	push	cs
-	pop	ds
-	mov	dx,offset interruptDMA	; Set interrupt vector
-	int	21h
-	pop	ds
-
-	or	[mcpStatus],S_INIT	; indicate successful initialization
-	mov	[retvalue],0
-@@exit:
-	mov	ax,[retvalue]
-	ret
-ENDP
-
-;/***********************************************************************
-; *
-; *	Function    :	int getDMApos():
-; *
-; *	Description :	Returns the position of DMA transfer
-; *
-; **********************************************************************/
-
-PROC	getDMApos FAR
-
-	cli
-@@05:
-	mov	al,0FFh
-	mov	dx,[curDMA.clear]
-	out	dx,al
-	mov	dx,[curDMA.count]
-	in	al,dx
-	mov	ah,al
-	in	al,dx
-	xchg	ah,al
-	mov	bx,ax
-	in	al,dx
-	mov	ah,al
-	in	al,dx
-	xchg	ah,al
-	sub	bx,ax
-	cmp	bx,64
-	jg	@@05
-	cmp	bx,-64
-	jl	@@05
-	neg	ax
-	cmp	[SoundCard.DMAChannel],4
-	jb	@@dma8
-	shl	ax,1			; 16-bit to 8-bit
-@@dma8:
-	add	ax,[bufferSize]		; AX = DMA position
-	sti
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	initDMA(void far *buffer,int maxsize, int required);
-; *
-; *	Description :   Init DMA for output
-; *
-; ************************************************************************/
-
-PROC    initDMA FAR buffer:DWORD,linear:DWORD,maxSize:DWORD,required:DWORD
-
-        mov     cx,[word maxSize]
-	mov	[bufferSize],cx
-	mov	ax,[WORD HIGH buffer]
-	mov	bx,[WORD LOW buffer]
-	add	bx,3
-	and	bx,NOT 3
-	mov	[dataBuf],bx		; Check if DMA buffers are on
-	mov	eax,[linear]		; a segment boundary
-	add	eax,3
-	and	eax,NOT 3
-	neg	ax
-	cmp	ax,cx			; Is buffer size >= data size
-	ja	@@bufOK
-	dec	ax
-	and	ax,NOT 3
-	mov	[bufferSize],ax
-	shr	cx,1
-	cmp	ax,cx			; Is it even half of it?
-	ja	@@bufOK
-	shl	cx,1
-	add	[dataBuf],ax
-	add	[dataBuf],7
-	and	[dataBuf],NOT 3
-	neg	ax
-	add	ax,cx			; AX = dataSize - AX
-	sub	ax,32
-	and	ax,NOT 3
-	mov	[bufferSize],ax
-@@bufOK:
-	cmp	[required],0
-	je	@@sizeok
-        cmp     ax,[word required]
-	jbe	@@sizeok
-        mov     ax,[word required]
-	mov	[bufferSize],ax
-@@sizeok:
-	and	[bufferSize],NOT 3
-	sub	ebx,ebx
-	mov	eax,[linear]		; Calculate DMA page and offset values
-	mov	bx,[dataBuf]
-	sub	bx,[WORD LOW buffer]	; Relative offset
-	add	eax,ebx
-	mov	ebx,eax
-	shr	ebx,16
-	cmp	[SoundCard.DMAChannel],4
-	jb	@@8bitDMA
-	push	bx
-	shr	bl,1
-	rcr	ax,1			; For word addressing
-	pop	bx
-@@8bitDMA:
-	mov	[DMApage],bl
-	mov	[DMAoffset],ax
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	setSamplingRate
-; *
-; *	Description :	Sets closest sampling rate possible on WSS
-; *
-; *	Input       :	AX = rate wanted
-; *
-; *	Returns     :	AX = closest possible rate
-; *
-; ************************************************************************/
-
-PROC	setSamplingRate NEAR USES si di
-	LOCAL delta:WORD,realrate:WORD
-
-	mov	cx,16			; 16 possible rates (actually 14)
-	mov	[delta],32000		; Delta is very big in the beginning
-	mov	si,0			; SI = closest match
-	mov	di,ax			; DI = original rate
-	sub	bx,bx			; BX = index
-@@loop:
-	mov	ax,di
-	sub	ax,[bx+WSS_rates]
-	cwd				; AX = abs(AX)
-	xor	ax,dx
-	sub	ax,dx
-	cmp	ax,[delta]
-	ja	@@next
-	mov	[delta],ax		; New delta
-	mov	si,[bx+WSS_rates+2]	; This position
-	mov	ax,[bx+WSS_rates]
-	mov	[realrate],ax
-@@next:
-	add	bx,4
-	loop	@@loop
-
-	mov	dx,[ioPort]
-	add	dx,4
-	mov	al,48h
-	out	dx,al			; Mute on
-	inc	dx
-	mov	ax,si
-	cmp	[SoundCard.stereo],1
-	jne	@@mono
-	or	al,010h			; Set stereo
-@@mono:
-	cmp	[SoundCard.sampleSize],1
-	je	@@8bit
-	or	al,040h			; Set 16-bit
-@@8bit:
-	out	dx,al			; Set CODEC format
-	dec	dx
-	mov	al,08h
-	out	dx,al			; Mute off
-	mov	ax,[realrate]
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	initRate
-; *
-; *	Description :   Inits sound card's sampling rate
-; *
-; ************************************************************************/
-
-PROC    initRate FAR USES di,sample_rate:DWORD
-
-	sub	eax,eax
-	mov	ax,[SoundCard.minRate]
-        cmp     [word sample_rate],ax
-	jae	@@rateok
-        mov     [word sample_rate],ax
-	jmp	@@rateok
-	mov	ax,[SoundCard.maxRate]
-        cmp     [word sample_rate],ax
-	jbe	@@rateok
-        mov     [word sample_rate],ax
-@@rateok:
-        mov     ax,[word sample_rate]
-	call	setSamplingRate
-	mov	[samplingRate],ax
-@@exit:
-	mov	ax,[samplingRate]
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	speakerOn
-; *
-; *	Description :	Connects WSS speaker
-; *
-; ************************************************************************/
-
-PROC	speakerOn FAR
-
-	mov	dx,[ioPort]
-	add	dx,4
-	mov	al,07h
-	out	dx,al			; Mute off
-	inc	dx
-	in	al,dx
-	and	al,7Fh
-	out	dx,al
-
-	mov	dx,[ioPort]
-	add	dx,4
-	mov	al,06h
-	out	dx,al			; Mute off
-	inc	dx
-	in	al,dx
-	and	al,7Fh
-	out	dx,al
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	speakerOff
-; *
-; *	Description :	Disconnects speaker from WSS
-; *
-; ************************************************************************/
-
-PROC	speakerOff FAR
-
-	mov	dx,[ioPort]
-	add	dx,4
-	mov	al,07h
-	out	dx,al			; Mute on
-	inc	dx
-	in	al,dx
-	or	al,80h
-	out	dx,al
-
-	mov	dx,[ioPort]
-	add	dx,4
-	mov	al,06h
-	out	dx,al			; Mute on
-	inc	dx
-	in	al,dx
-	or	al,80h
-	out	dx,al
-
-
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	startVoice
-; *
-; *	Description :	Starts to output voice.
-; *
-; ************************************************************************/
-
-PROC	startVoice FAR USES di
-
-	mov	cl,[SoundCard.DMAIRQ]		; Enable DMA interrupt
-	mov	ah,1
-	test	cl,8
-	jnz	@@10
-	shl	ah,cl
-	not	ah
-	in	al,21h
-	and	al,ah
-	out	21h,al
-	jmp	@@20
-@@10:
-	and	cl,7
-	shl	ah,cl
-	not	ah
-	in	al,0A1h
-	and	al,ah
-	out	0A1h,al
-@@20:
-	cli
-	mov	ah,[DMApage]		; Load correct DMA page and offset
-	mov	bx,[DMAoffset]		; values
-	mov	cx,[bufferSize]
-	cmp	[SoundCard.DMAchannel],4
-	jb	@@bufByte
-	shr	cx,1			; Word count for 16-bit DMA
-@@bufByte:
-	dec	cx
-	cli				; Set the DMA up and running
-	mov	al,[SoundCard.DMAChannel]
-	or	al,4
-	mov	dx,[curDMA.wrsmr]
-	out	dx,al			; Break On
-	mov	al,[SoundCard.DMAChannel]
-	and	al,3
-	or	al,058h
-	mov	dx,[curDMA.wrmode]
-	out	dx,al
-	mov	dx,[curDMA.page]
-	mov	al,ah
-	out	dx,al			; Page
-	mov	al,0FFh
-	mov	dx,[curDMA.clear]
-	out	dx,al			; Reset counter
-
-	mov	dx,[curDMA.addr]
-	mov	al,bl
-	out	dx,al			; Offset
-	mov	al,bh
-	out	dx,al
-
-	mov	dx,[curDMA.count]
-	mov	al,cl
-	out	dx,al			; Count
-	mov	al,ch
-	out	dx,al
-	mov	al,[SoundCard.DMAChannel]
-	and	al,3
-	mov	dx,[curDMA.wrsmr]
-	out	dx,al			; Break Off
-	sti
-
-	mov	cx,60000		; Sample count
-	mov	dx,[ioPort]
-	add	dx,4
-	mov	al,0Fh			; Low byte
-	out	dx,al
-	inc	dx
-	mov	al,cl
-	out	dx,al
-	dec	dx
-	mov	al,0Eh			; High byte
-	out	dx,al
-	inc	dx
-	mov	al,ch
-	out	dx,al
-
-	mov	dx,[ioPort]
-	add	dx,4
-	mov	al,09h			; Interface configuration
-	out	dx,al
-	inc	dx
-	mov	al,05h			; Use DMA playback
-	out	dx,al
-	dec	dx
-	mov	al,0Ah			; PIN control register
-	out	dx,al
-	inc	dx
-	mov	al,02h			; Turn on interrupts
-	out	dx,al
-@@exit:
-	ret
-ENDP
-
-
-;/*************************************************************************
-; *
-; *	Function    :	stopVoice
-; *
-; *	Description :	Stops voice output.
-; *
-; ************************************************************************/
-
-PROC	stopVoice FAR USES di
-
-	cli
-	mov	dx,[ioPort]
-	mov	al,0Ah			; PIN control register
-	out	dx,al
-	inc	dx
-	mov	al,0			; Turn off interrupts
-	out	dx,al
-	inc	dx
-	out	dx,al			; Ack outstanding interrupts
-	sub	dx,2
-	mov	al,9			; Use Interface Configuration Reg.
-	out	dx,al
-	inc	dx
-	mov	al,0
-	out	dx,al			; Turn off CODEC's DMA
-
-	mov	al,[SoundCard.DMAChannel] ; Reset DMA
-	or	al,4
-	mov	dx,[curDMA.wrsmr]
-	out	dx,al
-	mov	al,0FFh
-	mov	dx,[curDMA.clear]
-	out	dx,al
-@@exit:
-	ret
-ENDP
-
-;/*************************************************************************
-; *
-; *	Function    :	closeDMA
-; *
-; *	Description :   Returns DMA's IRQ vector
-; *
-; ************************************************************************/
-
-PROC closeDMA FAR
-	PUSHDS
-	mov	al,[SoundCard.DMAIRQ]
-	test	al,8			; Is IRQ > 7
-	jz	@@01
-	add	al,60h			; Yes, base is 70h
-@@01:
-	add	al,8
-	mov	dx,[WORD LOW saveDMAvector]
-	mov	ds,[WORD HIGH saveDMAvector]
-	mov	ah,25h
-	int	21h			; Restore DMA vector
-	POPDS
-	ret
-ENDP
-
-PROC closeWSS FAR
-	ret
-ENDP
-
-PROC pauseVoice FAR
-	ret
-ENDP
-
-PROC resumeVoice FAR
-	ret
-ENDP
-
-
-END
diff --git a/dmp/state.inc b/dmp/state.inc
deleted file mode 100644
index eca8fc4..0000000
--- a/dmp/state.inc
+++ /dev/null
@@ -1,63 +0,0 @@
-;$Author:   DCODY  $
-;$Date:   25 Jun 1992 23:28:14  $
-;$Header:   W:/sccs/inc/state.inv   1.1   25 Jun 1992 23:28:14   DCODY  $
-;$Log:   W:/sccs/inc/state.inv  $
-;
-;   Rev 1.1   25 Jun 1992 23:28:14   DCODY
-;PAS2 updated state table
-;
-;   Rev 1.0   15 Jun 1992 09:58:48   BCRANE
-;Initial revision.
-;$Logfile:   W:/sccs/inc/state.inv  $
-;$Modtimes$
-;$Revision:   1.1  $
-;$Workfile:   state.inc  $ 
-
-
-;   /*\
-;---|*|----====< Pro Audio Spectrum Hardware State Table >====----
-;---|*|
-;---|*| Media Vision, Inc. (c) Copyright 1991. All Rights Reserved
-;---|*|
-;   \*/
-
-MVState struc
-  _sysspkrtmr    db     0       ;    42 System Speaker Timer Address
-  _systmrctlr    db     0       ;    43 System Timer Control
-  _sysspkrreg    db     0       ;    61 System Speaker Register
-  _joystick      db     0       ;   201 Joystick Register
-  _lfmaddr       db     0       ;   388 Left  FM Synth Address
-  _lfmdata       db     0       ;   389 Left  FM Synth Data
-  _rfmaddr       db     0       ;   38A Right FM Synth Address
-  _rfmdata       db     0       ;   38B Right FM Synth Data
-  _dfmaddr       db     0       ;   788 Dual  FM Synthesizer Address Register
-  _dfmdata       db     0       ;   789 Dual  FM Synthesizer Data Register
-                 db     0       ;       reserved for future use
-  _paudiomixr    db     0       ;   78B Paralllel Audio Mixer Control
-  _audiomixr     db     0       ;   B88 Audio Mixer Control
-  _intrctlrst    db     0       ;   B89 Interrupt Status
-  _audiofilt     db     0       ;   B8A Audio Filter Control
-  _intrctlr      db     0       ;   B8B Interrupt Control
-  _pcmdata       db     0       ;   F88 PCM Data I/O Register
-  _RESRVD2       db     0       ;       reserved
-  _crosschannel  db     0       ;   F8A Cross Channel
-  _RESRVD3       db     0       ;       reserved
-  _samplerate    dw     0       ;  1388 Sample Rate Timer
-  _samplecnt     dw     0       ;  1389 Sample Count Register
-  _spkrtmr       dw     0       ;  138A Shadow Speaker Timer Count
-  _tmrctlr       db     0       ;  138B Shadow Speaker Timer Control
-  _mdirqvect     db     0       ;  1788 MIDI IRQ Vector Register
-  _mdsysctlr     db     0       ;  1789 MIDI System Control Register
-  _mdsysstat     db     0       ;  178A MIDI IRQ Status Register
-  _mdirqclr      db     0       ;  178B MIDI IRQ Clear Register
-  _mdgroup1      db     0       ;  1B88 MIDI Group #1 Register
-  _mdgroup2      db     0       ;  1B89 MIDI Group #2 Register
-  _mdgroup3      db     0       ;  1B8A MIDI Group #3 Register
-  _mdgroup4      db     0       ;  1B8B MIDI Group #4 Register
-MVState ends
-
-
-;   /*\
-;---|*| end of STATE.H
-;   \*/
-
diff --git a/dmp/stmload.pas b/dmp/stmload.pas
deleted file mode 100644
index bbd9c7d..0000000
--- a/dmp/stmload.pas
+++ /dev/null
@@ -1,399 +0,0 @@
-(***************************************************************************
-
-                                 STMLOAD.PAS
-                                 -----------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-loadSTM and ampLoadSTM functions
-Original C version by Otto Chrons
-
-***************************************************************************)
-
-Unit STMLoad; {$I-,X+}
-
-{$O+}
-
-Interface
-Uses MCP,AMP,Loaders,CSupport;
-
-Function LoadSTM(Var File_:File;Var Module:PModule):Integer;
-Function ampLoadSTM(name:String;options:longint):PModule;
-
-Implementation
-{$IFDEF USE_EMS}
-uses emhm;
-{$ENDIF}
-
-Var curTrack            : Integer;
-    patUsed             : Array[0..254] of byte;
-
-Type TSTMinst           = Record
-                            Name        : Array[0..12] of char;
-                            Disk        : Byte;
-                            Position    : Word;
-                            Length      : Word;
-                            Loopstart   : Word;
-                            Loopend     : Word;
-                            Volume      : Byte;
-                            __a         : Byte;
-                            Rate        : Word;
-                            __b         : Longint;
-                            __c         : Word;
-                          End;
-
-Function loadinstruments(Var f:File;Var Module:PModule):Integer;
-Var t,a          : Integer;
-    STMi         : TSTMinst;
-    instr        : Pinstrument;
-
-Begin
-  With Module^ do begin
-    instrumentCount:=31;
-    instruments:=calloc(31,sizeof(Tinstrument));
-    If instruments=Nil then begin loadinstruments:=-1; exit end;
-    Size:=Size+31*sizeof(Tinstrument);
-    Seek(f,48);
-    a:=0;
-    t:=0;
-    while (a<>-1) and (t<31) do begin
-      Blockread(f,STMi,sizeof(TSTMinst),a);
-      if a<>sizeOf(TSTMinst) then a:=-1;
-      instr:=@instruments^[t];
-      instr^.insType:=0;
-      strcpy(instr^.name,STMi.name);
-      strcpy(instr^.filename,STMi.name);
-      instr^.sample:=nil;
-      word(instr^.sample):=STMi.position;
-      instr^.rate:=STMi.rate;
-      instr^.volume:=STMi.volume;
-      instr^.size:=STMi.length;
-      instr^.loopstart:=STMi.loopstart;
-      instr^.loopend:=STMi.loopend;
-      if instr^.loopend=65535 then instr^.loopend:=0;
-      if (instr^.loopend<>0) and (instr^.loopend<instr^.size) then instr^.size:=instr^.loopend;
-      if (instr^.loopend>instr^.size) and (instr^.loopend<>0) then
-         instr^.loopend:=instr^.size;
-      if instr^.loopstart>instr^.loopend then instr^.loopend:=0;
-      if instr^.loopend=0 then instr^.loopstart:=0;
-      inc(t);
-    end;
-  end;
-  if a=-1 then loadinstruments:=-2 else loadinstruments:=0;
-end;
-
-Function loadPatterns(Var f:file; module:PModule):Integer;
-Var orders       : Array[0..127] of byte;
-    ptr          : pointer;
-    t,count      : integer;
-    pat          : PPattern;
-Begin
-  Fillchar(patUsed,255,0);
-  Seek(f,48+31*32);
-  Blockread(f,orders,128);
-  loadPatterns:=-2;
-  if IOresult<>0 then exit;
-  count:=0;
-  while (count<128) and (orders[count]<>99) do inc(count);
-  module^.patternCount:=count;
-  module^.patterns:=calloc(count,sizeof(TPattern));
-  loadPatterns:=-1;
-  if module^.patterns=nil then exit;
-  inc(module^.size,count*sizeof(TPattern));
-  for t:=0 to count-1 do begin
-    patUsed[orders[t]]:=1;
-    pat:=@module^.patterns^[t];
-    pat^.length:=64;
-    pat^.tracks[0]:=pointer(orders[t]*4+1);
-    pat^.tracks[1]:=pointer(orders[t]*4+2);
-    pat^.tracks[2]:=pointer(orders[t]*4+3);
-    pat^.tracks[3]:=pointer(orders[t]*4+4);
-  end;
-  loadPatterns:=0;
-end;
-
-Function STM2AMF(buffer:pointer;trk:Integer; module:PModule):PTrack;
-Type b = Array[0..65519] of byte;
-Var tracks            : PTrack;
-    i,t,pos,tick,a   : Integer;
-    note,ins,volume,
-    command,data,
-    curins,curvolume : Byte;
-    Temptrack        : Array[0..575] of byte;
-
-Procedure insertNote(a,b:integer);
-Begin
-  temptrack[pos*3]:=tick;
-  temptrack[pos*3+1]:=a;
-  temptrack[pos*3+2]:=b;
-  inc(pos);
-end;
-
-Procedure insertCmd(a,b:integer);
-Begin
-  temptrack[pos*3]:=tick;
-  temptrack[pos*3+1]:=a;
-  temptrack[pos*3+2]:=b;
-  inc(pos);
-end;
-
-Begin
-  pos:=0;
-  tick:=0;
-  curins:=$F0;
-  curvolume:=64;
-  inc(longint(buffer),trk*4);
-  Fillchar(temptrack,575,$FF);
-  for t:=0 to 63 do begin
-    tick:=t;
-    note:=b(buffer^)[t*16];
-    command:=(b(buffer^)[t*16+2] and $f)+64;
-    if command=ord('G') then begin
-      insertCmd(cmdBenderTo,b(buffer^)[t*16+3]);
-      command:=0;
-    end;
-    if command=ord('K') then insertCmd(cmdBenderTo,0);
-    volume:=(b(buffer^)[t*16+1] and 7)+(b(buffer^)[t*16+2] and $F0) div 2;
-    if volume>65 then volume:=65;
-    if note<>$FF then begin
-      ins:=(b(buffer^)[t*16+1] shr 3)-1;
-      if (ins<>curins) and (ins<>$FF) then begin
-        insertCmd(cmdInstr,ins);
-        module^.instruments^[ins].insType:=1;
-        curins:=ins;
-      end;
-      if (ins<>$FF) and (volume=65) then volume:=module^.instruments^[ins].volume;
-      if (volume=65) then volume:=255;
-      note:=36+(note and $F)+(note shr 4)*12;
-      insertNote(note,volume);
-    end else if volume<65 then
-      InsertCmd(cmdVolumeAbs,volume);
-    if command<>64 then begin
-      data:=b(buffer^)[t*16+3];
-      case chr(command) of
-        'A' : insertCmd(cmdTempo,data shr 4);
-        'B' : insertCmd(cmdGoto,data);
-        'C' : insertCmd(cmdBreak,0);
-        'D' : begin
-                if (data>=16) then data:=data shr 4 else data:=-data;
-                insertCmd(cmdVolume,data);
-              end;
-        'E' : begin
-                if (data>127) then data:=127;
-                insertCmd(cmdBender,data);
-              end;
-        'F' : begin
-                if (data>127) then data:=127;
-                insertCmd(cmdBender,-data);
-              end;
-        'H' : insertCmd(cmdVibrato,data);
-        'I' : insertCmd(cmdTremolo,data);
-        'J' : insertCmd(cmdArpeggio,data);
-        'K' : begin
-                if data>=16 then data:=data shr 4 else data:=-data;
-                insertCmd(cmdToneVol,data);
-              end;
-        'L' : begin
-                if data>=16 then data:=data shr 4 else data:=-data;
-                insertCmd(cmdVibrVol,data);
-              end;
-        'O' : insertCmd(cmdSync,data);
-      end;
-    end;
-  end;
-  if pos=0 then tracks:=nil else begin
-    inc(pos);
-    if (loadOptions and LM_IML)>0 then
-      for i:=1 to curTrack-1 do
-        if module^.tracks^[i]<>nil then
-        if (module^.tracks^[i]^.size=pos) and
-           (memcmp(@temptrack,pointer(longint(module^.tracks^[i])+3),pos*3)=0) then begin
-             STM2AMF:=module^.tracks^[i];
-             exit;
-           end;
-    tracks:=PTrack(malloc(pos*3+3));
-    if tracks<>nil then begin
-      inc(module^.size,pos*3+3);
-      tracks^.size:=pos;
-      tracks^.trkType:=0;
-      move(temptrack,pointer(longint(tracks)+3)^,pos*3);
-    end;
-  end;
-  STM2AMF:=tracks;
-end;
-
-Function loadTracks(Var f:file;var module:PModule):Integer;
-Var Count    : Byte;
-    t,a      : Integer;
-    Buffer   : Array[0..1023] of byte;
-
-Begin
-  seek(f,33);
-  Blockread(f,count,1);
-  module^.trackCount:=count*4;
-  module^.tracks:=calloc(count*4+4,sizeof(PTrack));
-  if module^.tracks=nil then begin loadTracks:=-1; exit end;
-  inc(module^.size,(count*4+4)*sizeof(PTrack));
-  seek(f,48+32*31+128);
-  module^.tracks^[0]:=nil;
-  curTrack:=1;
-  for t:=0 to count-1 do begin
-    if ((loadOptions and LM_IML)>0) and (patUsed[t]=0) then begin
-      module^.tracks^[curTrack]:=nil; inc(curTrack);
-      module^.tracks^[curTrack]:=nil; inc(curTrack);
-      module^.tracks^[curTrack]:=nil; inc(curTrack);
-      module^.tracks^[curTrack]:=nil; inc(curTrack);
-      seek(f,filepos(f)+1024);
-    end else begin
-      Blockread(f,buffer,1024);
-      if IOresult=0 then begin
-        module^.tracks^[curTrack]:=STM2AMF(@buffer,0,module); inc(curTrack);
-        module^.tracks^[curTrack]:=STM2AMF(@buffer,1,module); inc(curTrack);
-        module^.tracks^[curTrack]:=STM2AMF(@buffer,3,module); inc(curTrack);
-        module^.tracks^[curTrack]:=STM2AMF(@buffer,2,module); inc(curTrack);
-      end else begin
-        loadTracks:=-2;
-        exit;
-      end;
-    end;
-  end;
-  loadTracks:=0;
-end;
-
-Function loadSamples(var f:file; var module:PModule):integer;
-Var t,i,a,b       : Word;
-    instr         : Pinstrument;
-{$IFDEF USE_EMS}
-    handle        : TEMSH;
-{$ENDIF}
-Begin
-  for t:=0 to module^.instrumentCount-1 do begin
-    instr:=@module^.instruments^[t];
-    if ((loadOptions and LM_IML)>0) and (instr^.insType=0) then instr^.size:=0;
-    if instr^.size>0 then begin
-      seek(f,longint(word(instr^.sample))*16);
-      a:=instr^.loopend-instr^.loopstart;
-      if (instr^.loopend<>0) and (a<crit_size) then begin
-        b:=(Crit_Size div a)*a;
-        instr^.loopend:=instr^.loopstart+b;
-        loadSamples:=-1;
-        instr^.sample:=malloc(instr^.loopend+16);
-        if instr^.sample=nil then exit;
-        inc(module^.size,instr^.loopend);
-        loadSamples:=-2;
-        blockread(f,instr^.sample^,instr^.size);
-        if IOresult<>0 then exit;
-        instr^.size:=instr^.loopend;
-        for i:=1 to (Crit_Size div a)-1 do
-          move(pointer(longint(instr^.sample)+instr^.loopstart)^,
-               pointer(longint(instr^.sample)+instr^.loopstart+a*i)^,a);
-      end else begin
-        instr^.sample:=malloc(instr^.size+16);
-        loadSamples:=-1;
-        if instr^.sample=nil then exit;
-        inc(module^.size,instr^.size);
-        loadSamples:=-2;
-        blockread(f,instr^.sample^,instr^.size);
-        if IOresult<>0 then exit;
-      end;
-      mcpConvertSample(instr^.sample,instr^.size);
-{$IFDEF USE_EMS}
-        handle:=0;
-        if instr^.size>2048 then begin
-          handle:=emsAlloc(instr^.size);
-          if handle>0 then begin
-            emsCopyTo(handle,instr^.sample,0,instr^.size);
-            free(instr^.sample);
-            instr^.sample:=ptr($ffff,handle);
-          end;
-        end;
-{$ENDIF}
-    end else begin
-      instr^.size:=0;
-      instr^.sample:=nil;
-    end;
-  end;
-  loadSamples:=0;
-end;
-
-Procedure joinTracks2Patterns(var module:PModule);
-Var t,i     : Word;
-    pat     : PPattern;
-Begin
-  for t:=0 to module^.patternCount-1 do begin
-    pat:=@module^.patterns^[t];
-    for i:=0 to 3 do
-      if word(pat^.tracks[i])<=module^.trackCount then
-        pat^.tracks[i]:=module^.tracks^[word(pat^.tracks[i])] else
-        pat^.tracks[i]:=nil;
-  end;
-end;
-
-Function loadSTM;
-var a:integer;
-Begin
-  module^.tempo:=125;
-  module^.speed:=6;
-  a:=loadinstruments(file_,module);
-  loadSTM:=a;
-  if a<>0 then exit;
-  a:=loadPatterns(file_,module);
-  loadSTM:=a;
-  if a<>0 then exit;
-  a:=loadTracks(file_,module);
-  loadSTM:=a;
-  if a<>0 then exit;
-  a:=loadSamples(file_,module);
-  loadSTM:=a;
-  if a<>0 then exit;
-  joinTracks2Patterns(module);
-  loadSTM:=0;
-end;
-
-Function ampLoadSTM(name:String;options:longint):PModule;
-var f         : file;
-    l         : longint;
-    module    : PModule;
-    t,b       : integer;
-
-begin
-  ampLoadSTM:=nil;
-  loadOptions:=options;
-  module:=malloc(sizeof(TModule));
-  if module=nil then begin
-    moduleError:=MERR_Memory;
-    exit;
-  end;
-  fillchar(module^,sizeof(TModule),0);
-  assign(f,name);
-  reset(f,1);
-  if IOresult<>0 then begin
-    moduleError:=MERR_File;
-    exit;
-  end;
-  seek(f,28);
-  blockread(f,t,2);
-  if t=$21A then begin
-    module^.modType:=MOD_STM;
-    seek(f,0);
-    blockread(f,module^.name,20);
-    module^.name[20]:=#0;
-    module^.channelCount:=4;
-{    move(order4,module^.channelOrder,4);}
-  end else begin
-    module^.modType:=MOD_NONE;
-    moduleError:=MERR_Type;
-    exit;
-  end;
-  b:=loadSTM(f,module);
-  moduleError:=b;
-  if b=MERR_None then module^.filesize:=filesize(f) else begin
-    ampFreeModule(module);
-    free(module);
-    module:=nil;
-  end;
-  close(f);
-  ampLoadSTM:=module;
-end;
-
-end.
diff --git a/dmp/stmload.tpp b/dmp/stmload.tpp
deleted file mode 100644
index d107741..0000000
Binary files a/dmp/stmload.tpp and /dev/null differ
diff --git a/dmp/target.inc b/dmp/target.inc
deleted file mode 100644
index 69e22e1..0000000
--- a/dmp/target.inc
+++ /dev/null
@@ -1,171 +0,0 @@
-
-;   /*\
-;---|*|----====< TARGET.INC >====----
-;---|*|
-;---|*| This file defines which product is being compiled. This is used
-;---|*| for the PAS software libraries, etc.
-;---|*|
-;---|*| Copyright (c) 1992, Media Vision, Inc.  All Rights Reserved.
-;---|*|
-;---|*| To use this code, you must define one of the following variable names.
-;---|*|
-;---|*|    BUILD_NONE - General assembly of header. No target product defined
-;---|*|    BUILD_PAS1 - Original Pro Audio Spectrum.
-;---|*|    BUILD_PAS2 - Pro Audio Spectrum Plus.
-;---|*|    BUILD_PAS3 - Pro Audio Spectrum 16.
-;---|*|    BUILD_CDPC - CDPC.
-;---|*|
-;   \*/
-
-;;
-;; Each product will some/all of of these features
-;;
-
-bMVA508         =       0000000000000001b       ; MVA508(1) or National(0)
-bMVPS2          =       0000000000000010b       ; PS2 bus stuff
-bMVSLAVE        =       0000000000000100b       ; CDPC Slave device is present
-bMVSCSI         =       0000000000001000b       ; SCSI interface
-bMVENHSCSI      =       0000000000010000b       ; Enhanced SCSI interface
-bMVSONY         =       0000000000100000b       ; Sony 535 interface
-bMVDAC16        =       0000000001000000b       ; 16 bit DAC
-bMVSBEMUL       =       0000000010000000b       ; SB h/w emulation
-bMVMPUEMUL      =       0000000100000000b       ; MPU h/w emulation
-bMVOPL3         =       0000001000000000b       ; OPL3(1) or 3812(0)
-bMV101          =       0000010000000000b       ; MV101 ASIC
-bMV101_REV      =       0111100000000000b       ; MV101 Revision
-bMV101_MORE     =       1000000000000000b       ; more bits in BX
-
-;;
-;; Define the ASIC versions
-;;
-
-ASIC_VERSION_B  =       0000000000000010b       ; revision B
-ASIC_VERSION_C  =       0000000000000011b       ; revision C
-ASIC_VERSION_D  =       0000000000000100b       ; revision D
-ASIC_VERSION_E  =       0000000000000101b       ; revision E
-ASIC_VERSION_F  =       0000000000000110b       ; revision F
-
-;;
-;; First Pro Audio Spectrum feature list
-;;
-PRODUCT_PROAUDIO        =       bMVSCSI
-
-;;
-;; Pro Audio Plus feature list
-;;
-PRODUCT_PROPLUS         =       bMV101+      \
-                                bMVSCSI+     \
-                                bMVENHSCSI+  \
-                                bMVSBEMUL+   \
-                                bMVOPL3
-;;
-;; Pro Audio Spectrum 16 feature list
-;;
-PRODUCT_PRO16           =       bMV101+      \
-                                bMVA508+     \
-                                bMVSCSI+     \
-                                bMVENHSCSI+  \
-                                bMVSBEMUL+   \
-                                bMVDAC16+    \
-                                bMVOPL3
-;;
-;; CDPC feature list
-;;
-PRODUCT_CDPC            =       bMV101+      \
-                                bMVSLAVE+    \
-                                bMVSONY+     \
-                                bMVSBEMUL+   \
-                                bMVDAC16+    \
-                                bMVOPL3
-
-
-;;
-;; Set each one to zero - to be init later if selected
-;;
-
-PROAS100        =       0
-PROAS200        =       0
-PROAS300        =       0
-CDPC            =       0
-
-PRODUCTDEFINED  =       0               ;; to be set if a product is selected
-
-;;
-;;----====<  1st retail version of the Pro Audio Spectrum. >====----
-;;
-
-ifdef BUILD_PAS1
-PROAS100        =       1               ;; 1st board - Pro Audio Spectrum
-PRODUCTDEFINED  =       PRODUCT_PROAUDIO
-endif
-
-;;
-;;----====< 8 bit Integrated PAS with rev 2 of the MV101 >====----
-;;
-
-ifdef BUILD_PAS2
-PROAS200        =       1               ;; 2nd board - Pro Audio Spectrum
-PRODUCTDEFINED  =       PRODUCT_PROPLUS
-endif
-
-;;
-;;----====< 16 bit Integrated PAS with rev 2 of the MV101 >====----
-;;
-
-ifdef BUILD_PAS3
-PROAS300        =       1               ;; 3rd board - Pro Audio Spectrum
-PRODUCTDEFINED  =       PRODUCT_PRO16
-endif
-
-;;
-;;----====< 1st CDPC box >====----
-;;
-
-ifdef BUILD_CDPC
-CDPC            =       1               ;; CDPC stand alone box
-PRODUCTDEFINED  =       PRODUCT_CDPC
-endif
-
-;;
-;;----====< Generate an error if no product is defined >====----
-;;
-
-ife PRODUCTDEFINED
-endif
-
-;;
-;;------------------====< Hardware Dependencies >====-------------------
-;;
-
-if PROAS100                             ;; Media Vision Pro Audio Spectrum Orig
-HWREVISION      equ     00000000B       ;; the H/W revision #
-endif
-if PROAS200                             ;; Media Vision Pro Audio Spectrum Plus
-HWREVISION      equ     00000001B       ;; the H/W revision #
-endif
-if PROAS300                             ;; Media Vision Pro Audio Spectrum 16
-HWREVISION      equ     00000001B       ;; the H/W revision #
-endif
-if CDPC                                 ;; Media Vision CDPC
-HWREVISION      equ     00000111B       ;; the H/W revision #
-endif
-
-
-if (PRODUCTDEFINED AND bMVSBEMUL)
-  if (PRODUCTDEFINED AND bMVA508)
-    L_SB        equ     L_FREE
-    R_SB        equ     R_FREE
-  else
-    L_SB        equ     L_SPEAKER
-    R_SB        equ     R_SPEAKER
-  endif
-endif
-
-
-if (PRODUCTDEFINED AND bMVA508)
-VOLUMEMAX       equ     MVVOLUMEMAX
-else
-VOLUMEMAX       equ     NSVOLUMEMAX
-endif
-
-
diff --git a/dmp/temp/MODLOAD.TPP b/dmp/temp/MODLOAD.TPP
deleted file mode 100644
index 05acf6b..0000000
Binary files a/dmp/temp/MODLOAD.TPP and /dev/null differ
diff --git a/dmp/timeserv.asm b/dmp/timeserv.asm
deleted file mode 100644
index 02fffb8..0000000
--- a/dmp/timeserv.asm
+++ /dev/null
@@ -1,484 +0,0 @@
-;/************************************************************************
-; *
-; *     File        :   TIMESERV.ASM
-; *
-; *     Description :   Timer Service routines
-; *
-; *     Copyright (C) 1992 Otto Chrons
-; *
-; ***********************************************************************
-;
-;       Revision history of TIMESERV.ASM
-;
-;       1.0     16.4.93
-;               First version. Timer services work well.
-;
-;       1.1     7.5.93
-;               Previous timer is now never busy. Corrects the problem
-;               with some disk caches etc.
-;
-;       1.2     25.11.93
-;               New macros to make compilation under Watcom/32 possible
-;
-; ***********************************************************************/
-
-        IDEAL
-        JUMPS
-        P386N
-
-        INCLUDE "MODEL.INC"
-        INCLUDE "TIMESERV.INC"
-
-MACRO   checkInit
-
-		RETVAL  -1
-		cmp     [TSinited],1
-		jne     @@exit
-ENDM
-
-CSEGMENTS TIMESERV
-
-CDATASEG
-		TSroutines      TSROUTINE 16 dup(<>)
-		lastTS          DW      ?
-		TScount         DB      ?
-IFDEF __PASCAL__
-        EXTRN           TSinited:BYTE
-ELSE
-        TSinited        DB      0
-ENDIF
-        TStimerValue    DW      ?
-
-ENDS
-
-CCODESEG TIMESERV
-
-        copyrightText DB "Timer Service v1.2 - (C) 1993 Otto Chrons",0,1Ah
-
-        CPUBLIC tsInit, tsClose
-        CPUBLIC tsAddRoutine, tsRemoveRoutine, tsChangeRoutine
-        CPUBLIC tsSetTimerRate, tsGetTimerRate
-
-;/*************************************************************************
-; *
-; *     Function    :   setTimerRate
-; *
-; *     Description :   Set low-level timer rate
-; *
-; *     Input       :   AX = new timer rate
-; *
-; ************************************************************************/
-
-PROC    setTimerRate NEAR
-
-        pushf
-        cli
-        mov     bx,ax
-        mov     al,00110110b            ; Set timer rate
-        out     43h,al
-        mov     ax,bx
-        out     40h,al
-        mov     al,ah
-        out     40h,al
-        popf
-
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   timerCatch
-; *
-; *     Description :   TS's timer interrupt function which takes care of
-; *                     calling the service functions.
-; *
-; ************************************************************************/
-
-PROC    timerCatch
-
-        push    _ax _bx _cx ds es
-
-        mov     al,20h                  ; EOI
-        out     20h,al
-        sti
-
-        mov     ax,DGROUP
-        mov     ds,ax
-        mov     es,ax
-
-        cmp     [TScount],0
-        je      @@done
-IF32    <sub    ecx,ecx>
-        mov     cx,[lastTS]
-        inc     _cx
-        sub     _bx,_bx                   ; Offset to TSroutines
-@@loop:
-        cmp     [_bx+TSroutines.status],TS_ACTIVE
-        jne     @@over                  ; Is routine active
-        or      _bx,_bx                   ; First service is special
-        je      @@neverbusy
-        cmp     [_bx+TSroutines.busy],1
-        je      @@over
-@@neverbusy:
-        mov     ax,[_bx+TSroutines.timerAdd]
-        add     [_bx+TSroutines.timerPassed],ax
-        jnc     @@over
-@@callRoutine:
-        mov     [_bx+TSroutines.busy],1
-        pushf                           ; Make a fake interrupt call to
-        call    [_bx+TSroutines.routine] ; the service routine
-        mov     [_bx+TSroutines.busy],0
-@@over:
-        add     _bx,SIZE TSROUTINE
-        loop    @@loop
-@@done:
-        pop     es ds _cx _bx _ax
-        iret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int tsInit();
-; *
-; *     Description :   Initializes TimerService and catches timer interrupt.
-; *
-; *     Returns     :   0 if succesful
-; *                     -1 on error
-; *
-; ************************************************************************/
-
-CPROC   tsInit
-
-        push    _di
-
-        mov     _ax,-1
-        cmp     [TSinited],0
-        jne     @@exit
-
-        mov     [TScount],1
-		mov     [lastTS],0
-		PUSHDS
-		POPES
-		mov     _di,offset TSroutines    ; ES:DI = TSroutines
-		sub     ax,ax                   ; AX = 0
-		cld
-		mov     _cx,(SIZE TSROUTINE)*16
-		rep     stosb                   ; Reset TSroutines-structure
-
-		mov     ax,65535                ; AX = timer rate
-		mov     [TStimerValue],ax
-		mov     [TSroutines.timerValue],ax
-		mov     [TSroutines.timerAdd],ax        ; call every time
-		call    setTimerRate
-
-		push    es
-		mov     ax,3508h                ; Get timer interrupt routine
-		int     21h                     ; ESBX = address of routine
-IFDEF __C32__
-		mov     [WORD PTR 4+TSroutines.routine],es
-		mov     [DWORD TSroutines.routine],ebx
-ELSE
-		mov     [WORD HIGH TSroutines.routine],es
-		mov     [WORD LOW TSroutines.routine],bx
-ENDIF
-		mov     [TSroutines.status],TS_ACTIVE
-		pop     es
-
-		push    ds
-		push    cs
-		pop     ds
-		mov     _dx,offset timerCatch    ; DS:DX = timerCatch
-		mov     ax,2508h                ; Set our own timer handler
-		int     21h
-		pop     ds
-
-		mov     [TSinited],1
-		sub     ax,ax                   ; AX = 0, no error
-@@exit:
-		pop     _di
-		ret
-ENDP
-
-
-;/*************************************************************************
-; *
-; *     Function    :   void tsClose();
-; *
-; *     Description :   Closes TimerService and returns timer interrupt.
-; *
-; ************************************************************************/
-
-CPROC   tsClose
-
-		cmp     [TSinited],1
-		jne     @@exit
-
-		cli
-		mov     ax,[TSroutines.timerValue]
-		call    setTimerRate            ; Reset timer rate
-
-		push	ds
-		mov     dx,[WORD LOW TSroutines.routine]
-		mov     ds,[WORD HIGH TSroutines.routine]
-		mov     ax,2508h
-		int     21h                     ; Reset timer interrupt handler
-		pop		ds
-		sti
-
-        mov     [TSinited],0
-@@exit:
-        ret
-ENDP
-
-
-;/*************************************************************************
-; *
-; *     Function    :   int tsChangeRoutine(int tag,unsigned time);
-; *
-; *     Description :   Changes service routines time and resolution values.
-; *
-; *     Input       :   tag     =       indicates routine
-; *                     time    =       new timer rate
-; *                     (resolution =   new resolution for timer)
-; *
-; *     Returns     :   0       =       no error
-; *                     -1      =       TimerService not initialized
-; *                     -2      =       invalid tag
-; *                     -3      =       invalid parameter
-; *
-; ************************************************************************/
-
-CPROC   tsChangeRoutine  @@tag, @@timeValue
-
-        ENTERPROC
-
-        checkInit
-
-        imul    ebx,[@@tag],SIZE TSROUTINE
-        cmp     [_bx+TSroutines.status],TS_ACTIVE
-        jne     @@exit
-        mov     ax,[WORD @@timeValue]
-        mov     [_bx+TSroutines.timerValue],ax
-        cmp     ax,[TStimerValue]
-        jae     @@slower
-        mov     [TStimerValue],ax
-        call    setTimerRate
-@@slower:
-IF32    <sub    ecx,ecx>
-        mov     cx,[lastTS]
-        inc     cx
-		sub     _bx,_bx
-@@TSloop:
-        cmp     [_bx+TSroutines.status],TS_ACTIVE
-        jne     @@next
-        mov     dx,[TStimerValue]
-        mov     ax,65535
-        cmp     [_bx+TSroutines.timerValue],dx
-        jbe     @@noDiv
-        div     [_bx+TSroutines.timerValue]
-@@noDiv:
-        mov     [_bx+TSroutines.timerAdd],ax
-        mov     [_bx+TSroutines.timerPassed],65535
-@@next:
-        add     _bx,SIZE TSROUTINE
-        loop    @@TSloop
-        sub     ax,ax
-@@exit:
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int tsAddRoutine(void (far *func)(),unsigned time);
-; *
-; *     Description :   Adds a new service routine
-; *
-; *     Input       :   func       =    pointer to timer function
-; *                     time       =    timer rate, determines how often
-; *                                     "func" is called
-; *                     (resolution =   biggest allowable error in timing)
-; *
-; *     Returns     :   -1 = TimerService not initialized
-; *                     -2 = too many service routines
-; *                     -3 = error in parameter
-; *                     1-15 = tag for inited routine
-; *
-; ************************************************************************/
-
-CPROC   tsAddRoutine  @@func, @@timeValue
-        LOCALVAR        _byte @@tag
-
-        ENTERPROC       _si _di
-
-        checkInit
-
-        RETVAL  -2
-        cmp     [TScount],16            ; Are all tags used?
-        jge     @@exit
-
-        mov     _ax,1                    ; AL = tag
-        mov     _cx,15                   ; CX = counter
-@@loop:
-        push    _ax
-        imul    _ax,SIZE TSROUTINE
-        mov     _bx,_ax                   ; BX = offset into array
-        pop     _ax
-
-        cmp     [_bx+TSroutines.status],TS_INACTIVE
-        je      @@found
-        inc     _ax                      ; Next tag
-        loop    @@loop
-        mov     _ax,-2                   ; No free tag was found
-        jmp     @@exit
-@@found:
-        mov     [@@tag],al
-        cmp     ax,[lastTS]
-        jle     @@notLast
-        mov     [lastTS],ax
-@@notLast:
-        mov     eax,[@@func]                ; Copy function pointer
-        mov     [DWORD PTR _bx+TSroutines.routine],eax
-IFDEF __C32__
-        mov     ax,cs
-        mov     [WORD _bx+4+TSroutines.routine],ax
-ENDIF
-        mov     [_bx+TSroutines.status],TS_ACTIVE
-        mov     [_bx+TSroutines.busy],0
-        mov     ax,[WORD @@timeValue]
-        mov     [_bx+TSroutines.timerValue],ax
-        push    _bx
-        movzx   eax,[byte @@tag]                ; Initialize timer values
-        ecall   tsChangeRoutine eax,[@@timeValue]
-        pop     _bx
-        or      ax,ax
-        je      @@ok
-		mov     [_bx+TSroutines.status],TS_INACTIVE
-        jmp     @@exit
-@@ok:
-        inc     [TScount]
-        movzx   eax,[byte @@tag]                ; Return tag
-@@exit:
-        LEAVEPROC       _si _di
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int tsRemoveRoutine(int tag);
-; *
-; *     Description :   Removes the service routine indicated by the tag.
-; *
-; *     Input       :   tag     =       number that was returned when service
-; *                                     routine was added.
-; *
-; *     Returns     :   0       =       routine removed normally
-; *                     -1      =       TimerService not initialized
-; *                     -2      =       invalid tag
-; *
-; ************************************************************************/
-
-CPROC   tsRemoveRoutine  @@tag
-
-        ENTERPROC
-
-        checkInit
-
-        mov     ax,-2
-        mov     dx,[WORD @@tag]
-        cmp     dx,1
-        jl      @@exit
-        cmp     dx,15
-        jg      @@exit
-        mov     al,dl
-        mov     ah,SIZE TSROUTINE
-        mul     ah
-IF32    <sub    ebx,ebx>
-        mov     bx,ax                   ; BX = offset into array
-
-		mov     ax,-2                   ; Is tag active?
-        cmp     [_bx+TSroutines.status],TS_ACTIVE
-        jne     @@exit
-
-        mov     [_bx+TSroutines.status],TS_INACTIVE
-        dec     [TScount]
-        mov     _cx,16
-        sub     _bx,_bx
-        sub     ax,ax
-@@loop:
-        cmp     [_bx+TSroutines.status],TS_ACTIVE
-        jne     @@notActive
-        mov     [lastTS],ax
-@@notActive:
-        inc     ax
-        add     _bx,SIZE TSROUTINE
-        loop    @@loop
-
-        sub     ax,ax                   ; Inactivate tag
-@@exit:
-        LEAVEPROC
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   void tsSetTimerRate(ushort rate);
-; *
-; *     Description :   Sets a new hardware timer rate
-; *
-; *     Input       :   New rate
-; *
-; ************************************************************************/
-
-CPROC   tsSetTimerRate @@timeValue
-
-        ENTERPROC
-
-        checkinit
-
-        mov     ax,[WORD @@timeValue]
-        mov     [TStimerValue],ax
-        call    setTimerRate
-
-IF32    <sub    ecx,ecx>
-        mov     cx,[lastTS]
-        inc     cx
-        sub     _bx,_bx
-@@TSloop:
-        cmp     [_bx+TSroutines.status],TS_ACTIVE
-        jne     @@next
-        mov     dx,[TStimerValue]
-        mov     ax,65535
-        cmp     [_bx+TSroutines.timerValue],dx
-        jbe     @@noDiv
-        div     [_bx+TSroutines.timerValue]
-@@noDiv:
-        mov     [_bx+TSroutines.timerAdd],ax
-        mov     [_bx+TSroutines.timerPassed],65535
-@@next:
-        add     _bx,SIZE TSROUTINE
-        loop    @@TSloop
-        sub     ax,ax
-@@exit:
-        LEAVEPROC
-        ret
-ENDP
-
-;/************************************************************************
-; *
-; *     Function    :   ushort tsGetTimerRate(void);
-; *
-; *     Description :   Returns timer rate
-; *
-; ************************************************************************/
-
-CPROC   tsGetTimerRate
-
-        movzx   eax,[TStimerValue]
-        ret
-ENDP
-
-ENDS
-
-END
-
diff --git a/dmp/timeserv.inc b/dmp/timeserv.inc
deleted file mode 100644
index b725e98..0000000
--- a/dmp/timeserv.inc
+++ /dev/null
@@ -1,28 +0,0 @@
-; ************************************************************************
-; *
-; *     File        : TS.INC
-; *
-; *     Description : Include file for Timer Service
-; *
-; *     Copyright (C) 1992 Otto Chrons
-; *
-; ************************************************************************
-
-
-STRUC   TSROUTINE
-IFDEF __C32__
-    routine     DF      0
-ELSE
-    routine     DD      0
-ENDIF
-    timerValue  DW      0
-    timerRes    DW      0
-    timerAdd    DW      0
-    timerPassed DW      0
-    status      DB      0
-    busy        DB      0
-ENDS
-
-        TS_ACTIVE       = 1
-        TS_INACTIVE     = 0
-
diff --git a/dmp/timeserv.pas b/dmp/timeserv.pas
deleted file mode 100644
index 6670650..0000000
--- a/dmp/timeserv.pas
+++ /dev/null
@@ -1,39 +0,0 @@
-(****************************************************************************
-
-                                 TIMESERV.PAS
-                                 ------------
-
-                          (C) 1993 Jussi Lahdenniemi
-
-Turbo/Borland pascal unit header file for Timer service.
-Original C header by Otto Chrons
-
-****************************************************************************)
-
-Unit TimeServ;
-
-Interface
-
-Function  tsInit:Integer;
-Procedure tsClose;
-Function  tsAddRoutine(Func:Pointer;Time:longint):Integer;
-Function  tsRemoveRoutine(tag:longint):Integer;
-Function  tsChangeRoutine(tag:longint;time:longint):Integer;
-Procedure tsSetTimerRate(rate:longint);
-Function  tsGetTimerRate:word;
-
-Const tsInited : byte = 0;
-
-Implementation
-
-{$L TimeServ.Obj}
-
-Function  tsInit:Integer; External;
-Procedure tsClose; External;
-Function  tsAddRoutine(Func:Pointer;Time:longint):Integer; External;
-Function  tsRemoveRoutine(tag:longint):Integer; External;
-Function  tsChangeRoutine(tag:longint;time:longint):Integer; External;
-Procedure tsSetTimerRate(rate:longint); External;
-Function  tsGetTimerRate:word; External;
-
-End.
diff --git a/dmp/timeserv.tpp b/dmp/timeserv.tpp
deleted file mode 100644
index 9b6c172..0000000
Binary files a/dmp/timeserv.tpp and /dev/null differ
diff --git a/dmp/vds.asm b/dmp/vds.asm
deleted file mode 100644
index 0b83f6f..0000000
--- a/dmp/vds.asm
+++ /dev/null
@@ -1,182 +0,0 @@
-;/************************************************************************
-; *
-; *     File        : VDS.ASM
-; *
-; *     Description : Virtual DMA services
-; *
-; *     Copyright (C) 1993 Otto Chrons
-; *
-; ***********************************************************************/
-
-        IDEAL
-        JUMPS
-        P386
-
-;       L_PASCAL        = 1             ; Uncomment this for pascal-style
-
-IFDEF   L_PASCAL
-        LANG    EQU     PASCAL
-        MODEL TPASCAL
-ELSE
-        LANG    EQU     C
-        MODEL LARGE,C
-ENDIF
-        INCLUDE "MODEL.INC"
-
-DATASEG
-
-        vdsInited       DB ?
-
-CODESEG
-
-        PUBLIC  vdsInit
-        PUBLIC  vdsEnableDMATranslation, vdsDisableDMATranslation
-        PUBLIC  vdsLockDMA, vdsUnlockDMA
-
-
-;/*************************************************************************
-; *
-; *     Function    :   int vdsInit(void);
-; *
-; *     Description :   Initializes VDS
-; *
-; *     Returns     :   0 = OK
-; *                     -1 = error
-; *
-; ************************************************************************/
-
-PROC    vdsInit
-
-        mov     [vdsInited],0
-
-        mov     ax,40h
-        mov     es,ax
-        mov     al,[es:7Bh]
-        test    al,00100000b            ; Are services available?
-        mov     ax,-1                   ; Set error code
-        jz      @@exit
-        mov     [vdsInited],1
-        mov     ax,0
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int vdsEnableDMATranslation(short DMAchannel);
-; *
-; *     Description :   Enables DMA buffer translation (default)
-; *
-; *     Input       :   DMA channel
-; *
-; *     Returns     :   0 = OK
-; *                     -1 = error
-; *
-; ************************************************************************/
-
-PROC    vdsEnableDMATranslation DMAchannel:WORD
-
-        mov     ax,-1
-        cmp     [vdsInited],1
-        jne     @@exit
-        mov     ax,810Ch
-        mov     bx,[DMAchannel]         ; Enable DMA
-        sub     dx,dx
-        int     4Bh                     ; call VDS
-        mov     ax,-1
-        jc      @@exit                  ; Carry = error
-        sub     ax,ax
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int vdsDisableDMATranslation(short DMAchannel);
-; *
-; *     Description :   Disables DMA buffer translation
-; *
-; *     Input       :   DMA channel
-; *
-; *     Returns     :   0 = OK
-; *                     -1 = error
-; *
-; ************************************************************************/
-
-PROC    vdsDisableDMATranslation DMAchannel:WORD
-
-        mov     ax,-1
-        cmp     [vdsInited],1
-        jne     @@exit
-        mov     ax,810Bh
-        mov     bx,[DMAchannel]         ; Disable DMA
-        sub     dx,dx
-        int     4Bh                     ; call VDS
-        mov     ax,-1
-        jc      @@exit                  ; Carry = error
-        sub     ax,ax
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int vdsLockDMA(DDS *dds);
-; *
-; *     Description :   Locks DMA region
-; *
-; *     Input       :   Pointer to DDS structure
-; *
-; *     Returns     :   0 = OK
-; *                     -1 = error
-; *
-; ************************************************************************/
-
-PROC    vdsLockDMA USES di,pdds:DWORD
-
-        mov     ax,-1
-        cmp     [vdsInited],1
-        jne     @@exit
-
-        LESDI   [pdds]
-        mov     ax,8103h                ; Lock DMA region
-        mov     dx,0
-        int     4Bh
-        mov     ax,-1
-        jc      @@exit
-        sub     ax,ax
-@@exit:
-        ret
-ENDP
-
-;/*************************************************************************
-; *
-; *     Function    :   int vdsUnlockDMA(DDS *dds);
-; *
-; *     Description :   Unlocks DMA region
-; *
-; *     Input       :   Pointer to DDS structure
-; *
-; *     Returns     :   0 = OK
-; *                     -1 = error
-; *
-; ************************************************************************/
-
-PROC    vdsUnlockDMA USES di,pdds:DWORD
-
-        mov     ax,-1
-        cmp     [vdsInited],1
-        jne     @@exit
-
-        LESDI   [pdds]
-        mov     ax,8104h                ; Unlock DMA region
-        mov     dx,0
-        int     4Bh
-        mov     ax,-1
-        jc      @@exit
-        sub     ax,ax
-@@exit:
-        ret
-ENDP
-
-END
diff --git a/dmp/vds.pas b/dmp/vds.pas
deleted file mode 100644
index 7395032..0000000
--- a/dmp/vds.pas
+++ /dev/null
@@ -1,33 +0,0 @@
-Unit vds; { (C) 1993 Jussi Lahdenniemi,
-            original C-version (C) 1993 Otto Chrons
-
-            Virtual DMA services }
-
-Interface
-
-type PDDS           = ^TDDS;
-     TDDS           = record
-       size         : longint;
-       offset       : longint;
-       segment      : word;
-       ID           : word;
-       address      : longint;
-     end;
-
-Function vdsInit:integer;
-Function vdsEnableDMATranslation(DMAchannel:word):Integer;
-Function vdsDisableDMATranslation(DMAchannel:word):Integer;
-Function vdsLockDMA(dds:PDDS):Integer;
-Function vdsUnlockDMA(dds:PDDS):Integer;
-
-Implementation
-
-Function vdsInit:integer; external;
-Function vdsEnableDMATranslation(DMAchannel:word):Integer; external;
-Function vdsDisableDMATranslation(DMAchannel:word):Integer; external;
-Function vdsLockDMA(dds:PDDS):Integer; external;
-Function vdsUnlockDMA(dds:PDDS):Integer; external;
-
-{$L VDS.OBJ}
-
-end.
diff --git a/dmp/vds.tpp b/dmp/vds.tpp
deleted file mode 100644
index 50d1b31..0000000
Binary files a/dmp/vds.tpp and /dev/null differ
diff --git a/dosbox.conf b/dosbox.conf
index a3645ee..b5d9c29 100644
--- a/dosbox.conf
+++ b/dosbox.conf
@@ -237,8 +237,11 @@ ipx=false
 mount s /home/xen/saki/projects/Ironseed
 #mount f /home/xen/projects/Ironseed
 mount g /home/xen/saki/projects/Ironseed
+mount f /home/xen/saki/projects/Ironseed
 
-set path=z:\;g:\bp\bin;f:\bp\bin
+mount a /home/xen/saki/projects/Ironseed/masminst
+
+set path=z:\;g:\bp\bin;f:\bp\bin;f:\tc\bin
 
 s:
 cd ironseed
diff --git a/makedata/aliemake.pas b/makedata/aliemake.pas
index 15b90ed..0047fa8 100644
--- a/makedata/aliemake.pas
+++ b/makedata/aliemake.pas
@@ -1,4 +1,20 @@
 program makealiencontacts;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 type
  alientype=
diff --git a/makedata/alien.cpr b/makedata/alien.cpr
deleted file mode 100644
index 1bf03f3..0000000
Binary files a/makedata/alien.cpr and /dev/null differ
diff --git a/makedata/alien1.cpr b/makedata/alien1.cpr
deleted file mode 100644
index ec1850e..0000000
Binary files a/makedata/alien1.cpr and /dev/null differ
diff --git a/makedata/alien10.cpr b/makedata/alien10.cpr
deleted file mode 100644
index b811e21..0000000
Binary files a/makedata/alien10.cpr and /dev/null differ
diff --git a/makedata/alien2.cpr b/makedata/alien2.cpr
deleted file mode 100644
index 70bbf79..0000000
Binary files a/makedata/alien2.cpr and /dev/null differ
diff --git a/makedata/alien3.cpr b/makedata/alien3.cpr
deleted file mode 100644
index a079036..0000000
Binary files a/makedata/alien3.cpr and /dev/null differ
diff --git a/makedata/alien4.cpr b/makedata/alien4.cpr
deleted file mode 100644
index 2214f9c..0000000
Binary files a/makedata/alien4.cpr and /dev/null differ
diff --git a/makedata/alien5.cpr b/makedata/alien5.cpr
deleted file mode 100644
index 4e15bfe..0000000
Binary files a/makedata/alien5.cpr and /dev/null differ
diff --git a/makedata/alien6.cpr b/makedata/alien6.cpr
deleted file mode 100644
index c2c0019..0000000
Binary files a/makedata/alien6.cpr and /dev/null differ
diff --git a/makedata/alien7.cpr b/makedata/alien7.cpr
deleted file mode 100644
index d5fc07d..0000000
Binary files a/makedata/alien7.cpr and /dev/null differ
diff --git a/makedata/alien8.cpr b/makedata/alien8.cpr
deleted file mode 100644
index 77bc7c0..0000000
Binary files a/makedata/alien8.cpr and /dev/null differ
diff --git a/makedata/alien9.cpr b/makedata/alien9.cpr
deleted file mode 100644
index 270b92f..0000000
Binary files a/makedata/alien9.cpr and /dev/null differ
diff --git a/makedata/artimake.pas b/makedata/artimake.pas
index fa8b914..fb56452 100644
--- a/makedata/artimake.pas
+++ b/makedata/artimake.pas
@@ -1,4 +1,20 @@
 program makeartifact;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 type
  artifacttype=string[10];
diff --git a/makedata/back b/makedata/back
deleted file mode 100644
index 6c54a7b..0000000
--- a/makedata/back
+++ /dev/null
@@ -1,9 +0,0 @@
-crewcon1.txt:
-- 500     -1      1       65      ERASED ERASE
-+ -1      -1      1       65      ERASED ERASE
-- 501     -1      3       66      JAMMING SHIELD READING INCONCLUSIVE
-+ 102     -1      3       66      JAMMING SHIELD READING INCONCLUSIVE
-crewcon4.txt:
-- 500     -1      1       45      D'PAHK WORMS
-+ 102     -1      1       45      JAMMING SHIELD READING
-
diff --git a/makedata/bitmap.cpr b/makedata/bitmap.cpr
deleted file mode 100644
index 78ffb6b..0000000
Binary files a/makedata/bitmap.cpr and /dev/null differ
diff --git a/makedata/blast01.cpr b/makedata/blast01.cpr
deleted file mode 100644
index 61bcc0e..0000000
Binary files a/makedata/blast01.cpr and /dev/null differ
diff --git a/makedata/blast02.cpr b/makedata/blast02.cpr
deleted file mode 100644
index eb0b74b..0000000
Binary files a/makedata/blast02.cpr and /dev/null differ
diff --git a/makedata/blast03.cpr b/makedata/blast03.cpr
deleted file mode 100644
index 1095b85..0000000
Binary files a/makedata/blast03.cpr and /dev/null differ
diff --git a/makedata/blast04.cpr b/makedata/blast04.cpr
deleted file mode 100644
index 356d218..0000000
Binary files a/makedata/blast04.cpr and /dev/null differ
diff --git a/makedata/boss1.dta b/makedata/boss1.dta
deleted file mode 100644
index 47fb4f0..0000000
--- a/makedata/boss1.dta
+++ /dev/null
@@ -1 +0,0 @@
- p p pFpiplpep p pEpdpiptp p pSpepaprpcphp p pOppptpipopnpsp p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p p pHpeplppp p p qEqVqEqNqTqSq.qTqXqTq qevents                                                                                                                                                      SPE==Set Pending Event                                                                                                                                      1-10    these events are unset after each conversation                                                                                                      200-300   main story events                                                                                                                                 201     brought psycometrist back online, and activated sector codex          202     found satellite from human ship                                       203     find phaedor moch ship damaged and fighting                           204     shoot down phaedor moch                                               205     repair phaedor moch ship <receive strange panel from P6>              206     meet hallifax manuever                                                207     scavengers meet you                                                   208     teach scavengers pain                                                 209     get coolents from QP                                                  210     get solonoids from QP                                                 211     get hull increasing artifact from QP                                  212     get Muriel from QP (SPE for QP war)                                   213     Quai Pa'loi go to war                                                 214     offer help to q'ooul                                                   ?M?S?-?D?O?S? ?E?d?i?t?o?r? ? ?<?F?1?=?H?e?l?p?>? ?P?r?e?s?s? ?A?L?T? ?t?o? ?a?c?t?i?v?a?t?e? ?m?e?n?u?s? ? ? ? ? ? ? ? ? ?0 0 0 0 0 0 0 00000000010:0000010 G
\ No newline at end of file
diff --git a/makedata/boss2.dta b/makedata/boss2.dta
deleted file mode 100644
index 60c5e5d..0000000
--- a/makedata/boss2.dta
+++ /dev/null
@@ -1 +0,0 @@
-P	A	T	H	}	 	C	:	\	 	 	 	rive C is THOMAS-C                                                   Volume Serial Number is 1F30-16EF                                               Directory of C:\                                                                                                                                               APPS         <DIR>         01-19-94   3:40p                                     BATCH        <DIR>         01-19-94   3:40p                                     DATA         <DIR>         01-19-94   5:14p                                     DOOMDATA     <DIR>         01-19-94   3:40p                                     DOS          <DIR>         01-19-94   3:40p                                     DOWNLOAD     <DIR>         01-19-94   3:40p                                     IRONSEED     <DIR>         01-26-94   6:39p                                     LANG         <DIR>         01-19-94   3:40p                                     PROJECTS     <DIR>         01-26-94   6:45p                                     SC           <DIR>         01-19-94   5:14p                                     UTILITY      <DIR>         01-19-94   3:40p                                     AUTOEXEC BAT         1,503 02-10-94   5:41p                                     COMMAND  COM        54,619 09-30-93   6:20a                                     CONFIG   SYS         1,141 02-10-94   5:48p                                     FILE0000 CHK     1,056,768 02-11-94   3:48p                                     GCARD    CFG            27 10-10-93  12:56a                                     WINA20   386         9,349 03-10-93   6:00a                                            17 file(s)      1,123,407 bytes                                                                13,910,016 bytes free                                                                                                                     C	O	M	M	A	N	D	}	 	                                                                       
\ No newline at end of file
diff --git a/makedata/box.pas b/makedata/box.pas
deleted file mode 100644
index 13c58bb..0000000
--- a/makedata/box.pas
+++ /dev/null
@@ -1,311 +0,0 @@
-program rotatebox;
-uses crt,graph;
-
-
-type
- colortype= array[1..3] of byte;
- planetype=array[1..4,1..3] of real;
- boxtype=array[1..12] of planetype;
- paltype= array[0..255] of colortype;
- screentype= array[0..199,0..319] of byte;
- bitmaptype= array[0..99,0..99] of byte;
-const
- box: boxtype =
-(
- ((5,5,5),(5,-5,5),(-5,-5,5),(-5,5,5)),
- ((5,5,-5),(5,-5,-5),(-5,-5,-5),(-5,5,-5)),
- ((5,5,5),(5,-5,5),(5,-5,-5),(5,5,-5)),
- ((-5,5,5),(-5,-5,5),(-5,-5,-5),(-5,5,-5)),
- ((5,5,5),(5,5,-5),(-5,5,-5),(-5,5,5)),
- ((5,-5,5),(5,-5,-5),(-5,-5,-5),(-5,-5,5)),
-
- ((10,10,10),(10,-10,10),(-10,-10,10),(-10,10,10)),
- ((10,10,-10),(10,-10,-10),(-10,-10,-10),(-10,10,-10)),
- ((10,10,10),(10,-10,10),(10,-10,-10),(10,10,-10)),
- ((-10,10,10),(-10,-10,10),(-10,-10,-10),(-10,10,-10)),
- ((10,10,10),(10,10,-10),(-10,10,-10),(-10,10,10)),
- ((10,-10,10),(10,-10,-10),(-10,-10,-10),(-10,-10,10))
-
- );
-
-var
- x,y,z,sd,i,a,b,j,c,x1,j1,i2,j3: integer;
- ans: char;
- range,temp1,temp2,temp3: real;
- a1,a2,a3,yadj,pfac,xpart,yloc,ypart,xpart2,yloc2,ypart2,yhpart,yh: real;
- alt: integer;
- colors: paltype;
- points: boxtype;
- screen: screentype absolute $A000:0000;
- temp: ^screentype;
- tempp: planetype;
- bitmap: ^bitmaptype;
-
-{$L vga256}
-procedure vgadriver; external;
-{$L mover}
-{$F+}
-procedure mymove(var src,tar; count: integer); external;
-{$F-}
-
-function fastkeypressed: boolean; assembler;
-asm
- push ds
- mov ax, 40h
- mov ds, ax
- cli
- mov ax, [1Ah]
- cmp ax, [1Ch]
- sti
- mov ax, 0
- jz @nopress
- inc ax
-@nopress:
- pop ds
-end;
-
-procedure loadscreen(s: string);
-var vgafile: file of screentype;
-begin
- assign(vgafile,s);
- reset(vgafile);
- read(vgafile,screen);
- close(vgafile);
-end;
-
-procedure loadpal(s: string);
-var palfile: file of paltype;
-begin
- assign(palfile,s);
- reset(palfile);
- read(palfile,colors);
- close(palfile);
-end;
-
-procedure setrgb256(palnum,r,g,b: byte); assembler;
-asm
- xor bh, bh
- mov bl, palnum
- mov ax, 1010h
- mov dh, r
- mov ch, g
- mov cl, b
-  int 10h
-end;
-
-procedure set256Colors(pal: paltype); assembler;
-asm
- mov ax, 1012h
- mov bx, 0
- mov cx, 256
- les dx, Pal
-  int 10h
-end;
-
-{$F+}
-function testit : integer; assembler;
-asm
- mov ax, 1A00h
-  int 10h
- cmp al, 1Ah
- jne @@nope
- mov ax, 1
- jmp @@done
-@@nope:
- mov ax, 0
-@@done:
-end;
-{$F-}
-
-procedure readygraph;
-var testdriver,driver,mode,errcode: integer;
-begin
- testdriver:=installuserdriver('vga256',@testit);
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeLn('Error Installing VGA Driver:',errcode);
-   halt(4);
-  end;
- registerbgidriver(@vgadriver);
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeLn('Error Registering VGA Driver:',errcode);
-   halt(4);
-  end;
- driver:=detect;
- initgraph(driver,mode,'');
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeln('Video Initialization Failure: ',errcode);
-   halt(4);
-  end;
- loadpal('data\main.pal');
- set256colors(colors);
- setgraphbufsize(0);
- checksnow:=false;
-end;
-
-procedure draw;
-begin
- for x:=1 to 12 do
-   begin
-    pfac:=sd/(range-box[x,y,3]);
-    points[x,y,1]:=160+box[x,y,1]*pfac;
-    points[x,y,2]:=100-yadj*box[x,y,2]*pfac;
-{   moveto(round(160+box[x,4,1]*sd/(range-box[x,4,3])),
-        round(100-yadj*(box[x,4,2]*sd/(range-box[x,4,3]))));
-}   for y:=1 to 4 do
-    begin
-     pfac:=sd/(range-box[x,y,3]);
-     points[x,y,1]:=160+box[x,y,1]*pfac;
-     points[x,y,2]:=100-yadj*box[x,y,2]*pfac;
- {    lineto(round(points[x,y,1]),round(points[x,y,2]));
-  }  end;
-  end;
-
- for j:=1 to 4 do
-  begin
-   b:=0;
-   for x:=1 to 4 do b:=b+round(box[j,x,3]);
-   for i:=j to 4 do
-    begin
-     a:=0;
-     for x:=1 to 4 do a:=a+round(box[i,x,3]);
-     if a<b then
-      begin
-       tempp:=box[i];
-       box[i]:=box[j];
-       box[j]:=tempp;
-      end;
-    end;
-  end;
-
- for x:=3 to 4 do
-  begin
-   xpart:=(points[x,4,1]-points[x,1,1]);
-   yloc:=points[x,1,2];
-   yloc2:=points[x,2,2];
-   ypart:=(points[x,4,2]-points[x,1,2])/xpart;
-   for j:=1 to round(abs(xpart)) do
-    begin
-     if xpart<0 then j1:=-j else j1:=j;
-     x1:=round(points[x,1,1]+j1);
-     yh:=yloc2-ypart*2*j1-yloc;
-     i2:=round(yloc+j1*ypart);
-     j3:=round(j*100/xpart);
-     for i:=1 to round(yh) do
-      temp^[i+i2,x1]:=bitmap^[round(i*100/yh),j3];
-    end;
-  end;
-end;
-
-procedure altx;
-begin
- for x:=1 to 12 do
-  for y:=1 to 4 do
-   begin
-    temp2:=box[x,y,2];
-    temp3:=box[x,y,3];
-    box[x,y,2]:=(0.95533)*temp2-(0.29552)*temp3;
-    box[x,y,3]:=(0.29552)*temp2+(0.95533)*temp3;
-   end;
-end;
-
-procedure alty;
-begin
- for x:=1 to 12 do
-  for y:=1 to 4 do
-   begin
-    temp1:=box[x,y,1];
-    temp3:=box[x,y,3];
-    box[x,y,1]:=(0.95533)*temp1-(0.29552)*temp3;
-    box[x,y,3]:=(0.29552)*temp1+(0.95533)*temp3;
-   end;
-end;
-
-procedure alty2;
-begin
- for x:=1 to 12 do
-  for y:=1 to 4 do
-   begin
-    temp1:=box[x,y,1];
-    temp3:=box[x,y,3];
-    box[x,y,1]:=(0.95533)*temp1+(0.29552)*temp3;
-    box[x,y,3]:=(-0.29552)*temp1+(0.95533)*temp3;
-   end;
-end;
-
-procedure altz;
-begin
- for x:=1 to 12 do
-  for y:=1 to 4 do
-   begin
-    temp1:=box[x,y,1];
-    temp2:=box[x,y,2];
-    box[x,y,1]:=(0.95533)*temp1-(0.29552)*temp2;
-    box[x,y,2]:=(0.29552)*temp1+(0.95533)*temp2;
-   end;
-end;
-
-begin
- readygraph;
- fillchar(colors,768,0);
- set256colors(colors);
- loadscreen('makedata\bitmap.vga');
- new(bitmap);
- for i:=0 to 99 do
-  begin
-   move(screen[i],bitmap^[i],100);
-   fillchar(screen[i],100,0);
-  end;
- loadpal('data\main.pal');
- set256colors(colors);
- range:=200;
- yadj:=1600/1920;
- sd:=500;
- alt:=0;
- setcolor(47);
- new(temp);
- repeat
-  repeat
-    fillchar(temp^,64000,0);
-   case alt of
-    0:;
-    1:altx;
-    2:altx;
-    3:alty2;
-    4:alty;
-    5:altz;
-    6:altz;
-    7:range:=range+4;
-    8:range:=range-4;
-    9:begin altx; alty; altz; end;
-   end;
-   draw;
-   mymove(temp^,screen,16000);
-  until fastkeypressed;
-  ans:=readkey;
-  case upcase(ans) of
-   'R': alt:=8;
-   'F': alt:=7;
-   'A': alt:=1;
-   'Z': alt:=2;
-   'S': alt:=3;
-   'X': alt:=4;
-   'D': alt:=5;
-   'C': alt:=6;
-   '+':;
-   '-':;
-   'M': alt:=9;
-   else alt:=0;
-  end;
-  draw;
- until ans=#27;
- dispose(bitmap);
- dispose(temp);
- closegraph;
-end.
-
diff --git a/makedata/breach1.cpr b/makedata/breach1.cpr
deleted file mode 100644
index 820f534..0000000
Binary files a/makedata/breach1.cpr and /dev/null differ
diff --git a/makedata/breach2.cpr b/makedata/breach2.cpr
deleted file mode 100644
index 2ad28a5..0000000
Binary files a/makedata/breach2.cpr and /dev/null differ
diff --git a/makedata/c7.cpr b/makedata/c7.cpr
deleted file mode 100644
index 207d872..0000000
Binary files a/makedata/c7.cpr and /dev/null differ
diff --git a/makedata/cargmake.pas b/makedata/cargmake.pas
index 5cb33fe..ec6469b 100644
--- a/makedata/cargmake.pas
+++ b/makedata/cargmake.pas
@@ -1,4 +1,20 @@
 program generatecargodata;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 const
  maxcargo= 145;
@@ -16,9 +32,9 @@ var
  c: char;
 
 begin
- assign(f,'data\cargo.dta');
+ assign(f,'data/cargo.dta');
  rewrite(f);
- assign(ft,'makedata\cargo.txt');
+ assign(ft,'makedata/cargo.txt');
  reset(ft);
  readln(ft);
  for i:=1 to maxcargo do
diff --git a/makedata/channel7.cpr b/makedata/channel7.cpr
deleted file mode 100644
index 6d9604e..0000000
Binary files a/makedata/channel7.cpr and /dev/null differ
diff --git a/makedata/channel7.pal b/makedata/channel7.pal
deleted file mode 100644
index 2105f24..0000000
Binary files a/makedata/channel7.pal and /dev/null differ
diff --git a/makedata/char.cpr b/makedata/char.cpr
deleted file mode 100644
index d63b38f..0000000
Binary files a/makedata/char.cpr and /dev/null differ
diff --git a/makedata/char.pal b/makedata/char.pal
deleted file mode 100644
index 3ded02a..0000000
Binary files a/makedata/char.pal and /dev/null differ
diff --git a/makedata/char1.dta b/makedata/char1.dta
deleted file mode 100644
index f3d351e..0000000
Binary files a/makedata/char1.dta and /dev/null differ
diff --git a/makedata/charani.cpr b/makedata/charani.cpr
deleted file mode 100644
index 0632218..0000000
Binary files a/makedata/charani.cpr and /dev/null differ
diff --git a/makedata/cloud.pas b/makedata/cloud.pas
deleted file mode 100644
index d470ff0..0000000
--- a/makedata/cloud.pas
+++ /dev/null
@@ -1,29 +0,0 @@
-program testcloud;
-uses crt,graph,data;
-
-var
- x,y: integer;
- vgafile: file of screentype;
- done: boolean;
-
-begin
- randomize;
- set256colors(colors);
- x:=160;
- y:=100;
- done:=false;
- repeat
-  x:=x-1+random(3);
-  y:=y-1+random(3);
-  if x<0 then x:=319
-   else if x>319 then x:=0;
-  if y<0 then y:=199
-   else if y>199 then y:=0;
-  if screen[y,x]<31 then inc(screen[y,x]);
- until (keypressed) or (done);
-{ assign(vgafile,'data\test.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);}
- closegraph;
-end.
\ No newline at end of file
diff --git a/makedata/cloud2.pal b/makedata/cloud2.pal
deleted file mode 100644
index deaf681..0000000
--- a/makedata/cloud2.pal
+++ /dev/null
@@ -1,62 +0,0 @@
-%'=-+%"5"+)=
-
-) 1)+"")";% 3
-'/"-"%+7
-
-%"/';
-
-1
-1'95-=3)3"%+)
-151=)'"'1 9
-%1) 9+"-
-
-))=
- 77= '=+-=
-- 
-
-
-%-)3'3
-
-
-
-'5)'' 
-%%++" ";3-=
-37/"/
-'-
-)11="' '"+'; 75='-)"3 
-
-
-1)=
-+-"7
-
-" ;'1 9
-
-
-%/ 1/-=)5
-%
--%)=%%/)=
-""9-371=%
-
-
-1
-
-
-)")
-
- ";
-"++="1
-
-
-
-7-9)%;
-
-
-
-'
-5 3
-/"9%"=)3)=
-
-
-7
-+1"7
-+ )/%;;=
\ No newline at end of file
diff --git a/makedata/cloud2.pas b/makedata/cloud2.pas
deleted file mode 100644
index e6642cb..0000000
--- a/makedata/cloud2.pas
+++ /dev/null
@@ -1,29 +0,0 @@
-program testcloud;
-uses crt,graph,data;
-
-var
- x,y: integer;
- vgafile: file of screentype;
- done: boolean;
-
-begin
- randomize;
- set256colors(colors);
- x:=160;
- y:=100;
- done:=false;
- repeat
-  x:=x-1+random(3);
-  y:=y-1+random(3);
-  if x<0 then x:=319
-   else if x>319 then x:=0;
-  if y<0 then y:=199
-   else if y>199 then y:=0;
-  if screen[y,x]<31 then inc(screen[y,x]);
- until (keypressed) or (done);
- assign(vgafile,'data\testcld.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);
- closegraph;
-end.
\ No newline at end of file
diff --git a/makedata/cmftool.pas b/makedata/cmftool.pas
deleted file mode 100644
index b766c4d..0000000
--- a/makedata/cmftool.pas
+++ /dev/null
@@ -1,380 +0,0 @@
-UNIT CMFTool;
-{** Unit - uses SBFMDRV.COM **}
-INTERFACE
-USES Dos;
-TYPE
-  CMFFileTyp = FILE;
-  CMFDataTyp = Pointer;
-  CMFHeader = RECORD
-    CMFFileID         : ARRAY[0..3] OF CHAR;
-    CMFVersion        : WORD;
-    CMFInstrBlockOfs  : WORD;
-    CMFMusicBlockOfs  : WORD;
-    CMFTickPerBeat    : WORD;
-    CMFClockTicksPS   : WORD;
-    CMFFileTitleOfs   : WORD;
-    CMFComposerOfs    : WORD;
-    CMFMusicRemarkOfs : WORD;
-    CMFChannelsUsed   : ARRAY[0..15] OF CHAR;
-    CMFInstrNumber    : WORD;
-    CMFBasicTempo     : WORD;
-  END;
-CONST
-   CMFToolVersion       = 'v1.0';
-VAR
-   CMFStatusByte      : BYTE;
-   CMFErrStat         : WORD;
-   CMFDriverInstalled : BOOLEAN;
-   CMFDriverIRQ       : WORD;
-   CMFSongPaused      : BOOLEAN;
-   OldExitProc        : Pointer;
-PROCEDURE PrintCMFErrMessage;
-FUNCTION  CMFGetSongBuffer(VAR CMFBuffer : Pointer; CMFFile : STRING):BOOLEAN;
-FUNCTION  CMFFreeSongBuffer (VAR CMFBuffer : Pointer):BOOLEAN;
-FUNCTION  CMFInitDriver : BOOLEAN;
-FUNCTION  CMFGetVersion : WORD;
-PROCEDURE CMFSetStatusByte;
-FUNCTION  CMFSetInstruments(VAR CMFBuffer : Pointer):BOOLEAN;
-FUNCTION  CMFSetSingleInstruments(VAR CMFInstrument:Pointer; No:WORD):BOOLEAN;
-PROCEDURE CMFSetSysClock(Frequency : WORD);
-PROCEDURE CMFSetDriverClock(Frequency : WORD);
-PROCEDURE CMFSetTransposeOfs (Offset : INTEGER);
-FUNCTION  CMFPlaySong(VAR CMFBuffer : Pointer) : BOOLEAN;
-FUNCTION  CMFStopSong : BOOLEAN;
-FUNCTION  CMFResetDriver:BOOLEAN;
-FUNCTION  CMFPauseSong : BOOLEAN;
-FUNCTION  CMFContinueSong : BOOLEAN;
-IMPLEMENTATION
-TYPE
-   TypeCastTyp = ARRAY [0..6000] of Char;
-VAR
-   Regs : Registers;
-   CMFIntern : ^CMFHeader; { Internal pointer to CMF structure }
-PROCEDURE PrintCMFErrMessage;
-{ PURPOSE : Displays SB error as text; no change to error status. }
-BEGIN
-   CASE CMFErrStat OF
-      100 : Write(' SBFMDRV sound driver not found ');
-      110 : Write(' Driver reset successful ');
-      200 : Write(' CMF file not found ');
-      210 : Write(' No memory free for CMF file ');
-      220 : Write(' File not in CMF format ');
-      300 : Write(' Memory allocation error occurred ');
-      400 : Write(' Too many instruments defined ');
-      500 : Write(' CMF data could not be played ');
-      510 : Write(' CMF data could not be stopped ');
-      520 : Write(' CMF data could not be paused ');
-      530 : Write(' CMF data could not be continued ');
-      END;
-   END;
-FUNCTION Exists (Filename : STRING):BOOLEAN;
-{ PURPOSE : Checks for the existence of a file, and returns a Boolean exp. }
-VAR
-   F : File;
-BEGIN
-   Assign(F,Filename);
-{$I-}
-   Reset(F);
-   Close(F);
-{$I+}
-   Exists := (IoResult = 0) AND (Filename <> '');
-   END;
-PROCEDURE AllocateMem (VAR Pt : Pointer; Size : LongInt);
-{ Reserves as many bytes as Size allows, then sets the pointer in the 
-  Pt variable. If not enough memory is available, Pt is set to NIL. }
-VAR
-   SizeIntern : WORD;
-BEGIN
-   Inc(Size,15);
-   SizeIntern := (Size shr 4);
-   Regs.AH := $48;
-   Regs.BX := SizeIntern;
-   MsDos(Regs);
-   IF (Regs.BX <> SizeIntern) THEN Pt := NIL
-   ELSE Pt := Ptr(Regs.AX,0);
-   END;
-FUNCTION  CheckFreeMem (VAR CMFBuffer : Pointer; CMFSize : LongInt):BOOLEAN;
-{ Ensures that enough memory has been allocated for CMF file. }
-BEGIN
-   AllocateMem(CMFBuffer,CMFSize);
-   CheckFreeMem := CMFBuffer <> NIL;
-   END;
-FUNCTION  CMFGetSongBuffer(VAR CMFBuffer : Pointer; CMFFile : STRING):BOOLEAN;
-{ Loads file into memory; returns TRUE if load successful, FALSE if not. }
-CONST
-   FileCheck : STRING[4] = 'CTMF';
-VAR
-   CMFFileSize : LongInt;
-   FPresent    : BOOLEAN;
-   VFile       : CMFFileTyp;
-   Segs        : WORD;
-   Read        : WORD;
-   Checkcount  : BYTE;
-BEGIN
-   FPresent := Exists(CMFFile);
-
-{ CMF file could not be found }
-   IF Not(FPresent) THEN BEGIN
-      CMFGetSongBuffer := FALSE;
-      CMFErrStat   := 200;
-      EXIT
-      END;
-   Assign(VFile,CMFFile);
-   Reset(VFile,1);
-   CMFFileSize := Filesize(VFile);
-   AllocateMem(CMFBuffer,CMFFileSize);
-{ Insufficient memory for CMF file }
-   IF (CMFBuffer = NIL) THEN BEGIN
-      Close(VFile);
-      CMFGetSongBuffer := FALSE;
-      CMFErrStat   := 210;
-      EXIT;
-      END;
-   Segs := 0;
-   REPEAT
-      Blockread(VFile,Ptr(seg(CMFBuffer^)+4096*Segs,Ofs(CMFBuffer^))^,$FFFF,Read);
-      Inc(Segs);
-      UNTIL Read = 0;
-   Close(VFile);
-{ File not in CMF format }
-   CMFIntern := CMFBuffer;
-   CheckCount := 1;
-   REPEAT
-      IF FileCheck[CheckCount] = CMFIntern^.CMFFileID[CheckCount-1]
-         THEN Inc(CheckCount)
-         ELSE CheckCount := $FF;
-      UNTIL CheckCount >= 3;
-   IF NOT(CheckCount = 3) THEN BEGIN
-      CMFGetSongBuffer := FALSE;
-      CMFErrStat   := 220;
-      EXIT;
-      END;
-{ Load was successful }
-   CMFGetSongBuffer := TRUE;
-   CMFErrStat   := 0;
-   END;
-FUNCTION CMFFreeSongBuffer (VAR CMFBuffer : Pointer):BOOLEAN;
-{ Frees memory allocated for CMF file. }
-BEGIN
-   Regs.AH := $49;
-   Regs.ES := seg(CMFBuffer^);
-   MsDos(Regs);
-   CMFFreeSongBuffer := TRUE;
-   IF (Regs.AX = 7) OR (Regs.AX = 9) THEN BEGIN
-      CMFFreeSongBuffer := FALSE;
-      CMFErrStat := 300
-      END;
-   END;
-FUNCTION CMFInitDriver : BOOLEAN;
-{ Checks for SBFMDRV.COM resident in memory, and resets driver }
-CONST
-   DriverCheck :STRING[5] = 'FMDRV';
-VAR
-   ScanIRQ,
-   CheckCount  : BYTE;
-   IRQPtr,
-   DummyPtr    : Pointer;
-BEGIN
-{ Possible SBFMDRV interrupts lie in range $80 - $BF }
-   FOR ScanIRQ := $80 TO $BF DO BEGIN
-      GetIntVec(ScanIRQ, IRQPtr);
-      DummyPtr := Ptr(Seg(IRQPtr^), $102);
-{ Check for string 'FMDRV' in interrupt program. }
-      CheckCount := 1;
-      REPEAT
-         IF DriverCheck[CheckCount] = TypeCastTyp(DummyPtr^)[CheckCount]
-            THEN Inc(CheckCount)
-            ELSE CheckCount := $FF;
-         UNTIL CheckCount >= 5;
-      IF (CheckCount = 5) THEN BEGIN
-{ String found; reset executed }
-         Regs.BX := 08;
-         CMFDriverIRQ := ScanIRQ;
-         Intr(CMFDriverIRQ, Regs);
-         IF Regs.AX = 0 THEN
-            CMFInitDriver := TRUE
-         ELSE BEGIN
-            CMFInitDriver := FALSE;
-            CMFErrStat    := 110;
-            END;
-         Exit;
-         END
-      ELSE BEGIN
-{ String not found }
-         CMFInitDriver := FALSE;
-         CMFErrStat := 100;
-         END;
-      END;
-   END;
-FUNCTION CMFGetVersion : WORD;
-{ Gets version number from SBFMDRV driver. }
-BEGIN
-   Regs.BX := 0;
-   Intr(CMFDriverIRQ,Regs);
-   CMFGetVersion := Regs.AX;
-   END;
-PROCEDURE CMFSetStatusByte;
-{ Place driver status byte in CMFStatusByte variable. }
-BEGIN
-   Regs.BX:= 1;
-   Regs.DX:= Seg(CMFStatusByte);
-   Regs.AX:= Ofs(CMFStatusByte);
-   Intr(CMFDriverIRQ, Regs);
-   END;
-FUNCTION CMFSetInstruments(VAR CMFBuffer : Pointer):BOOLEAN;
-{ Sets SB card FM registers to instrumentation stated in CMF file. }
-BEGIN
-    CMFIntern := CMFBuffer;
-    IF CMFIntern^.CMFInstrNumber > 128 THEN BEGIN
-       CMFErrStat := 400;
-       CMFSetInstruments := FALSE;
-       Exit;
-       END;
-    Regs.BX := 02;
-    Regs.CX := CMFIntern^.CMFInstrNumber;
-    Regs.DX := Seg(CMFBuffer^);
-    Regs.AX := Ofs(CMFBuffer^)+CMFIntern^.CMFInstrBlockOfs;
-    Intr(CMFDriverIRQ, Regs);
-    CMFSetInstruments := TRUE;
-   END;
-FUNCTION CMFSetSingleInstruments(VAR CMFInstrument:Pointer; No:WORD):BOOLEAN;
-{ Sets SB FM registers to instrument values corresponding to the
-  data structure following the CMFInstrument pointer. }
-BEGIN
-    IF No > 128 THEN BEGIN
-       CMFErrStat := 400;
-       CMFSetSingleInstruments := FALSE;
-       Exit;
-       END;
-    Regs.BX := 02;
-    Regs.CX := No;
-    Regs.DX := Seg(CMFInstrument^);
-    Regs.AX := Ofs(CMFInstrument^);
-    Intr(CMFDriverIRQ, Regs);
-    CMFSetSingleInstruments := TRUE;
-   END;
-PROCEDURE CMFSetSysClock(Frequency : WORD);
-{ Sets default value of timer 0 to new value. }
-BEGIN
-   Regs.BX := 03;
-   Regs.AX := (1193180 DIV Frequency);
-   Intr(CMFDriverIRQ, Regs);
-   END;
-PROCEDURE CMFSetDriverClock(Frequency : WORD);
-{ Sets driver timer frequency to new value. }
-BEGIN
-   Regs.BX := 04;
-   Regs.AX := (1193180 DIV Frequency);
-   Intr(CMFDriverIRQ, Regs);
-   END;
-PROCEDURE CMFSetTransposeOfs (Offset : INTEGER);
-{ Transposes all notes in the CMF file by "Offset." }
-BEGIN
-   Regs.BX := 05;
-   Regs.AX := Offset;
-   Intr(CMFDriverIRQ, Regs);
-   END;
-FUNCTION CMFPlaySong(VAR CMFBuffer : Pointer) : BOOLEAN;
-{ Initializes all important parameters and starts song playback. }
-VAR
-   Check : BOOLEAN;
-BEGIN
-   CMFIntern := CMFBuffer;
-{ Set driver clock frequency }
-   CMFSetDriverClock(CMFIntern^.CMFClockTicksPS);
-{ Set instruments }
-   Check := CMFSetInstruments(CMFBuffer);
-   IF Not(Check) THEN Exit;
-   Regs.BX := 06;
-   Regs.DX := Seg(CMFIntern^);
-   Regs.AX := Ofs(CMFIntern^)+CMFIntern^.CMFMusicBlockOfs;
-   Intr(CMFDriverIRQ, Regs);
-   IF Regs.AX = 0 THEN BEGIN
-      CMFPlaySong := TRUE;
-      CMFSongPaused := FALSE;
-      END
-   ELSE BEGIN
-      CMFPlaySong := FALSE;
-      CMFErrStat := 500;
-      END;
-   END;
-FUNCTION CMFStopSong : BOOLEAN;
-{ Attempts to stop song playback. }
-BEGIN
-   Regs.BX := 07;
-   Intr(CMFDriverIRQ, Regs);
-   IF Regs.AX = 0 THEN
-      CMFStopSong := TRUE
-   ELSE BEGIN
-      CMFStopSong := FALSE;
-      CMFErrStat  := 510;
-      END;
-   END;
-FUNCTION CMFResetDriver:BOOLEAN;
-{ Resets driver to starting status. }
-BEGIN
-   Regs.BX := 08;
-   Intr(CMFDriverIRQ, Regs);
-   IF Regs.AX = 0 THEN
-      CMFResetDriver := TRUE
-   ELSE BEGIN
-      CMFResetDriver := FALSE;
-      CMFErrStat    := 110;
-      END;
-   END;
-FUNCTION CMFPauseSong : BOOLEAN;
-{ Attempts to pause song playback. If pause is possible, this
-  function sets the CMFSongPaused variable to TRUE. }
-BEGIN
-   Regs.BX := 09;
-   Intr(CMFDriverIRQ, Regs);
-   IF Regs.AX = 0 THEN BEGIN
-      CMFPauseSong  := TRUE;
-      CMFSongPaused := TRUE;
-      END
-   ELSE BEGIN
-      CMFPauseSong := FALSE;
-      CMFErrStat   := 520;
-      END;
-   END;
-FUNCTION CMFContinueSong : BOOLEAN;
-{ Attempts to continue playback of a paused song. If continuation
-  is possible, this function sets CMFSongPaused to FALSE. }
-BEGIN
-   Regs.BX := 10;
-   Intr(CMFDriverIRQ, Regs);
-   IF Regs.AX = 0 THEN BEGIN
-      CMFContinueSong  := TRUE;
-      CMFSongPaused    := FALSE;
-      END
-   ELSE BEGIN
-      CMFContinueSong := FALSE;
-      CMFErrStat      := 530;
-      END;
-   END;
-{$F+}
-PROCEDURE CMFToolsExitProc;
-{$F-}
-{ Resets the status byte address, allowing this program to exit.}
-BEGIN
-   Regs.BX:= 1;
-   Regs.DX:= 0;
-   Regs.AX:= 0;
-   Intr(CMFDriverIRQ, Regs);
-   ExitProc := OldExitProc;
-   END;
-BEGIN
-{ Reset old ExitProc to the Tool unit proc }
-   OldExitProc := ExitProc;
-   ExitProc := @CMFToolsExitProc;
-{ Initialize variables }
-   CMFErrStat := 0;
-   CMFSongPaused := FALSE;
-{ Initialize driver }
-   CMFDriverInstalled := CMFInitDriver;
-   IF CMFDriverInstalled THEN BEGIN
-      CMFStatusByte := 0;
-      CMFSetStatusByte;
-      END;
-   END.
-
diff --git a/makedata/combat.pas b/makedata/combat.pas
deleted file mode 100644
index 0e1d235..0000000
--- a/makedata/combat.pas
+++ /dev/null
@@ -1,443 +0,0 @@
-unit combat;
-
-{$O+}
-
-interface
-
-type
- alientype=
-  record
-   name: string[15];
-   techmin,techmax,anger,congeniality,victory,defeat,id: integer;
-   war: boolean;
-   front,side,long,short,back: integer;
-  end;
-
-procedure initiatecombat;
-procedure createwandering(order: integer; alien: alientype);
-
-implementation
-
-uses crt, graph, data, gmouse, utils, display, journey, utils2;
-
-const
- maxships = 5;
-type
- alienshiparray= array[1..maxships] of alienshiptype;
-var
- i,j,a,b,n,x2,y2,targetindex: integer;
- done: boolean;
- poweredup: array[1..10] of integer;
- ships: ^alienshiparray;
-
-procedure createwandering(order: integer; alien: alientype);
-var x,y: integer;
-begin
- with ship.wandering do
-  begin
-   orders:=order;
-   x:=hi(alien.techmin);
-   y:=lo(alien.techmin);
-   techlevel:=alien.techmin;
-   if alien.defeat>alien.victory then
-    begin
-     i:=(alien.defeat-alien.victory) div 2;
-     repeat
-      inc(y);
-      if y>9 then
-       begin
-        inc(x);
-        y:=0;
-        if x>6 then
-         begin
-          x:=6;
-          y:=0;
-         end;
-       end;
-      techlevel:=x*256+y;
-      dec(i);
-     until (i=0) or (techlevel=alien.techmax);
-    end;
-   congeniality:=abs(alien.congeniality+random(11)-5);
-   anger:=abs(alien.anger+random(11)-5);
-   alienid:=alien.id;
-   case orders of
-    0: begin
-        relx:=3000+random(10000);
-        if random(2)=1 then relx:=-relx;
-        rely:=3000+random(10000);
-        if random(2)=1 then rely:=-rely;
-        relz:=3000+random(10000);
-        if random(2)=1 then relz:=-relz;
-       end;
-    1: begin
-        relx:=5000+random(12000);
-        if random(2)=1 then relx:=-relx;
-        rely:=5000+random(12000);
-        if random(2)=1 then rely:=-rely;
-        relz:=5000+random(12000);
-        if random(2)=1 then relz:=-relz;
-       end;
-   end;
- end;
-end;
-
-procedure checkdamages;
-begin
- mousehide;
- x:=round(ship.hulldamage*0.162);
- for i:=176 to 180 do
-  begin
-   fillchar(screen[i,25],x,i-96);
-   if x<162 then
-    fillchar(screen[i,25+x],162-x,0);
-  end;
- x:=round((100-ship.damages[1])/2);
- for i:=152 to 156 do
-  begin
-   fillchar(screen[i,81],x,i-72);
-   if x<50 then
-    fillchar(screen[i,81+x],50-x,0);
-  end;
- for j:=2 to 7 do
-  begin
-   a:=round((100-ship.damages[j])/2);
-   x:=(j-2) mod 3;
-   y:=(j-2) div 3;
-   for i:=0 to 4 do
-    begin
-     fillchar(screen[i+y*8+160,x*68+13],a,i+80);
-     if a<50 then
-      fillchar(screen[i+y*8+160,x*68+13+a],50-a,i+64);
-    end;
-  end;
- mouseshow;
-end;
-
-procedure decpower;
-begin
- if ship.shield>1501 then
-  ship.battery:=ship.battery-round(weapons[ship.shield-1442].energy*ship.shieldlevel/100)+20;
- if ship.battery>32000 then ship.battery:=32000
- else if ship.battery<0 then
-  begin
-   tcolor:=88;
-   printbigbox('COMPUTER:SECONDARY POWER FAILURE','SHIELDS POWERING DOWN...');
-   ship.shieldlevel:=0;
-   ship.battery:=0;
-   tcolor:=95;
-   for i:=192 to 196 do
-    fillchar(screen[i,25],162,0);
-  end;
- for j:=1 to n do
-  with ships^[j] do
-   begin
-    battery:=battery-round(weapons[shield-1442].energy*shieldlevel/100)+regen;
-    if battery>32000 then battery:=32000
-     else if battery<0 then
-     begin
-      shieldlevel:=0;
-      battery:=0;
-      for i:=39 to 43 do
-       fillchar(screen[i,26],162,0);
-     end;
-   end;
-end;
-
-procedure powerup;
-begin
- mousehide;
- for j:=1 to 10 do
-  if (poweredup[j]>-1) and (poweredup[j]<100) then
-   begin
-    inc(poweredup[j]);
-    i:=round(poweredup[j]*0.31);
-    if i<16 then setcolor(80+i) else setcolor(32+i);
-    x:=((j-1) mod 5)*23+204;
-    y:=((j-1) div 5)*23+153;
-    rectangle(x,y,x+21,y+21);
-   end;
- x:=round(ship.battery*0.00506);
- for i:=184 to 188 do
-  begin
-   fillchar(screen[i,25],x,i-104);
-   if x<162 then
-    fillchar(screen[i,25+x],162-x,0);
-  end;
- if ship.battery>0 then
-  begin
-   if ship.shieldlevel<ship.shieldopt[3] then
-    inc(ship.shieldlevel);
-   x:=round(ship.shieldlevel*1.62);
-   for i:=192 to 196 do
-    begin
-     fillchar(screen[i,25],x,i-112);
-     if x<162 then
-      fillchar(screen[i,25+x],162-x,0);
-    end;
-  end;
- for j:=1 to n do
-  begin
-   if (ships^[j].battery>0) then
-    begin
-     if ships^[j].shieldlevel<100 then inc(ships^[j].shieldlevel);
-     x:=round(ships^[j].shieldlevel*1.62);
-     for i:=39 to 43 do
-      begin
-       fillchar(screen[i,26],x,i+41);
-       if x<162 then
-        fillchar(screen[i,26+x],162-x,0);
-      end;
-    end;
-   x:=round(ships^[j].battery*0.00194);
-   for i:=31 to 34 do
-    begin
-     fillchar(screen[i,14],x,i+49);
-     if x<62 then
-      fillchar(screen[i,14+x],62-x,0);
-    end;
-  end;
- mouseshow;
-end;
-
-procedure moveships;
-begin
-
- {***find targets here!!****}
- for j:=1 to n do
-  with ships^[j] do
-   begin
-    tarx:=5;
-    tary:=5;
-    tarz:=5;
-   end;
-
- for j:=1 to n do
-  with ships^[j] do
-   begin
-    if relx>tarx then dec(relx)
-     else if relx<tarx then inc(relx);
-    if rely>tary then dec(rely)
-     else if rely<tary then inc(rely);
-    if relz>tarz then dec(relz)
-     else if relz<tarz then inc(relz);
-  end;
-end;
-
-procedure showships;
-begin
- setcolor(8);
- setwritemode(xorput);
- mousehide;
- for j:=1 to n do
-  begin
-   x:=ships^[j].relx;
-   y:=ships^[j].rely;
-   z:=ships^[j].relz;
-   if z=0 then x1:=0.01 else x1:=z;
-   ar:=x/sin(arctan(x/x1));
-   br:=ar/2;
-   if x=0 then x1:=0.01 else x1:=x;
-   t2:=arctan(z/(2*x1));
-   x1:=105+(ar*cos(t1+t2))/10;
-   y1:=102+(br*sin(t1+t2)+y)/14;
-   x2:=round(x1);
-   y2:=round(y1);
-   moveto(x,y);
-   x:=ships^[j].relx;
-   y:=0;
-   z:=ships^[j].relz;
-   if z=0 then x1:=0.01 else x1:=z;
-   ar:=x/sin(arctan(x/x1));
-   br:=ar/2;
-   if x=0 then x1:=0.01 else x1:=x;
-   t2:=arctan(z/(2*x1));
-   x1:=105+(ar*cos(t1+t2))/10;
-   y1:=102+(br*sin(t1+t2)+y)/14;
-   x:=round(x1);
-   y:=round(y1);
-   line(x,y,x2,y2);
-   screen[y,x]:=screen[y,x] xor 39;
-  end;
- mouseshow;
- setwritemode(copyput);
-end;
-
-procedure findmouse;
-var button: boolean;
-begin
- if mouse.getstatus(left) then button:=true else button:=false;
- if not button then exit;
- {**************}
-end;
-
-procedure processkey;
-var ans: char;
-begin
- ans:=readkey;
- case ans of
-  #27: begin
-        done:=true;
-        bkcolor:=0;
-       end;
- end;
-end;
-
-procedure mainloop;
-var index: integer;
-begin
- index:=0;
- showships;
- repeat
-  findmouse;
-  if fastkeypressed then processkey;
-  inc(index);
-  if index=8 then
-   begin
-    decpower;
-    index:=0;
-   end;
-  powerup;
-  showships;
-  moveships;
-  showships;
-  delay(tslice*7);
- until done;
-end;
-
-procedure showweaponicon(x1,y1,weap,node: integer);
-var j,i: integer;
-begin
- readweaicon(weap-1);
- case node of
-  1,2,6,7: begin
-            for i:=0 to 9 do
-             for j:=0 to 19 do
-              screen[y1+j,x1+i]:=tempicon^[i,a+j];
-            for i:=0 to 9 do
-             for j:=0 to 19 do
-              screen[y1+j,x1+i+10]:=tempicon^[i,a+j];
-           end;
-      3,4: begin
-            for i:=0 to 19 do
-             mymove(tempicon^[i,a],screen[y1+i,x1],5);
-           end;
-      8,9: begin
-            for i:=0 to 19 do
-             mymove(tempicon^[19-i,a],screen[y1+i,x1],5);
-           end;
-     5,10: begin
-            for i:=0 to 9 do
-             for j:=0 to 19 do
-              screen[y1+j,x1+20-i]:=tempicon^[i,a+j];
-            for i:=0 to 9 do
-             for j:=0 to 19 do
-              screen[y1+j,x1+10-i]:=tempicon^[i,a+j];
-           end;
-
- end;
-end;
-
-procedure getshipinfo(n: integer);
-var f: file of alienshiptype;
-    i,j: integer;
-begin
- assign(f,'data\ships.dta');
- reset(f);
- if ioresult<>0 then errorhandler('ships.dta',1);
- i:=lo(ship.wandering.techlevel);
- j:=hi(ship.wandering.techlevel);
- if j<4 then begin j:=4; i:=0; end;
- j:=j-4;
- seek(f,j+i);
- if ioresult<>0 then errorhandler('ships.dta'+chr(j+i+48),5);
- read(f,ships^[n]);
- if ioresult<>0 then errorhandler('ships.dta'+chr(j+i+48),5);
- close(f);
-end;
-
-procedure showtargetinfo;
-var str1: string[5];
-    t: longint;
-begin
- t:=ships^[targetindex].maxhull*5;
- str(t:5,str1);
- printxy(70,18,str1+' KT');
-
- {*****************}
-
-end;
-
-procedure readyships;
-var f: file of alientype;
-    t: alientype;
-begin
- n:=1;
- for j:=1 to n do
-  with ships^[j] do
-   begin
-    getshipinfo(n);
-    relx:=ship.wandering.relx-10+random(21);
-    rely:=ship.wandering.rely-10+random(21);
-    relz:=ship.wandering.relz-10+random(21);
-    if (shield<1502) then shieldlevel:=100;
-   end;
- assign(f,'save\contacts.dta');
- reset(f);
- if ioresult<>0 then errorhandler('contacts.dta',1);
- repeat
-  read(f,t);
-  if ioresult<>0 then errorhandler('contacts.dta',5);
- until t.id=ship.wandering.alienid;
- close(f);
- printxy(40,6,t.name);
-end;
-
-procedure readydata;
-begin
- mousehide;
- savescreen;
- fading;
- loadscreen('data\war.vga');
- done:=false;
- new(ships);
- tcolor:=95;
- bkcolor:=0;
- oldt1:=t1;
- targetindex:=1;
- for j:=1 to 10 do poweredup[j]:=-1;
- for j:=1 to 10 do
-  if checkloc(j) then
-   begin
-    case j of
-      1,2,10: i:=j;
-      3: i:=7;
-      4: i:=3;
-      5: i:=8;
-      6: i:=4;
-      7: i:=9;
-      8: i:=6;
-      9: i:=5;
-    end;
-    if ship.armed then poweredup[i]:=99 else poweredup[i]:=0;
-    if ship.gunnodes[j]=0 then poweredup[i]:=-1
-     else showweaponicon(((i-1) mod 5)*23+205,((i-1) div 5)*23+154,ship.gunnodes[j],i);
-   end;
- checkdamages;
- readyships;
- showtargetinfo;
- powerup;
- fadein;
- mouseshow;
-end;
-
-procedure initiatecombat;
-begin
- readydata;
- mainloop;
- dispose(ships);
- removedata;
-end;
-
-begin
-end.
\ No newline at end of file
diff --git a/makedata/combat2.pas b/makedata/combat2.pas
deleted file mode 100644
index cfd84b9..0000000
--- a/makedata/combat2.pas
+++ /dev/null
@@ -1,966 +0,0 @@
-unit combat;
-
-{***************************
-   Battle/Combat unit for IronSeed
-
-   Channel 7
-   Destiny: Virtual
-
-
-   (C) DEC. 31, 1993
-
-***************************}
-
-{$O+}
-
-interface
-
-procedure initiatecombat;
-
-implementation
-
-uses crt, graph, data, gmouse, utils, display, journey, utils2, saveload, weird, usecode;
-
-const
- maxships = 15;
- shipclass : array[0..14] of string[14] =
-  ('SHUTTLE       ','SCOUT         ','FIGHTER       ','ASSULT SCOUT  ',
-   'PATROL CRAFT  ','CORVETTE      ','FRIGATE       ','LT. DESTROYER ',
-   'HV. DESTROYER ','LT. CRUISER   ','HV. CRUISER   ','BATTLE CRUISER',
-   'FLAGSHIP      ','BATTLESHIP    ','DREADNAUGHT   ');
-type
- alienshiparray= array[1..maxships] of alienshiptype;
- statpictype= array[0..1,0..11] of byte;
- alienshipdisplay= array[140..193,201..314] of byte;
- barpictype= array[0..3,0..3] of byte;
- shieldpictype= array[0..6,0..3] of byte;
-var
- oldshddmg,i,j,a,b,nships,targetindex,fireweapon: integer;
- range: longint;
- done,scanning,weapondisplay,autofire,engaging: boolean;
- poweredup: array[1..10] of integer;
- ships: ^alienshiparray;
- statpic,blank: ^statpictype;
- stats: array[1..3] of byte;
- part,r: real;
- asdisplay: ^alienshipdisplay;
- str1: string[10];
- barpic: ^barpictype;
- bar: array[1..4] of byte;
- shieldpic,shieldpic2: ^shieldpictype;
-
-procedure displaystats;
-var i: integer;
-begin
- mousehide;
- part:=102/ship.hullmax*ship.hulldamage;
- if round(part)<>stats[1] then
-  begin
-   for i:=0 to 1 do
-    move(blank^[i],screen[111-stats[1]+i,267],10);
-   stats[1]:=round(part);
-   y:=111-round(part);
-   for i:=0 to 1 do
-    move(statpic^[i],screen[y+i,267],10);
-   end;
- part:=102/32000*ship.battery;
- if round(part)<>stats[2] then
-  begin
-   for i:=0 to 1 do
-    move(blank^[i],screen[111-stats[2]+i,283],10);
-   stats[2]:=round(part);
-   y:=111-round(part);
-   for i:=0 to 1 do
-    move(statpic^[i],screen[y+i,283],10);
-  end;
- part:=102/100*ship.shieldlevel;
- if round(part)<>stats[3] then
-  begin
-   for i:=0 to 1 do
-    move(blank^[i],screen[111-stats[3]+i,299],10);
-   stats[3]:=round(part);
-   y:=111-round(part);
-   for i:=0 to 1 do
-    move(statpic^[i],screen[y+i,299],10);
-  end;
- mouseshow;
-end;
-
-procedure displayshieldpic(n: integer);
-begin
- mousehide;
- part:=102/100*ship.shieldopt[3];
- for i:=0 to 6 do
-  fillchar(screen[108-round(part)+i,310],4,0);
- if n>100-ship.damages[2] then n:=100-ship.damages[2];
- ship.shieldopt[3]:=n;
- part:=102/100*ship.shieldopt[3];
- for i:=0 to 6 do
-  mymove(shieldpic^[i],screen[108-round(part)+i,310],1);
- mouseshow;
-end;
-
-procedure displaytargetinfo2;
-var str1: string[6];
-begin
- with ships^[targetindex] do
-  begin
-   tcolor:=26;
-   bkcolor:=0;
-   printxy(252,141,chr(hi(techlevel)+48)+
-    '.'+chr(lo(techlevel)+48));
-   i:=270000 div accelmax;
-   str(i,str1);
-   printxy(223,187,str1);
-   for i:=1 to 7 do
-    begin
-     b:=round((100-damages[i])/100*38);
-     fillchar(screen[i*5+149,204],b,44);
-     fillchar(screen[i*5+150,204],b,45);
-     if b<38 then
-      begin
-       fillchar(screen[i*5+149,205+b],38-b,0);
-       fillchar(screen[i*5+150,205+b],38-b,0);
-      end;
-    end;
-  end;
-end;
-
-procedure givedamage(n,d: integer);
-var j: integer;
-begin
- d:=round(d/100*(100-ship.damages[3]));
- with ships^[targetindex] do
-  begin
-   case n of
-    1: inc(damages[5],d);
-    2: dec(hulldamage,d);
-    3: dec(hulldamage,d div 2);
-    4: case random(8) of
-        0: inc(damages[1],d);
-        1: inc(damages[2],d);
-        2: inc(damages[3],d);
-        3: inc(damages[4],d);
-        4: inc(damages[6],d);
-        5: inc(damages[7],d);
-        6,7: dec(hulldamage,d);
-       end;
-    5: inc(damages[2],d);
-   end;
-   if hulldamage<0 then hulldamage:=0;
-   for j:=1 to 7 do if damages[j]>100 then damages[j]:=100;
-   if shieldlevel<0 then shieldlevel:=0;
-   if shield=1501 then shieldlevel:=damages[2];
-   if damages[5]=100 then hulldamage:=0;
-  end;
-end;
-
-procedure displaymap; forward;
-
-procedure firingweapon(n: integer);
-var j,i,a,b,c,d: integer;
-begin
- if skillcheck(4) then
-  begin
-   c:=ship.gunnodes[n];
-   b:=ships^[targetindex].shield-1442;
-   for j:=1 to 4 do if weapons[c].dmgtypes[j]>0 then
-    begin
-     i:=round(weapons[c].dmgtypes[j]/100*weapons[c].damage*5);
-     if ships^[targetindex].shieldlevel=0 then givedamage(j,i)
-     else
-      begin
-       a:=round(weapons[b].dmgtypes[j]/100*weapons[b].damage*ships^[targetindex].shieldlevel/100);
-       if a<i then
-        begin
-         givedamage(j,i-a);
-         ships^[targetindex].shieldlevel:=1;
-         if ships^[targetindex].shield=1501 then ships^[targetindex].damages[2]:=100;
-        end
-       else
-        begin
-         part:=i/ships^[targetindex].shieldlevel;
-         part:=part*(1/weapons[b].damage);
-         part:=part*100;
-         a:=round(part*100);
-         d:=ships^[targetindex].shieldlevel-a;
-         if d<0 then
-          begin
-           givedamage(5,random(4)+1);
-           if ships^[targetindex].shield=1501 then
-            ships^[targetindex].damages[2]:=100;
-           ships^[targetindex].shieldlevel:=1;
-          end
-         else
-          begin
-           ships^[targetindex].shieldlevel:=d;
-           if ships^[targetindex].shield=1501 then
-            ships^[targetindex].damages[2]:=100-d;
-          end;
-        end;
-      end;
-    end;
-  end;
- if ships^[targetindex].hulldamage=0 then
-  begin
-   ships^[targetindex].hulldamage:=1;
-   displaymap;
-   ships^[targetindex].hulldamage:=0;
-   y:=round(ships^[targetindex].rely/range*26.66);
-   x:=round(ships^[targetindex].relx/range*80);
-   z:=round(ships^[targetindex].relz/range*40);
-   if (abs(x)<80) and (abs(y)<40) and (abs(z)<40) then
-    begin
-     if z<0 then
-      for i:=y+70 to y+70-z do
-       screen[i,x+160]:=screen[i,x+160] xor 6
-     else
-      for i:=y+70 downto y+70-z do
-       screen[i,x+160]:=screen[i,x+160] xor 6;
-     screen[y+70,x+160]:=screen[y+70,x+160] xor 85;
-     screen[y+70-z,x+160]:=screen[y+70-z,x+160] xor 31;
-    end;
-   targetindex:=1;
-   while (targetindex<=nships) and (ships^[targetindex].hulldamage=0) do inc(targetindex);
-   if targetindex>nships then done:=true;
-   displaymap;
-  end;
- poweredup[n]:=0;
- fireweapon:=0;
- if not weapondisplay then displaytargetinfo2;
-end;
-
-procedure powerup;
-begin
- mousehide;
- for j:=1 to 10 do
-  if (poweredup[j]>-1) and (poweredup[j]<100) then
-   begin
-    if (poweredup[j]=0) and (ship.battery>=weapons[ship.gunnodes[j]].energy) then
-     begin
-      dec(ship.battery,weapons[ship.gunnodes[j]].energy);
-      poweredup[j]:=1;
-     end
-    else if poweredup[j]>0 then inc(poweredup[j]);
-    if weapondisplay then
-     begin
-      i:=round(poweredup[j]*0.31);
-      if i<16 then setcolor(80+i) else setcolor(32+i);
-      x:=((j-1) mod 5)*22+203;
-      y:=((j-1) div 5)*25+144;
-      rectangle(x,y,x+21,y+21);
-     end;
-   end
-  else if poweredup[j]=100 then
-    begin
-     part:=weapons[ship.gunnodes[j]].range;
-     if part>=r then setcolor(47) else setcolor(63);
-     if weapondisplay then
-      begin
-       x:=((j-1) mod 5)*22+203;
-       y:=((j-1) div 5)*25+144;
-       rectangle(x,y,x+21,y+21);
-      end;
-     if (part>=r) and ((autofire) or (fireweapon=j)) then firingweapon(j);
-   end;
- mouseshow;
- if (ship.battery>0) and (ship.shieldlevel<ship.shieldopt[3]) then inc(ship.shieldlevel)
-  else if (ship.battery=0) and (ship.shieldlevel>0) then dec(ship.shieldlevel)
-  else if (Ship.shieldlevel>ship.shieldopt[3]) then dec(ship.shieldlevel);
- for j:=1 to nships do
-  with ships^[j] do
-   begin
-    if shield>1501 then
-     begin
-      if (battery>0) and (shieldlevel<(100-damages[2])) then inc(shieldlevel)
-       else if (battery=0) and (shieldlevel>0) then dec(shieldlevel)
-       else if shieldlevel>(100-damages[2]) then dec(shieldlevel);
-     end;
-    for i:=1 to 20 do
-     if charges[i]<100 then
-      begin
-       if (charges[i]=0) and (battery>=weapons[1].energy) then
-        begin
-         dec(battery,weapons[1].energy);
-         charges[i]:=1;
-        end
-       else if charges[i]>0 then inc(charges[i]);
-     end;
-   end;
-end;
-
-procedure showweaponicon(x1,y1,weap,node: integer);
-var j,i: integer;
-begin
- if weap=0 then
-  begin
-   for i:=0 to 19 do
-    fillchar(screen[y1+i,x1],20,3);
-   exit;
-  end;
- readweaicon(weap-1);
- case node of
-  1,2,3,8: for i:=0 to 19 do
-            for j:=0 to 19 do
-             screen[y1+j,x1+i]:=tempicon^[i,j];
-  4,6: for i:=0 to 19 do
-        mymove(tempicon^[i],screen[y1+i,x1],5);
-  5,7: for i:=0 to 19 do
-        mymove(tempicon^[19-i],screen[y1+i,x1],5);
-  9,10: for i:=0 to 19 do
-         for j:=0 to 19 do
-          screen[y1+j,x1+20-i]:=tempicon^[i,j];
- end;
-end;
-
-procedure displayweapons;
-begin
- weapondisplay:=true;
- mousehide;
- for i:=140 to 193 do
-  fillchar(screen[i,201],114,0);
- for j:=1 to 10 do
-   begin
-    x:=((j-1) mod 5)*22+203;
-    y:=((j-1) div 5)*25+144;
-    showweaponicon(x+1,y+1,ship.gunnodes[j],j);
-    if ship.gunnodes[j]>0 then
-     begin
-      a:=round(poweredup[j]*0.31);
-      if a<16 then setcolor(80+a) else setcolor(32+a);
-      rectangle(x,y,x+21,y+21);
-     end;
-   end;
- mouseshow;
-end;
-
-procedure displaydamage;
-var a,b,i: integer;
-begin
- mousehide;
- for a:=1 to 7 do
-  begin
-   b:=round((100-ship.damages[a])/100*51);
-   fillchar(screen[a*9+63,7],b,44);
-   fillchar(screen[a*9+64,7],b,45);
-   if b<50 then
-    begin
-     fillchar(screen[a*9+63,8+b],50-b,0);
-     fillchar(screen[a*9+64,8+b],50-b,0);
-    end;
-  end;
- if 100-ship.damages[2]<ship.shieldopt[3] then displayshieldpic(100-ship.damages[2]);
- part:=108-(102/100*(100-ship.damages[2]));
- if round(part)<>oldshddmg then
-  begin
-   for i:=0 to 6 do
-    fillchar(screen[oldshddmg+i,294],4,0);
-   for i:=0 to 6 do
-    mymove(shieldpic2^[i],screen[round(part)+i,294],1);
-   oldshddmg:=round(part);
-  end;
- mouseshow;
-end;
-
-procedure suckpower;
-begin
- if ship.shield>1501 then
-  ship.battery:=ship.battery-round(weapons[ship.shield-1442].energy*ship.shieldlevel/100);
- ship.battery:=ship.battery+round((100-ship.damages[1])/4);
- if ship.battery<0 then ship.battery:=0
-  else if ship.battery>32000 then ship.battery:=32000;
- for j:=1 to nships do if ships^[j].hulldamage>0 then
-  with ships^[j] do
-   begin
-    if shield>1501 then dec(battery,round(weapons[shield-1442].energy*shieldlevel/100));
-    inc(battery,round(regen*(100-damages[1])/100));
-    if battery<0 then battery:=0
-     else if battery>32000 then battery:=32000;
-   end;
-end;
-
-procedure displaytargetinfo;
-var b: integer;
-begin
- mousehide;
- with ships^[targetindex] do
-  begin
-   r:=sqr(relx/10);
-   r:=r+sqr(rely/10);
-   r:=r+sqr(relz/10);
-   r:=sqrt(r)*100;
-   str(r:10:3,str1);
-   tcolor:=60;
-   printxy(32,158,str1+' KM');
-   tcolor:=95;
-   b:=ships^[targetindex].maxhull;
-   if b<1000 then b:=b div 100
-   else b:=((b-1000) div 1600) + 9;
-   printxy(4,150,shipclass[b]+' '+chr(48+targetindex));
-   b:=round(hulldamage/maxhull*91);
-   if b<>bar[1] then
-    begin
-     for i:=0 to 3 do
-      fillchar(screen[i+167,bar[1]+22],4,0);
-     for i:=0 to 3 do
-      mymove(barpic^[i],screen[i+167,b+22],1);
-     bar[1]:=b;
-    end;
-   b:=round(battery/32000*91);
-   if b<>bar[2] then
-    begin
-     for i:=0 to 3 do
-      fillchar(screen[i+174,bar[2]+22],4,0);
-     for i:=0 to 3 do
-      mymove(barpic^[i],screen[i+174,b+22],1);
-     bar[2]:=b;
-    end;
-   b:=round((100-damages[5])/100*91);
-   if b<>bar[3] then
-    begin
-     for i:=0 to 3 do
-      fillchar(screen[i+181,bar[3]+22],4,0);
-     for i:=0 to 3 do
-      mymove(barpic^[i],screen[i+181,b+22],1);
-     bar[3]:=b;
-    end;
-   b:=round(shieldlevel/100*91);
-   if b<>bar[4] then
-    begin
-     for i:=0 to 3 do
-      fillchar(screen[i+188,bar[4]+22],4,0);
-     for i:=0 to 3 do
-      mymove(barpic^[i],screen[i+188,b+22],1);
-     bar[4]:=b;
-    end;
-  end;
- mouseshow;
-end;
-
-procedure displaymap;
-begin
- mousehide;
- for j:=1 to nships do if ships^[j].hulldamage>0 then
-  begin
-   y:=round(ships^[j].rely/range*26.66);
-   x:=round(ships^[j].relx/range*80);
-   z:=round(ships^[j].relz/range*40);
-   if (abs(x)<80) and (abs(y)<40) and (abs(z)<40) then
-    begin
-     if z<0 then
-      for i:=y+70 to y+70-z do
-       screen[i,x+160]:=screen[i,x+160] xor 6
-     else
-      for i:=y+70 downto y+70-z do
-       screen[i,x+160]:=screen[i,x+160] xor 6;
-     screen[y+70,x+160]:=screen[y+70,x+160] xor 85;
-     screen[y+70-z,x+160]:=screen[y+70-z,x+160] xor 31;
-     if j=targetindex then
-      begin
-       screen[y+70-z-2,x+160-2]:=screen[y+70-z-2,x+160-2] xor 60;
-       screen[y+70-z-2,x+160-1]:=screen[y+70-z-2,x+160-1] xor 60;
-       screen[y+70-z-1,x+160-2]:=screen[y+70-z-1,x+160-2] xor 60;
-       screen[y+70-z+2,x+160+1]:=screen[y+70-z+2,x+160+1] xor 60;
-       screen[y+70-z+2,x+160+2]:=screen[y+70-z+2,x+160+2] xor 60;
-       screen[y+70-z+1,x+160+2]:=screen[y+70-z+1,x+160+2] xor 60;
-      end;
-    end;
-  end;
- mouseshow;
-end;
-
-procedure takedamage(n,d: integer);
-var j: integer;
-begin
- case n of
-  1: inc(ship.damages[5],d);
-  2: dec(ship.hulldamage,d);
-  3: dec(ship.hulldamage,d div 2);
-  4: case random(8) of
-      0: inc(ship.damages[1],d);
-      1: inc(ship.damages[2],d);
-      2: inc(ship.damages[3],d);
-      3: inc(ship.damages[4],d);
-      4: inc(ship.damages[6],d);
-      5: inc(ship.damages[7],d);
-      6,7: dec(ship.hulldamage,d);
-     end;
-  5: inc(ship.damages[2],d);
- end;
- for j:=1 to 7 do if ship.damages[j]>100 then ship.damages[j]:=100;
- if ship.hulldamage<0 then ship.hulldamage:=0;
- displaydamage;
- if ship.hulldamage=0 then deathsequence(0)
-  else if ship.damages[5]=100 then deathsequence(1);
- if ship.shield=1501 then ship.shieldlevel:=ship.damages[2];
-end;
-
-procedure impact(s,n: integer);
-var a,b,c,j,i: integer;
-begin
- b:=ship.shield-1442;
- for j:=1 to 4 do if weapons[n].dmgtypes[j]>0 then
-  begin
-   i:=round(weapons[n].dmgtypes[j]/100*weapons[n].damage*5);
-   if ship.shieldlevel=0 then takedamage(j,i)
-   else
-    begin
-     a:=round(weapons[b].dmgtypes[j]/100*weapons[b].damage*ship.shieldlevel/100);
-     if a<i then
-      begin
-       takedamage(j,round((i-a)/100*(100-ships^[s].damages[3])));
-       ship.shieldlevel:=0;
-       if ship.shield=1501 then ship.damages[2]:=100;
-      end
-     else
-      begin
-       a:=round((i/(ship.shieldlevel/100*weapons[b].damage)*100));
-       c:=ship.shieldlevel-a;
-       if c<0 then
-        begin
-         takedamage(5,random(4)+1);
-         if ship.shield=1501 then
-          begin
-           ship.damages[2]:=100;
-           displaydamage;
-          end;
-         ship.shieldlevel:=1;
-        end
-       else
-        begin
-         ship.shieldlevel:=c;
-         if ship.shield=1501 then
-          begin
-           ship.damages[2]:=100-c;
-           displaydamage;
-          end;
-        end;
-      end;
-    end;
-  end;
- displaystats;
-end;
-
-procedure moveships;
-begin
- for j:=1 to nships do if ships^[j].hulldamage>0 then
-  with ships^[j] do
-  begin
-   if (relx<5000) and (relx>0) and (dx<-2000) then inc(dx,accelmax)
-    else if (relx>-5000) and (relx<0) and (dx>2000) then dec(dx,accelmax)
-    else if (relx>0) and (dx>-1000) then dec(dx,accelmax)
-    else if (relx<0) and (dx<1000) then inc(dx,accelmax);
-   if (rely<5000) and (rely>0) and (dy<-2000) then inc(dy,accelmax)
-    else if (rely>-5000) and (rely<0) and (dy>2000) then dec(dy,accelmax)
-    else if (rely>0) and (dy>-1000) then dec(dy,accelmax)
-    else if (rely<0) and (dy<1000) then inc(dy,accelmax);
-   if (relz<5000) and (relz>0) and (dz<-2000) then inc(dz,accelmax)
-    else if (relz>-5000) and (relz<0) and (dz>2000) then dec(dz,accelmax)
-    else if (relz>0) and (dz>-1000) then dec(dz,accelmax)
-    else if (relz<0) and (dz<1000) then inc(dz,accelmax);
-   relx:=relx+dx;
-   rely:=rely+dy;
-   relz:=relz+dz;
-   r:=sqr(relx/10);
-   r:=r+sqr(rely/10);
-   r:=r+sqr(relz/10);
-   r:=sqrt(r)*100;
-   for a:=1 to 20 do
-    if (charges[a]=100) then
-     begin
-      part:=ships^[j].range;
-      if part>=r then
-       begin
-        i:=random(100);
-        if i<skill then impact(j,1);
-        charges[a]:=0;
-       end;
-     end;
-  end;
-end;
-
-procedure findmouse;
-begin
- if not mouse.getstatus(left) then exit;
- case mouse.x of
-  291..312: case mouse.y of
-             134..139: begin
-                        if weapondisplay then
-                         begin
-                          mousehide;
-                          for i:=140 to 193 do
-                           move(asdisplay^[i],screen[i,201],114);
-                          mouseshow;
-                          weapondisplay:=false;
-                          displaytargetinfo2;
-                         end
-                        else
-                         begin
-                          weapondisplay:=true;
-                          displayweapons;
-                         end;
-                       end;
-                 5..111: displayshieldpic(round((111-mouse.y)*100/102));
-               144..164: if weapondisplay then fireweapon:=5;
-               169..189: if weapondisplay then fireweapon:=10;
-             end;
-  127..147: case mouse.y of
-             141..157: if range>5000 then
-                        begin
-                         displaymap;
-                         dec(range,5000);
-                         str(range:7,str1);
-                         printxy(99,122,str1);
-                         displaymap;
-                        end;
-             159..174: if not autofire then
-                        begin
-                         autofire:=true;
-                         mousehide;
-                         for i:=132 to 135 do screen[i,112]:=63;
-                         mouseshow;
-                        end
-                       else
-                        begin
-                         autofire:=false;
-                         mousehide;
-                         for i:=132 to 135 do screen[i,112]:=95;
-                         mouseshow;
-                        end;
-            end;
-  149..160: case mouse.y of
-             141..157: if range<5000000 then
-                        begin
-                         displaymap;
-                         inc(range,5000);
-                         str(range:7,str1);
-                         printxy(99,122,str1);
-                         displaymap;
-                        end;
-             159..174: begin
-                        displaymap;
-                        inc(targetindex);
-                        while (targetindex<=nships) and (ships^[targetindex].hulldamage=0) do inc(targetindex);
-                        if (targetindex>nships) or (ships^[targetindex].hulldamage=0) then
-                         begin
-                          targetindex:=1;
-                          while (targetindex<nships) and (ships^[targetindex].hulldamage=0) do inc(targetindex);
-                         end;
-                        if not weapondisplay then
-                         begin
-                          mousehide;
-                          for i:=140 to 193 do
-                           move(asdisplay^[i],screen[i,201],114);
-                          mouseshow;
-                          displaytargetinfo2;
-                         end;
-                        displaymap;
-                       end;
-             176..197: begin engaging:=true; done:=true; end;
-            end;
-  161..171: case mouse.y of
-             141..157: if range<5000000 then
-                        begin
-                         displaymap;
-                         inc(range,5000);
-                         str(range:7,str1);
-                         printxy(99,122,str1);
-                         displaymap;
-                        end;
-             159..174: begin
-                        displaymap;
-                        dec(targetindex);
-                        while (targetindex>0) and (ships^[targetindex].hulldamage=0) do dec(targetindex);
-                        if (targetindex=0) then
-                         begin
-                          targetindex:=nships;
-                          while (targetindex>0) and (ships^[targetindex].hulldamage=0) do dec(targetindex);
-                         end;
-                        if not weapondisplay then
-                         begin
-                          mousehide;
-                          for i:=140 to 193 do
-                           move(asdisplay^[i],screen[i,201],114);
-                          mouseshow;
-                          displaytargetinfo2;
-                         end;
-                        displaymap;
-                       end;
-             176..197: begin engaging:=true; done:=true; end;
-            end;
-  173..193: case mouse.y of
-             141..157: if not scanning then
-                        begin
-                         scanning:=true;
-                         mousehide;
-                         for i:=132 to 135 do screen[i,207]:=63;
-                         mouseshow;
-                        end
-                       else
-                        begin
-                         scanning:=false;
-                         mousehide;
-                         for i:=132 to 135 do screen[i,207]:=95;
-                         mouseshow;
-                        end;
-            end;
-  203..222: if weapondisplay then
-             case mouse.y of
-              144..164: fireweapon:=1;
-              169..189: fireweapon:=6;
-             end;
-  225..245: if weapondisplay then
-             case mouse.y of
-              144..164: fireweapon:=2;
-              169..189: fireweapon:=7;
-             end;
-  247..267: if weapondisplay then
-             case mouse.y of
-              144..164: fireweapon:=3;
-              169..189: fireweapon:=8;
-             end;
-  269..289: if weapondisplay then
-             case mouse.y of
-              144..164: fireweapon:=4;
-              169..189: fireweapon:=9;
-             end;
- end;
-end;
-
-procedure processkey;
-var ans: char;
-begin
- ans:=readkey;
- case upcase(ans) of
-  '`': bossmode;
- end;
-end;
-
-procedure mainloop;
-var index: integer;
-begin
- index:=0;
- displaymap;
- repeat
-  findmouse;
-  if fastkeypressed then processkey;
-  inc(index);
-  if index=8 then
-   begin
-    suckpower;
-    index:=0;
-    displaymap;
-    moveships;
-    displaymap;
-   end;
-  displaystats;
-  displaytargetinfo;
-  powerup;
-  delay(tslice*7);
- until done;
-end;
-
-procedure getshipinfo(n,j: integer);
-var f: file of alienshiptype;
-    i: integer;
-begin
- if ship.wandering.alienid>2000 then i:=ship.wandering.alienid-2000 else i:=0;
- assign(f,'data\ships.dta');
- reset(f);
- if ioresult<>0 then errorhandler('ships.dta',5);
- seek(f,j+i*11);
- if ioresult<>0 then errorhandler('ships.dta',5);
- read(f,ships^[n]);
- if ioresult<>0 then errorhandler('ships.dta',5);
- close(f);
-end;
-
-procedure readyships;
-var f: file of alientype;
-    t: alientype;
-begin
- nships:=0;
- assign(f,tempdir+'\contacts.dta');
- reset(f);
- if ioresult<>0 then errorhandler(tempdir+'\contacts.dta',1);
- repeat
-  read(f,t);
-  if ioresult<>0 then errorhandler(tempdir+'\contacts.dta',5);
- until t.id=ship.wandering.alienid;
- close(f);
- tcolor:=95;
- printxy(4,142,t.name);
- a:=t.victory;
- if a=0 then a:=1;
- repeat
-  inc(nships);
-  with ships^[nships] do
-   begin
-    if a<11 then c:=random(a)+1
-     else c:=random(11)+1;
-    getshipinfo(nships,c);
-    dec(a,c);
-    relx:=ship.wandering.relx*1000-500+random(1000);
-    rely:=ship.wandering.rely*1000-500+random(1000);
-    relz:=ship.wandering.relz*1000-500+random(1000);
-    if (shield<1502) then shieldlevel:=100;
-   end;
- until (nships=maxships) or (a=0);
-end;
-
-procedure readydata;
-begin
- mousehide;
- compressfile(tempdir+'\current.vga',@screen);
- fading;
- loadscreen('data\war.vga',@screen);
- loadpal('data\war.pal');
- done:=false;
- new(ships);
- new(statpic);
- new(blank);
- new(barpic);
- new(asdisplay);
- new(shieldpic);
- new(shieldpic2);
- for i:=10 to 11 do
-  move(screen[i,80],statpic^[i-10],10);
- for i:=20 to 21 do
-  move(screen[i,267],blank^[i-20],10);
- for i:=0 to 3 do
-  mymove(screen[i+10,100],barpic^[i],1);
- for i:=0 to 6 do
-  mymove(screen[i+10,110],shieldpic^[i],1);
- for i:=0 to 6 do
-  mymove(screen[i+10,120],shieldpic2^[i],1);
- for i:=6 to 20 do
-  fillchar(screen[i,72],177,0);
- tcolor:=95;
- bkcolor:=0;
- oldt1:=t1;
- targetindex:=1;
- if ship.options[4]=0 then
-  begin
-   autofire:=true;
-   scanning:=true;
-   for i:=132 to 135 do screen[i,207]:=63;
-   for i:=132 to 135 do screen[i,112]:=63;
-  end
- else
-  begin
-   autofire:=false;
-   scanning:=false;
-   for i:=132 to 135 do screen[i,207]:=95;
-   for i:=132 to 135 do screen[i,112]:=95;
-  end;
- stats[1]:=0;
- stats[2]:=0;
- stats[3]:=0;
- oldshddmg:=0;
- fireweapon:=0;
- engaging:=false;
- range:=60000;
- printxy(99,122,'  600000 KM.R.');
- for j:=1 to 10 do
-  begin
-   poweredup[j]:=-1;
-   if ship.armed then poweredup[j]:=99 else poweredup[j]:=0;
-   if ship.gunnodes[j]=0 then poweredup[j]:=-1;
-  end;
- for i:=140 to 193 do
-  move(screen[i,201],asdisplay^[i],114);
- for j:=1 to 4 do bar[j]:=0;
- for j:=1 to 3 do stats[j]:=0;
- displayweapons;
- displaystats;
- displaydamage;
- displayshieldpic(ship.shieldopt[3]);
- readyships;
- displaytargetinfo;
- mouseshow;
- fadein;
-end;
-
-procedure savevictories;
-var f: file of alientype;
-    t: alientype;
-begin
- assign(f,tempdir+'\contacts.dta');
- reset(f);
- if ioresult<>0 then errorhandler(tempdir+'\contacts.dta',1);
- i:=-1;
- repeat
-  inc(i);
-  read(f,t);
-  if ioresult<>0 then errorhandler(tempdir+'\contacts.dta',4);
- until t.id=ship.wandering.alienid;
- seek(f,i);
- if ioresult<>0 then errorhandler(tempdir+'\contacts.dta',4);
- inc(t.victory,nships);
- inc(t.defeat,nships);
- if t.victory>20000 then t.victory:=20000;
- write(f,t);
- if ioresult<>0 then errorhandler(tempdir+'\contacts.dta',4);
- close(f);
-end;
-
-procedure aftereffects;
-var cargoitems: array[0..15] of integer;
-begin
- mousehide;
- for i:=6 to 120 do
-  fillchar(screen[i,72],178,0);
- for i:=140 to 193 do
-  fillchar(screen[i,201],114,0);
- tcolor:=95;
- printxy(78,8,'VICTORY!');
- mouseshow;
- if yesnorequest('DEPLOY SCAVENGER BOTS?',0,31) then
-  begin
-   mousehide;
-   tcolor:=22;
-   bkcolor:=0;
-   printxy(78,18,'SCAVENGER BOTS DEPLOYED...');
-   tcolor:=28;
-   fillchar(cargoitems,11,0);
-   i:=nships+random(2);
-   if i>15 then i:=15;
-   a:=1;
-   while cargo[a].index<>3000 do inc(a);
-   for j:=0 to i do
-    begin
-     cargoitems[j]:=random(21);
-     printxy(84,28+j*6,cargo[a+cargoitems[j]].name);
-     addcargo2(cargoitems[j]+3000);
-    end;
-   mouseshow;
-   while fastkeypressed do readkey;
-   readkey;
-  end;
- savevictories;
-end;
-
-procedure initiatecombat;
-begin
- readydata;
- mainloop;
- dispose(statpic);
- dispose(blank);
- dispose(ships);
- dispose(asdisplay);
- dispose(barpic);
- dispose(shieldpic);
- dispose(shieldpic2);
- if not engaging then aftereffects;
- removedata;
- if (engaging) and (targetready) then
-  engage(systems[nearby[target].index].x,systems[nearby[target].index].y,systems[nearby[target].index].z)
-  else if engaging then
-   begin
-    targetready:=true;
-    engage(ship.posx-10+random(20),ship.posy-10+random(20),ship.posz-10+random(20));
-   end;
-end;
-
-begin
-end.
\ No newline at end of file
diff --git a/makedata/comm.pas b/makedata/comm.pas
deleted file mode 100644
index dd966e5..0000000
--- a/makedata/comm.pas
+++ /dev/null
@@ -1,1514 +0,0 @@
-unit comm;
-
-{***************************
-   Communication unit for IronSeed
-
-   Channel 7
-   Destiny: Virtual
-
-
-   (C) DEC. 31, 1993
-
-***************************}
-
-{$O+}
-
-interface
-
-procedure initialcontact;
-procedure conversewithcrew;
-procedure continuecontact;
-
-implementation
-
-uses crt, data, gmouse, utils, combat, utils2, weird;
-
-const
- numback= 14;
-type
- localalienarray= array[1..6] of alientype;
- infodisplay= array[20..105,222..302] of byte;
-var
- commlevel,i,j,techlvl,eattype,contactindex,cursorx,index: integer;
- alien: ^alientype;
- temp: ^conversetype;
- brighter,infomode: boolean;
- str1, str2: ^string;
- question: string[20];
- c: ^conversearray;
- r: ^responsearray;
- locals: ^localalienarray;
- tmpm: ^mouseicontype;
- t: ^infodisplay;
-
-procedure gettechlevel(plan: integer);
-var i: integer;
-begin
- techlvl:=-2;
- case tempplan^[plan].system of
-  93,138,78,191,171,221,45:
-    begin
-     techlvl:=6*256;
-     exit;
-    end;
- end;
- case tempplan^[plan].state of
-  2: case tempplan^[plan].mode of
-      2: techlvl:=-1;
-      3: techlvl:=tempplan^[plan].age div 15000000;
-     end;
-  3: begin
-      techlvl:=(tempplan^[plan].mode-1)*256;
-      case tempplan^[plan].mode of
-       1: techlvl:=techlvl+tempplan^[plan].age div 1500000;
-       2: techlvl:=techlvl+tempplan^[plan].age div 1000;
-       3: techlvl:=techlvl+tempplan^[plan].age div 800;
-      end;
-     end;
-  4: begin
-      techlvl:=(tempplan^[plan].mode+2)*256;
-      case tempplan^[plan].mode of
-       1: techlvl:=techlvl+tempplan^[plan].age div 400;
-       2: techlvl:=techlvl+tempplan^[plan].age div 200;
-      end;
-     end;
-  5: case tempplan^[plan].mode of
-      1: begin
-          i:=tempplan^[plan].age div 100000000;
-          if i>9 then i:=9;
-          techlvl:=techlvl+i;
-         end;
-      2: techlvl:=-1;
-     end;
-  6: if tempplan^[curplan].mode=2 then techlvl:=6*256;   {void dwellers}
- end;
- i:=random(9);                              { junk first random number }
- eattype:=random(3);
- randomize;
-end;
-
-procedure sprinkle(x1,y1,x2,y2,seed: integer);
-var total,j,max: word;
-begin
- max:=(x2-x1)*(y2-y1);
- total:=0;
- j:=0;
- repeat
-  inc(total);
-  j:=j+seed;
-  if j>max then j:=j-max;
-  screen[y1+j div (x2-x1),x1+j mod (x2-x1)]:=0;
-  if total mod 50=0 then delay(x div 3);
-  until total>max;
-end;
-
-procedure getname;
-type nametype= string[15];
-var str1: nametype;
-    f: file of nametype;
-    n: integer;
-begin
- n:=contactindex-tempplan^[contactindex].system;
- assign(f,'data\planname.txt');
- reset(f);
- if ioresult<>0 then errorhandler('data\planname.txt',1);
- seek(f,n);
- if ioresult<>0 then errorhandler('data\planname.txt',6);
- read(f,str1);
- if ioresult<>0 then errorhandler('data\planname.txt',6);
- alien^.name:=str1;
- close(f);
-end;
-
-procedure addtofile;
-var confile,target: file of alientype;
-    err,add: boolean;
-    temp: alientype;
-    index: integer;
-begin
- assign(confile,'save\contacts.dta');
- reset(confile);
- if ioresult<>0 then errorhandler('contacts.dta',1);
- err:=false;
- add:=false;
- index:=-1;
- repeat
-  inc(index);
-  read(confile,temp);
-  if ioresult<>0 then err:=true;
-  if (not err) and (temp.id=alien^.id) then
-   begin
-    seek(confile,index);
-    if ioresult<>0 then errorhandler('contacts.dta',5);
-    write(confile,alien^);
-    if ioresult<>0 then errorhandler('contacts.dta',5);
-    add:=true;
-   end;
- until (err) or (add);
- if not add then
-  begin
-   seek(confile,index);
-   if ioresult<>0 then errorhandler('contacts.dta',5);
-   write(confile,alien^);
-   if ioresult<>0 then errorhandler('contacts.dta',5);
-  end;
- close(confile);
-end;
-
-procedure getspecial(n: integer);
-var f: file of alientype;
-begin
- assign(f,'data\contact0.dta');
- reset(f);
- if ioresult<>0 then errorhandler('data\contact0.dta',1);
- seek(f,n-1);
- if ioresult<>0 then errorhandler('data\contact0.dta',5);
- read(f,alien^);
- if ioresult<>0 then errorhandler('data\contact0.dta',5);
- alien^.id:=contactindex;
- case n of
-   1: i:=103;
-   2: i:=102;
-   3: i:=114;
-   4: i:=106;
-   5: i:=111;
-   6: i:=107;
-   7: i:=113;
-   8: i:=110;
-   9: i:=104;
-  10: i:=105;
-  11: i:=101;
-  else errorhandler('Nutty event in setting special...',6);
- end;
- runevent(i);
-end;
-
-procedure setalienstructure(starting: integer);
-begin
- case tempplan^[contactindex].system of
-   93: getspecial(1);
-  138: getspecial(2);
-   45: getspecial(4);
-  221: getspecial(5);
-   78: getspecial(6);
-  171: getspecial(8);
-  191: getspecial(9);
-  else
-   begin
-    alien^.conindex:=0;
-    getname;
-    x:=hi(techlvl);
-    y:=lo(techlvl);
-    with alien^ do
-     begin
-      y:=y-5;
-      if y<0 then
-       begin
-        dec(x);
-        y:=10+y;
-       end;
-      if x<0 then
-       begin
-        x:=0;
-        y:=0;
-       end;
-      techmin:=x*256+y;
-      y:=lo(techlvl);
-      y:=y+5;
-      if y>9 then
-       begin
-        inc(x);
-        y:=y-10;
-       end;
-      if x>5 then
-       begin
-        x:=5;
-        y:=0;
-       end;
-      techmax:=x*256+y;
-      id:=contactindex;
-      victory:=0;
-      defeat:=0;
-      war:=false;
-      case starting of
-       1: begin
-           if random(3)=0 then war:=true;
-           congeniality:=15;
-           anger:=30;
-           createwandering(0,alien^);
-          end;
-       2: begin
-           congeniality:=20;
-           anger:=10;
-          end;
-       3: begin
-           congeniality:=40;
-           anger:=0;
-          end;
-       4: begin
-           congeniality:=20;
-           anger:=15;
-          end;
-       5: begin
-           congeniality:=5;
-           anger:=0;
-           createwandering(1,alien^);
-          end;
-      end;
-     end;
-   end;
- end;
- addtofile;
-end;
-
-procedure contactsequence(com: integer);
-var a,b,index,contactmade: integer;
-    t: ^char;
-begin
- mousehide;
- for i:=23 to 56 do
-  fillchar(screen[i,194],118,0);
- tcolor:=47;
- printxy(194,23,'SCANNING EM BANDS');
- for a:=1 to 2000 do
-  begin
-   t1:=t1+0.01;
-   if t1=6.28 then t1:=0;
-   for b:=0 to 34 do
-    begin
-     j:=abs(round(20*(sin(b*0.09+t1))));
-     x:=20;
-     for i:=0 to j do
-      begin
-       screen[55-j,b*3+199]:=x;
-       screen[55-j,b*3+200]:=x;
-      end;
-     screen[54-j,b*3+199]:=0;
-     screen[54-j,b*3+200]:=0;
-    end;
-  end;
- sprinkle(194,30,311,56,17);
- printxy(194,23,'AQUIRING TRANSMISSION');
- wait(2);
- printxy(194,23,'ANALYZING DATA STREAM');
- y:=0;
- x:=0;
- for a:=1 to 5000 do
-  begin
-   printxy(x*5+194,y*6+31,chr(48+random(2)));
-   inc(x);
-   if x>20 then
-    begin
-     x:=0;
-     inc(y);
-     if y>3 then y:=0;
-    end;
-   delay(tslice div 10);
-  end;
- sprinkle(194,30,311,56,17);
- printxy(194,23,'INITIALIZE CYPHER KEY');
- t:=ptr(random(1000),0);
- for a:=1 to 5000 do
-  begin
-   inc(t);
-   printxy(x*5+194,y*6+31,t^);
-   inc(x);
-   if x>20 then
-    begin
-     x:=0;
-     inc(y);
-     if y>3 then y:=0;
-    end;
-   delay(tslice div 10);
-  end;
- sprinkle(194,30,311,56,17);
- printxy(194,23,'MATRIX ESTABLISHED   ');
- for i:=29 to 55 do
-  fillchar(screen[i,194],118,0);
- wait(1);
- printxy(194,29,'TRANSFERING CYPHER');
- wait(1);
- gettechlevel(contactindex);
- if techlvl<1 then
-  begin
-   printxy(194,35,'UNINTELLIGIBLE CYPHER');
-   tcolor:=94;
-   printxy(194,41,'CONTACT FAILURE');
-   mouseshow;
-   exit;
-  end;
- contactmade:=0;
- if (hi(techlvl)<4) then
-  case eattype of
-   0: if random(5)=0 then contactmade:=1;
-   1: case com of
-       0: contactmade:=5;
-       1: contactmade:=3;
-       2: contactmade:=2;
-      end;
-   2: if random(2)=0 then contactmade:=random(5)
-   end
-  else
-   case eattype of
-    0: case com of
-        0: if random(2)=0 then contactmade:=1 else contactmade:=3;
-        1: contactmade:=2+random(2);
-        2: contactmade:=2;
-       end;
-    1: case com of
-        0: contactmade:=4;
-        1: contactmade:=2+random(2);
-	2: contactmade:=2;
-       end;
-    2: if random(2)=0 then contactmade:=random(5);
-   end;
- if contactmade>0 then
-  begin
-   tempplan^[contactindex].notes:=tempplan^[contactindex].notes or 2;
-   setalienstructure(contactmade);
-  end;
- printxy(194,35,'CYPHER ACKNOWLEDGED');
- wait(1);
- printxy(194,41,'AWAITING RESPONSE');
- wait(1);
- if contactmade>0 then
-  printxy(194,47,'CONTACT ESTABLISHED')
- else
-  begin
-   tcolor:=94;
-   printxy(194,47,'NO RESPONSE');
-  end;
- mouseshow;
-end;
-
-procedure showoptions;
-var str1: string[3];
-    a: integer;
-begin
- tcolor:=26;
- mousehide;
- for i:=125 to 189 do
-  fillchar(screen[i,15],278,0);
- case commlevel of
-  0: begin
-      printxy(15,125,'ESTABLISH INITIAL CONTACT WITH ALIENS');
-      if (not showplanet) or (ship.orbiting=0) or (testbit(tempplan^[curplan].notes,1)) then tcolor:=10;
-      printxy(25,135,'1. PLANET: SONIC/VISUAL/RADIO');
-      if (not showplanet) then tcolor:=8 else tcolor:=26;
-      printxy(25,145,'2. SYSTEM: RADIO/SUBSPACE');
-     end;
-  1: begin
-      printxy(20,125,'ESTABLISH POSTURE');
-      printxy(25,135,'1. HOSTILE');
-      printxy(25,145,'2. FRIENDLY');
-      printxy(25,155,'3. SERVILE');
-     end;
-  2: begin
-      printxy(15,125,'CONTACT ALIENS ON NEARBY PLANET');
-      y:=1;
-      a:=1;
-      j:=findfirstplanet(tempplan^[curplan].system);
-      inc(j);
-      if tempplan^[j].system=tempplan^[curplan].system then
-       repeat
-        gettechlevel(j);
-        if (hi(techlvl)>=3) and (not testbit(tempplan^[j].notes,1))
-         and (lo(techlvl)<10) then
-         begin
-          printxy(25,125+y*10,chr(48+y)+'.');
-          printplanet(40,125+y*10,tempplan^[curplan].system,a);
-          str(hi(techlvl),str1);
-          printxy(110,125+y*10,'INDUSTRIAL LEVEL '+str1);
-          inc(y);
-         end;
-        inc(j);
-        inc(a);
-       until tempplan^[j].system<>tempplan^[curplan].system;
-      if y=1 then printxy(25,135,'NO NEARBY ALIENS DETECTED.');
-     end;
- end;
- mouseshow;
-end;
-
-procedure command(com: integer);
-var contactmade: integer;
-begin
- case commlevel of
-  0: case com of
-      1: begin
-          if (not showplanet) or (ship.orbiting=0)
-           or (testbit(tempplan^[curplan].notes,1)) then exit;
-          commlevel:=1;
-          contactindex:=curplan;
-          showoptions;
-         end;
-      2: begin
-          if not showplanet then exit;
-          commlevel:=2;
-          showoptions;
-         end;
-     end;
-  1: begin
-      if (com>3) then exit;
-      contactsequence(com-1);
-      commlevel:=0;
-      showoptions;
-     end;
-  2: begin
-      y:=0;
-      j:=findfirstplanet(tempplan^[curplan].system);
-      inc(j);
-      if tempplan^[j].system=tempplan^[curplan].system then
-       repeat
-        gettechlevel(j);
-        if (hi(techlvl)>=3) and (not testbit(tempplan^[j].notes,1))
-         and (lo(techlvl)<10) then
-         inc(y);
-        inc(j);
-       until (tempplan^[j].system<>tempplan^[curplan].system) or (y=com);
-      if y<>com then
-       begin
-        commlevel:=0;
-        showoptions;
-        exit;
-       end;
-      contactindex:=j-1;
-      commlevel:=1;
-      showoptions;
-     end;
- end;
-end;
-
-procedure findmouse;
-var button: boolean;
-begin
- if mouse.getstatus(left) then button:=true else button:=false;
- if not button then exit;
- case mouse.x of
-  308..317: if (mouse.y>142) and (mouse.y<167) then done:=true;
-   15..290: case mouse.y of
-             135..141: command(1);
-             145..151: command(2);
-             155..161: command(3);
-             165..171: command(4);
-             175..181: command(5);
-             185..191: command(6);
-            end;
- end;
- idletime:=0;
-end;
-
-procedure processkey;
-var ans: char;
-begin
- ans:=readkey;
- case ans of
-  #27: if commlevel<>0 then
-        begin
-         commlevel:=0;
-         showoptions;
-        end
-       else done:=true;
-  '1'..'6': command(ord(ans)-48);
-  '`': bossmode;
- end;
- idletime:=0;
-end;
-
-procedure mainloop;
-begin
- repeat
-  if fastkeypressed then processkey;
-  findmouse;
-  inc(idletime);
-  if idletime=maxidle then screensaver;
-  adjustlights;
-  delay(tslice*9);
- until done;
-end;
-
-procedure readydata;
-begin
- mousehide;
- savescreen;
- fading;
- loadscreen('data\com.vga');
- loadpal('data\com.pal');
- for i:=10 to 110 do
-  for j:=0 to 319 do
-   if (screen[i,j]=255) and ((i+j) mod 2=0) then screen[i,j]:=8
-    else if (screen[i,j]=255) then screen[i,j]:=0;
- new(tmpm);
- for i:=0 to 15 do
-  begin
-   mymove(screen[i+130,20],tmpm^[i],4);
-   fillchar(screen[i+130,20],16,0);
-  end;
- mousesetcursor(tmpm^);
- dispose(tmpm);
- new(alien);
- oldt1:=t1;
- bkcolor:=0;
- tcolor:=31;
- done:=false;
- commlevel:=0;
- fadein;
- mouseshow;
-end;
-
-procedure initialcontact;
-begin
- readydata;
- showoptions;
- mainloop;
- dispose(alien);
- mouse.setmousecursor(2);
- removedata;
-end;
-
-{***************************************************************************}
-
-procedure loadconversation;
-var fc: file of converseindex;
-    fr: file of responsetype;
-    s: string[2];
-    str1: string[4];
-begin
- fillchar(r^,sizeof(responsearray),0);
- fillchar(c^,sizeof(conversearray),0);
- str((contactindex+1):4,str1);
- if contactindex<1000 then str1[1]:='0';
- if contactindex<100 then str1[2]:='0';
- if contactindex<10 then str1[3]:='0';
- assign(fc,'data\conv'+str1+'.ind');
- reset(fc);
- if ioresult<>0 then errorhandler('conv'+str1+'.ind',1);
- i:=0;
- repeat
-  inc(i);
-  read(fc,c^[i]);
- until ioresult<>0;
- close(fc);
- assign(fr,'data\conv'+str1+'.dta');
- reset(fr);
- if ioresult<>0 then errorhandler('conv'+str1+'.dta',1);
- i:=0;
- repeat
-  inc(i);
-  read(fr,r^[i]);
- until ioresult<>0;
- close(fr);
-end;
-
-procedure showportrait(n: integer);
-var datafile: file of portraittype;
-    s: string[2];
-    portrait: ^portraittype;
-begin
- new(portrait);
- str(n:2,s);
- if n<10 then s[1]:='0';
- assign(datafile,'data\image'+s+'.vga');
- if ioresult<>0 then errorhandler('portrait',1);
- reset(datafile);
- if ioresult<>0 then errorhandler('portrait',5);
- read(datafile,portrait^);
- close(datafile);
- for i:=0 to 34 do
-  begin
-   move(portrait^[i*2],screen[i*2+41,126],70);
-   delay(tslice div 5);
-  end;
- for i:=0 to 34 do
-  begin
-   move(portrait^[i*2+1],screen[i*2+42,126],70);
-   delay(tslice div 5);
-  end;
- dispose(portrait);
-end;
-
-procedure drawcursor;
-begin
- for i:=(contactindex mod 3)*30+37 to (contactindex mod 3)*30+42 do
-  for j:=(contactindex div 3)*138+89 to (contactindex div 3)*138+93 do
-   if screen[i,j] div 16=3 then screen[i,j]:=screen[i,j]+32;
- showportrait(ship.crew[contactindex+1].index);
-end;
-
-procedure erasecursor;
-begin
- for i:=(contactindex mod 3)*30+37 to (contactindex mod 3)*30+42 do
-  for j:=(contactindex div 3)*138+89 to (contactindex div 3)*138+93 do
-   if screen[i,j] div 16=5 then screen[i,j]:=screen[i,j]-32;
-end;
-
-procedure displaycrewnames;
-var a,b: integer;
-begin
- t1:=22/36;
- for a:=0 to 5 do
-  begin
-   i:=1;
-   repeat
-    printxy((a div 3)*230+12+i*5,(a mod 3)*30+37,ship.crew[a+1].name[i]);
-    inc(i);
-   until ship.crew[a+1].name[i]=' ';
-   j:=round((0.40*ship.crew[a+1].men+0.60*ship.crew[a+1].emo-0.20*ship.crew[a+1].phy)*0.36);
-   if j>36 then j:=36
-   else if j<1 then j:=0;
-   for b:=0 to j do
-    begin
-     screen[(a mod 3)*30+48,(a div 3)*258+b+13]:=round(t1*b)+73;
-     screen[(a mod 3)*30+49,(a div 3)*258+b+13]:=round(t1*b)+73;
-    end;
-   if j<34 then
-    for b:=j+1 to 36 do
-     begin
-     screen[(a mod 3)*30+48,(a div 3)*258+b+13]:=0;
-     screen[(a mod 3)*30+49,(a div 3)*258+b+13]:=0;
-    end;
-  end;
-end;
-
-procedure command2(n: integer);
-begin
- mousehide;
- for i:=135 to 189 do
-  fillchar(screen[i,15],278,0);
- printxy(12,182,'SUBJECT:');
- if contactindex>-1 then erasecursor;
- contactindex:=n;
- drawcursor;
- showportrait(ship.crew[contactindex+1].index);
- mouseshow;
- loadconversation;
-end;
-
-procedure findmouse2;
-begin
- if not mouse.getstatus(left) then exit;
- case mouse.y of
-    30..50: case mouse.x of
-                9..85: if contactindex<>0 then command2(0);
-             235..311: if contactindex<>3 then command2(3);
-            end;
-    60..80: case mouse.x of
-                9..85: if contactindex<>1 then command2(1);
-             235..311: if contactindex<>4 then command2(4);
-            end;
-   90..110: case mouse.x of
-                9..85: if contactindex<>2 then command2(2);
-             235..311: if contactindex<>5 then command2(5);
-            end;
-  154..170: if mouse.x>309 then done:=true;
- end;
- idletime:=0;
-end;
-
-procedure printxy2(x1,y1,m,n,o: integer; s: string);
-var letter,j2,a,index,t: integer;
-label skipit;
-begin
- t:=tcolor;
- brighter:=false;
- j2:=0;
- for j:=1 to length(s) do
-  begin
-   if s[j]=#200 then
-    begin
-     if brighter then brighter:=false else brighter:=true;
-     goto skipit;
-    end;
-   letter:=ord(s[j]);
-   if (brighter) then
-    case ship.options[4] of
-     0: tcolor:=m;
-     1: tcolor:=n;
-     2: tcolor:=o;
-    end
-    else tcolor:=o;
-   bkcolor:=m;
-   inc(j2);
-   index:=1;
-   for i:=1 to 6 do
-    begin
-     for a:=4 to 7 do
-      if testbit(font[letter,index],a) then screen[y1+i,x1+j2*5+7-a]:=tcolor
-       else if bkcolor<255 then screen[y1+i,x1+j2*5+7-a]:=bkcolor;
-     dec(tcolor,2);
-     inc(i);
-     for a:=0 to 3 do
-      if testbit(font[letter,index],a) then screen[y1+i,x1+j2*5+3-a]:=tcolor
-       else if bkcolor<255 then screen[y1+i,x1+j2*5+3-a]:=bkcolor;
-     inc(index);
-     dec(tcolor,2);
-    end;
-   for i:=1 to 6 do screen[y1+i,x1+j2*5+4]:=bkcolor;
-   delay(tslice div 3);
-   index:=1;
-   bkcolor:=0;
-   if (brighter) then
-    case ship.options[4] of
-     0: tcolor:=m;
-     1: tcolor:=n;
-     2: tcolor:=o;
-    end
-    else tcolor:=o;
-   for i:=1 to 6 do
-    begin
-     for a:=4 to 7 do
-      if testbit(font[letter,index],a) then screen[y1+i,x1+j2*5+7-a]:=tcolor
-       else if bkcolor<255 then screen[y1+i,x1+j2*5+7-a]:=bkcolor;
-     dec(tcolor,2);
-     inc(i);
-     for a:=0 to 3 do
-      if testbit(font[letter,index],a) then screen[y1+i,x1+j2*5+3-a]:=tcolor
-       else if bkcolor<255 then screen[y1+i,x1+j2*5+3-a]:=bkcolor;
-     inc(index);
-     dec(tcolor,2);
-    end;
-   for i:=1 to 6 do screen[y1+i,x1+j2*5+4]:=bkcolor;
-skipit:
-  end;
- tcolor:=t;
-end;
-
-function parsestatement(y,n,p,q,s: integer): integer;
-var done: boolean;
-    a,b,c,i2,letter: integer;
-begin
- str1^:=r^[n].response;
- i:=1;
- j:=1;
- repeat
-  if str1^[i]=#201 then
-   begin
-    inc(i);
-    a:=ord(str1^[i])+35-48;
-    b:=20;
-    while ship.crew[a].name[b]=' ' do dec(b);
-    for c:=1 to b do
-     begin
-      letter:=ord(ship.crew[a].name[c]);
-      case chr(letter) of
-       ' ' ..'"': letter:=letter-31;
-       ''''..'?': letter:=letter-35;
-       'A' ..'Z': letter:=letter-36;
-       else letter:=1;
-      end;
-      str2^[j]:=chr(letter);
-      inc(j);
-     end;
-    dec(j);
-   end
-  else str2^[j]:=str1^[i];
-  inc(j);
-  inc(i);
- until i>ord(str1^[0]);
- str2^[0]:=chr(j-1);
- done:=false;
- repeat
-  str1^:=str2^;
-  i:=56;
-  if ord(str1^[0])>56 then
-   begin
-    while str1^[i]<>#1 do dec(i);
-    str2^:=copy(str1^,i+1,ord(str1^[0])-i);
-    str1^[0]:=chr(i-1);
-   end else done:=true;
-  printxy2(12,135+y*6,p,q,s,str1^);
-  inc(y);
-  if y=8 then
-   begin
-    tcolor:=207;
-    printxy(146,191,'MORE');
-    i2:=4;
-    mouseshow;
-    repeat
-     for j:=183 to 188 do
-      fillchar(screen[j,15],288,0);
-     inc(i2);
-     if i2=28 then i2:=4;
-     if i2<16 then
-      for j:=192 to 207 do
-       colors[j,2]:=round((j-191)/16*4*i2)
-     else
-      for j:=192 to 207 do
-       colors[j,2]:=round((j-191)/16*4*(31-i2));
-     set256colors(colors);
-     delay(tslice*5);
-    until (fastkeypressed) or (mouse.getstatus(left));
-    while fastkeypressed do readkey;
-    mousehide;
-    printxy(146,191,'    ');
-    tcolor:=s;
-    y:=1;
-    for j:=141 to 188 do
-     fillchar(screen[j,15],288,0);
-   end;
- until done;
- parsestatement:=y;
-end;
-
-procedure checkstring(p,q,s: integer);
-var index,index2,i,i2: integer;
-begin
- mousehide;
- for i:=135 to 181 do
-  fillchar(screen[i,15],288,0);
- for i:=182 to 187 do
-  fillchar(screen[i,61],100,0);
- tcolor:=s;
- printxy(12,135,question);
- i:=20;
- while question[i]=' ' do dec(i);
- if i=0 then
-  begin
-   mouseshow;
-   exit;
-  end;
- question[0]:=chr(i);
- for j:=1 to i do
-  case question[j] of
-   ' ' ..'"': question[j]:=chr(ord(question[j])-31);
-   ''''..'?': question[j]:=chr(ord(question[j])-35);
-   'A' ..'Z': question[j]:=chr(ord(question[j])-36);
-   '%': question[j]:=#55;
-   else question[j]:=#1;
-  end;
- index:=0;
- repeat
-  inc(index);
-  j:=pos(#1+question+#1,c^[index].keyword);
- until ((j>0) and (checkevent(c^[index].event))) or (c^[index].rcode=0);
- runevent(c^[index].runevent);
- fillchar(question,21,ord(' '));
- question[0]:=#20;
- cursorx:=1;
- if j=0 then
-  begin
-   mouseshow;
-   exit;
-  end;
- i:=1;
- while r^[i].index<>c^[index].index do inc(i);
- case c^[index].rcode of
-  1: parsestatement(1,i,p,q,s);
-  2: begin
-      j:=1;
-      while r^[i+j].index=c^[index].index do inc(j);
-      parsestatement(1,i+random(j),p,q,s);
-     end;
-  3: begin
-      index2:=i;
-      i2:=1;
-      repeat
-       i2:=parsestatement(i2,index2,p,q,s);
-       inc(index2);
-      until r^[i].index<>r^[index2].index;
-      printxy(12,182,'SUBJECT:');
-     end;
- end;
- if (c^[index].runevent=20000) or (c^[index].index=2) then
-  begin
-   for i:=182 to 187 do
-    fillchar(screen[i,12],200,0);
-   contactindex:=-1;
-  end;
- mouseshow;
-end;
-
-procedure processkey2;
-var ans: char;
-    old: integer;
-begin
- ans:=upcase(readkey);
- tcolor:=31;
- case ans of
-  'A'..'Z',' ','0'..'9','''','-': if contactindex>-1 then
-        begin
-         if cursorx<20 then
-          begin
-           for j:=20 downto cursorx do question[j]:=question[j-1];
-           question[cursorx]:=ans;
-           inc(cursorx);
-          end else question[cursorx]:=ans;
-         mousehide;
-         printxy(57,182,question);
-         mouseshow;
-        end;
-   #8: if contactindex>-1 then
-        begin
-         if cursorx>1 then dec(cursorx);
-         for j:=cursorx to 19 do question[j]:=question[j+1];
-         question[20]:=' ';
-         mousehide;
-         printxy(57,182,question);
-         mouseshow;
-        end;
-   #0: if contactindex>-1 then
-        begin
-         ans:=readkey;
-         case ans of
-          #77: if cursorx<20 then inc(cursorx);
-          #75: if cursorx>1 then dec(cursorx);
-          #83: begin
-                for j:=cursorx to 19 do question[j]:=question[j+1];
-                mousehide;
-                printxy(57,182,question);
-                mouseshow;
-               end;
-         end;
-        end;
-  #13: if contactindex>-1 then
-        begin
-         old:=contactindex;
-         checkstring(95,176,170);
-         if contactindex=-1 then
-          begin
-           contactindex:=old;
-           erasecursor;
-           contactindex:=-1;
-          end;
-        end;
-  #27: done:=true;
-  '`': bossmode;
- end;
- idletime:=0;
-end;
-
-procedure mainloop2;
-begin
- repeat
-  if fastkeypressed then processkey2;
-  findmouse2;
-  if idletime=maxidle then screensaver;
-  if contactindex>-1 then
-   begin
-    bkcolor:=95;
-    printxy(cursorx*5+52,182,question[cursorx]);
-    delay(tslice*2);
-    bkcolor:=0;
-    printxy(cursorx*5+52,182,question[cursorx]);
-    delay(tslice*2);
-   end
-  else delay(tslice*4);
- until done;
-end;
-
-procedure readycrewdata;
-begin
- mousehide;
- savescreen;
- fading;
- loadscreen('data\charcom.vga');
- loadpal('data\charcom.pal');
- oldt1:=t1;
- bkcolor:=0;
- tcolor:=170;
- printxy(12,182,'CONVERSE WITH CREW MEMBER:');
- done:=false;
- contactindex:=-1;
- fillchar(question,21,ord(' '));
- question[0]:=#20;
- new(temp);
- new(str1);
- new(str2);
- new(r);
- new(c);
- cursorx:=1;
- displaycrewnames;
- fadein2;
- mouseshow;
-end;
-
-procedure conversewithcrew;
-begin
- readycrewdata;
- mainloop2;
- dispose(str2);
- dispose(str1);
- dispose(temp);
- dispose(c);
- dispose(r);
- removedata;
-end;
-
-{*****************************************************************************}
-
-procedure loadbackground(n: integer);
-var f: file of screentype;
-    str1: string[2];
-    t: ^screentype;
-begin
- new(t);
- str(((n-1) div 2)+1,str1);
- loadpal('data\back'+str1+'.pal');
- set256colors(colors);
- assign(f,'data\back'+str1+'.vga');
- reset(f);
- if ioresult<>0 then errorhandler('back'+str1+'.vga',1);
- read(f,t^);
- if ioresult<>0 then errorhandler('back'+str1+'.vga',5);
- close(f);
- y:=((n-1) mod 2)*100;
- for i:=10 to 110 do
-  for j:=0 to 319 do
-   if (backgr^[i,j]=255) then screen[i,j]:=t^[i-10+y,j];
- dispose(t);
-end;
-
-procedure loadalienpic(n: integer);
-var f: file of screentype;
-    str1: string[2];
-    t: ^screentype;
-    p: ^paltype;
-    fp: file of paltype;
-begin
- str(n,str1);
- new(p);
- assign(fp,'data\alien'+str1+'.pal');
- reset(fp);
- if ioresult<>0 then errorhandler('data\alien'+str1+'.pal',1);
- read(fp,p^);
- if ioresult<>0 then errorhandler('data\alien'+str1+'.pal',5);
- close(fp);
- for j:=160 to 255 do colors[j]:=p^[j];
- set256colors(colors);
- dispose(p);
- new(t);
- assign(f,'data\alien'+str1+'.vga');
- reset(f);
- if ioresult<>0 then errorhandler('alien'+str1+'.vga',1);
- read(f,t^);
- if ioresult<>0 then errorhandler('alien'+str1+'.vga',5);
- close(f);
- for i:=10 to 110 do
-  for j:=0 to 160 do
-   if (backgr^[i,j+70]=255) and (t^[i-10,j]>0) then screen[i,j+70]:=t^[i-10,j];
- dispose(t);
-end;
-
-procedure getshipinfo;
-var confile: file of alientype;
-    done: boolean;
-    temp: alientype;
-    str1: string[11];
-    r: real;
-begin
- assign(confile,'save\contacts.dta');
- reset(confile);
- if ioresult<>0 then errorhandler('contacts.dta',1);
- done:=false;
- repeat
-  read(confile,temp);
-  if ioresult<>0 then done:=true;
-  if (not done) and (temp.id>0) and (temp.id=ship.wandering.alienid) then done:=true;
- until done;
- close(confile);
- printxy(217,20,temp.name);
- printxy(217,20,temp.name);
- printxy(217,30,'VIDCOM');
- printxy(217,40,systems[tempplan^[temp.id].system].name);
- str1:=chr(hi(temp.techmin)+48)+'.'+chr(lo(temp.techmin)+48);
- printxy(217,50,'MIN TECH: '+str1);
- str1:=chr(hi(temp.techmax)+48)+'.'+chr(lo(temp.techmax)+48);
- printxy(217,60,'MAX TECH: '+str1);
- printxy(217,70,'STATUS:');
- if temp.war then printxy(252,70,'WAR')
-  else printxy(252,70,'PEACE');
- if temp.anger=0 then
-  begin
-   if temp.congeniality>20 then i:=3
-    else i:=1;
-  end
- else
-  begin
-   r:=temp.congeniality/temp.anger;
-   if r<0.3 then i:=5
-   else if r<0.7 then i:=4
-   else if round(r)=1 then i:=2
-   else i:=3;
-  end;
- case i of
-  1: str1:='AFRAID';
-  2: str1:='INDIFFERENT';
-  3: str1:='FRIENDLY';
-  4: str1:='ANGRY';
-  5: str1:='VIOLENT';
- end;
- printxy(217,80,str1);
-end;
-
-procedure displayoptions3;
-var done: boolean;
-    j: integer;
-begin
- tcolor:=28;
- mousehide;
- for i:=125 to 189 do
-  fillchar(screen[i,15],278,0);
- case commlevel of
-  -2: begin
-       printxy(15,125,'CONTINUE TRANSACTION WITH ALIENS.');
-       j:=1;
-       while (j<8) and (locals^[j].id<>curplan) do inc(j);
-       if (j<8) and (locals^[j].id=curplan) then tcolor:=26
-        else tcolor:=16;
-       printxy(25,135,'1. PLANET: SONIC/VISUAL/RADIO');
-       j:=1;
-       while (j<8) and (locals^[j].id<32000) do inc(j);
-       if j=1 then tcolor:=16 else tcolor:=26;
-       printxy(25,145,'2. SYSTEM: RADIO/SUBSPACE');
-       if ship.wandering.alienid<16000 then
-        tcolor:=26 else tcolor:=16;
-       printxy(25,155,'3. SHIP HAIL: VIDCOM');
-       tcolor:=28;
-      end;
- -1: begin
-      printxy(15,125,'CONTACT ALIEN:');
-      y:=0;
-      for j:=1 to 6 do
-       if locals^[j].id<32000 then
-        begin
-         inc(y);
-         printxy(25,125+y*10,chr(y+48)+'. '+locals^[j].name);
-        end;
-      if y=0 then printxy(25,135,'NO ALIENS CONTACTED IN SYSTEM.');
-     end;
-  0: begin
-      tcolor:=28;
-      printxy(12,182,'SUBJECT:');
-     end;
-end;
- mouseshow;
-end;
-
-procedure getcontactindex;
-var i: integer;
-begin
- if index=5000 then;          {************************ we got problems!!!!}
- i:=0;
- if locals^[index].conindex=0 then
-  begin
-   i:=1099;
-   loadbackground(random(numback)+1);
-   loadalienpic(12+random(4));
-  end
- else
-  begin
-   i:=locals^[index].conindex;
-   loadbackground(random(numback)+1);
-   loadalienpic(i);
-   i:=i+999;
-  end;
- contactindex:=i;
-end;
-
-procedure command3(com: integer);
-begin
- case commlevel of
-  -2: begin
-       if com>3 then exit;
-       case com of
-        1: begin
-            j:=1;
-            while (j<7) and (locals^[j].id<>curplan) do inc(j);
-            if (j<7) and (locals^[j].id=curplan) then
-             begin
-              index:=j;
-              commlevel:=0;
-              getcontactindex;
-              displayoptions3;
-             end
-            else
-             begin
-              index:=0;
-              commlevel:=-2;
-              displayoptions3;
-             end;
-           end;
-        2: begin
-            j:=1;
-            while (j<7) and (locals^[j].id<32000) do inc(j);
-            if j=1 then commlevel:=-2 else commlevel:=-1;
-            displayoptions3;
-          end;
-        3: if ship.wandering.alienid<16000 then
-            begin
-             commlevel:=0;
-             index:=5000;
-             getcontactindex;
-             displayoptions3;
-            end
-           else
-            begin
-             commlevel:=-2;
-             displayoptions3;
-            end;
-       end;
-      end;
- -1: if locals^[com].id<32000 then
-      begin
-       commlevel:=0;
-       index:=com;
-       getcontactindex;
-       displayoptions3;
-      end;
- end;
- if contactindex>-1 then loadconversation;
-end;
-
-procedure getinfo;
-var str1: string[11];
-    r: real;
-begin
- if infomode then
-  begin
-   infomode:=false;
-   mousehide;
-   for i:=20 to 105 do
-    mymove(t^[i],screen[i,222],20);
-   mouseshow;
-   exit;
-  end;
- if contactindex=0 then exit;
- infomode:=true;
- mousehide;
- for i:=20 to 105 do
-  mymove(screen[i,222],t^[i],20);
- mouseshow;
- tcolor:=31;
- bkcolor:=255;
- if index=5000 then getshipinfo
- else begin
-  printxy(217,20,locals^[index].name);
-  if curplan=locals^[index].id then
-   begin
-    if hi(locals^[index].techmax)>=3 then printxy(217,30,'RADIO')
-     else printxy(217,30,'VISUAL');
-   end
-  else printxy(217,30,'SUBSPACE');
-  printxy(217,40,systems[tempplan^[curplan].system].name);
-  str1:=chr(hi(locals^[index].techmin)+48)+'.'+chr(lo(locals^[index].techmin)+48);
-  printxy(217,50,'MIN TECH: '+str1);
-  str1:=chr(hi(locals^[index].techmax)+48)+'.'+chr(lo(locals^[index].techmax)+48);
-  printxy(217,60,'MAX TECH: '+str1);
-  printxy(217,70,'STATUS:');
-  if locals^[index].war then printxy(252,70,'WAR')
-   else printxy(252,70,'PEACE');
-  if locals^[index].anger=0 then
-   begin
-    if locals^[index].congeniality>20 then i:=3
-     else i:=1;
-   end
-  else
-   begin
-    r:=locals^[index].congeniality/locals^[index].anger;
-    if r<0.3 then i:=5
-    else if r<0.7 then i:=4
-    else if round(r)=1 then i:=2
-    else i:=3;
-   end;
-  case i of
-   1: str1:='AFRAID';
-   2: str1:='INDIFFERENT';
-   3: str1:='FRIENDLY';
-   4: str1:='ANGRY';
-   5: str1:='VIOLENT';
-  end;
-  printxy(217,80,str1);
- end;
-end;
-
-procedure findmouse3;
-var button: boolean;
-begin
- if mouse.getstatus(left) then button:=true else button:=false;
- if not button then exit;
- case mouse.x of
-  308..317: if (mouse.y>142) and (mouse.y<169) then done:=true;
-  247..267: case mouse.y of
-             135..141: command3(1);
-             145..151: command3(2);
-             155..161: command3(3);
-             165..171: command3(4);
-             175..181: command3(5);
-             185..191: command3(6);
-             105..110: if contactindex>0 then getinfo;
-            end;
-   15..290: case mouse.y of
-             135..141: command3(1);
-             145..151: command3(2);
-             155..161: command3(3);
-             165..171: command3(4);
-             175..181: command3(5);
-             185..191: command3(6);
-            end;
- end;
- idletime:=0;
-end;
-
-procedure processkey3;
-var ans: char;
-begin
- ans:=upcase(readkey);
- tcolor:=26;
- case ans of
-  'A'..'Z',' ','0'..'9','''','-': if contactindex>-1 then
-        begin
-         if cursorx<20 then
-          begin
-           for j:=20 downto cursorx do question[j]:=question[j-1];
-           question[cursorx]:=ans;
-           inc(cursorx);
-          end else question[cursorx]:=ans;
-         mousehide;
-         printxy(57,182,question);
-         mouseshow;
-        end;
-   #8: if contactindex>-1 then
-        begin
-         if cursorx>1 then dec(cursorx);
-         for j:=cursorx to 19 do question[j]:=question[j+1];
-         question[20]:=' ';
-         mousehide;
-         printxy(57,182,question);
-         mouseshow;
-        end;
-   #0: if contactindex>-1 then
-        begin
-         ans:=readkey;
-         case ans of
-          #77: if cursorx<20 then inc(cursorx);
-          #75: if cursorx>1 then dec(cursorx);
-          #83: begin
-                for j:=cursorx to 19 do question[j]:=question[j+1];
-                mousehide;
-                printxy(57,182,question);
-                mouseshow;
-               end;
-         end;
-        end;
-  #13: if contactindex>-1 then checkstring(47,31,28);
-  #27: done:=true;
-  '`': bossmode;
- end;
- idletime:=0;
-end;
-
-procedure mainloop3;
-begin
- repeat
-  findmouse3;
-  if fastkeypressed then processkey3;
-  if idletime=maxidle then screensaver;
-  if contactindex>-1 then
-   begin
-    bkcolor:=47;
-    printxy(cursorx*5+52,182,question[cursorx]);
-    delay(tslice*2);
-    bkcolor:=0;
-    printxy(cursorx*5+52,182,question[cursorx]);
-    delay(tslice*2);
-   end
-  else delay(tslice*4);
- until done;
-end;
-
-procedure getlocals;
-var confile: file of alientype;
-    done: boolean;
-    temp: alientype;
-begin
- assign(confile,'save\contacts.dta');
- reset(confile);
- if ioresult<>0 then errorhandler('contacts.dta',1);
- i:=0;
- done:=false;
- for j:=1 to 6 do locals^[j].id:=32000;
- repeat
-  read(confile,temp);
-  if ioresult<>0 then done:=true;
-  if (not done) and (temp.id>0) and (tempplan^[temp.id].system=tempplan^[curplan].system) then
-   begin
-    inc(i);
-    locals^[i]:=temp;
-   end;
- until (done) or (i=7);
- if i=7 then errorhandler('Too many aliens in system.',6);
- close(confile);
-end;
-
-procedure readydata3;
-begin
- mousehide;
- savescreen;
- fading;
- loadscreen('data\com.vga');
- loadpal('data\com.pal');
- mymove(screen,backgr^,16000);
- for i:=10 to 110 do
-  for j:=0 to 319 do
-   if (screen[i,j]=255) and ((i+j) mod 2=0) then screen[i,j]:=8
-    else if (screen[i,j]=255) then screen[i,j]:=0;
- new(tmpm);
- for i:=0 to 15 do
-  begin
-   mymove(screen[i+130,20],tmpm^[i],4);
-   fillchar(screen[i+130,20],16,0);
-  end;
- mousesetcursor(tmpm^);
- dispose(tmpm);
- done:=false;
- bkcolor:=0;
- tcolor:=28;
- infomode:=false;
- fillchar(question,21,ord(' '));
- question[0]:=#20;
- commlevel:=-2;
- contactindex:=-1;
- oldt1:=t1;
- cursorx:=1;
- new(temp);
- new(locals);
- new(str1);
- new(str2);
- new(c);
- new(r);
- new(t);
- getlocals;
- displayoptions3;
- fadein;
- mouseshow;
-end;
-
-procedure reloadbackground;
-var vgafile: file of screentype;
-begin
- assign(vgafile,'data\cloud.vga');
- reset(vgafile);
- if ioresult<>0 then errorhandler('data\cloud.vga',1);
- read(vgafile,backgr^);
- if ioresult<>0 then errorhandler('data\cloud.vga',5);
- close(vgafile);
-end;
-
-procedure continuecontact;
-begin
- readydata3;
- mainloop3;
- dispose(str2);
- dispose(str1);
- dispose(temp);
- dispose(locals);
- dispose(c);
- dispose(r);
- dispose(t);
- reloadbackground;
- mouse.setmousecursor(1);
- removedata;
-end;
-
-begin
-end.
diff --git a/makedata/comscrn.cpr b/makedata/comscrn.cpr
deleted file mode 100644
index d07ed56..0000000
Binary files a/makedata/comscrn.cpr and /dev/null differ
diff --git a/makedata/context.pas b/makedata/context.pas
deleted file mode 100644
index c65aa68..0000000
--- a/makedata/context.pas
+++ /dev/null
@@ -1,17 +0,0 @@
-program converttext;
-
-var
- f: text;
- t: char;
-
-begin
- assign(f,paramstr(1));
- reset(f);
- repeat
-  read(f,t);
-  if ord(t)<128 then {write(t)} else
-  if ord(t)=145 then write(#10,#13) else
-   write(chr(ord(t)-128));
- until eof(f);
- close(f);
-end.
\ No newline at end of file
diff --git a/makedata/convert.pas b/makedata/convert.pas
deleted file mode 100644
index bba59aa..0000000
--- a/makedata/convert.pas
+++ /dev/null
@@ -1,130 +0,0 @@
-program convertchars;
-
-uses data;
-
-type
- crewtype=
-  record
-   name: string[20];
-   phy,men,emo,status,level,index: byte;
-   xp: longint;
-  end;
- shiptype=
-  record
-   wandering: onealientype;
-   crew: array[1..10] of crewtype;
-   encodes: array[1..6] of crewtype;
-   gunnodes: array[1..10] of byte;      {installation positions}
-   armed: boolean;
-   fuel,fuelmax,battery,hulldamage,cargomax,hullmax,
-    accelmax,gunmax,shieldlevel,shield,posx,posy,posz,
-    orbiting: integer;                  {kilograms, gigawatts}
-   cargo: array[1..250] of integer;     {items => m3}
-   numcargo: array[1..250] of integer;  {number of each item}
-   engrteam: array[1..3] of teamtype;
-   damages: array[1..7] of byte;        {0=none, 100=destroyed}
-   shieldopt: array[1..3] of byte;
-   options: array[1..6] of byte;
-   research: byte;
-   shiptype: array[1..3] of byte;
-   events: array[0..200] of byte;
-   stardate: array[1..5] of integer;    {month day year  hour minute}
-  end;                                  {00    00  00    00   00    }
- crewtype2=
-  record
-   name: string[20];
-   phy,men,emo,status,level,index,skill,perf,san: byte;
-   xp: longint;
-  end;
- shiptype2=
-  record
-   wandering: onealientype;
-   crew: array[1..6] of crewtype2;
-   encodes: array[1..6] of crewtype2;
-   gunnodes: array[1..10] of byte;      {installation positions}
-   armed: boolean;
-   fuel,fuelmax,battery,hulldamage,cargomax,hullmax,
-    accelmax,gunmax,shieldlevel,shield,posx,posy,posz,
-    orbiting: integer;                  {kilograms, gigawatts}
-   cargo: array[1..250] of integer;     {items => m3}
-   numcargo: array[1..250] of integer;  {number of each item}
-   engrteam: array[1..3] of teamtype;
-   damages: array[1..7] of byte;        {0=none, 100=destroyed}
-   shieldopt: array[1..3] of byte;
-   options: array[1..6] of byte;
-   research: byte;
-   shiptype: array[1..3] of byte;
-   events: array[0..200] of byte;
-   stardate: array[1..5] of integer;    {month day year  hour minute}
-  end;                                  {00    00  00    00   00    }
-
-var
- shipfile: file of shiptype;
- shipfile2: file of shiptype2;
- systfile: file of systemarray;
- num,j: integer;
- ship: shiptype;
- ship2: shiptype2;
-
-begin
- num:=4;
- assign(shipfile,'save'+chr(num+48)+'\ship.dta');
- reset(shipfile);
- if ioresult<>0 then errorhandler('ship.dta',1);
- read(shipfile,ship);
- if ioresult<>0 then errorhandler('ship.dta',5);
- close(shipfile);
- with ship2 do
-  begin
-   wandering:=ship.wandering;
-   for j:=1 to 10 do gunnodes[j]:=ship.gunnodes[j];
-   armed:=ship.armed;
-   fuel:=ship.fuel;
-   fuelmax:=ship.fuelmax;
-   battery:=ship.battery;
-   hulldamage:=ship.hulldamage;
-   cargomax:=ship.cargomax;
-   hullmax:=ship.hullmax;
-   accelmax:=ship.accelmax;
-   gunmax:=ship.gunmax;
-   shieldlevel:=ship.shieldlevel;
-   shield:=ship.shield;
-   posx:=ship.posx;
-   posy:=ship.posy;
-   posz:=ship.posz;
-   orbiting:=ship.orbiting;
-   for j:=1 to 250 do cargo[j]:=ship.cargo[j];
-   for j:=1 to 250 do numcargo[j]:=ship.numcargo[j];
-   for j:=1 to 3 do engrteam[j]:=ship.engrteam[j];
-   for j:=1 to 7 do damages[j]:=ship.damages[j];
-   for j:=1 to 3 do shieldopt[j]:=ship.shieldopt[j];
-   for j:=1 to 6 do options[j]:=ship.options[j];
-   research:=ship.research;
-   for j:=1 to 3 do shiptype[j]:=ship.shiptype[j];
-   for j:=0 to 200 do events[j]:=ship.events[j];
-   for j:=1 to 5 do stardate[j]:=ship.stardate[j];
-   for j:=1 to 6 do
-    with ship2.crew[j] do
-     begin
-      name:=ship.crew[j].name;
-      phy:=ship.crew[j].phy;
-      men:=ship.crew[j].men;
-      emo:=ship.crew[j].emo;
-      status:=ship.crew[j].status;
-      level:=ship.crew[j].level;
-      status:=ship.crew[j].status;
-      xp:=ship.crew[j].xp;
-      skill:=1;
-      perf:=1;
-      san:=1;
-      index:=ship.crew[j].index;
-      ship2.encodes[j]:=ship2.crew[j];
-     end;
-  end;
- assign(shipfile2,'save'+chr(num+48)+'\ship.dta');
- rewrite(shipfile2);
- if ioresult<>0 then errorhandler('ship.dta',1);
- write(shipfile2,ship2);
- if ioresult<>0 then errorhandler('ship.dta',5);
- close(shipfile2);
-end.
\ No newline at end of file
diff --git a/makedata/convmake.pas b/makedata/convmake.pas
deleted file mode 100644
index 15ec43f..0000000
--- a/makedata/convmake.pas
+++ /dev/null
@@ -1,107 +0,0 @@
-program makeconversation;
-
-uses crt;
-
-
-type
-   converseindex = record
-		      event,runevent,rcode,index : integer;
-		      keyword			 : string[75];
-		   end;				 
-   responsetype	 = record
-		      index    : integer;
-		      response : string[255];
-		   end;	       
-
-var
- ft: text;
- i,j,err: integer;
- ans: char;
- done: boolean;
- c: converseindex;
- r: responsetype;
- f: file of converseindex;
- f2: file of responsetype;
- str1: string[5];
- fname,fname2: string[30];
-
-procedure error(s: string);
-begin
-   clrscr;
-   writeln(#10#10,s);
-   halt;
-end;
-
-begin
-   fname:=paramstr(2);
-   fname2:=paramstr(1);
-   assign(f,'data\'+fname+'.ind');
-   rewrite(f);
-   if ioresult<>0 then error('Error creating data\'+fname+'.ind.');
-   assign(f2,'data\'+fname+'.dta');
-   if ioresult<>0 then error('Error creating data\'+fname+'.dta.');
-   rewrite(f2);
-   assign(ft,fname2);
-   reset(ft);
-   if ioresult<>0 then error(fname2+' not found.');
-   done:=false;
-   repeat
-      read(ft,c.event);
-      if c.event>-500 then
-      begin
-	 read(ft,c.runevent);
-	 read(ft,c.rcode);
-	 read(ft,c.index);
-	 for i:=1 to 5 do read(ft,ans);
-	 fillchar(c.keyword,76,ord(' '));
-	 readln(ft,c.keyword);
-	 writeln(c.event,' ',c.runevent,' ',c.rcode,' ',c.index,' ',c.keyword);
-	 c.keyword[0]:=#75;
-	 for j:=1 to 75 do
-	    case c.keyword[j] of
-	      ' ' ..'"': c.keyword[j]:=chr(ord(c.keyword[j])-31);
-	      ''''..'?': c.keyword[j]:=chr(ord(c.keyword[j])-35);
-	      'A' ..'Z': c.keyword[j]:=chr(ord(c.keyword[j])-36);
-	      '%'	: c.keyword[j]:=#55;
-	      '^'	: c.keyword[j]:=#200;
-	      '@'	: c.keyword[j]:=#201;
-	    else c.keyword[j]:=#1;
-	    end;	
-	 write(f,c);
-      end;
-   until c.event=-500;
-   readln(ft);
-   repeat
-      read(ft,r.index);
-      if r.index<>-500 then
-      begin
-	 for i:=1 to 5 do read(ft,ans);
-	 if c.index<10 then read(ft,ans);
-	 readln(ft,r.response);
-	 writeln(r.index,' ',r.response);
-	 for j:=1 to length(r.response) do
-	    case r.response[j] of
-	      ' ' ..'"': r.response[j]:=chr(ord(r.response[j])-31);
-	      ''''..'?': r.response[j]:=chr(ord(r.response[j])-35);
-	      'A' ..'Z': r.response[j]:=chr(ord(r.response[j])-36);
-	      '%'	: r.response[j]:=#55;
-	      '^'	: r.response[j]:=#200;
-	      '@'	: r.response[j]:=#201;
-	    else r.response[j]:=#1;
-	    end;
-	 write(f2,r);
-      end;
-   until r.index=-500;
-   close(ft);
-   close(f);
-   close(f2);
-end.
-
-
-
-
-
-
-
-
-
diff --git a/makedata/creamake.pas b/makedata/creamake.pas
index ecca8b1..0b9ba50 100644
--- a/makedata/creamake.pas
+++ b/makedata/creamake.pas
@@ -1,4 +1,20 @@
 program generatecargodata;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 uses crt;
 
@@ -72,7 +88,7 @@ begin
  reset(f2);
  read(f2,cr^);
  close(f2);
- assign(ft,'itemdata.txt');
+ assign(ft,'other\itemdata.txt');
  rewrite(ft);
  writeln(ft,'    ITEM TO CREATE             PART #1             PART #2              PART#3 WORTH LEVELS            ');
  writeln(ft,'------------------ ------------------- ------------------- ------------------- ----- ------------------');
diff --git a/makedata/crewmake.pas b/makedata/crewmake.pas
index 690b5f6..0ca55b6 100644
--- a/makedata/crewmake.pas
+++ b/makedata/crewmake.pas
@@ -1,4 +1,21 @@
 program makecrew;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
+
 uses crt;
 
 type
@@ -38,7 +55,7 @@ begin
  assign(fs,'makedata\crew.txt');
  reset(fs);
  assign(ft,'data\crew.dta');
- reset(ft);
+ rewrite(ft);
  clrscr;
  for a:=1 to 30 do
   begin
diff --git a/makedata/demo2.pas b/makedata/demo2.pas
deleted file mode 100644
index 3b58420..0000000
--- a/makedata/demo2.pas
+++ /dev/null
@@ -1,237 +0,0 @@
-program seefire;
-
-{$M 3000,214000,214000}
-
-uses graph, crt;
-
-
-const
- maxlines= 1;
- strs : array[0..maxlines] of string[40] =
-('CHANNEL 7','DESTINY: VIRTUAL');
-
-type
- Image = RECORD
-   ImageP: POINTER;
-   X: WORD;
-   Y: WORD;
-  END;
- ballpic = array[0..100,0..100] of byte;
- paltype = array[0..255,1..3] of byte;
- screentype = array[0..199,0..319] of byte;
- fonttype = array[1..3] of byte;
-const
-  font: array[1..55] of fonttype=(
-(0,0,0),       { } (102,96,96),   {!} (85,80,0),     {"} (34,0,0),      {'}
-(36,68,32),    {(} (66,34,64),    {)} (9,105,0),     {*} (4,228,0),     {+}
-(0,2,36),      {,} (0,240,0),     {-} (0,0,32),      {.} (1,36,128),    {/}
-(107,221,96),  {0} (98,34,240),   {1} (241,104,240), {2} (241,33,224),  {3}
-(153,241,16),  {4} (248,113,224), {5} (248,249,240), {6} (241,17,16),   {7}
-(249,105,240), {8} (249,241,16),  {9} (102,6,96),    {:} (102,6,98),    {;}
-(18,66,16),    {<} (15,15,0),     {=} (132,36,128),  {>} (105,32,32),   {?}
-(121,185,144), {a} (249,169,240), {b} (248,136,240), {c} (233,153,224), {d}
-(240,200,240), {e} (248,232,128), {f} (248,153,240), {g} (153,249,144), {h}
-(114,34,112),  {i} (241,25,96),   {j} (158,153,144), {k} (136,136,240), {l}
-(159,153,144), {m} (233,153,144), {n} (249,153,240), {o} (249,152,128), {p}
-(105,155,112), {q} (249,169,144), {r} (132,33,224),  {s} (114,34,32),   {t}
-(153,153,240), {u} (153,153,96),  {v} (153,187,96),  {w} (153,105,144), {x}
-(153,113,16),  {y} (242,72,240),  {z} (9,36,144));   {%}
-var
-  screen: screentype absolute $A000:0000;
-  colors: paltype;
-  s,s2: ^screentype;
-  water,waterindex,j2,ofsx,index,alt,radius,c,ecl,m,r2,i,j: integer;
-  part2,part,c2,y: real;
-
-{$L mover2}
-{$L vga256}
-procedure vgadriver; external;
-procedure mymove2(var src,tar; count: integer); external;
-
-procedure errorhandler(s: string; errtype: integer);
-begin
- closegraph;
- writeln;
- case errtype of
-  1: writeln('File Error: ',s);
-  2: writeln('Mouse Error: ',s);
-  3: writeln('Sound Error: ',s);
-  4: writeln('EMS Error: ',s);
-  5: writeln('Fatal File Error: ',s);
-  6: writeln('Program Error: ',s);
-  7: writeln('Music Error: ',s);
- end;
- halt(4);
-end;
-
-function fastkeypressed: boolean; assembler;
-asm
- push ds
- mov ax, 40h
- mov ds, ax
- cli
- mov ax, [1Ah]
- cmp ax, [1Ch]
- sti
- mov ax, 0
- jz @nopress
- inc ax
-@nopress:
- pop ds
-end;
-
-procedure loadpal(s: string);
-var palfile: file of paltype;
-begin
- assign(palfile,s);
- reset(palfile);
- if ioresult<>0 then errorhandler(s,1);
- read(palfile,colors);
- if ioresult<>0 then errorhandler(s,5);
- close(palfile);
-end;
-
-procedure set256Colors(pal: paltype); assembler;
-asm
- mov ax, 1012h
- mov bx, 0
- mov cx, 256
- les dx, Pal
-  int 10h
-end;
-
-function testbit(b,bit: byte) : boolean; assembler;
-asm
- mov cl, bit
- mov bl, 1
- shl bl, CL
- mov al, 0
- test b, bl
- jz @@no
- inc al
-@@no:
-end;
-
-{$F+}
-function testit : integer; assembler;
-asm
- mov ax, 1A00h
-  int 10h
- cmp al, 1Ah
- jne @@nope
- mov ax, 1
- jmp @@done
-@@nope:
- mov ax, 0
-@@done:
-end;
-{$F-}
-
-procedure readygraph;
-var testdriver,driver,mode,errcode: integer;
-begin
- testdriver:=installuserdriver('vga256',@testit);
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeLn('Error Installing VGA Driver:',errcode);
-   halt(4);
-  end;
- registerbgidriver(@vgadriver);
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeLn('Error Registering VGA Driver:',errcode);
-   halt(4);
-  end;
- driver:=detect;
- initgraph(driver,mode,'');
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeln('Video Initialization Failure: ',errcode);
-   halt(4);
-  end;
- loadpal('landform.pal');
- set256colors(colors);
- setgraphbufsize(0);
- checksnow:=false;
-end;
-
-procedure rotate;
-label endcheck;
-begin
- for i:=6 to 2*r2+4 do
-   begin
-    y:=sqrt(radius-sqr(i-r2-5));
-    m:=round((r2-y)*c2);
-    part:=r2/y;
-    alt:=0;
-    for j:=1 to 2*r2+10 do
-     begin
-      index:=round(j*part);
-      if index>2*r2+10 then goto endcheck;
-      ofsx:=j+m;
-      if (ecl>170) then alt:=(index-ecl+186) div 2
-       else if (ecl<171) and (index<ecl) then alt:=(ecl-index) div 2
-       else alt:=0;
-      if alt<0 then alt:=0;
-      if (index+c)>320 then j2:=index+c-320
-       else j2:=index+c;
-      if (alt<6) and (s^[i,j2]<water) then s2^[i,ofsx]:=waterindex+6-alt
-       else if s^[i,j2]<water then s2^[i,ofsx]:=waterindex
-       else if alt>round((s^[i,j2]-water)*part2) then s2^[i,ofsx]:=1
-       else s2^[i,ofsx]:=round((s^[j2,i]-water)*part2)-alt+4;
-endcheck:
-     end;
-   end;
- mymove2(s2^,screen,16000);
-end;
-
-procedure generate;
-var x1,y1,b: integer;
-    a: longint;
-begin
- fillchar(s^,64000,30);
- for b:=1 to 5 do
-  begin
-   x1:=random(320);
-   y1:=random(200);
-   for a:=1 to 105000 do
-    begin
-     x1:=x1-1+random(3);
-     y1:=y1-1+random(3);
-     if x1>320 then x1:=0 else if x1<0 then x1:=319;
-     if y1>200 then y1:=0 else if y1<0 then y1:=199;
-     if s^[y1,x1]<250 then s^[y1,x1]:=s^[y1,x1]+5;
-    end;
-  end;
-end;
-
-begin
- readygraph;
- new(s);
- new(s2);
- generate;
- fillchar(s2^,64000,0);
-
- c:=0;
- ecl:=50;
- c2:=1.09;
- radius:=5000;
- r2:=round(sqrt(radius));
- water:=0;
- waterindex:=41;
- part2:=28/(255-water);
-
- repeat
-  inc(c,5);
-  if c>320 then c:=0;
-  rotate;
-
- until fastkeypressed;
- dispose(s);
- dispose(s2);
- closegraph;
- writeln(#13+#10+#10+'(C) 1994 by Robert Morgan, Channel 7, Destiny: Virtual.');
-end.
\ No newline at end of file
diff --git a/makedata/destiny.cpr b/makedata/destiny.cpr
deleted file mode 100644
index 33d5c72..0000000
Binary files a/makedata/destiny.cpr and /dev/null differ
diff --git a/makedata/destiny.pal b/makedata/destiny.pal
deleted file mode 100644
index 439781b..0000000
Binary files a/makedata/destiny.pal and /dev/null differ
diff --git a/makedata/destiny2.cpr b/makedata/destiny2.cpr
deleted file mode 100644
index 637a264..0000000
Binary files a/makedata/destiny2.cpr and /dev/null differ
diff --git a/makedata/destiny2.pal b/makedata/destiny2.pal
deleted file mode 100644
index db79965..0000000
Binary files a/makedata/destiny2.pal and /dev/null differ
diff --git a/makedata/docrew.pas b/makedata/docrew.pas
deleted file mode 100644
index 577a421..0000000
--- a/makedata/docrew.pas
+++ /dev/null
@@ -1,29 +0,0 @@
-program makecrew;
-
-type
- crewtype=record
-   name: string[20];
-   phy,men,emo,status,skilllevel: byte;
-   xp: integer;
-  end;
-var
- j,emo,phy,men: integer;
- ft: text;
- i: string[6];
-
-
-begin
- assign(ft,'makedata\crew.txt');
- rewrite(ft);
- randomize;
- for j:=1 to 30 do
-  begin
-   phy:=random(100);
-   men:=random(100);
-   emo:=random(abs(175-men-phy));
-   if emo>100 then emo:=emo mod 100;
-   if random(100)<40 then i:='FEMALE' else i:='MALE';
-   writeln(ft,phy:3,men:8,emo:8,random(8):8,i:8);
-  end;
- close(ft);
-end.
\ No newline at end of file
diff --git a/makedata/dpancon1.txt b/makedata/dpancon1.txt
deleted file mode 100644
index e1e8095..0000000
--- a/makedata/dpancon1.txt
+++ /dev/null
@@ -1,295 +0,0 @@
-D'PANK   (ALPHA 1.00)
-FRIENDLY
-
-280     20000   1       73      HI HELLO GREETS GREETINGS HYA HIYA SALUTATIONS WELCOME-1      20000   2       2       BYE GOOD-BYE GOODBYE OVER OUT 10-4
-286     -1      1       69      HI HELLO GREETS GREETINGS HYA HIYA SALUTATIONS WELCOME-1      20000   2       2       BYE GOOD-BYE GOODBYE OVER OUT 10-4
-600     -1      1       1       HI HELLO GREETS GREETINGS HYA HIYA SALUTATIONS WELCOME-1      20000   2       2       BYE GOOD-BYE GOODBYE OVER OUT 10-4
-213     600     1       56      HI HELLO GREETS GREETINGS HYA HIYA SALUTATIONS WELCOME
--1      -1      1       1       HI HELLO GREETS GREETINGS HYA HIYA SALUTATIONS WELCOME-1      20000   2       2       BYE GOOD-BYE GOODBYE OVER OUT 10-4
--1      -1      1       3       HELP
--1      -1      1       4       STATUS
--1      -1      1       5       VOID DWELLERS
--1      -1      1       6       D'PANK WORMS
--1      -1      1       7       SENGZHAC BUGS BUGGERS
-221     -1      1       53      GUILD TRADERS
--1      -1      1       8       GUILD TRADERS
--1      -1      1       9       PHAEDOR MOCH PUPPET
-278     291     1       67      ERMIGEN
-277     -1      1       66      ERMIGEN
--1      -1      1       10      ERMIGEN
-263     -1      1       63      QUAI PA'LOI
-213     -1      1       57      QUAI PA'LOI
--1      -1      1       11      QUAI PA'LOI
-263     -1      1       64      PAI ALOI
-213     -1      1       58      PAI ALOI
--1      -1      1       12      PAI ALOI
-263     -1      1       65      Q'OOUL
-213     -1      1       59      Q'OOUL
--1      -1      1       13      Q'OOUL
--1      -1      3       14      ICON
--1      -1      1       15      TITERIAN
--1      -1      1       16      YLINTHLIXYMN YILLER  
-221     -1      1       62      YLINTHLIXYMN YILLER
-286     -1      1       78      SCAVENGERS SCAVS
-277     -1      1       77      SCAVENGERS SCAVS
-255     -1      1       76      SCAVENGERS SCAVS
-223     -1      1       75      SCAVENGERS SCAVS
-208     -1      1       17      SCAVENGERS SCAVS
--1      -1      1       74      SCAVENGERS SCAVS
--1      -1      1       16      AARD
--1      -1      1       19      MALZATOIR
--1      -1      3       20      **** NAMELESS
--1      -1      1       22      DERRAAK
--1      -1      1       23      TROJAN GATE GATES
--1      -1      1       24      MONKS MONK
--1      -1      1       25      HOMEWORLD
--1      20001   1       26      SELL BUY TRADE
--1      -1      1       27      HALLIFAX MANUEVER
--1      -1      1       29      SHUNT
--1      -1      3       31      GOD'S GODS EYE
--1      -1      1       33      THERMOPLAST
--1      -1      1       36      CHILDREN
--1      -1      1       37      LIGHT
--1      -1      1       38      KNOWLEDGE
--1      -1      1       39      SOURCE INNER
--1      -1      1       40      SUN
--1      -1      1       41      SEED
--1      -1      1       42      IRON IRONSEED
--1      -1      1       43      HEAT
--1      -1      1       44      HE
--1      -1      1       45      TEMPORAL ANCHOR
--1      -1      1       46      DEVICES
--1      -1      1       47      KENDAR
--1      -1      1       48      SECRET
--1      -1      1       49      BREATHTAKING
--1      -1      1       50      INSPIRING
--1      -1      1       51      PLANET
--1      -1      1       52      BLINDED
-221     -1      1       54      MISTAKE
-221     222     1       55      RACE
-213     -1      1       60      CHAOS
-221     238     1       61      GENETIC CLONING MATERIAL
-291     -1      1       68      WILL
-286     20007   1       70      PROBOT
-279     20100   3       71      *answer.yes
-279     -1      1       72      *answer.no
--1      -1      1       79      THERMATURGE
-255     -1      1       80      THERMATURGE
-286     -1      1       79      THERMATURGE
-
-
-HI
-1       ENTER THE ^LIGHT^, FOR WE ARE THE ^CHILDREN^ OF THE ^SUN^.  LIGHT REVEALS MUCH, AND THE LIGHT OF THE SUN REVEALS ALL.
-
-BYE
-2       WALK SWIFTLY THROUGH THE DARKNESS, AND RETURN SOON TO THE LIGHT.
-
-VOID DWELLERS
-5       DID THEY SEND YOU HERE?  THEY CARE ONLY ABOUT GOSSIP...THEY DO NOT TRADE IN REAL KNOWLEDGE.  YOU CAN TALK WITH THEM IF YOU ARE INTERESTED IN WHO JUST DESTROYED WHAT PLANET.  WHEN YOU ARE READY FOR THE TRUE SEARCH FOR KNOWLEDGE, TALK TO US.
-
-D'PANK
-6       THAT WOULD BE US.  WE ARE THE ^CHILDREN^ OF THE ^SUN^, THE GATHERERS OF KNOWLEDGE, AND THE WALKERS OF THE LIGHT.
-
-SENGZHAC
-7       ^HE^ ARE AMONG THE OLDEST AND WISEST OF THE RACES IN THIS SECTION OF THE GALAXY.  HE GUARDS SOMETHING KNOWN BY MOST AS THE ^GOD'S EYE^.
-
-GUILD
-8       THE GUILD SEEK NOT KNOWLEDGE OF THE UNIVERSE...ONLY PROFIT IN IT.  THEY ARE TRICKY.  BE WARRY IN YOUR DEALINGS WITH THEM AND IN THE DEALS THAT YOU ACCEPT FROM THEM.
-
-PHADOR MOCH
-9       THEY ARE NOT A RACE WORTHY OF NOTE.  THEY ARE MUCH TOO OFFENSIVE AND VILE...MAYBE EVEN, A DARK RACE.
-
-ERMIGEN
-10      THEY ARE A STRONG MILITARY RACE.  THIER SHIPS ARE BETTER SHIELDED THAN ANY IN THIS SECTOR.  IT IS EVEN RUMORED THAT THEY HAVE BEEN ABLE TO BUILD A ^TEMPORAL ANCHOR^.
-
-QUAI PA'LOI
-11      THEY ARE QUITE AN ADVANCED RACE, BUT THEY HAVE AN ODD FACINATION WITH SMALL ODD DEVICES.  THEY HAVE BEEN KNOWN TO TRADE LARGE AMOUNTS OF WEAPONS FOR WHAT AMOUNTS TO A FEW SMALL PLASMA COUPLERS.
-
-PAI ALOI
-12      THEY ARE A SMALL FACTION OF QUAI PA'LOI WHO ARE CONVINCED THAT THEY ARE SQUANDERING THEIR RESOURCES BY TRADING THEM WITH OTHER RACES.  THEY ARE TRYING TO GAIN SUPPORT IN THEIR COUNSELS, BUT THEY ARE NOT STRONG ENOUGH TO TAKE ON THE ^Q'OOUL^ JUST YET.
-
-Q'OOUL
-13      AS THE HEAD FACTION OF THE QUAI PA'LOI, THEY SET THE POLICIES AS FAR AS TRADE AND ALIEN RELATIONS ARE CONCERNED.  THE ^PAI ALOI^ ARE NOT HAPPY WITH THEIR POLICIES, BUT THAT IS THEIR PROBLEM.
-
-ICON
-14      THE ICON ARE RARELY SEEN AND NEVER HEARD.  THEY SEEM CONTENT TO STAY ON THEIR HOMEWORLD, WHEREEVER THAT IS, UNLESS ODD EVENTS DRAW THEM OUT.  IT IS RUMORED THAT THE GUILD HAS SOME CONTACT WITH THEM, BUT THEY TEND TO BE QUIET ABOUT THEIR
-14      RELATIONS.  THAT IS, UNLESS YOU NAME THE RIGHT PRICE.
-
-TITERIAN
-15      THE TITERIAN ARE ALSO SEEKERS OF KNOWLEDGE, BUT THEY DO NOT SEEK THEIR KNOWLEDGE FROM THE SUN.  THEY SEEK IT IN SOMETHING THEY CALL QUANTUM PROBABILITIES.
-
-YLINTHLIXYMN AARD
-16      WE HAVE NOT SENSED THEIR LIGHT.
-
-SCAVENGERS
-17      THEY ARE A NUSNACE, BUT THEY ARE NOT A DANGER.  JUST KEEP AN EYE ON THEM AND THEY CAN BE AVOIDED.
-
-MALZATOIR
-19      THE MALZATOIR ARE VERY ADVANCED, BUT THEY ARE CONTENT TO STAY IN THEIR OWN SYSTEM.
-
-****
-20      THE ****, ALSO KNOWN AS THE NAMELESS ONES, ARRIVED SOON AFTER AN ODD STELLAR OCCURANCE.  THEY APPEARED TO BE SCIENTISTS, BUT THEIR EXPERIMENTS SOON ESCALATED.  THEY BEGAN BUILDING AWESOME ^DEVICES^.  THEY USED THEIR DEVICES TO CONTROL THE OTHER   
-20      RACES AND SPREAD THEIR POWER.  FORTUNATELY, THE ^KENDAR^ DISCOVERED A ^SECRET^, AND THEY CORNERED AND DEFEATED THE ****.
-
-DERRAAK
-22      HE IS A PIRATE WHO OPERATES NEAR TRADE CENTERS.  HE SEEMS TO ATTACK AT RANDOM AND HE ALWAYS TAKES TAKES ODD TECH ITEMS.  HE SEEMS TO ATTACK ALL RACES EQUALLY EXCEPT FOR THE TITERIANS.  THEY SEEM TO KNOW HOW TO WARD HIM OFF.
-
-TROJAN GATE
-23      WE HAVE SEEN THEM...THERE ARE MANY, BUT THEY ARE NOT ILLUMINATED PROPERLY FOR US TO GUESS THEIR FUNCTION.
-
-MONKS
-24      WE HAVE HEARD OF THEM, BUT WE DO NOT KNOW WHERE TO FIND THEM.
-
-HOMEWORLD
-25      OUR WORLD, TALPARRA, IS DEEP AND WARM.  THE CANYONS NEAR THE SUN ARE ^BREATHTAKING^ AND ^INSPIRING^ TO ALL THOSE WHO SEEK LIGHT.  NEAR US IS A ^PLANET^ WHICH GLOWS WITH LIGHT.  WE WISH TO EXAMINE ITS LIGHT, BUT WE ARE ^BLINDED^.
-
-TRADE
-26      AH, KNOWLEDGE ALSO SPRINGS FROM THE EXCHANGE OF GOODS.  SHOW US WHAT YOU HAVE, THAT WE MIGHT LEARN.
-
-HALLIFAX
-27      IT IS SOME TYPE OF A RITUAL...SO OLD THAT WE ARE NOT SURE ITS PERFORMERS EVEN REMEMBER ITS ORIGINAL INTENT.
-
-SHUNT
-29      THE SHUNT DRIVE IS A THEORETICAL SYSTEM, BUT WE HAVE NEVER HEARD OF A WORKING VERSION OF IT.
-
-GODS EYE
-31      WE HAVE HEARD VERY LITTLE OF IT.  THE GOD'S EYE IS A SMALL PLANETOID OR ASTEROID THAT IS DEEP IN SENGZHAC TERRITORY.  IT ISN'T LIKELY THAT YOU WILL EVER SEE IT BECAUSE THE SENGZHAC HAVE A STRANGE RELIGEOUS ATTACHMENT TO IT.  ANY SHIP THAT TRIES TO
-31      APPROACH THE EYE IS DESTROYED.
-
-THERMOPLAST
-33      THAT IS INDEED AN INTERESTING IDEA.  IF WE HAD A SMALL DEVICE PROTECTED WITH THERMOPLAST, WE MIGHT BE ABLE TO SEND IT INTO THE SUN TO ACHEIVE TRUE ENLIGHTENMENT.
-
-CHILDREN
-36      ALL COMES FROM THE ^SUN^...FROM DEEP WITHIN IT.  ALL ARE ITS CHILDREN, AND WE SEEK ^KNOWLEDGE^ IN THE ^LIGHT^.
-
-LIGHT
-37      THE LIGHT GUIDES US AND LEADS US TO ^KNOWLEDGE^.  SINCE THE SUN IS THE SOURCE OF THE LIGHT, THEN IT IS ALSO THE SOURCE OF KNOWLEDGE.
-
-KNOWLEDGE
-38      YES, WE SEEK THE KNOWLEDGE OF THE SUN.  WE STRIVE TO ENTER INTO IT AND FIND THE INNER ^SOURCE^.
-
-SOURCE
-39      IT IS THE ^SEED^ FROM WHICH ALL LIGHT AND KNOWLEDGE GROWS.  KNOWLEDGE STEMS FROM THE SOURCE, AND IT FLOURISHES IN THE ^HEAT^ AND THE LIGHT.
-
-SUN
-40      THE SUN GIVES US WARMTH AND LIGHT.  FROM THE ^SOURCE^ DEEP WITHIN, WE GAIN ^KNOWLEDGE^.  ONE DAY, WE WILL ENTER THE SUN AND GAIN KNOWLEDGE DIRECTLY FROM THE ^SOURCE^.
-
-SEED
-41      THE SEED IS OF ^IRON^, BUT THERE IS MUCH MORE TO IT THAN CAN BE PLAINLY SEEN.
-
-IRON
-42      WE WISH TO KNOW THE SIGNIFICANCE.  MAYBE WE WILL LEARN THIS WHEN WE REACH THE SOURCE.
-
-HEAT
-43      THE SUN IS VERY HOT.  THE HEAT KEEPS US FROM ENTERING INTO THE SUN.  WE TRAIN AND DISIPLINE OURSELVES TO WITHSTAND THE HEAT.  SO FAR NONE OF US HAVE BEEN STRONG ENOUGH TO ENTER.
-
-HE
-44      WE REFER TO THE SENGZHAC AS HE BECAUSE THE SENGZHAC ARE A COLLECTIVE ENTITY, ONE BRAIN WITH MANY BODIES.  
-
-ANCHOR
-45      TEMPORAL ANCHORS ARE THE STRONGEST SHIELDS EVER BUILT.  THEY WERE INVENTED, ALONG WITH MANY OTHER INTERESTING ^DEVICES^, BY THE ^****^.  
-
-DEVICES
-46      THE ^****^ HAD MANY DEVICES...MOST OF THEM FAR MORE ADVANCED THAN ANY DEVICES THE OTHER RACES HAD.  THE DEVICES PURPOSES WERE TO MAKE THE **** STRONG AND THE REST OF THE RACES WEAK.  THAT IS WHY YOU WILL NOT FIND ANY OF THEIR DEVICES AROUND NOW.
-
-KENDAR
-47      IT WAS A TEMPORARY ALLIANCE OF ALL THE ESTABLISHED RACES IN THE AREA.  THE RACES KNEW THAT THEY WERE NO MATCH FOR THE ^DEVICES^ ALONE.
-
-SECRET
-48      IF WE KNEW, THEN IT WOULDN'T BE MUCH OF A SECRET.
-
-BREATHTAKING
-49      OH, I CAN FEEL THE HEAT AND THE LIGHT IN MY GILLS EVEN NOW.     
-
-INSPIRING
-50      YES.  WHENEVER I SEE THE VALLEYS OF THE SUN, I AM FLOODED WITH THE DESIRE TO CONTINUE DEEPER AND DEEPER...TO ENTER INTO IT...TO JOIN WITH IT...BUT OF COURSE, THEN I COME TO MY SENSES AND GO DEHYDRATE MY SORROWS IN A BOTTLE OF OXIDANTS.
-
-PLANET
-51      THE PLANET IS LOCATED AT *****.
-
-BLINDED
-52      THERE IS A SHIELD AROUND THE ^PLANET^ THAT KEEPS US FROM APPROACHING TO SEE IT.
-
-GUILD
-53      THE GUILD HAVE MADE A TERRIBLE ^MISTAKE^.  THEY HAVE DESTROYED ANOTHER ^RACE^.
-
-MISTAKE
-54      THEY HAVE DESTROYED THE HOME PLANET OF A SIENTIENT ^RACE^.  THEY ARE VERY UPSET, AND THEY WISH TO TRY TO REPOPULTE THE RACE.  UNFORTUNATELY, THEY DON'T HAVE ANY GENETIC ^MATERIAL^ TO USE AS A CLONING SEED.
-
-RACE
-55      THE RACE WAS KNOWN AS THE YLINTHLIXYMN, OR YILLERS FOR SHORT.
-
-HI (AT START OF WAR)
-56      ENTER THE ^LIGHT^, FOR WE ARE THE ^CHILDREN^ OF THE ^SUN^.  WE HAVE HEARD THAT THERE IS SOMTHING HAPPENING WITH THE ^QUAI PA'LOI^.
-
-QUAI PA'LOI
-57      THEY HAVE GONE TO WAR WITH THEMSELVES.  THE PAI ALOI HAVE OVERTHROWN THE Q'OOUL.  EVERYTHING SEEMS TO BE IN ^CHAOS^.
-
-PAI ALOI
-58      THEY HAVE TAKEN OVER THE QUAI PA'LOI HOMEWORLD, AND CANCELED FORMER ALL TRADE AGREEMENTS.
-
-Q'OOUL
-59      THEY RAN...I DON'T THINK THAT THEY EVEN LOOKED BACK.  I AM NOT SURE THAT THEY WILL EVEN ATTEMPT TO TAKE BACK THEIR RULE.
-
-CHAOS
-60      THE PAI ALOI ARE RADICAL EXTREMISTS.  THEY WERE ABLE TO BAND TOGETHER ON THE ISSUE OF NO OUTSIDE TRADING, BUT THEY CANNOT AGREE ON ANYTHING ELSE.  THERE IS BOUND TO BE MUCH INTERNAL FIGHTING...THE Q'OOUL COULD PROBABLY DEFEAT THEM IN A SINGLE SWOOP.
-
-MATERIAL
-61      IT IS HARD TO FIND ANY PRESERVED GENETIC MATERIAL FROM A DEAD RACE.  PERHAPS SOMEONE HAS KEPT SOME GENETIC ARCHIVES.
-
-YILLERS
-62      THEY WERE DESTROYED BY THE GUILD OVER A TRADE DISAGREEMENT.
-
-QUAI PA'LOI
-63      THE Q'OOUL HAVE FINALLY REGAINED CONTROL OF THE REALM.  UNFORTUNATELY, THERE IS NOT MUCH LEFT ON THEIR PLANET.  THE PAI ALOI'S INTERNAL FIGHTING DESTORYED MOST OF THE PLANETS RESOURCES.
-
-PAI ALOI
-64      THEIR LEADERS HAVE FLED...IT IS RUMORED THAT THEY ARE LOOKING FOR A NEW CAUSE TO BAND THEM TOGETHER.
-
-Q'OOUL
-65      THEY HAVE MUCH WORK TO DO TO TRY TO REESTABLISH THEIR NOW DYING WORLD.  IT IS SAD TO SEE SUCH AN ENLIGHTENED RACE FALL INTO DARKNESS.
-
-ERMIGEN
-66      WE HAVE HEARD THAT THEY HAVE BEEN DESTROYED...WE ARE NOT SURE IF IT IS TRUE, BUT WE CERTAINLY WISH TO SEEK LIGHT IN THE MATTER.
-
-ERMIGEN
-67      THE STORY YOU HAVE BROUGHT US ABOUT THEIR SHIP HITTING THE SUN IS VERY UNLIKELY.  THE ERMIGEN HAD VERY RELIABLE EQUIPMENT AND PILOTS.  WE BELIEVE THAT THEY MUST HAVE BEEN DESTROYED BY THEIR OWN ^WILL^.
-
-WILL
-68      WHY THEY WOULD DO SUCH A THING, WE CANNOT SEE.  MAYBE YOU CAN FIND LIGHT ELSEWHERE.
-
-HI  (WANT PROBOT)
-69      WELCOME BACK TO THE LIGHT...WE HAVE HEARD THAT YOU HAVE A ^PROBOT^ THAT HAS A STRONG THERMAL SHIELDING...MAYBE STRONG ENOUGH TO ENTER THE SUN.  WE WOULD BE WILLING TO OFFER YOU SOMETHING...ANYTHING FOR IT.
-
-PROBOT
-70      ARE YOU WILLING TO SELL US THE THERMAL PROBOT?  YOU CAN NAME YOUR PRICE...
-
-71      WONDERFUL, WHAT IS IT THAT YOU WANT FROM US...A THERMATURGE!!!  THAT IS OUT OF THE QUESTION.  THERMATURGES ARE MUCH TOO DANGEROUS.  WHAT DO YOU MEAN, "NO THERMATURGE, NO PROBOT."  WE MUST HAVE THAT PROBOT...GIVE IT TO US...PLEASE!!!  THE SUN BECONS.
-71      THE SEED..THE SUN..THE SUNSEED..THE IRONSEED..WE MUST HAVE IT.  OKAY, OKAY, WE WILL MEET YOUR DEMANDS.  WE HAVE WAITED FOR SO LONG TO ENTER THE SUN.  WE NO LONGER NEED IT TO DEFEND OURSELVES AGAINST THE SCAVENGERS.  WHAT HARM COULD YOU DO WITH ONLY
-71      ONE THERMATURGE.. ..THANK YOU FOR THE TRANSACTION.  WE MUST NOW BEGIN PREPARING FOR OUR JOURNEY INTO THE SUN.  GOOD-BYE.
-
-72      FINE, WE WILL WAIT UNTIL YOU ARE READY TO ALLOW US PASSAGE INTO THE SUN.
-
-HI (END)
-73      I AM SORRY, BUT WE ARE TOO BUSY TO TALK...WE ARE IN THE MIDST OF EXPLORING THE SUN AND EXAMINING THE LIGHT...GOOD-BYE.
-
-SCAVS
-74      WE HAVE NOT HEARD OF THEM.
-
-SCAVS
-75      THEY ARE BECOMING BOLD, BUT THEY ARE STILL NOT TO DANGEROUS.  THEY WILL NEVER GET NEAR US AS LONG AS WE HAVE OUR THERMATURGE.
-
-SCAVS
-76      THE SCAVENGERS HAVE BECOME VERY DANGEROUS...SOMETHING MUST BE DONE ABOUT THEM.  WE ARE HAVE TO USE OUR THERMATURGE TO FEND THEM OFF.
-
-SCAVS
-77      THEY HAVE STOPPED ATTACKING.  WE THINK THAT THEY MUST BE GATHERING SOMEWHERE...TO WHAT END, WE ONLY HOPE THAT THEY ARE NOT PLANNING OUR DOOM.
-
-SCAVS
-78      YES, WE HEARD THAT YOU HAD DESTROYED THOSE BOTS OF GREAT DARKNESS...WELL DONE.
-
-THERMATURGE
-79      IT IS A VERY POWERFUL WEAPON...IT BREATHES FIREY DEATH...EVEN IN THE DEPTHS OF SPACE.
-
-THEMATURGE
-80      WE NEED IT TO DEFEND AGAINST THE SCAVENGERS.
\ No newline at end of file
diff --git a/makedata/editencd.pas b/makedata/editencd.pas
deleted file mode 100644
index 82a07f2..0000000
--- a/makedata/editencd.pas
+++ /dev/null
@@ -1,41 +0,0 @@
-program edit_encode_animation_sequence;
-
-uses crt, graph, data, gmouse;
-
-type
- aniscrtype= array[0..60,0..54] of byte;
-var
- aniscr: aniscrtype;
- i,j,a,b: integer;
-
-
-procedure convert;
-begin
- loadscreen('data\char.vga');
- for i:=100 to 160 do
-  for j:=40 to 94 do
-   aniscr[i-100,j-40]:=screen[i,j];
- fillchar(screen,64000,0);
- for b:=0 to 2 do
- for a:=0 to 4 do
-  for i:=0 to 60 do
-   for j:=0 to 54 do
-    screen[i+b*60,j+a*60]:=aniscr[i,j];
-end;
-
-procedure save;
-var vgafile: file of screentype;
-begin
- assign(vgafile,'data\charani.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);
-end;
-
-begin
- convert;
- save;
-
- readkey;
- closegraph;
-end.
\ No newline at end of file
diff --git a/makedata/editmap.pas b/makedata/editmap.pas
deleted file mode 100644
index 7c7a9e3..0000000
--- a/makedata/editmap.pas
+++ /dev/null
@@ -1,244 +0,0 @@
-program mapeditor;
-
-uses crt, graph, graphics;
-
-type
- maptype= array[0..254,0..254] of byte;
- tempscreentype= array[0..224,0..224] of byte;
-var
- i,j,a,b,x,y,xc,yc,x3,y3,c,d: integer;
- map: ^maptype;
- ans: char;
- curx,cury: integer;
- done: boolean;
- str1,str2: string[3];
- facingdir,x1,x2,y1,y2,f,e,dx,g,h,dy,dx2,dy2: real;
- locx,locy: integer;
- temp: ^tempscreentype;
-
-procedure loadmap;
-var fm: file of maptype;
-begin
- assign(fm,'data\map001.dta');
- reset(fm);
- read(fm,map^);
- close(fm);
-end;
-
-procedure savemap;
-var fm: file of maptype;
-begin
- assign(fm,'data\map001.dta');
- reset(fm);
- write(fm,map^);
- close(fm);
-end;
-
-procedure readydata;
-var fi: file of iconarraytype;
-begin
- assign(fi,'data\icons.vga');
- reset(fi);
- read(fi,icons);
- close(fi);
- new(map);
- new(temp);
- loadmap;
- done:=false;
- curx:=2;
- cury:=2;
- tcolor:=63;
- bkcolor:=0;
- locx:=16;
- locy:=16;
- facingdir:=1.57;
-end;
-
-procedure draw2;
-begin
- for i:=0 to 160 do
-  mymove(temp^[i+locy,locx],screen[10+i,10],40);
-end;
-
-procedure redraw;
-begin
- for a:=-3+curx to 2+curx do
-  for b:=-3+cury to 2+cury do
-   begin
-    if a<0 then c:=255+a
-     else if a>254 then c:=a-255
-     else c:=a;
-    if b<0 then d:=255+b
-     else if b>254 then d:=b-255
-     else d:=b;
-    y:=(b-cury)*32+96;
-    x:=(a-curx)*32+96;
-    for i:=0 to 31 do
-     mymove(icons[map^[d,c],i],temp^[y+i,x],8);
-   end;
-end;
-
-procedure drawmap;
-begin
- x3:=locx;
- f:=yc;
- e:=xc;
- for j:=0 to 119 do
-  begin
-   f:=f+dy;
-   e:=e+dx;
-   inc(x3);
-   y3:=locy;
-   g:=0;
-   h:=0;
-   for i:=0 to 119 do
-    begin
-     inc(y3);
-     g:=g+dy2;
-     h:=h+dx2;
-     screen[round(f-g),round(e+h)]:=temp^[y3,x3];
-     screen[round(f-g)+1,round(e+h)]:=temp^[y3,x3];
-    end;
-  end;
-end;
-
-procedure mainloop;
-begin
- redraw;
- x1:=-60*cos(-facingdir);
- y1:=-60*sin(-facingdir);
- x2:=60*cos(-facingdir+1.57);
- y2:=60*sin(-facingdir+1.57);
- xc:=round(x1+x2)+160;
- yc:=round(y1+y2)+100;
- dx:=(x1+160-xc)/60;
- dy:=(y1+100-yc)/60;
- dx2:=cos(facingdir);
- dy2:=sin(facingdir);
- repeat
-  drawmap;
-    ans:=readkey;
-    case ans of
-     #0: begin
-          ans:=readkey;
-          case ans of
-           #72: begin
-                 locx:=locx+round(7*cos(facingdir));
-                 locy:=locy+round(7*sin(facingdir));
-                 if locx>31 then
-                   begin
-                    if curx=254 then curx:=0 else inc(curx);
-                    locx:=locx-32;
-                    redraw;
-                   end
-                 else if locx<0 then
-                   begin
-                    if curx=0 then curx:=254 else dec(curx);
-                    locx:=locx+32;
-                    redraw;
-                   end;
-                 if locy>31 then
-                   begin
-                    if cury=254 then cury:=0 else inc(cury);
-                    locy:=locy-32;
-                    redraw;
-                   end
-                 else if locy<0 then
-                   begin
-                    if cury=0 then cury:=254 else dec(cury);
-                    locy:=locy+32;
-                    redraw;
-                   end;
-                end;
-           #77: begin
-                 facingdir:=facingdir+0.314;
-                 if facingdir>6.28 then facingdir:=facingdir-6.28;
-                 x1:=-60*cos(-facingdir);
-                 y1:=-60*sin(-facingdir);
-                 x2:=60*cos(-facingdir+1.57);
-                 y2:=60*sin(-facingdir+1.57);
-                 xc:=round(x1+x2)+160;
-                 yc:=round(y1+y2)+100;
-                 dx:=(x1+160-xc)/60;
-                 dy:=(y1+100-yc)/60;
-                 dx2:=cos(facingdir);
-                 dy2:=sin(facingdir);
-                end;
-           #75: begin
-                 facingdir:=facingdir-0.314;
-                 if facingdir<0 then facingdir:=facingdir+6.28;
-                 x1:=-60*cos(-facingdir);
-                 y1:=-60*sin(-facingdir);
-                 x2:=60*cos(-facingdir+1.57);
-                 y2:=60*sin(-facingdir+1.57);
-                 xc:=round(x1+x2)+160;
-                 yc:=round(y1+y2)+100;
-                 dx:=(x1+160-xc)/60;
-                 dy:=(y1+100-yc)/60;
-                 dx2:=cos(facingdir);
-                 dy2:=sin(facingdir);
-                end;
-{          case ans of
-           #72: if locy<4 then
-                  begin
-                   locy:=31;
-                   if cury=0 then cury:=254 else dec(cury);
-                   redraw;
-                  end
-                 else dec(locy,4);
-           #80: if locy>27 then
-                  begin
-                   locy:=0;
-                   if cury=254 then cury:=0 else inc(cury);
-                   redraw;
-                  end
-                 else inc(locy,4);
-           #75: if locx<4 then
-                  begin
-                   locx:=31;
-                   if curx=0 then curx:=254 else dec(curx);
-                   redraw;
-                  end
-                 else dec(locx,4);
-           #77: if locx>27 then
-                  begin
-                   locx:=0;
-                   if curx=254 then curx:=0 else inc(curx);
-                   redraw;
-                  end
-                 else inc(locx,4);
-           #77: if curx=254 then curx:=0 else inc(curx);
-           #61: savemap;
-           #59: done:=true;
-}          end;
-          str(curx:3,str1);
-          str(cury:3,str2);
-          printxy(280,20,str1+','+str2);
-          str(locx:3,str1);
-          str(locy:3,str2);
-          printxy(280,30,str1+','+str2);
-         end;
-     '1': map^[cury,curx]:=random(2);
-     '2': map^[cury,curx]:=random(5)+2;
-     '3': map^[cury,curx]:=7;
-     '4': map^[cury,curx]:=8;
-     '5': map^[cury,curx]:=9;
-     '6': map^[cury,curx]:=10;
-     '7': map^[cury,curx]:=11;
-     #27: done:=true;
-    end;
- until done;
-end;
-
-procedure changes;
-begin
-{ for i:=0 to 254 do
-  for j:=0 to 254 do
-   map^[i,j]:=random(2);}
-end;
-
-begin
- readydata;
- changes;
- mainloop;
-end.
\ No newline at end of file
diff --git a/makedata/editscr.pas b/makedata/editscr.pas
deleted file mode 100644
index 2284b96..0000000
--- a/makedata/editscr.pas
+++ /dev/null
@@ -1,208 +0,0 @@
-program makescreen;
-uses crt;
-
-type
- icontype= array[1..17,1..15] of byte;
- fonttype= array[1..3] of byte;
- colortype= array[1..3] of byte;
- paltype= array[0..255] of colortype;
- screentype=array[0..199,0..319] of byte;
-
-const
-  font: array[1..54] of fonttype=(
-(0,0,0),       { }(102,96,96),   {!}(85,80,0),     {"}(34,0,0),      {'}
-(36,68,32),    {(}(66,34,64),    {)}(9,105,0),     {*}(4,228,0),     {+}
-(0,2,36),      {,}(0,240,0),     {-}(0,6,96),      {.}(1,36,128),    {/}
-(107,221,96),  {0}(38,34,112),   {1}(105,36,240),  {2}(225,97,224),  {3}
-(53,241,16),   {4}(248,113,224), {5}(36,233,96),   {6}(241,36,128),  {7}
-(105,105,96),  {8}(105,113,32),  {9}(102,6,96),    {:}(102,6,98),    {;}
-(18,66,16),    {<}(15,15,0),     {=}(132,36,128),  {>}(105,32,32),   {?}
-
-(105,249,144), {a}(233,233,224), {b}
-(105,137,96),  {c}(233,153,224), {d}(248,232,240), {e}(248,232,128), {f}
-(105,139,96),  {g}(153,249,144), {h}(114,34,112),  {i}(17,25,96),    {j}
-(154,202,144), {k}(136,136,240), {l}(159,153,144), {m}(157,185,144), {n}
-(105,153,96),  {o}(233,232,128), {p}(105,155,112), {q}(233,234,144), {r}
-(120,97,224),  {s}(114,34,32),   {t}(153,153,96),  {u}(153,150,96),  {v}
-(153,187,96),  {w}(153,105,144), {x}(153,114,64),  {y}(242,72,240))  {z};
-
-var
- tdelay,index,curx,x,cury,i,j,backcolor,
- testdriver,mode,driver,errcode,last,under,textcolor: integer;
- ans: char;
- vgastr: string;
- temppal,colors: paltype;
-
-
-{$L video}
-
-procedure initvga; external;
-procedure setpix(x,y: integer; pcolor: byte); external;
-function  getpix(x,y: integer ): byte; external;
-
-{$F+}
-
-procedure loadpal(s: string);
-var palfile: file of paltype;
-begin
- assign(palfile,s);
- reset(palfile);
- read(palfile,colors);
- close(palfile);
-end;
-
-procedure set256Colors(var pal : paltype); assembler;
-asm
- mov ax, 1012h
- mov bx, 0
- mov cx, 256
- les dx, Pal
- int 10h
-end;
-
-procedure save;
-var vgadata: file of screentype;
-    temp: ^screentype;
-begin
- new(temp);
- setpix(curx,cury,under);
- assign(vgadata,vgastr+'.sga');
- reset(vgadata);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-    temp^[i,j]:=getpix(j,i);
- write(vgadata,temp^);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-    temp^[i,j]:=getpix(j,i+200);
- write(vgadata,temp^);
- close(vgadata);
- dispose(temp);
-end;
-
-procedure load;
-var vgadata: file of screentype;
-    temp: ^screentype;
-begin
- new(temp);
- assign(vgadata,vgastr+'.sga');
- reset(vgadata);
- read(vgadata,temp^);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   setpix(j,i,temp^[i,j]);
- read(vgadata,temp^);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   setpix(j,i+200,temp^[i,j]);
- close(vgadata);
- dispose(temp);
- last:=getpix(curx,cury);
- under:=getpix(curx,cury);
-end;
-
-procedure savepalette;
-var palfile: file of paltype;
-begin
- assign(palfile,vgastr+'.pal');
- reset(palfile);
- write(palfile,colors);
- close(palfile);
- set256colors(colors);
-end;
-
-procedure myswap(a,b: byte);
-var c: colortype;
-begin
- c:=colors[a];
- colors[a]:=colors[b];
- colors[b]:=c;
-end;
-
-procedure converterasdfasd;
-var temp: ^screentype;
-begin
- new(temp);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   temp^[i,j]:=getpix(j,i);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   begin
-    setpix(j,i*2,temp^[i,j]);
-    setpix(j,i*2+1,temp^[i,j]);
-   end;
- dispose(temp);
-end;
-
-procedure readpalette;
-var palfile: file of paltype;
-begin
- assign(palfile,vgastr+'.pal');
- reset(palfile);
- read(palfile,colors);
- close(palfile);
- set256colors(colors);
-end;
-
-procedure mainloop;
-begin
- repeat
-   setpix(curx,cury,getpix(curx,cury)+2);
-   if keypressed then
-   begin
-   ans:=readkey;
-   case upcase(ans) of
-    #0:begin
-        ans:=readkey;
-        setpix(curx,cury,under);
-        case ans of
-         #72:if cury=0 then cury:=399 else dec(cury);
-         #80:if cury=399 then cury:=0 else inc(cury);
-         #75:if curx=0 then curx:=319 else dec(curx);
-         #77:if curx=319 then curx:=0 else inc(curx);
-         #71:begin curx:=(curx div 10) - 1; curx:=curx*10 mod 320; end;
-         #79:begin curx:=(curx div 10) + 1; curx:=curx*10 mod 320; end;
-         #73:begin cury:=(cury div 10) - 1; cury:=cury*10 mod 400; end;
-         #81:begin cury:=(cury div 10) + 1; cury:=cury*10 mod 400; end;
-        end;
-        under:=getpix(curx,cury);
-       end;
-    ' ':under:=last;
-    'S':save;
-    'L':load;
-    '1':begin under:=0; last:=0; end;
-    '2':begin under:=16; last:=16; end;
-    '3':begin under:=32; last:=32; end;
-    '4':begin under:=48; last:=48; end;
-    '5':begin under:=64; last:=64; end;
-    '6':begin under:=80; last:=80; end;
-    '7':begin under:=96; last:=96; end;
-    '8':begin under:=112; last:=112; end;
-    '9':begin under:=128; last:=128; end;
-    'Q':begin under:=144; last:=144; end;
-    'W':begin under:=160; last:=160; end;
-    'E':begin under:=176; last:=176; end;
-    'R':begin under:=192; last:=192; end;
-    'T':begin under:=208; last:=208; end;
-    '+':begin inc(under); last:=under; end;
-    '-':begin dec(under); last:=under; end;
-    'S':save;
-    'L':load;
-   end;
-   end;
- until ans=#59;
-end;
-
-begin
- initvga;
- vgastr:=paramstr(1);
-
- x:=100;
- curx:=0;
- cury:=0;
- load;
- readpalette;
- mainloop;
- textmode(co80);
-end.
\ No newline at end of file
diff --git a/makedata/elemmake.pas b/makedata/elemmake.pas
index b23b7cb..7d96863 100644
--- a/makedata/elemmake.pas
+++ b/makedata/elemmake.pas
@@ -1,4 +1,20 @@
 program generatecargodata;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 type
  cargotype=
@@ -17,7 +33,7 @@ var
 
 begin
  assign(f,'\ironseed\data\elements.dta');
- reset(f);
+ rewrite(f);
  assign(ft,'\ironseed\makedata\element.txt');
  reset(ft);
  read(ft,index);
diff --git a/makedata/end1.txt b/makedata/end1.txt
deleted file mode 100644
index a3078a7..0000000
--- a/makedata/end1.txt
+++ /dev/null
@@ -1,57 +0,0 @@
-When we had defeated what we thought 
-was the last of the scourge a sea of
-scavenger ships appeared through God's
-Eye! The fleet we had destroyed was
-only a small fraction of the armada
-that now poured from the other side of
-space.
- Ships from every empire threw
-themselves into the frey. Gouts of firey
-death rained down from every ship, hot
-steel boiling off into the vacuum. Each 
-of us said a prayer. Turning the ship 
-about we sent the Ironseed head long 
-into battle. There was no hope of 
-survival. We were struck by a full salvo
-from a Scavenger incorporator and all
-seemed lost.
-
-We waited for the death shot but it
-never came. All firing stopped and
-for a moment silence fell across the 
-ship. 
- A great swirling void as red as blood
-enveloped the Eye. Gravimetric readings 
-went off the scale. Science couldn't  
-explain it. Space itself was being wrent 
-apart. Angry bolts of energy lashed out 
-through the wall of ships and debris, 
-vast tracks of empty space left in their 
-wake. The dark fleet was collapsing back 
-into the wake of the void!
- Ships struggled to break free. There 
-was no escape as the last of them fell 
-into the void. 
- As the last ship fell out of sight we 
-received a message...
-...from the scavenger overmind.
-
-
- The swirling red of the void receeded 
-and brightened to a glowing center.
-The intense psychic energy released
-must be responsible for what we saw 
-next. A great pair of human hands
-appeared in the space around the void
-and a voice spoke, warm and comforting.
-"We are the Monks, the Keepers of 
-Hallifax, the Eye of God. We see all
-things. This day we saw great evil
-about to be done. The Scavengers are
-with us now. They were ours from the
-beginning.
- You brought us the prize for this 
-we grant you what lies beyond the Eye."
-A great blue sphere came through the 
-light and the brightness vanished along
-with the Eye itself.
diff --git a/makedata/endtext2.txt b/makedata/endtext2.txt
deleted file mode 100644
index 871c388..0000000
--- a/makedata/endtext2.txt
+++ /dev/null
@@ -1 +0,0 @@
-_________________________________________________
diff --git a/makedata/event0.txt b/makedata/event0.txt
deleted file mode 100644
index daa2d6f..0000000
--- a/makedata/event0.txt
+++ /dev/null
@@ -1,121 +0,0 @@
-Sengzhac
-LOG45                 NOTHING                 WE HAVE NOTHING MORE TO SAY TO YOU...
-LOG34                 NOTHING                 still WE DO not think you Are worthy... do more for us.
-log24                 doom gate(log45)        we will be joining your silly kendar. EXPLAIN WHY THE TEMPLE IS SIGNIFIGANT.
-log0                  nothing                 YOU RETURN? DIE, LITTLE PIGGY!
-
-
-
-
-
-
-D'phak
-LOG46                 NOTHING                 FINAL HELLO...
-log18                 thermaturge(LOG46)      join the kendar
-LOG43                 NOTHING                 AHHH... YOU HAVE RETURNED
-log30                 NOTHING                 d'pahk suggest giving yiller genes to the guild
-LOG34                 NOTHING                 YOU HAVE NO MERIT... WE WILL NOT JOIN (THE ERMIGEN HAVE NOT JOINED)
-log1                  nothing                 ahhh... you have returned.
-
-
-
-
-Aard
-LOG45                 LOG31                   HELLO SIGNIFYING THAT THEY ARE NOW MEMBERS...
-LOG27(ERMIGEN DEATH)  NOTHING                 YOU MUST HURRY AND GATHER TOGETHER THE KENDAR
-
-
-
-
-
-
-
-
-Ermigen
-LOG34                 NOTHING                 HELLO AGAIN FELLOW MEMBER.
-LOG32                 LOG34                   WE WILL JOIN(INCLUDE THEM TELLING YOU ABOUT THE TROJAN GATE.)
-LOG33                 NOTHING                 HELLO AGAIN.
-TORQUE STANCHION      LOG33                   THANKS.
-
-
-
-
-
-
-Titarian
-LOG47                 NOTHING                 LAST HELLO...
-LOG36                 LOG47                   WE JOIN THE KENDAR
-LOG35                 NOTHING                 THEY MENTION THE DERELICT (MAYBE THE LOCATION?)
-LOG4                  LOG35                   WE FORESEE A BRIGHT SPOT
-LOG25                 NOTHING                 PIRATE IS DEAD RESPONSE
-LOG37                 NOTHING                 WE TELL YOU WHERE THE PIRATE IS
-
-
-
-
-Quai Pa'loi
-SILLY PART 1          GOOD PART 1             THANKS 1
-SILLY PART 2          GOOD PART 2             THANKS 2
-SILLY PART 3          GOOD PART 3             THANKS 3
-LOG 48                NOTHING                 FINAL HELLO
-GOOLAS                MULTI-IMAGER(LOG48)     END WAR JOIN KENDAR?
-LOG38                 NOTHING                 WE'RE HAVING A WAR ALREADY...SHEESH. GO AWAY.
-LOG13                 LOG38(QUAI WAR)         QUAI WAR...
-LOG30(ERMGN DEAD)     NOTHING                 TENSION MOUNTS... THE PLOT THICKENS
-LOG21                 NOTHING                 STRANGE THINGS ARE AFOOT AT THE CIRCLE K
-LOG 5                 NOTHING                 HELLO AGAIN
-Scavengers
-LOG30                 NOTHING                 WE ARE NEW IMPROVED VERY EVIL SCAVENGERS... WE WILL DESTROY YU ALL (CACKLES)
-LOG21                 NOTHING                 A BIT MORE AGRESSIVE
-LOG6                  NOTHING                 THE OTHER HELLO...
-
-
-
-
-
-
-
-Icon
-GLYPTIC SCYTHE        NOTHING                 WE DECYPHERED THE WORD CUTTER... AND THE MOCH STAND FOR...
-LOG21                 NOTHING                 GO FORTH AND SPEAK FOR US THAT THE KENDAR MIGHT BE AGAIN!
-
-
-
-
-
-
-
-
-The Guild
-IF LOG39 EXISTS THEN SKIP NEXT IF LOG SCAN
-LOG38                 LOG39                   THE MOCH HAVE THE GOOLAS
-LOG44                 NOTHING                 FINAL HELLO (HERE'S HOW YOU KILL THE SCAVENGERS)
-LOG25                 LOG44                   WE JOIN YOU NOW... THIS KENDAR OF YOURS.
-LOG43                 LOG41                   WE KNOW WHAT WE WANT YOU TO DO... KILL DERRAAK
-LOG49                 LOG43                   NOW... BEFORE WE JOIN, WE NEED TO YOU NO KILL DERRAAK.
-LOG8                  NOTHING                 HELLO... I BELIEVE WE'VE MET.
-
-
-
-Phaedor Moch
-LOG48(QUAI WAR ENDS)  NOTHING                 FINAL HELLO
-LOG39             GOOLAS(IF DON'T HAVE THEM)  AND WE HAVE THE GOOLAS!!
-LOG40                 NOTHING                 OTHER HELLO
-NOTHING               GLYPTIC SCYTHE(LOG40)   HAPPY? I THOUGHT SO.(TAKE IT TO THE ICON)
-
-
-
-
-
-
-Void Dwellers
-LOG44                 NOTHING                 FINAL HELLO
-LOG19                 LOG44                   VOID DWELLERS TELL YOU ABOUT GOD EYE... IT'S SIGNIFIGANCE.
-LOG9                  NOTHING                 OTHER HELLO
-
-
-
-
-
-
-
diff --git a/makedata/eventmak.pas b/makedata/eventmak.pas
index ce159d6..68b69ba 100644
--- a/makedata/eventmak.pas
+++ b/makedata/eventmak.pas
@@ -1,4 +1,20 @@
 program eventmake;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 uses crt;
 
diff --git a/makedata/events.txt b/makedata/events.txt
deleted file mode 100644
index cb28081..0000000
--- a/makedata/events.txt
+++ /dev/null
@@ -1,175 +0,0 @@
-events
-
-SPE==Set Pending Event
-
-1-10    these events are unset after each conversation
-
-200-300   main story events
-
-201     brought psycometrist back online, and activated sector codex
-202     found satellite from human ship
-203     find phaedor moch ship damaged and fighting
-204     shoot down phaedor moch
-205     repair phaedor moch ship <receive strange panel from P6>
-206     meet hallifax manuever
-207     scavengers meet you
-208     teach scavengers pain
-209     get coolents from QP
-210     get solonoids from QP
-211     get hull increasing artifact from QP
-212     get Muriel from QP (SPE for QP war)
-213     Quai Pa'loi go to war
-214     offer help to q'ooul
-215     guild tells you the moch have the goo launchers
-216     fix muriel's stasis field
-217     wake muriel
-218     muriel tells you where her mother is
-219     ermigen tell you about trojan gate
-220     use trojan gate
-221     confront guild about destroyed planet
-222     learn name of ylinthelixymn (yillers)
-223     scavs capture muriel
-224     destroy scav guarding base
-225     aria tells you muriel is android
-226     aria gives you a scavenger brain
-227     rescue muriel and get info on yillers (SPE muriel talk with you)
-228     muriel encodes herself
-229     get distress signal from aard
-230     help aard, aard undisquise themselves (SPE science talk...set up
-        morph-talk program
-232     titerian mention bright spot
-233     titerian tell you about race that worships titerian
-234     meet the race of titerian worshipers
-235     find abandoned world of monks
-236     tell worshipers that monks moved...they tell you about shunt world
-237     tell worshipers answer to question after consulting monks
-238     dpank suggest giving yiller genes to guild
-239     give genes to guild..get many cool things 
-240     titerian tell about derelict
-241     find derelict
-242     get thermoplast tech
-244     system with bright spot goes nova (and vision occurs in blackout)
-        (SPE for void dwellers to tell you about god's eye) <SPE for titerian
-        to tell about derelict)
-246     void dwellers tell you about eye (SPE for vision "seek sight in iron")
-248     shunt ship crash
-249     get shunt drive (SEP for crew comments)
-250     first try to install shunt
-251     second try to install shunt
-252     third try to install shunt
-253     fourth try to install shunt (SEP for more crew comments) (SEP for
-        guild to tell you how to destroy scavs using drive)
-254     guild tell you about shunt drive and starhammers (SEP for MalZatoir
-        to be destroyed)
-255     MalZatoir destroyed (SEP for icon to contact you)
-256     icon bouy contacts you
-257     icon decipher panel from moch ship
-258     moch trade you guns for worthless junk
-259     icon tell you about hallifax
-260     activate sheild device at hallifax
-261     monks ask you to bring them mobius device (SEP for temple vision)
-262     have vision and get temple coords
-263     give guns to q'ooul war over
-264     rewarded for winning war with multi-imager
-265     find temple (SEP for crew to tell you to use detonator)
-266     blast into temple (SEP for void dwellers to tell you location of
-        god's eye) (SEP for derraak to steal shunt drive)
-267     derraak steals shunt drive
-268     guild tell you ask titerians about derraak
-270     guild tell you derraak's favorite system to hide in
-271     titerians tell you what they know about him (SPE for crew to suggest
-        how to catch him)
-272     crew tell you how to catch him (SPE for derraak to attack in his
-        favorite system)
-273     plant homing device on derraak
-274     find derraak's base
-275     destroy derraak's ship
-276     retrieve shunt drive and other things
-277     repair drive (SPE for crew to tell you you don't have enough energy
-        to activate the drive.) (SPE for someone to tell you that the
-        ermigen are destroyed and scavs are gathering at a planet with
-        a trojan gate)
-278     search ermigen homeworld and find records
-279     send thermal probot to sun and get anchor (SPE for dpahk to ask you
-        about probot for them)
-280     give probot to dpahk and get thermaturge
-281     talk to sengzhac and get doom gate
-282     build mobius device
-283     give device to monks and lower number of sengzhac at final battle
-        (won't let you go to god's eye until scavs are destroyed)
-284     your ship is nearly destroyed by scavs...they learn hope...
-285     launch shunt into gate
-286     enter gate after shunt
-287     defeat the sengzhac
-288     activate device (SPE for vision in 2 minutes)
-289     place channeler in device
-290     activate device and win
-291     you are told that the ermigen were destroyed on purpose
-292     aria found killed by scavengers
-
-COVO SETS FOR CHRISP
-600-700
-
-600    Dpahk tell you about QP war
-601    first trade with void dwellers
-602    void dwellers tell coords of god's eye
-603    confront ermigen with fear
-604    give scavs info
-605    first talk to murial
-606    first talk to aria
-607    told aria about muriel
-608    aria told you about brain
-
-OTHER EVENTS 20000-20100
-20000  exit conversation
-20001  trade
-20002  exit into battle
-20003  increase anger 1
-20004  increase anger 5
-20005  decrease anger 1
-20006  decrease anger 5
-20007  yes/no question   next entry is yes answer  second entry is no answer
-
-OTHER EVENTS CHRISP
- 20100-20200
-
-20100   if player has thrermal probot, take it and give them a thermaturge
-        then set event 280 and exit conversation
-20101   if player has coolant and radioactive, take it and give them
-        strange panel, then set event 205
-20102   set event 246 and set up for vision from the **** about seek sight
-        in iron when the ship engages its engines the next time
-20103   if player has a data board, take it and give him 10 industrial chemicals...set
-        event 209
-20104   if player has a data board, take it and give him 20 solonoids...set
-        event 210
-20105   if player has a data board, take it and give him artifact to increase
-        hull points...set event 211
-20106   if player has a data board, take it and give him muriel...set
-        event 212
-20107   give player the multi-imager...they cannot drop this item.  also set
-        event 264
-20108   take yiller genetic material from player and give the player some neat
-        stuff.  set event 239 and exit conversation.(after giving player time
-        to read the text of course)
-20109   if 230 (morphtalk) is not set then
-               display message #54 and exit to battle
-        if 230 is set then
-           if 266 (been to temple) is not set, then
-               display message #56 and exit con peacefully
-           else...if 266 is set then
-               if 264 (imager) is not set then display mess #55 and exit
-                  peacefully
-               if 264 is set then display message #56 (56 HAS MULTIPLE LINES)
-20110   give player a doom gate and set 281
-20111   if player has worthless junk, then take it and give goolas and set
-        258, and print "P6> HERE YOU ARE."...if no junk, then just print
-        "YOU HAVE NO JUNK...SORRY."
-        (NOTE:  goolas cannot be dropped.)
-20112   if player has stratamount, take it and set event 230 and print
-        "Thank you, we will not forget this."
-        if player doesn't have a stratamount, then print
-        "Then please find one and bring it to us."
-20113   set event 208 and exit con...the scavenger ship should leave quickly
-        before any communication or battle attempts can be made.
-20114   give player scavenger brain and set event 226 (note: can't drop brain)
diff --git a/makedata/events0.txt b/makedata/events0.txt
deleted file mode 100644
index a88f0f1..0000000
--- a/makedata/events0.txt
+++ /dev/null
@@ -1,207 +0,0 @@
-W acky New Event List
-
-big wacky logs for meetin' aliens
-
-0 SENGZHAC
-1 D'PAHK
-2 AARD
-3 ERMIGEN
-4 TITARIAN
-5 QUAI PA'LOI
-6 SCAVENGERS
-7 ICON
-8 GUILD
-9 VOID DWELLERS
-10 GREETINGS AND HALLUCINATIONS
-11 SECTOR CODEX
-12 SECOND BUOY LOCATED
-13 HALLIFAX MANEUVER
-14 TROJAN GATE
-15 A PLANET'S DESTRUCTION
-16 MONKS OF PAPESIA
-17 DERELICT DISCOVERED
-18 DEVELOPMENT OF THERMOPLAST TECHNOLOGY
-19 ENCOUNTERED NOVA (INCLUDE VISION OF TEMPLE COORD)
-20 LOCATION OF SHUNT CAPABLE SHIP
-21 DESTRUCTION OF THE MALZATOIR
-22 DISCOVERY OF ICON DATA BUOY
-23 GUILD JOIN
-24 INSIDE THE TEMPLE OF IRON
-25 INSIDE THE PIRATE BASE
-26 PIRACY!
-27 ICON TRANSMISSION
-28 ERMIGEN DATA TAPES
-29 LAST SCAVENGER TRANSMISSION
-30 THE ERMIGEN WERE DESTROYED
-31 THE AARD JOIN THE KENDAR
-32 ICON URGE YOU TO REFORM THE KENDAR
-33 REPAIR THE ERMIGEN SHIP
-34 ERMIGEN JOIN THE KENDAR
-35 TITARIANS MENTION BRIGHT SPOT?
-36 SHUNT DRIVE RESEARCH COMPLETED
-37 GUILD WANTS DERRAAK ELIMINATED
-38 QUAI GO TO WAR
-39 THE GUILD TELL YOU THAT THE MOCH HAVE THE GOOLAS
-40 ENCOUNTER THE PHAEDOR MOCH AND REPAIR THEIR SHIP
-41 GUILD TELL YOU HOW AND WHERE TO DEFEAT DERRAAK(THE PIRATE)
-42 FIND TEMPLE OF IRON
-43 GUILD THNK YOU FOR YLINTH'S GENES
-44 VOID DWELLERS TELL YOU ABOUT GOD'S EYE
-45 RECEIVE DOOM GATE
-46 RECEIVE THERMATURGE
-47 TITARIAN JOIN THE KENDAR
-48 QUAI PALOI JOIN KENDAR
-Sengzhac
-what do they want?      what do they give?      statement?
-0.LOG45                 NOTHING                 WE HAVE NOTHIHNG MORE TO SAY TO YOU...
-1.LOG34                 NOTHING                 WE WILL BE WANTING YOUR (SOMETHING), BRING IT TO US.
-2.log24                 doom gate(log45)        we will be joining your silly kendar.
-3.other thingy          nothing                 we still do not think that you re worthy... do more for us.
-4.log0                  nothing                 YOU RETURN? DIE, LITTLE PIGGY
-5.
-6.
-7.
-8.
-9.
-
-D'phak
-what do they want?      what do they give?      statement?
-0.LOG 46                NOTHING                 FINAL HELLO...
-1.log18                 thermaturge(LOG46)      join the kendar
-2.log30                 NOTHING                 d'pahk suggest giving yiller genes to the guild
-3.LOG 34                NOTHING                 YOU HAVE NO MERIT... WE WILL NOT JOIN (THE ERMIGEN HAVE NOT JOINED)
-4.log1                  nothing                 ahhh... you have returned.
-5.
-6.
-7.
-8.
-9.
-
-Aard
-what do they want?      what do they give?      statement?
-0.LOG45                 LOG31                   HELLO SIGNIFYING THAT THEY ARE NOW MEMBERS...
-1.LOG27(ERMIGEN DEATH)  NOTHING                 YOU MUST HURRY AND GATHER TOGETHER THE KENDAR
-2.
-3.
-4.
-5.
-6.
-7.
-8.
-9.
-
-Ermigen
-what do they want?      what do they give?      statement?
-3.LOG34                 NOTHING                 HELLO AGAIN FELLOW MEMBER.
-2.LOG32                 LOG34                   WE WILL JOIN(INCLUDE THEM TELLING YOU ABOUT THE TROJAN GATE.)
-1.LOG33                 NOTHING                 HELLO AGAIN.
-0.SOME SHIP PART        LOG33                   THANKS.
-4.
-5.
-6.
-7.
-8.
-9.
-
-Titarian
-what do they want?      what do they give?      statement?
-0.LOG47                 NOTHING                 LAST HELLO...
-1.LOG36                 LOG47                   WE JOIN THE KENDAR
-2.LOG35                 NOTHING                 THEY MENTION THE DERELICT (MAYBE THE LOCATION?)
-3.LOG4                  LOG35                   WE FORESEE A BRIGHT SPOT
-4.LOG25                 NOTHING                 PIRATE IS DEAD RESPONSE
-5.LOG37                 NOTHING                 WE TELL YOU WHERE THE PIRATE IS
-6.
-7.
-8.
-9.
-
-Quai Pa'loi
-what do they want?      what do they give?      statement?
-0.SILLY PART 1          GOOD PART 1             THANKS 1
-1.SILLY PART 2          GOOD PART 2             THANKS 2
-2.SILLY PART 3          GOOD PART 3             THANKS 3
-3.LOG 48                NOTHING                 FINAL HELLO
-4.GOOLAS                MULTI-IMAGER(LOG48)     END WAR JOIN KENDAR?
-5.LOG38                 NOTHING                 WE'RE HAVING A WAR ALREADY...SHEESH. GO AWAY.
-6.LOG13                 LOG38(QUAI WAR)         QUAI WAR...
-7.LOG30(ERMGN DEAD)     NOTHING                 TENSION MOUNTS... THE PLOT THICKENS
-8.LOG21                 NOTHING                 STRANGE THINGS ARE AFOOT AT THE CIRCLE K
-9.LOG 5                 NOTHING                 HELLO AGAIN
-
-Scavengers
-what do they want?      what do they give?      statement?
-0.LOG30                 NOTHING                 WE ARE NEW IMPROVED VERY EVIL SCAVENGERS... WE WILL DESTROY YU ALL (CACKLES)
-1.LOG21                 NOTHING                 A BIT MORE AGRESSIVE
-2.LOG6                  NOTHING                 THE OTHER HELLO...
-3.
-4.
-5.
-6.
-7.
-8.
-9.
-
-Icon
-what do they want?      what do they give?      statement?
-0.GLYPTIC SCYTHE  ???   NOTHING                 WE DECYPHERED THE WORD CUTTER... AND THE MOCH STAND FOR...
-1.LOG21                 NOTHING                 GO FORTH AND SPEAK FOR US THAT THE KENDAR MIGHT BE AGAIN!
-2.
-3.
-4.
-5.
-6.
-7.
-8.
-9.
-
-The Guild
-what do they want?      what do they give?      statement?
-0.IF LOG39 EXISTS THEN SKIP NEXT IF LOG SCAN
-1.LOG38                 LOG39                   THE MOCH HAVE THE GOOLAS
-2.LOG44                 NOTHING                 FINAL HELLO (HERE'S HOW YOU KILL THE SCAVENGERS)
-3.LOG26(PIRATE DEFEATED)LOG23                   WE JOIN YOU NOW... THIS KENDAR OF YOURS.
-4.LOG43                 LOG41                   WE KNOW WHAT WE WANT YOU TO DO... KILL DERRAAK
-5.YLINTH GENES          LOG43                   NOW... BEFORE WE JOIN, WE NEED TO YOU NO KILL DERRAAK.
-6.
-7.
-8.
-9.
-
-Phaedor Moch
-what do they want?      what do they give?      statement?
-3.LOG48(QUAI WAR ENDS)  NOTHING                 FINAL HELLO
-1.LOG39        GOOLAS (IF THEY DON'T YET HAVE THE GOOLAS)  AND WE HAVE THE GOOLAS!!
-0.LOG40                 NOTHING                 OTHER HELLO
-2.(FIRST MEET)NOTHING   GLYPTIC SCYTHE(LOG40)   HAPPY? I THOUGHT SO.(TAKE IT TO THE ICON)
-4.
-5.
-6.
-7.
-8.
-9.
-
-Void Dwellers
-what do they want?      what do they give?      statement?
-0.LOG44                 NOTHING                 FINAL HELLO
-1.LOG19                 LOG44                   VOID DWELLERS TELL YOU ABOUT GOD EYE... IT'S SIGNIFIGANCE.
-2.LOG9                  NOTHING                 OTHER HELLO
-3.
-4.
-5.
-6.
-7.
-8.
-9.
-
-MONKS
-what do they want?      what do they give?      statement?0.
-1.???
-2.
-3.
-4.
-5.
-6.
-7.
-8.
-9.
\ No newline at end of file
diff --git a/makedata/explode3.sam b/makedata/explode3.sam
deleted file mode 100644
index 65734d1..0000000
Binary files a/makedata/explode3.sam and /dev/null differ
diff --git a/makedata/fight.cpr b/makedata/fight.cpr
deleted file mode 100644
index d7a141a..0000000
Binary files a/makedata/fight.cpr and /dev/null differ
diff --git a/makedata/font.cpr b/makedata/font.cpr
deleted file mode 100644
index 1dd4dc3..0000000
Binary files a/makedata/font.cpr and /dev/null differ
diff --git a/makedata/getfont.pas b/makedata/getfont.pas
index 113b611..bc645c2 100644
--- a/makedata/getfont.pas
+++ b/makedata/getfont.pas
@@ -1,4 +1,20 @@
 program getfontfromfile;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 uses crt,graftool;
 
diff --git a/makedata/getscree.pas b/makedata/getscree.pas
deleted file mode 100644
index 0ae1c98..0000000
--- a/makedata/getscree.pas
+++ /dev/null
@@ -1,102 +0,0 @@
-program getscreen;
-{$M 2000,70000,70000}
-uses crt,Dos;
-type
- screentype= array[0..199,0..319] of byte;
- colort2= array[0..2] of byte;
- colortype= array[0..255] of colort2;
- texttype= array[0..24,0..79] of integer;
-var
-  Int1cSave : Pointer;
-  breakflag: boolean;
-  vgafile: file of screentype;
-  palfile: file of colortype;
-  txtfile: file of texttype;
-  j,i: integer;
-  buffer: ^screentype;
-  colors: colortype;
-  screen: screentype absolute $A000:0000;
-  textscreen: texttype absolute $B800:0000;
-  buffer2: ^texttype;
-
-procedure getrgb256(palnum: byte; var r,g,b); assembler;
-asm
- xor bh, bh
- mov bl, palnum
- mov ax, 1015h
-  int 10h
- les di, r
- mov es:[di], dh
- les di, g
- mov es:[di], ch
- les di, b
- mov es:[di], cl
-end;
-
-procedure convert;
-var min, index: integer;
-    temp: colort2;
-begin
- min:=colors[0,0]+colors[0,1]+colors[0,2];
- if min=0 then exit;
- for j:=0 to 255 do
-  if (colors[j,0]+colors[j,1]+colors[j,2])<min then
-   begin
-    index:=j;
-    min:=colors[j,0]+colors[j,1]+colors[j,2];
-   end;
- if index=0 then exit;
- temp:=colors[index];
- colors[index]:=colors[0];
- colors[0]:=temp;
- for j:=0 to 319 do
-  for i:=0 to 199 do
-   if buffer^[i,j]=0 then buffer^[i,j]:=index
-    else if buffer^[i,j]=index then buffer^[i,j]:=0;
- writeln;
- writeln('0 to ',index,':',min);
-end;
-
-{$F+}
-procedure BreakHandler; interrupt;
-begin
- if port[$60]<>216 then exit;
- move(textscreen,buffer2^,4000);
- move(screen,buffer^,64000);
- for j:=0 to 255 do
-  getrgb256(j,colors[j,0],colors[j,1],colors[j,2]);
- BreakFlag := TRUE;
-end;
-{$F-}
-
-begin
- new(buffer);
- new(buffer2);
- breakflag:=false;
- GetIntVec($1c,Int1cSave);
- SetIntVec($1c,Addr(BreakHandler));
- swapvectors;
- exec('c:\dos\command.com','');
- swapvectors;
- SetIntVec($1c,Int1cSave);
- if breakflag then
-  begin
-   convert;
-   assign(vgafile,'c:\ironseed\makedata\test.vga');
-   rewrite(vgafile);
-   write(vgafile,buffer^);
-   close(vgafile);
-   assign(palfile,'c:\ironseed\makedata\test.pal');
-   rewrite(palfile);
-   write(palfile,colors);
-   close(palfile);
-
-   assign(txtfile,'c:\ironseed\makedata\test.txt');
-   rewrite(txtfile);
-   write(txtfile,buffer2^);
-   close(txtfile);
-
-  end;
- dispose(buffer);
- dispose(buffer2);
-end.
\ No newline at end of file
diff --git a/makedata/gmouse.pas b/makedata/gmouse.pas
deleted file mode 100644
index bea1be8..0000000
--- a/makedata/gmouse.pas
+++ /dev/null
@@ -1,146 +0,0 @@
-unit gmouse;
-
-interface
-
-type
- curtype = array[0..63] of byte;
- mousetype =
-  object
-   error,but1,but2,but3: boolean;
-   x,y: integer;
-   buttons: byte;
-   procedure show;
-   procedure hide;
-   constructor initialize;
-   procedure getpos;
-   function getstatus(button: byte) : boolean;
-   procedure setxy(x1,y1: integer);
-   procedure sethoriz(xmin,xmax: integer);
-   procedure setvert(ymin,ymax: integer);
-   procedure setsensitivity(xratio,yratio: integer);
-   procedure setcursor(curseg,curofs,hotx,hoty: word);
-  end;
-const
- left: byte  = 0;
- right: byte = 1;
- defaultcur : curtype =
-(255,239,255,227,255,240,63,152,15,204,7,230,15,227,159,241,
-207,240,103,248,51,248,153,252,204,253,229,255,241,255,251,255,
-0,0,0,48,0,60,0,63,192,31,240,31,128,15,192,15,
-224,7,240,6,120,2,60,2,30,0,12,0,4,0,0,0);
- targetcur : curtype =
-(255,255,127,252,31,240,143,226,231,206,231,206,243,159,131,130,
-243,159,231,206,231,206,143,226,31,240,127,252,255,255,255,255,
-0,0,0,0,128,3,224,15,240,31,240,31,248,63,248,62,248,
-63,240,31,240,31,224,15,128,3,0,0,0,0,0,0);
-
-var
- mouse:mousetype;
-
-implementation
-
-uses data;
-
-constructor mousetype.initialize; assembler;
-asm
- mov ax, 0
- int 51
- mov mouse.error, 0
- cmp ax, 0
- jne @@noerror
- mov mouse.error, 1
-@@noerror:
- mov mouse.buttons, bl
-end;
-
-procedure mousetype.hide; assembler;
-asm
- mov ax, 2
- int 51
-end;
-
-procedure mousetype.show; assembler;
-asm
- mov ax, 1
- int 51
-end;
-
-procedure mousetype.getpos; assembler;
-asm
- mov ax, 3
- int 51
- mov mouse.x, cx
- mov mouse.y, dx
-end;
-
-function mousetype.getstatus(button: byte) : boolean; assembler;
-asm
- mov ax, 3
- int 51
- shr cx, 1
- mov mouse.x, cx
- mov mouse.y, dx
- cmp button, 1
- je @@right
- test bx, 1
- jz @@nope
- mov ax, 1
- jmp @@done
-@@right:
- test bx, 2
- jz @@nope
- mov ax, 1
- jmp @@done
-@@nope:
- mov ax, 0
-@@done:
-end;
-
-procedure mousetype.setXY(x1,y1: integer); assembler;
-asm
- mov ax, 4
- mov cx, x1
- mov dx, y1
- int 51
-end;
-
-procedure mousetype.sethoriz(xmin,xmax: integer); assembler;
-asm
- mov ax, 7
- mov cx, xmin
- mov dx, xmax
- int 51
-end;
-
-procedure mousetype.setvert(ymin,ymax: integer); assembler;
-asm
- mov ax, 8
- mov cx, ymin
- mov dx, ymax
- int 51
-end;
-
-procedure mousetype.setSensitivity(xratio,yratio:integer); assembler;
-asm
- mov ax, 15
- mov cx, xratio
- mov dx, yratio
- int 51
-end;
-
-procedure mousetype.setcursor(curseg,curofs,hotx,hoty: word); assembler;
-asm
- push es
- mov ax, curseg
- mov es, ax
- mov dx, curofs
- mov bx, hotx
- mov cx, hoty
- mov ax, 9
- int 51
- pop es
-end;
-
-begin
- mouse.initialize;
-end.
\ No newline at end of file
diff --git a/makedata/gmouse2.pas b/makedata/gmouse2.pas
deleted file mode 100644
index 1ccd725..0000000
--- a/makedata/gmouse2.pas
+++ /dev/null
@@ -1,208 +0,0 @@
-unit gmouse;
-
-interface
-
-type
- curtype = array[0..63] of byte;
- mouseicontype = array[0..31,0..31] of byte;
- mousetype =
-  object
-   error,but1,but2,but3: boolean;
-   back,fore: mouseicontype;
-   x,y: integer;
-   buttons: byte;
-   procedure show;
-   procedure hide;
-   constructor initialize;
-   procedure getpos;
-   function getstatus(button: byte) : boolean;
-   procedure movecursor;
-   procedure setxy(x1,y1: integer);
-   procedure sethoriz(xmin,xmax: integer);
-   procedure setvert(ymin,ymax: integer);
-   procedure setsensitivity(xratio,yratio: integer);
-   procedure setcursor(curseg,curofs,hotx,hoty: word);
-  end;
-const
- left: byte  = 0;
- right: byte = 1;
- defaultcur : curtype =
-(255,239,255,227,255,240,63,152,15,204,7,230,15,227,159,241,
-207,240,103,248,51,248,153,252,204,253,229,255,241,255,251,255,
-0,0,0,48,0,60,0,63,192,31,240,31,128,15,192,15,
-224,7,240,6,120,2,60,2,30,0,12,0,4,0,0,0);
- targetcur : curtype =
-(255,255,127,252,31,240,143,226,231,206,231,206,243,159,131,130,
-243,159,231,206,231,206,143,226,31,240,127,252,255,255,255,255,
-0,0,0,0,128,3,224,15,240,31,240,31,248,63,248,62,248,
-63,240,31,240,31,224,15,128,3,0,0,0,0,0,0);
-
-var
- mouse:mousetype;
- i,j: integer;
- mptr1,mptr2: word;
-
-implementation
-
-uses crt, graph, data;
-
-constructor mousetype.initialize; assembler;
-asm
- push es
- mov ax, 0
- int 51
- mov mouse.error, 0
- cmp ax, 0
- jne @@noerror
- mov mouse.error, 1
-@@noerror:
- mov mouse.buttons, bl
- mov cx, 1
- mov ax, mptr1
- mov es, ax
- mov dx, mptr2
- mov ax, 0Ch
-  int 33h
- pop es
-end;
-
-{$F+}
-procedure mousetype.movecursor;
-begin
- asm
-  push ds
-  push cx
-  push dx
- end;
- for i:=0 to 31 do
-  move(mouse.back[i],screen[mouse.y+i,mouse.x],32);
- asm
-  pop dx
-  pop cx
-  shr cx, 1
-  mov mouse.x, cx
-  mov mouse.y, dx
- end;
- for i:=0 to 31 do
-  move(screen[mouse.y+i,mouse.x],mouse.back[i],32);
- for i:=0 to 31 do
-  for j:=0 to 31 do
-   if mouse.fore[i,j]<255 then screen[mouse.y+i,mouse.x+j]:=mouse.fore[i,j];
- asm
-  pop ds
- end;
-end;
-{$F-}
-
-procedure mousetype.hide;
-begin
- for i:=0 to 31 do
-  mymove(mouse.back[i],screen[mouse.y+i,mouse.x],8);
-end;
-
-procedure mousetype.show;
-begin
- asm
-  mov ax, 3
-   int 33h
-  shr cx, 1
-  mov mouse.x, cx
-  mov mouse.y, dx
- end;
- for i:=0 to 31 do
-  mymove(screen[mouse.y+i,mouse.x],mouse.back[i],8);
- for i:=0 to 31 do
-  for j:=0 to 31 do
-   if mouse.fore[i,j]<255 then screen[mouse.y+i,mouse.x+j]:=mouse.fore[i,j];
-end;
-
-procedure mousetype.getpos; assembler;
-asm
- mov ax, 3
- int 51
- shr cx, 1
- mov mouse.x, cx
- mov mouse.y, dx
-end;
-
-function mousetype.getstatus(button: byte) : boolean; assembler;
-asm
- mov ax, 3
- int 51
- shr cx, 1
- mov mouse.x, cx
- mov mouse.y, dx
- cmp button, 1
- je @@right
- test bx, 1
- jz @@nope
- mov ax, 1
- jmp @@done
-@@right:
- test bx, 2
- jz @@nope
- mov ax, 1
- jmp @@done
-@@nope:
- mov ax, 0
-@@done:
-end;
-
-procedure mousetype.setxy(x1,y1: integer); assembler;
-asm
- mov ax, 4
- mov cx, x1
- mov dx, y1
- int 51
-end;
-
-procedure mousetype.sethoriz(xmin,xmax: integer); assembler;
-asm
- mov ax, 7
- mov cx, xmin
- mov dx, xmax
- int 51
-end;
-
-procedure mousetype.setvert(ymin,ymax: integer); assembler;
-asm
- mov ax, 8
- mov cx, ymin
- mov dx, ymax
- int 51
-end;
-
-procedure mousetype.setsensitivity(xratio,yratio:integer); assembler;
-asm
- mov ax, 15
- mov cx, xratio
- mov dx, yratio
- int 51
-end;
-
-procedure mousetype.setcursor(curseg,curofs,hotx,hoty: word); assembler;
-asm
- push es
- mov ax, curseg
- mov es, ax
- mov dx, curofs
- mov bx, hotx
- mov cx, hoty
- mov ax, 9
- int 51
- pop es
-end;
-
-begin
- mptr1:=seg(mousetype.movecursor);
- mptr2:=ofs(mousetype.movecursor);
- mouse.x:=160;
- mouse.y:=100;
- fillchar(mouse.back,1024,0);
- fillchar(mouse.fore,1024,255);
- for i:=0 to 31 do
-  for j:=0 to 31 do
-   if (i=j) or (31-j=i) then mouse.fore[i,j]:=31;
- mouse.initialize;
- mouse.setxy(320,100);
-end.
\ No newline at end of file
diff --git a/makedata/grab.pas b/makedata/grab.pas
deleted file mode 100644
index bd760ca..0000000
--- a/makedata/grab.pas
+++ /dev/null
@@ -1,22 +0,0 @@
-program grabit;
-
-var
- f,f2: file of byte;
- j: longint;
- temp: byte;
-
-
-begin
- assign(f2,'test.s3m');
- reset(f2);
- assign(f,'c:\apps\demo\unreal.exe');
- reset(f);
- seek(f,805274);
- for j:=0 to 163088 do
-  begin
-   read(f,temp);
-   write(f2,temp);
-  end;
- close(f);
- close(f2);
-end.
\ No newline at end of file
diff --git a/makedata/graphics.pas b/makedata/graphics.pas
deleted file mode 100644
index bd3debb..0000000
--- a/makedata/graphics.pas
+++ /dev/null
@@ -1,293 +0,0 @@
-unit graphics;
-
-interface
-const
- minmemory= 50;
-type
- fonttype= array[1..3] of byte;
- colortype= array[1..3] of byte;
- paltype= array[0..255] of colortype;
- screentype= array[0..199,0..319] of byte;
-const
- font: array[1..55] of fonttype=(
-(0,0,0),       { } (102,96,96),   {!} (85,80,0),     {"} (34,0,0),      {'}
-(36,68,32),    {(} (66,34,64),    {)} (9,105,0),     {*} (4,228,0),     {+}
-(0,2,36),      {,} (0,240,0),     {-} (0,0,32),      {.} (1,36,128),    {/}
-(107,221,96),  {0} (38,34,112),   {1} (105,36,240),  {2} (225,97,224),  {3}
-(53,241,16),   {4} (248,113,224), {5} (36,233,96),   {6} (241,36,128),  {7}
-(105,105,96),  {8} (105,113,32),  {9} (102,6,96),    {:} (102,6,98),    {;}
-(18,66,16),    {<} (15,15,0),     {=} (132,36,128),  {>} (105,32,32),   {?}
-(105,249,144), {a} (233,233,224), {b} (105,137,96),  {c} (233,153,224), {d}
-(240,232,240), {e} (248,232,128), {f} (105,139,96),  {g} (153,249,144), {h}
-(114,34,112),  {i} (17,25,96),    {j} (154,202,144), {k} (136,136,240), {l}
-(159,153,144), {m} (157,185,144), {n} (105,153,96),  {o} (233,232,128), {p}
-(105,155,112), {q} (233,170,144), {r} (120,97,224),  {s} (114,34,32),   {t}
-(153,153,96),  {u} (153,150,96),  {v} (153,187,96),  {w} (153,105,144), {x}
-(153,114,64),  {y} (242,72,240),  {z} (9,36,144));   {%}
-var
- colors: paltype;
- screen: screentype absolute $A000:$0000;
- tcolor,bkcolor,tslice: integer;
-
-procedure errorhandler(s: string;errtype: integer);
-procedure setrgb256(palnum,r,g,b: byte);
-procedure getrgb256(palnum: byte; var r,g,b);
-procedure set256colors(pal : paltype);
-procedure printxy(x1,y1: integer; s: string);
-procedure fading;
-procedure fadein;
-procedure loadscreen(s: string);
-procedure loadpal(s: string);
-function testbit(b : byte; bit : byte) : boolean;
-function fastkeypressed : boolean;
-procedure fadein2;
-procedure mymove(var src,tar; count: integer);
-
-implementation
-
-uses crt, graph;
-
-var
- i,j: integer;
-
-{$L vga256}
-{$L mover}
-procedure vgadriver; external;
-{$F+}
-procedure mymove(var src,tar; count: integer); external;
-{$F-}
-
-function fastkeypressed: boolean; assembler;
-asm
- push ds
- mov ax, 40h
- mov ds, ax
- cli
- mov ax, [1Ah]
- cmp ax, [1Ch]
- sti
- mov ax, 0
- jz @nopress
- inc ax
-@nopress:
- pop ds
-end;
-
-procedure loadscreen(s: string);
-var vgafile: file of screentype;
-begin
- assign(vgafile,s);
- reset(vgafile);
- if ioresult<>0 then errorhandler(s,1);
- read(vgafile,screen);
- if ioresult<>0 then errorhandler(s,5);
- close(vgafile);
-end;
-
-procedure loadpal(s: string);
-var palfile: file of paltype;
-begin
- assign(palfile,s);
- reset(palfile);
- if ioresult<>0 then errorhandler(s,1);
- read(palfile,colors);
- if ioresult<>0 then errorhandler(s,5);
- close(palfile);
-end;
-
-procedure setrgb256(palnum,r,g,b: byte); assembler;
-asm
- xor bh, bh
- mov bl, palnum
- mov ax, 1010h
- mov dh, r
- mov ch, g
- mov cl, b
-  int 10h
-end;
-
-procedure getrgb256(palnum: byte; var r,g,b); assembler;
-asm
- xor bh, bh
- mov bl, palnum
- mov ax, 1015h
-  int 10h
- les di, r
- mov es:[di], dh
- les di, g
- mov es:[di], ch
- les di, b
- mov es:[di], cl
-end;
-
-procedure set256Colors(pal: paltype); assembler;
-asm
- mov ax, 1012h
- mov bx, 0
- mov cx, 256
- les dx, Pal
-  int 10h
-end;
-
-function testbit(b,bit: byte) : boolean; assembler;
-asm
- mov cl, bit
- mov bl, 1
- shl bl, CL
- mov al, 0
- test b, bl
- jz @@no
- inc al
-@@no:
-end;
-
-procedure printxy(x1,y1: integer; s: string);
-var letter,a,index,t: integer;
-begin
- t:=tcolor;
- for j:=1 to length(s) do
-  begin
-   tcolor:=t;
-   case s[j] of
-    ' ' ..'"':letter:=ord(s[j])-31;
-    ''''..'?':letter:=ord(s[j])-35;
-    'A' ..'Z':letter:=ord(s[j])-36;
-    '%': letter:=55;
-    else letter:=1;
-   end;
-   index:=1;
-   for i:=1 to 6 do
-    begin
-     for a:=4 to 7 do
-      if testbit(font[letter,index],a) then screen[y1+i,x1+j*5+7-a]:=tcolor
-       else if bkcolor<255 then screen[y1+i,x1+j*5+7-a]:=bkcolor;
-     dec(tcolor,2);
-     inc(i);
-     for a:=0 to 3 do
-      if testbit(font[letter,index],a) then screen[y1+i,x1+j*5+3-a]:=tcolor
-       else if bkcolor<255 then screen[y1+i,x1+j*5+3-a]:=bkcolor;
-     inc(index);
-     dec(tcolor,2);
-    end;
-    for i:=1 to 6 do screen[y1+i,x1+j*5+4]:=bkcolor;
-  end;
- tcolor:=t;
-end;
-
-procedure errorhandler(s: string; errtype: integer);
-begin
- closegraph;
- writeln;
- case errtype of
-  1: writeln('File Error: ',s);
-  2: writeln('Mouse Error: ',s);
-  3: writeln('Sound Error: ',s);
-  4: writeln('EMS Error: ',s);
-  5: writeln('Fatal File Error: ',s);
-  6: writeln('Program Error: ',s);
-  7: writeln('Music Error: ',s);
- end;
- halt(4);
-end;
-
-{$F+}
-function testit : integer; assembler;
-asm
- mov ax, 1A00h
-  int 10h
- cmp al, 1Ah
- jne @@nope
- mov ax, 1
- jmp @@done
-@@nope:
- mov ax, 0
-@@done:
-end;
-{$F-}
-
-procedure readygraph;
-var testdriver,driver,mode,errcode: integer;
-begin
- testdriver:=installuserdriver('vga256',@testit);
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeLn('Error Installing VGA Driver:',errcode);
-   halt(4);
-  end;
- registerbgidriver(@vgadriver);
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeLn('Error Registering VGA Driver:',errcode);
-   halt(4);
-  end;
- driver:=detect;
- initgraph(driver,mode,'');
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeln('Video Initialization Failure: ',errcode);
-   halt(4);
-  end;
- loadpal('data\main.pal');
- set256colors(colors);
- setgraphbufsize(0);
- checksnow:=false;
-end;
-
-procedure fading;
-var a: integer;
-    temppal: paltype;
-begin
- mymove(colors,temppal,192);
- for a:=30 downto 1 do
-  begin
-   for j:=0 to 255 do
-    for i:=1 to 3 do
-     temppal[j,i]:=round(a*temppal[j,i]/30);
-   set256colors(temppal);
-   delay(tslice);
-  end;
- fillchar(temppal,768,0);
- set256colors(temppal);
- delay(tslice);
-end;
-
-procedure fadein;
-var a: integer;
-    temppal: paltype;
-begin
- fillchar(temppal,768,0);
- for a:=0 to 15 do
-  begin
-   for j:=0 to 15 do
-    for i:=a to 15 do
-     temppal[j*16+i]:=colors[j*16+a];
-   set256colors(temppal);
-   delay(tslice*2);
-  end;
- set256colors(colors);
- delay(tslice);
-end;
-
-procedure fadein2;
-var a: integer;
-    temppal: paltype;
-begin
- for j:=0 to 255 do for i:=1 to 3 do temppal[j,i]:=0;
- for a:=1 to 25 do
-  begin
-   for j:=0 to 255 do
-    for i:=1 to 3 do
-     temppal[j,i]:=round(a*colors[j,i]/25);
-   set256colors(temppal);
-   delay(tslice);
-  end;
- set256colors(colors);
-end;
-
-begin
- checkbreak:=false;
- readygraph;
-end.
diff --git a/makedata/gun2.sam b/makedata/gun2.sam
deleted file mode 100644
index a8037f6..0000000
Binary files a/makedata/gun2.sam and /dev/null differ
diff --git a/makedata/gun3.sam b/makedata/gun3.sam
deleted file mode 100644
index bf8aad3..0000000
Binary files a/makedata/gun3.sam and /dev/null differ
diff --git a/makedata/hotkey.asm b/makedata/hotkey.asm
deleted file mode 100644
index 5ea93dc..0000000
--- a/makedata/hotkey.asm
+++ /dev/null
@@ -1,111 +0,0 @@
-p286
-segment hotkey_text byte public 'code'
- assume cs:hotkey_text
- assume ds:hotkey_text
- org 100h
-comstart:
- jmp start
-
-oldseg   dw 0
-oldofs   dw 0
-filename db 'f:\ironseed\data\test.vga',0
-palname  db 'f:\ironseed\data\test.pal',0
-palnum   db 0
-buffer   db 3 dup(0)
-handle   dw 0
-
-proc dumpit
- pushf
- push ax
- push bx
- push cx
- push dx
- push ds
- cli
- cld
- mov dx, cs
- mov ds, dx
- mov dx, offset filename
- mov ax, 3D02h
-  int 21h           ; open file
- jc @@error
- mov bx, ax
- mov cx, 64000
- mov dx, 0A000h
- mov ds, dx
- mov dx, 0
- mov ah, 40h
-  int 21h           ; save it
- jc @@error
- mov ah, 3Eh
-  int 21h           ; close file
- jc @@error
- mov dx, cs
- mov ds, dx
- mov dx, offset palname
- mov ax, 3D02h
-  int 21h           ; open file
- jc @@error
- mov [cs:handle], ax
- mov [cs:palnum], 0
-@@outerloop:
- xor bh, bh
- mov bl, [cs:palnum]
- mov ax, 1015h
-  int 10h
- mov [cs:buffer], dh
- mov [cs:buffer+1], ch
- mov [cs:buffer+2], cl
- mov cx, 3
- mov bx, [cs:handle]
- mov dx, cs
- mov ds, dx
- mov dx, offset buffer
- mov ah, 40h
-  int 21h           ; saveit
- jc @@error
- inc [cs:palnum]
- cmp [cs:palnum], 0
- jne @@outerloop
- mov ah, 3Eh
-  int 21h           ; close file
-@@error:
- pop ds
- assume ds:nothing
- pop dx
- pop cx
- pop bx
- pop ax
- popf
- sti
- ret
-endp dumpit
-
-proc newvec far   ; new interrupt
- cmp ah, 4Fh
- jne @@done
- cmp al, 68
- jne @@done
- call dumpit
-@@done:
- push [cs:oldseg]
- push [cs:oldofs]
- retf             ; go to old interrupt
-endp newvec
-
-start:
- mov ax, 3515h
-  int 21h
- mov [cs:oldofs], bx
- mov [cs:oldseg], es
- mov dx, cs
- mov ds, dx
- mov dx, offset newvec
- mov ax, 2515h
-  int 21h
- mov dx, 35
- mov ax, 3100h
-  int 21h
-
-ends hotkey_text
-end comstart
diff --git a/makedata/hotkey.pas b/makedata/hotkey.pas
deleted file mode 100644
index 0807e94..0000000
--- a/makedata/hotkey.pas
+++ /dev/null
@@ -1,99 +0,0 @@
-p286
-segment hotkey_text byte public 'code'
- assume cs:hotkey_text
- assume ds:hotkey_text
- org 100h
-comstart:
- jmp start
-
-done db 0
-oldseg dw 0
-oldofs dw 0
-filename db 'e:\ironseed\data\test.vga',0
-handle dw 0
-
-proc dumpit
- push bx
- push cx
- push dx
- push ds
- mov dx, cs
- mov ds, dx
- mov dx, offset filename
- mov ax, 3D02h
-  int 21h
- jc @@error
- mov [handle], ax
- mov bx, [handle]
- mov cx, 64000
- mov dx, 0A000h
- mov ds, dx
- mov dx, 0
- mov ah, 40h
-  int 21h
-@@error:
- pop ds
- pop dx
- pop cx
- pop bx
- ret
-endp dumpit
-
-proc newvec
- push dx
- push ds
- cmp ah, 4Fh
- jne @@odd
- cmp al, 16h
- jne @@done
-; call dumpit
- mov dl, 'W'
- mov ah, 02h
-  int 21h
- jmp @@done
-@@odd:
- mov dl, 'X'
- mov ah, 02h
-  int 21h
-; push [oldseg]
-; push [oldofs]
-; retf
-@@done:
- mov [done], 1
- mov dl, 'O'
- mov ah, 02h
-  int 21h
- stc
- pop ds
- pop dx
- iret
-endp newvec
-
-start:
- mov [done], 0
- mov ax, 3515h
-  int 21h
- mov [oldofs], bx
- mov [oldseg], es
- mov dx, cs
- mov ds, dx
- mov dx, offset newvec
- mov ax, 2515h
-  int 21h
-@@loopit:
- cmp [done], 0
- jne @@loopit
- mov dx, [oldseg]
- mov ds, dx
- mov dx, [oldofs]
- mov ax, 2515h
-  int 21h
- mov ax, 4C00h
-  int 21h
-
- mov dx, 32
- mov ax, 3100h
-  int 21h
-
-ends hotkey_text
-end comstart
diff --git a/makedata/iconmake.pas b/makedata/iconmake.pas
index 8dec2c9..92cf1d1 100644
--- a/makedata/iconmake.pas
+++ b/makedata/iconmake.pas
@@ -1,4 +1,21 @@
 program convertplanicons;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
+
 uses crt, data;
 
 type
diff --git a/makedata/image01.cpr b/makedata/image01.cpr
deleted file mode 100644
index a57e442..0000000
Binary files a/makedata/image01.cpr and /dev/null differ
diff --git a/makedata/image02.cpr b/makedata/image02.cpr
deleted file mode 100644
index 9a84bc7..0000000
Binary files a/makedata/image02.cpr and /dev/null differ
diff --git a/makedata/image03.cpr b/makedata/image03.cpr
deleted file mode 100644
index 1f50f90..0000000
Binary files a/makedata/image03.cpr and /dev/null differ
diff --git a/makedata/image04.cpr b/makedata/image04.cpr
deleted file mode 100644
index 56ca54c..0000000
Binary files a/makedata/image04.cpr and /dev/null differ
diff --git a/makedata/image05.cpr b/makedata/image05.cpr
deleted file mode 100644
index 7a5b39b..0000000
Binary files a/makedata/image05.cpr and /dev/null differ
diff --git a/makedata/image06.cpr b/makedata/image06.cpr
deleted file mode 100644
index 9fd4c7b..0000000
Binary files a/makedata/image06.cpr and /dev/null differ
diff --git a/makedata/image07.cpr b/makedata/image07.cpr
deleted file mode 100644
index cc756db..0000000
Binary files a/makedata/image07.cpr and /dev/null differ
diff --git a/makedata/image08.cpr b/makedata/image08.cpr
deleted file mode 100644
index c4bfb22..0000000
Binary files a/makedata/image08.cpr and /dev/null differ
diff --git a/makedata/image09.cpr b/makedata/image09.cpr
deleted file mode 100644
index fec5aed..0000000
Binary files a/makedata/image09.cpr and /dev/null differ
diff --git a/makedata/image10.cpr b/makedata/image10.cpr
deleted file mode 100644
index 1ea9607..0000000
Binary files a/makedata/image10.cpr and /dev/null differ
diff --git a/makedata/image11.cpr b/makedata/image11.cpr
deleted file mode 100644
index ff42aca..0000000
Binary files a/makedata/image11.cpr and /dev/null differ
diff --git a/makedata/image12.cpr b/makedata/image12.cpr
deleted file mode 100644
index 097dd42..0000000
Binary files a/makedata/image12.cpr and /dev/null differ
diff --git a/makedata/image13.cpr b/makedata/image13.cpr
deleted file mode 100644
index 4fd803c..0000000
Binary files a/makedata/image13.cpr and /dev/null differ
diff --git a/makedata/image14.cpr b/makedata/image14.cpr
deleted file mode 100644
index b4fcc7e..0000000
Binary files a/makedata/image14.cpr and /dev/null differ
diff --git a/makedata/image15.cpr b/makedata/image15.cpr
deleted file mode 100644
index a8e326f..0000000
Binary files a/makedata/image15.cpr and /dev/null differ
diff --git a/makedata/image16.cpr b/makedata/image16.cpr
deleted file mode 100644
index 6869639..0000000
Binary files a/makedata/image16.cpr and /dev/null differ
diff --git a/makedata/image17.cpr b/makedata/image17.cpr
deleted file mode 100644
index 75bab1b..0000000
Binary files a/makedata/image17.cpr and /dev/null differ
diff --git a/makedata/image18.cpr b/makedata/image18.cpr
deleted file mode 100644
index b6d7711..0000000
Binary files a/makedata/image18.cpr and /dev/null differ
diff --git a/makedata/image19.cpr b/makedata/image19.cpr
deleted file mode 100644
index a1a8a3d..0000000
Binary files a/makedata/image19.cpr and /dev/null differ
diff --git a/makedata/image20.cpr b/makedata/image20.cpr
deleted file mode 100644
index 4ebb118..0000000
Binary files a/makedata/image20.cpr and /dev/null differ
diff --git a/makedata/image21.cpr b/makedata/image21.cpr
deleted file mode 100644
index d2c0c57..0000000
Binary files a/makedata/image21.cpr and /dev/null differ
diff --git a/makedata/image22.cpr b/makedata/image22.cpr
deleted file mode 100644
index 8451ddf..0000000
Binary files a/makedata/image22.cpr and /dev/null differ
diff --git a/makedata/image23.cpr b/makedata/image23.cpr
deleted file mode 100644
index 7150503..0000000
Binary files a/makedata/image23.cpr and /dev/null differ
diff --git a/makedata/image24.cpr b/makedata/image24.cpr
deleted file mode 100644
index 0626e56..0000000
Binary files a/makedata/image24.cpr and /dev/null differ
diff --git a/makedata/image25.cpr b/makedata/image25.cpr
deleted file mode 100644
index 5422c03..0000000
Binary files a/makedata/image25.cpr and /dev/null differ
diff --git a/makedata/intro.cpr b/makedata/intro.cpr
deleted file mode 100644
index 04ba764..0000000
--- a/makedata/intro.cpr
+++ /dev/null
@@ -1 +0,0 @@
-~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{zzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxxxxxxxxxxxxxxxxxxxxxwwwwwwwwwwwwwwwwwwwwyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyxxxxxxxxxwwwwwwwwwwwwwwwwwwwwvvvvvvvvvvvvvvvvvvvvyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyywwwwwwwwwwwwwwwwwwwwwwwwwwwwwvvvvvvvvvvvvvvvvvvvvyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyywwwwwwwwwvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyvvvvvvvvvvvvvvvvvvvvvvvvvvvvvuuuuuuuuuuuuuuuuuuuuyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyvvvvvvvvvvvvvvvvvvvvvvvvvvvvvuuuuuuuuuuuuuuuuuuuuyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyvvvvvvvvvuuuuuuuuuuuuuuuuuuuuttttttttttttttttttttyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyuuuuuuuuuuuuuuuuuuuuuuuuuuuuuttttttttttttttttttttyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyuuuuuuuuuttttttttttttttttttttttttttttttttttttttttyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyttttttttttttttttttttttttttttt||||||||||||||||||||yyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyttttttttttttttttttttttttttttt|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||tttttttttttttttttttssssssssssssssssssss{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{sssssssssssssssssssssssssssssssssssssss{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{sssssssssssssssssssrrrrrrrrrrrrrrrrrrrrzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrryyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyrrrrrrrrrrrrrrrrrrrqqqqqqqqqqqqqqqqqqqqyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxqqqqqqqqqqqqqqqqqqqppppppppppppppppppppxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxpppppppppppppppppppppppppppppppppppppppxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxpppppppppppppppppppppppppppppppppppppppwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwdwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwpppppppppppppppppppoooooooooooooooooooovvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvlvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvooooooooooooooooooooooooooooooooooooooovvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvqovvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvooooooooooooooooooonnnnnnnnnnnnnnnnnnnnvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvtkvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuutduuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuunnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuu]uuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuunnnnnnnnnnnnnnnnnnnmmmmmmmmmmmmmmmmmmmmttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttqtttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttt]ktttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttmmmmmmmmmmmmmmmmmmmlllllllllllllllllllltttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttdgtttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttlllllllllllllllllllllllllllllllllllllllsssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssq]sssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssslllllllllllllllllllllllllllllllllllllllrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr]rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrlllllllllllllllllllkkkkkkkkkkkkkkkkkkkkrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrkkkkkkkkkkkkkkkkkkkjjjjjjjjjjjjjjjjjjjjqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppjjjjjjjjjjjjjjjjjjjiiiiiiiiiiiiiiiiiiiippppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiippppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppiiiiiiiiiiiiiiiiiiihhhhhhhhhhhhhhhhhhhhooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooomoooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooohhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnknnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnknnnnnnnnnnnnnnnnndknnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnhhhhhhhhhhhhhhhhhhhggggggggggggggggggggnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnknnnnnnnnnnnnnnnnnljdbZknnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnngggggggggggggggggggggggggggggggggggggggmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmjmmmmmmmmmmmmmmmmmmmmmmjbbdkmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmgggggggggggggggggggffffffffffffffffffffmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmhmmmmmmmmmmmmmmmmmmmmmmmmmjjbbdmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmffffffffffffffffffffffffffffffffffffffflllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllljbbYdlllllllllllllllllllllllllllllllllllllffffffffffffffffffffffffffffffffffffffflllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllljbhlllllllllllllllllllllllllllllllllfffffffffffffffffffeeeeeeeeeeeeeeeeeeeekkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkjbVdkkkkkkkkkkkkkkkkkkkkkkkkkkkkeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeekkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkjbVkkkkkkkkkkkkkkkkkkkkkkkkkkeeeeeeeeeeeeeeeeeeeddddddddddddddddddddjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjbVjjjjjjjjjjjjjjjjjjjjjjjjdddddddddddddddddddddddddddddddddddddddjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjijjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjbVjjjjjjjjjjjjjjjjjjjjjjdddddddddddddddddddddddddddddddddddddddjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjijjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjVjjjjjjjjjjjjjjjjjjjjdddddddddddddddddddcccccccccccccccccccciiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiijViiiiiiiiiiiiiiiiiiccccccccccccccccccccccccccccccccccccccciiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiijbiiiiiiiiiiiiiiiiicccccccccccccccccccbbbbbbbbbbbbbbbbbbbbhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhbVhhhhhhhhhhhhhhhbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbhhhhhhhhhhhhh]hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhghhhhfhhhhhhhhhhhhhhhhhhU_hhhhh[UUhhhhhhhhhhhVhhhhhhhhhhhhhbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbggggggggggggggggggggggggggggggggggggggggggggcggggegggggggggggggUgggggUgggggggggggggggggggggggbbbbbbbbbbbbbbbbbbbaaaaaaaaaaaaaaaaaaaagggggggggggggggggggggggggggggggggggggggggggggaggggbZgggggggggggggggggggggggggggggVggggggggggaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaafffffffffffffffffffffffffffffffffffffffffffeafff`ffffffffffffffffffffffffffffffffffffffaaaaaaaaaaaaaaaaaaa````````````````````ffffffffffffffffffffffffffffffffffffffffff_`faefffffffffffffffffffffffffffffVffffffff```````````````````````````````````````ffffffffffffffffffffffffffffffffffffffffeaffffffffffffffffffffffffffffffW[ffffffff```````````````````____________________eeeeeeeeeeeeeeeeeeeefeeeeeeeeeeeeeeeeefeeeeeeeeeeeeeeeeUeeeeeeeeeeeeeeee[_b_eeeeeee_______________________________________eeeeeeeeeeeeeeeeeeeeefeeeeeeeeeeeeeeeeefeeeeeeeeeeeeeeeeZUUUYeeeeeeZWWWeeeeeeeeeee_adbeeeeee_______________________________________ddddddddddddddddddddddddddddddddddddddddddddd`bdddddddddddddddddddddddddddddddddddddddddddddddddddd_ddddb\ddddd___________________^^^^^^^^^^^^^^^^^^^^ddddddddddddddddddddddddddddddddddddddddddddddacddddddddddUUddddddd]Uddddddddddddd_ddddd^ddddd^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccUccccccccccccc_ccccc_ccccc^^^^^^^^^^^^^^^^^^^]]]]]]]]]]]]]]]]]]]]ccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc_ccccccccccc]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbb^bbbbbbbbbbbbbbbbbbbbbbbbbbb_bbbbbbbbbbb]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb_bbbbbbbbbbb]]]]]]]]]]]]]]]]]]]\\\\\\\\\\\\\\\\\\\\bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbabbbbbbbbbbabbbbbbbbbbbUbbbbbbbbbbbbbbbbbbbb_bbbbbbbbbbb\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\aaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaWaaaaaaaUaaaaaaaaaaaaa_aaaaaaaaaaa\\\\\\\\\\\\\\\\\\\[[[[[[[[[[[[[[[[[[[[aaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaabaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa_aaaaaaaaaaa[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[```````````````````````````````````````````````````````````````````````````````````````_`````^`````[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[____________________________________`______________________U_____________________^T\_____[[[[[[[[[[[[[[[[[[[ZZZZZZZZZZZZZZZZZZZZ____________________________________________________________U____________________[TT______ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ____________________________________________________________________________]]TW_______ZZZZZZZZZZZZZZZZZZZYYYYYYYYYYYYYYYYYYYY^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^]^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^]^^^^^^^^^^^^^^^^]^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^Z^^^^^^^^YYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYY]]]]]]]]]]]]]]]]]]]]^]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]U]]]]]]]]]]]]]]]]Z]]]]]]]]]YYYYYYYYYYYYYYYYYYYXXXXXXXXXXXXXXXXXXXX]]]]]]]]]]]]]]]]]]]\^]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]U]]]]]]]]]]]]]]]]Y]]]]]]]]]]XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\XXXXXXXXXXXXXXXXXXXWWWWWWWWWWWWWWWWWWWWSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\SSSSSWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[SSSSSWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[RRRRRWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWVVVVVVVVVVVVVVVVVVVVQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQ[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[QQQQQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQZZZZZZZZZZZZZZZZZZZZYYZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZQQQQQVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVUUUUUUUUUUUUUUUUUUUUQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQZZZZZZZZZZZZZZZZZZZZZZYYZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZQQQQQUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPYYYYYYYYYYYYYYYYYYYYYYYYYYZYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYPPPPPUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYZZYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYPPPPPUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUTTTTTTTTTTTTTTTTTTTTOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXYXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXOOOOOTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXOOOOOTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTSSSSSSSSSSSSSSSSSSSSOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWOOOOOSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWZWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWNNNNNSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWMMMMMSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSRRRRRRRRRRRRRRRRRRRRMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVXVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMMMMMRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVWVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVMMMMMRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRQQQQQQQQQQQQQQQQQQQQLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUULLLLLQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUULLLLLQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTKKKKKQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQPPPPPPPPPPPPPPPPPPPPKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTKKKKKPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSS[SSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSKKKKKPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPOOOOOOOOOOOOOOOOOOOOJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSUSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIISSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRROOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOONNNNNNNNNNNNNNNNNNNNIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNMMMMMMMMMMMMMMMMMMMMHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPUQPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMLLLLLLLLLLLLLLLLLLLLFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOVOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLKKKKKKKKKKKKKKKKKKKKEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOTOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEENNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIILLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIILLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     
\ No newline at end of file
diff --git a/makedata/intro.pal b/makedata/intro.pal
deleted file mode 100644
index af71c1a..0000000
Binary files a/makedata/intro.pal and /dev/null differ
diff --git a/makedata/intro.pas b/makedata/intro.pas
deleted file mode 100644
index e187bda..0000000
--- a/makedata/intro.pas
+++ /dev/null
@@ -1,2489 +0,0 @@
-program intro;
-{$M 4500,350000,350000}
-
-{***************************
-
-  Introduction Sequence for IronSeed
-
-  Channel 7
-  Destiny: Virtual
-
-  Copywrite 1994
-
-***************************}
-
-{$I dsmi.inc}, emhm, crt, graph, gmouse, getcpu, dos;
-
-const
- CPR_NONE=0;                    {   0 no compresion            }
- CPR_NOPAL=1;                   {   1 no palette, compressed   }
- CPR_PAL=2;                     {   2 palette, compressed      }
- CPR_HEADERINCL=3;              {   3 header included          }
- CPR_ERROR=255;                 { global error                 }
- CPR_CURRENT=CPR_HEADERINCL;    { current version              }
- CPR_BUFFSIZE= 8192;            { adjustable buffer size       }
-type
- CPR_HEADER=
-  record
-   signature: word;             {RWM, no version. RM, version  }
-   version: byte;
-   width,height: word;
-   palette: boolean;
-  end;
- pCPR_HEADER= ^CPR_HEADER;
-type
- planetype= array[1..4,1..3] of real;
- boxtype= array[1..6] of planetype;
- shippixtype= array[0..9,0..19,0..29] of byte;
- msgpixtype= array[0..9,0..4,0..9] of byte;
- overridetype= array[90..110,200..240] of byte;
- overridetype2= array[0..40,0..110] of byte;
- peoplepixtype= array[0..15,0..28,0..28] of byte;
- screentype= array[0..199,0..319] of byte;
- paltype=array[0..255,1..3] of byte;
- fonttype= array[0..2] of byte;
- plantype= array[1..120,1..120] of byte;
- landtype= array[1..240,1..120] of byte;
- pscreentype= ^screentype;
- bigbuffertype= array[0..4095] of byte;
- buftype= array[0..2047] of byte;
-const
- id = 'apeiron';
- version= '1.00005';
- buffsize = 4096;
- font: array[1..82] of fonttype=
-  ((0,0,0),(34,32,32),(85,0,0),(34,0,0),(36,68,32),
-   (66,34,64),(9,105,0),(2,114,0),(0,2,36),(0,240,0),
-   (0,0,32),(1,36,128),(107,221,96),(38,34,112),(241,248,240),
-   (241,113,240),(170,175,32),(248,241,240),(248,249,240),(241,17,16),
-   (249,105,240),(249,241,240),(2,2,0),(2,2,36),(18,66,16),
-   (15,15,0),(132,36,128),(249,48,32),(249,249,144),(249,233,240),
-   (249,137,240),(233,153,224),(248,232,240),(248,232,128),(248,185,240),
-   (153,249,144),(114,34,112),(241,25,240),(158,153,144),(136,136,240),
-   (159,153,144),(157,185,144),(249,153,240),(249,248,128),(249,155,240),
-   (249,233,144),(120,97,224),(242,34,32),(153,153,240),(153,149,32),
-   (153,187,96),(153,105,144),(153,241,240),(242,72,240),(9,36,144),
-   (8,66,16),(15,155,208),(143,153,240),(15,136,240),(31,153,240),
-   (15,188,240),(249,200,128),(15,151,159),(143,153,144),(32,34,32),
-   (16,17,159),(137,233,144),(34,34,32),(9,249,144),(14,153,144),
-   (15,153,240),(15,153,248),(15,153,241),(15,152,128),(7,66,224),
-   (39,34,32),(9,153,240),(9,149,32),(9,155,96),(9,105,144),
-   (9,159,31),(15,36,240));
-
-var
- song: pointer;
- tcolor,bkcolor,i,j,z,cursor,permx,permy,code,j2,m,index,alt,ecl,
-  r2,c,radius,m1,m2,m3,m4,tslice,water,waterindex,x,ofsx,ofsy: integer;
- keymode,moderror: boolean;
- key: char;
- modth,modtm,modts,curth,curtm,curts: byte;
- vgahandles: array[0..8] of word;
- y,part,part2,c2: real;
- planet: ^plantype;
- landform: ^landtype;
- shippix: ^shippixtype;
- msgpix: ^msgpixtype;
- override: ^overridetype;
- override2: ^overridetype2;
- peoplepix: ^peoplepixtype;
- screen: screentype absolute $A000:0000;
- colors: paltype;
- s1,s2,s3: pscreentype;
- k: word;
- module: pmodule;
- sc: tsoundCard;
- spcindex: array[0..5] of integer;
-
-{$L mover2}
-{$L vga256}
-{$L scroller}
-{$L v3220pa}
-{$F+}
-procedure upscroll(s: screentype); external;
-{$F-}
-procedure vgadriver; external;
-procedure mymove2(var src,tar; count: integer); external;
-procedure init320200; external;
-procedure setpix(x,y: integer; pcolor: byte); external;
-function  getpix(x,y: integer): byte ; external;
-procedure setpage(page: byte); external;
-procedure showpage(page: byte); external;
-
-procedure errorhandler(s: string; errtype: integer);
-begin
- closegraph;
- writeln;
- case errtype of
-  1: writeln('Open File Error: ',s);
-  2: writeln('Mouse Error: ',s);
-  3: writeln('Sound Error: ',s);
-  4: writeln('EMS Error: ',s);
-  5: writeln('Fatal File Error: ',s);
-  6: writeln('Program Error: ',s);
-  7: writeln('Music Error: ',s);
- end;
- halt(4);
-end;
-
-procedure initializemod;
-var options: integer;
-begin
- if emsinit(200,800)<>0 then
-  begin
-   moderror:=true;
-   exit;
-   errorhandler('Initializing.',4);
-  end;
- options:=MCP_QUALITY;
- if getcputype and 4>0 then options:=options or MCP_486;
- if initdsmi(22000,4096,options,@sc)<>0 then errorhandler('Initializing Mod Player.',7);
-end;
-
-procedure stopmod;
-var i: integer;
-begin
- if moderror then exit;
- for i:=64 downto 0 do
-  begin
-   mcpsetmastervolume(i);
-   delay(10);
-  end;
- mcpclearbuffer;
- ampstopmodule;
- ampfreemodule(module);
-end;
-
-procedure setnewsampling(n: integer);
-begin
- if moderror then exit;
- mcpsetsamplingrate(n);
-end;
-
-procedure playmod(looping: boolean;s: string);
-var j: integer;
-    voltable: array[0..31] of integer;
-begin
- if moderror then exit;
- module:=amploadmod(s,LM_IML);
- if sc.id<>ID_GUS then mcpStartVoice else gusStartVoice;
- for j:=0 to 31 do voltable[j]:=j*2+1;
- cdiSetupChannels(0,module^.channelCount+4,@voltable);
- for j:=0 to module^.channelcount-1 do
-  cdisetpan(j,40);
- for j:=0 to 3 do
-  cdisetpan(module^.channelcount+j,Pan_Surround);
- mcpsetmastervolume(64);
- if looping then ampplaymodule(module,PM_Loop)
-  else ampplaymodule(module,0);
-end;
-
-procedure soundeffect(s: string; rate: integer);
-var f: file;
-    size,j: integer;
-    si: tsampleinfo;
-begin
- assign(f,s);
- reset(f,1);
- if ioresult<>0 then errorhandler(s,1);
- size:=filesize(f);
- if memavail<size then errorhandler('Sample Memory too small.',7);
- getmem(si.sample,size);
- blockread(f,si.sample^,size);
- if ioresult<>0 then errorhandler(s,6);
- close(f);
- if rate=0 then rate:=11900;
- with si do
-  begin
-   length:=size;
-   loopstart:=0;
-   loopend:=0;
-   mode:=0;
-   sampleid:=0;
-  end;
- mcpconvertsample(si.sample,size);
- for j:=0 to 3 do if mcpsetsample(module^.channelcount+j,@si)<>0 then errorhandler(s+',Setting sample.',7);
- for j:=0 to 3 do if mcpplaysample(module^.channelcount+j,rate,64)<>0 then errorhandler(s+',Playing.',7);
- freemem(si.sample,size);
-end;
-
-function fastkeypressed: boolean; assembler;
-asm
- push ds
- mov bx, 40h
- mov ds, bx
- mov bx, [1Ah]
- cmp bx, [1Ch]
- mov ax, 0
- jz @nopress
- inc ax
-@nopress:
- pop ds
-end;
-
-procedure uncompressfile(s: string; ts: pscreentype; h: pCPR_HEADER);
-type bigbuffertype=array[0..CPR_BUFFSIZE-1] of byte;
-var f: file;
-    err,num,count,databyte,j,total,index,totalsize: word;
-    buffer: ^bigbuffertype;
-
- procedure handleerror;
- begin
-  h^.version:=CPR_ERROR;
-  dispose(buffer);
-  close(f);
-  j:=ioresult;
- end;
-
- function handleversion(n: integer): boolean;
-
- begin
-  handleversion:=false;
-  case n of
-   0: begin                                   { no compression }
-       seek(f,0);
-       num:=64000;
-       blockread(f,ts^,num,err);
-       if (err<num) or (ioresult<>0) then exit;
-       dispose(buffer);
-       close(f);
-       h^.version:=CPR_NONE;
-       h^.width:=320;
-       h^.height:=200;
-       h^.palette:=false;
-      end;
-   1: begin                                   { no extras }
-       seek(f,3);
-       total:=filesize(f)-3;
-       h^.version:=CPR_NOPAL;
-       h^.width:=320;
-       h^.height:=200;
-       h^.palette:=false;
-      end;
-   2: begin                                   { Imbedded palette }
-       num:=768;
-       seek(f,3);
-       blockread(f,colors,num,err);
-       if (err<num) or (ioresult<>0) then exit;
-       total:=filesize(f)-771;
-       h^.version:=CPR_PAL;
-       h^.width:=320;
-       h^.height:=200;
-       h^.palette:=true;
-      end;
-   3: if h^.palette then                      { header included }
-       begin
-        num:=768;
-        blockread(f,colors,num,err);
-        if (err<num) or (ioresult<>0) then exit;
-        total:=filesize(f)-768-sizeof(CPR_HEADER);
-       end
-      else total:=filesize(f)-sizeof(CPR_HEADER);
-   else exit;
-  end;
-  handleversion:=true;
- end;
-
- function checkversion: boolean;
- begin
-  checkversion:=false;
-  num:=sizeof(CPR_HEADER);
-  blockread(f,h^,num,err);
-  if (err<num) or (ioresult<>0) then exit;
-  if h^.signature<>22354 then
-   begin
-    if (h^.signature<>19794) and (not handleversion(0)) then exit
-     else if (h^.signature=19794) and (not handleversion(h^.version)) then exit;
-   end
-  else handleversion(CPR_NOPAL);
-  checkversion:=true;
- end;
-
- procedure getbuffer;
- begin
-  if total>CPR_BUFFSIZE then num:=CPR_BUFFSIZE else num:=total;
-  blockread(f,buffer^,num,err);
-  if (err<num) or (ioresult<>0) then
-   begin
-    handleerror;
-    exit;
-   end;
-  total:=total-num;
-  index:=0;
- end;
-
-begin
- if CPR_BUFFSIZE<1024 then
-  begin
-   handleerror;
-   exit;
-  end;
- new(buffer);
- assign(f,s);
- reset(f,1);
- if ioresult<>0 then
-  begin
-   handleerror;
-   exit;
-  end;
- if not checkversion then
-  begin
-   handleerror;
-   exit;
-  end;
- if h^.version=CPR_NONE then exit;
- getbuffer;
- j:=0;
- totalsize:=h^.width*h^.height;
- repeat
-  if buffer^[index]=255 then
-   begin
-    inc(index);
-    if index=CPR_BUFFSIZE then getbuffer;
-    count:=buffer^[index];
-    inc(index);
-    if index=CPR_BUFFSIZE then getbuffer;
-    databyte:=buffer^[index];
-    if j+count>totalsize then count:=totalsize-j;
-    fillchar(ts^[0,j],count,databyte);
-    j:=j+count;
-   end
-  else
-   begin
-    ts^[0,j]:=buffer^[index];
-    inc(j);
-   end;
-  inc(index);
-  if index=CPR_BUFFSIZE then getbuffer;
- until j=totalsize;
- close(f);
- dispose(buffer);
-end;
-
-procedure loadpalette(s: string);
-var palfile: file of paltype;
-begin
- assign(palfile,s);
- reset(palfile);
- if ioresult<>0 then errorhandler(s,1);
- read(palfile,colors);
- if ioresult<>0 then errorhandler(s,5);
- close(palfile);
-end;
-
-procedure loadscreen(s: string; ts: pointer);
-var ftype: CPR_HEADER;
-    s2: string[30];
-begin
- uncompressfile(s,ts,@ftype);
- if ftype.version=CPR_ERROR then errorhandler(s,5);
-end;
-
-procedure setrgb256(palnum,r,g,b: byte); assembler;
-asm
- xor bh, bh
- mov bl, palnum
- mov ax, 1010h
- mov dh, r
- mov ch, g
- mov cl, b
-  int 10h
-end;
-
-procedure getrgb256(palnum: byte; var r,g,b); assembler;
-asm
- xor bh, bh
- mov bl, palnum
- mov ax, 1015h
-  int 10h
- les di, r
- mov es:[di], dh
- les di, g
- mov es:[di], ch
- les di, b
- mov es:[di], cl
-end;
-
-procedure set256Colors(pal: paltype); assembler;
-asm
- xor di, di
- push es
- les si, [pal]
- mov dx, 03C8h
- xor ax, ax
- out dx, al
- inc dx
-@@loop:
- mov al, [es:si]
- out dx, al
- mov al, [es:si+1]
- out dx, al
- mov al, [es:si+2]
- out dx, al
- add si, 3
- inc di
- cmp di, 256
- jne @@loop
- pop es
-{ mov ax, 1012h
- mov bx, 0
- mov cx, 256
- les dx, Pal
-  int 10h }
-end;
-
-function testbit(b,bit: byte) : boolean; assembler;
-asm
- mov cl, bit
- mov bl, 1
- shl bl, CL
- mov al, 0
- test b, bl
- jz @@no
- inc al
-@@no:
-end;
-
-procedure fading;
-var a,b: integer;
-    temppal: paltype;
-begin
- mymove2(colors,temppal,192);
- b:=tslice div 4;
- for a:=24 downto 0 do
-  begin
-   for j:=0 to 255 do
-    for i:=1 to 3 do
-     temppal[j,i]:=round(a*colors[j,i]/24);
-   set256colors(temppal);
-   delay(b);
-  end;
-end;
-
-procedure printxy(x1,y1: integer; s: string);
-var letter,a,x,y,t: integer;
-begin
- t:=tcolor;
- x1:=x1+4;               { this stupid offset is pissing me off!!!!}
- for j:=1 to length(s) do
-  begin
-   tcolor:=t;
-   case s[j] of
-     'a'..'z': letter:=ord(s[j])-40;
-    'A' ..'Z': letter:=ord(s[j])-36;
-    ' ' ..'"': letter:=ord(s[j])-31;
-    ''''..'?': letter:=ord(s[j])-35;
-    '%': letter:=55;
-    else letter:=1;
-   end;
-   y:=y1;
-   for i:=0 to 5 do
-    begin
-     x:=x1;
-     inc(y);
-     for a:=7 downto 4 do
-      begin
-       inc(x);
-       if font[letter,i div 2] and (1 shl a)>0 then screen[y,x]:=tcolor
-        else if bkcolor<255 then screen[y,x]:=bkcolor;
-      end;
-     dec(tcolor,2);
-     x:=x1;
-     inc(y);
-     inc(i);
-     for a:=3 downto 0 do
-      begin
-       inc(x);
-       if font[letter,i div 2] and (1 shl a)>0 then screen[y,x]:=tcolor
-        else if bkcolor<255 then screen[y,x]:=bkcolor;
-      end;
-     dec(tcolor,2);
-    end;
-   x1:=x1+5;
-   if bkcolor<255 then for i:=1 to 6 do screen[y1+i,x1]:=bkcolor;
-  end;
- tcolor:=t;
-end;
-
-{$F+}
-function testit : integer; assembler;
-asm
- mov ax, 1A00h
-  int 10h
- cmp al, 1Ah
- jne @@nope
- mov ax, 1
- jmp @@done
-@@nope:
- mov ax, 0
-@@done:
-end;
-{$F-}
-
-procedure readygraph;
-var testdriver,driver,mode,errcode: integer;
-begin
- testdriver:=installuserdriver('vga256',@testit);
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeLn('Error Installing VGA Driver:',errcode);
-   halt(4);
-  end;
- registerbgidriver(@vgadriver);
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeLn('Error Registering VGA Driver:',errcode);
-   halt(4);
-  end;
- driver:=detect;
- initgraph(driver,mode,'');
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeln('Video Initialization Failure: ',errcode);
-   halt(4);
-  end;
- loadpalette('data\main.pal');
- set256colors(colors);
- setgraphbufsize(0);
- checksnow:=false;
-end;
-
-procedure fadein;
-var a,b: integer;
-    temppal: paltype;
-begin
- b:=tslice div 4;
- fillchar(temppal,768,0);
- for a:=1 to 24 do
-  begin
-   for j:=0 to 255 do
-    for i:=1 to 3 do
-     temppal[j,i]:=round(a*colors[j,i]/24);
-   set256colors(temppal);
-   delay(b);
-  end;
- set256colors(colors);
-end;
-
-procedure runintro; forward;
-
-procedure blast(c1,c2,c3: integer);
-var a: integer;
-begin
- for a:=1 to 25 do
-  begin
-   for j:=0 to 255 do
-    begin
-     colors[j,1]:=colors[j,1] + round(a*(c1-colors[j,1])/25);
-     colors[j,2]:=colors[j,2] + round(a*(c2-colors[j,2])/25);
-     colors[j,3]:=colors[j,3] + round(a*(c3-colors[j,3])/25);
-    end;
-   set256colors(colors);
-   delay(tslice);
-  end;
- set256colors(colors);
-end;
-
-procedure loadstarfield;
-begin
- new(s1);
- new(s2);
- new(s3);
- mousehide;
- mymove2(screen,s2^,16000);
- mouseshow;
- loadscreen('data\cloud.vga',s1);
-end;
-
-procedure startit;
-begin
- case cursor of
-  1: code:=1;
-  2: begin
-      dispose(s1);
-      dispose(s2);
-      dispose(s3);
-      fading;
-      mousehide;
-      fillchar(screen,64000,0);
-      stopmod;
-      runintro;
-      loadstarfield;
-     end;
-  3: code:=2;
-  4: code:=4;
- end;
-end;
-
-procedure drawcursor;
-begin
- if cursor=0 then exit;
- case cursor of
-  1:rectangle(25,158,159,177);
-  2:rectangle(43,178,159,197);
-  3:rectangle(159,158,283,177);
-  4:rectangle(159,178,267,197);
- end;
-end;
-
-procedure findmouse;
-var button: boolean;
-begin
- if mouse.getstatus(left) then button:=true else button:=false;
- if (permx<>mouse.x) or (permy<>mouse.y) then keymode:=false;
- if (keymode) and (not button) then exit;
- case mouse.y of
-  158..177: case mouse.x of
-           25..159: cursor:=1;
-           160..283: cursor:=3;
-           else cursor:=0;
-          end;
-  178..197: case mouse.x of
-           43..159: cursor:=2;
-           160..267: cursor:=4;
-           else cursor:=0;
-          end;
-  else if not keymode then cursor:=0;
- end;
- if (button) and (cursor>0) then startit;
-end;
-
-procedure checkkey(c: char);
-begin
- case c of
-  #72: if cursor=0 then cursor:=1
-       else if cursor=1 then cursor:=4 else dec(cursor);
-  #80: if cursor=0 then cursor:=1
-       else if cursor=4 then cursor:=1 else inc(cursor);
-  #75: if cursor>2 then cursor:=cursor-2
-       else cursor:=cursor+2;
-  #77: if cursor>2 then cursor:=cursor-2
-       else cursor:=cursor+2;
- end;
-end;
-
-procedure mainloop;
-begin
- code:=0;
- cursor:=0;
- keymode:=false;
- loadstarfield;
- k:=random(32000);
- playmod(true,'sound\gener1.mod');
- setcolor(207);
- repeat
-  dec(k);
-  if k>63999 then k:=k+64000;
-  asm
-   push ds
-   push es
-   mov ax, [k]
-   les di, [s3]
-   lds si, [s1]
-   mov cx, 64000
-   sub cx, ax
-   mov di, ax
-   cld
-   rep movsb
-   mov cx, ax
-   xor di, di
-   rep movsb
-   pop es
-   pop ds
-  end;
-  asm
-   push ds
-   push es
-   les si, [s2]
-   lds di, [s3]
-   mov si, 64000
-   xor di, di
-  @@loopit:
-   cmp di, [es: si]
-   je @@black
-   mov al, [es: si]
-   mov [ds: si], al
-  @@black:
-   dec si
-   jnz @@loopit
-   pop es
-   pop ds
-  end;
-  mousehide;
-  mymove2(s3^,screen,16000);
-  drawcursor;
-  mouseshow;
-  findmouse;
-  if fastkeypressed then
-   begin
-    keymode:=true;
-    permx:=mouse.x;
-    permy:=mouse.y;
-    key:=readkey;
-    if key=#0 then checkkey(readkey);
-    if key=#13 then startit;
-   end;
-  delay(tslice);
- until code>0;
- dispose(s1);
- dispose(s2);
- dispose(s3);
- stopmod;
- fading;
- mousehide;
- closegraph;
- textmode(co80);
-end;
-
-procedure showmars;
-var temp: pscreentype;
-begin
- fillchar(colors,768,0);
- set256colors(colors);
- loadscreen('data\cloud.vga',@screen);
- new(temp);
- loadscreen('data\world.vga',temp);
- colors[29]:=colors[0];
- colors[30]:=colors[0];
- set256colors(colors);
- upscroll(temp^);
- dispose(temp);
-end;
-
-procedure gettime; assembler;
-asm
- mov ah, 2Ch
-  int 21h
- mov modth, ch
- mov modtm, cl
- mov modts, dh
-end;
-
-function timewait(t: integer): boolean;
-begin
- asm
-  mov ah, 2Ch
-   int 21h
-  mov curth, ch
-  mov curtm, cl
-  mov curts, dh
- end;
- i:=abs(curth-modth)*3600+abs(curtm-modtm)*60+curts-modts;
- if i>t then timewait:=true else timewait:=false;
-end;
-
-procedure wait(s: integer);
-var modth,modtm,modts,curth,curtm,curts: byte;
-begin
- asm
-  mov ah, 2Ch
-   int 21h
-  mov modth, ch
-  mov modtm, cl
-  mov modts, dh
- end;
- repeat
-  asm
-   mov ah, 2Ch
-    int 21h
-   mov curth, ch
-   mov curtm, cl
-   mov curts, dh
-  end;
-  i:=abs(curth-modth)*3600+abs(curtm-modtm)*60+curts-modts;
- until i>s;
-end;
-
-procedure dothefade;
-var temppal: paltype;
-    a: integer;
-begin
- mymove2(colors,temppal,192);
- for a:=31 downto 0 do
-  begin
-   for j:=0 to 31 do
-    if j<>31 then
-     begin
-      for i:=1 to 3 do
-       temppal[j,i]:=round(a*colors[j,i]/32);
-     end
-    else
-     begin
-      if a>16 then
-       begin
-        for i:=1 to 3 do
-         temppal[31,i]:=round((a-16)*colors[31,i]/16);
-       end
-      else
-       begin
-        temppal[31,1]:=round(63/16*(16-a));
-       end;
-     end;
-   set256colors(temppal);
-   delay(round(tslice*1.6));
-  end;
- mymove2(temppal,colors,192);
-end;
-
-procedure printxy2(x1,y1,tcolor: integer; s: string);
-var letter,a,x,y: integer;
-begin
- x1:=x1+4;               { this stupid offset is pissing me off!!!!}
- for j:=1 to length(s) do
-  begin
-   case s[j] of
-     'a'..'z': letter:=ord(s[j])-40;
-    'A' ..'Z': letter:=ord(s[j])-36;
-    ' ' ..'"': letter:=ord(s[j])-31;
-    ''''..'?': letter:=ord(s[j])-35;
-    '%': letter:=55;
-    else letter:=1;
-   end;
-   y:=y1;
-   for i:=0 to 5 do
-    begin
-     x:=x1;
-     inc(y);
-     for a:=7 downto 4 do
-      begin
-       inc(x);
-       if font[letter,i div 2] and (1 shl a)>0 then screen[y,x]:=tcolor;
-      end;
-     x:=x1;
-     inc(y);
-     inc(i);
-     for a:=3 downto 0 do
-      begin
-       inc(x);
-       if font[letter,i div 2] and (1 shl a)>0 then screen[y,x]:=tcolor;
-      end;
-    end;
-   x1:=x1+5;
-  end;
-end;
-
-procedure writestr2(s1,s2,s3: string);
-var i,j1,j2,j3,b: integer;
-begin
- fillchar(screen,64000,0);
- j1:=156-((length(s1)*5) div 2);
- j2:=156-((length(s2)*5) div 2);
- j3:=156-((length(s3)*5) div 2);
- set256colors(colors);
- b:=tslice div 2;
- for i:=31 downto 0 do
-  begin
-   printxy2(j1-i,90-i,31-i,s1);
-   printxy2(j1-i,90+i,31-i,s1);
-   printxy2(j1+i,90-i,31-i,s1);
-   printxy2(j1+i,90+i,31-i,s1);
-   printxy2(j2-i,100-i,31-i,s2);
-   printxy2(j2-i,100+i,31-i,s2);
-   printxy2(j2+i,100-i,31-i,s2);
-   printxy2(j2+i,100+i,31-i,s2);
-   printxy2(j3-i,110-i,31-i,s3);
-   printxy2(j3-i,110+i,31-i,s3);
-   printxy2(j3+i,110-i,31-i,s3);
-   printxy2(j3+i,110+i,31-i,s3);
-   delay(b);
-  end;
- dothefade;
-end;
-
-procedure domainscreen;
-var backgr: pscreentype;
-begin
- loadscreen('data\main.vga',@screen);
- new(backgr);
- loadscreen('data\cloud.vga',backgr);
- asm
-  push es
-  push ds
-  les si, [backgr]
-  mov ax, $A000
-  mov ds, ax
-  xor si, si
- @@loopit:
-  mov al, [ds: si]
-  cmp al, 255
-  jne @@nodraw
-  mov al, [es: si]
-  mov [ds: si], al
- @@nodraw:
-  inc si
-  cmp si, 64000
-  jne @@loopit
-  pop ds
-  pop es
- end;
- dispose(backgr);
-end;
-
-procedure scrollmainscreen;
-var temp,backgr: pscreentype;
-    y1,a,b,t: integer;
-begin
- new(temp);
- new(backgr);
- loadscreen('data\main.vga',temp);
- loadscreen('data\cloud.vga',backgr);
- set256colors(colors);
- for i:=1 to 120 do
-  mymove2(planet^[i],backgr^[i+12,28],30);
- for y1:=0 to 4 do
-  for b:=6 to 138 do
-   for a:=10 to 303 do
-    if temp^[b,a]=255 then screen[b,a]:=backgr^[b+y1,a+y1];
- t:=tslice div 4;
- for y1:=0 to 36 do
-  begin
-   for j:=0 to 255 do
-    begin
-     colors[j,1]:=colors[j,1] + round((63-colors[j,1])/30);
-     colors[j,2]:=colors[j,2] - round(colors[j,2]/30);
-     colors[j,3]:=colors[j,3] - round(colors[j,3]/30);
-    end;
-   set256colors(colors);
-   delay(t);
-  end;
- dispose(backgr);
- dispose(temp);
-end;
-
-procedure powerupencodes;
-var a,b,y,t,sd,range: integer;
-    yadj,pfac,part,temp1,temp3: real;
-begin
- sd:=500;
- range:=80;
- yadj:=1800/1920;
- setcolor(31);
- part:=31/36;
- t:=tslice div 2;
- for a:=0 to 5 do
-  for b:=0 to 36 do
-   begin
-    screen[(a mod 3)*30+48,(a div 3)*258+b+13]:=round(b*part)+64;
-    screen[(a mod 3)*30+49,(a div 3)*258+b+13]:=round(b*part)+64;
-    for i:=128 to 143 do
-     colors[i]:=colors[random(22)];
-    for i:=144 to 159 do
-     colors[i]:=colors[0];
-    set256colors(colors);
-    delay(t);
-    for i:=144 to 159 do
-     colors[i]:=colors[random(16)];
-    for i:=128 to 143 do
-     colors[i]:=colors[0];
-    set256colors(colors);
-    for i:=(a mod 3)*30+37 to (a mod 3)*30+42 do
-     for j:=(a div 3)*138+89 to (a div 3)*138+93 do
-      if screen[i,j] div 16=3 then screen[i,j]:=screen[i,j]+32;
-   end;
-end;
-
-procedure createplanet(xc,yc: integer);
-var x1,y1: integer;
-    a: longint;
-begin
- x1:=xc;
- y1:=yc;
- for a:=1 to 75000 do
-  begin
-   x1:=x1-1+random(3);
-   y1:=y1-1+random(3);
-   if x1>240 then x1:=1 else if x1<1 then x1:=240;
-   if y1>120 then y1:=1 else if y1<1 then y1:=120;
-   if landform^[x1,y1]<240 then landform^[x1,y1]:=landform^[x1,y1]+5;
-  end;
-end;
-
-procedure generateplanet;
-var f: file of landtype;
-begin
- randomize;
- assign(f,'data\plan1.dta');
- reset(f);
- if ioresult<>0 then errorhandler('data\plan1.dta',1);
- read(f,landform^);
- if ioresult<>0 then errorhandler('data\plan1.dta',5);
- close(f);
- fillchar(planet^,14400,0);
- water:=50;
- part2:=28/(255-water);
- c:=0;
- ecl:=180;
- radius:=3025;
- c2:=1.09;
- r2:=round(sqrt(radius));
- waterindex:=33;
- for j:=0 to 3 do spcindex[j]:=48+j;
- spcindex[4]:=128;
- spcindex[5]:=129;
-end;
-
-procedure setupbreach1;
-var a: integer;
-begin
- new(shippix);
- new(msgpix);
- new(override);
- for a:=0 to 9 do
-  for i:=0 to 19 do
-   move(screen[i+(a div 5)*20+20,(a mod 5)*30+110],shippix^[a,i],30);
- for a:=0 to 9 do
-  for i:=0 to 4 do
-   move(screen[i+(a div 3)*10+20,(a mod 3)*10+60],msgpix^[a,i],10);
- for i:=90 to 110 do
-  move(screen[i,200],override^[i,200],41);
- for i:=90 to 110 do
-  fillchar(screen[i,200],41,0);
- for i:=20 to 60 do
-  fillchar(screen[i,60],201,0);
- fadein;
-end;
-
-procedure breach1wait(t: integer);
-var modth,modtm,modts,curth,curtm,curts: byte;
-    a,b,c: integer;
-begin
- asm
-  mov ah, 2Ch
-   int 21h
-  mov modth, ch
-  mov modtm, cl
-  mov modts, dh
- end;
- repeat
-  if random(2)=0 then
-   begin
-    a:=random(10);
-    for i:=0 to 19 do
-     move(shippix^[a,i],screen[i+91,100],30);
-    for b:=0 to 3 do
-     begin
-      a:=random(6);
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+90+b*6,70],10);
-      if random(2)=0 then
-       begin
-        a:=random(6);
-        for i:=0 to 4 do
-         move(msgpix^[a,i],screen[i+90+b*6,80],10);
-        c:=90;
-       end
-      else
-       begin
-        c:=80;
-        for i:=0 to 4 do
-         fillchar(screen[i+90+b*6,90],10,0);
-       end;
-      a:=random(3)+6;
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+90+b*6,c],10);
-     end;
-    end;
-  if random(2)=0 then
-   begin
-    a:=random(10);
-    for i:=0 to 19 do
-     move(shippix^[a,i],screen[i+91,220],30);
-    for b:=0 to 3 do
-     begin
-      a:=random(6);
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+90+b*6,190],10);
-      if random(2)=0 then
-       begin
-        a:=random(6);
-        for i:=0 to 4 do
-         move(msgpix^[a,i],screen[i+90+b*6,200],10);
-        c:=210;
-       end
-      else
-       begin
-        c:=200;
-        for i:=0 to 4 do
-         fillchar(screen[i+90+b*6,210],10,0);
-       end;
-      a:=random(3)+6;
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+90+b*6,c],10);
-     end;
-   end;
-  delay(tslice*10);
-  asm
-   mov ah, 2Ch
-    int 21h
-   mov curth, ch
-   mov curtm, cl
-   mov curts, dh
-  end;
-  i:=abs(curth-modth)*3600+abs(curtm-modtm)*60+curts-modts;
- until i>t;
-end;
-
-procedure overridebreach1;
-var a: integer;
-begin
- for a:=0 to 10 do
-  begin
-   for i:=90 to 112 do
-    begin
-     fillchar(screen[i,190],61,0);
-     fillchar(screen[i,70],61,0);
-    end;
-   delay(tslice*5);
-   for i:=90 to 110 do
-    begin
-     move(override^[i,200],screen[i,200],41);
-     move(override^[i,200],screen[i,80],41);
-    end;
-   delay(tslice*8);
-  end;
-end;
-
-procedure uploadencodes;
-var str1: string[4];
-    a,b,c,i,j: integer;
-begin
- str1:='7A1E';
- for j:=0 to 300 do
-  begin
-   for b:=0 to 3 do
-    begin
-     for c:=0 to random(4)+1 do
-      begin
-       a:=random(6);
-       for i:=0 to 4 do
-        move(msgpix^[a,i],screen[i+90+b*6,70+c*10],10);
-      end;
-      if c<4 then
-       for i:=0 to 5 do
-        fillchar(screen[i+90+b*6,80+c*10],(5-c)*10,0);
-      a:=random(3)+6;
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+90+b*6,80+c*10],10);
-    end;
-   for b:=0 to 3 do
-    begin
-     for c:=0 to random(4)+1 do
-      begin
-       a:=random(6);
-       for i:=0 to 4 do
-        move(msgpix^[a,i],screen[i+90+b*6,190+c*10],10);
-      end;
-      if c<4 then
-       for i:=0 to 5 do
-        fillchar(screen[i+90+b*6,200+c*10],(5-c)*10,0);
-      a:=random(3)+6;
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+90+b*6,200+c*10],10);
-    end;
-   delay(tslice div 2);
-   printxy(70,30,str1);
-   inc(str1[4]);
-   if str1[4]='[' then
-    begin
-     str1[4]:='0';
-     inc(str1[3]);
-     if str1[3]='[' then
-      begin
-       str1[3]:='0';
-       inc(str1[2]);
-      end
-     else if str1[3]=':' then str1[3]:='A';
-    end
-   else if str1[4]=':' then str1[4]:='A';
-  end;
- for i:=89 to 112 do
-  begin
-   fillchar(screen[i,190],61,0);
-   fillchar(screen[i,70],61,0);
-  end;
-end;
-
-procedure setupbreach2;
-var a: integer;
-begin
- new(peoplepix);
- new(override2);
- for a:=0 to 3 do
-  for i:=0 to 28 do
-   move(screen[i+21,25+a*30],peoplepix^[a,i],29);
- for a:=0 to 3 do
-  for i:=0 to 28 do
-   move(screen[i+51,25+a*30],peoplepix^[a+4,i],29);
- for a:=0 to 3 do
-  for i:=0 to 28 do
-   move(screen[i+21,173+a*30],peoplepix^[a+8,i],29);
- for a:=0 to 3 do
-  for i:=0 to 28 do
-   move(screen[i+51,173+a*30],peoplepix^[a+12,i],29);
- for i:=0 to 40 do
-  move(screen[i+130,30],override2^[i],111);
- for i:=21 to 79 do
-  begin
-   fillchar(screen[i,24],120,0);
-   fillchar(screen[i,173],120,0);
-   fillchar(screen[i+100,24],120,0);
-  end;
- for i:=21 to 79 do
-  begin
-   move(screen[i+100,173],screen[i,24],120);
-   move(screen[i+100,173],screen[i,173],120);
-   move(screen[i+100,173],screen[i+100,24],120);
-  end;
- for a:=0 to 9 do
-  for i:=0 to 4 do
-   for j:=0 to 9 do
-    if msgpix^[a,i,j]>0 then msgpix^[a,i,j]:=111;
- a:=random(16);
- for i:=0 to 28 do
-  move(peoplepix^[a,i],screen[36+i,191],29);
- a:=random(16);
- for i:=0 to 28 do
-  move(peoplepix^[a,i],screen[136+i,191],29);
- a:=random(16);
- for i:=0 to 28 do
-  move(peoplepix^[a,i],screen[36+i,42],29);
- a:=random(16);
- for i:=0 to 28 do
-  move(peoplepix^[a,i],screen[136+i,42],29);
-end;
-
-procedure breach2wait(t: integer);
-var modth,modtm,modts,curth,curtm,curts: byte;
-    a,b: integer;
-begin
- asm
-  mov ah, 2Ch
-   int 21h
-  mov modth, ch
-  mov modtm, cl
-  mov modts, dh
- end;
- repeat
-  for b:=0 to 3 do
-    begin
-     for c:=0 to random(3)+2 do
-      begin
-       a:=random(6);
-       for i:=0 to 4 do
-        move(msgpix^[a,i],screen[i+138+b*6,230+c*10],10);
-      end;
-      if c<5 then
-       for i:=0 to 5 do
-        fillchar(screen[i+138+b*6,220+c*10],(7-c)*10,0);
-      a:=random(3)+6;
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+138+b*6,220+c*10],10);
-    end;
-  for b:=0 to 3 do
-    begin
-     for c:=0 to random(3)+2 do
-      begin
-       a:=random(6);
-       for i:=0 to 4 do
-        move(msgpix^[a,i],screen[i+38+b*6,230+c*10],10);
-      end;
-      if c<5 then
-       for i:=0 to 5 do
-        fillchar(screen[i+38+b*6,220+c*10],(7-c)*10,0);
-      a:=random(3)+6;
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+38+b*6,220+c*10],10);
-    end;
-  for b:=0 to 3 do
-    begin
-     for c:=0 to random(3)+2 do
-      begin
-       a:=random(6);
-       for i:=0 to 4 do
-        move(msgpix^[a,i],screen[i+138+b*6,81+c*10],10);
-      end;
-      if c<5 then
-       for i:=0 to 5 do
-        fillchar(screen[i+138+b*6,71+c*10],(7-c)*10,0);
-      a:=random(3)+6;
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+138+b*6,71+c*10],10);
-    end;
-  for b:=0 to 3 do
-    begin
-     for c:=0 to random(3)+2 do
-      begin
-       a:=random(6);
-       for i:=0 to 4 do
-        move(msgpix^[a,i],screen[i+38+b*6,81+c*10],10);
-      end;
-      if c<5 then
-       for i:=0 to 5 do
-        fillchar(screen[i+38+b*6,71+c*10],(7-c)*10,0);
-      a:=random(3)+6;
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+38+b*6,71+c*10],10);
-    end;
-  if random(2)=0 then
-   begin
-    a:=random(16);
-    for i:=0 to 28 do
-     move(peoplepix^[a,i],screen[36+i,191],29);
-   end;
-  if random(2)=0 then
-   begin
-    a:=random(16);
-    for i:=0 to 28 do
-     move(peoplepix^[a,i],screen[136+i,191],29);
-   end;
-  if random(2)=0 then
-   begin
-    a:=random(16);
-    for i:=0 to 28 do
-     move(peoplepix^[a,i],screen[36+i,42],29);
-   end;
-  if random(2)=0 then
-   begin
-    a:=random(16);
-    for i:=0 to 28 do
-     move(peoplepix^[a,i],screen[136+i,42],29);
-   end;
-  delay(tslice*10);
-  asm
-   mov ah, 2Ch
-    int 21h
-   mov curth, ch
-   mov curtm, cl
-   mov curts, dh
-  end;
-  i:=abs(curth-modth)*3600+abs(curtm-modtm)*60+curts-modts;
- until i>t;
-end;
-
-procedure overridebreach2;
-var a: integer;
-begin
- for a:=0 to 10 do
-  begin
-   for i:=0 to 40 do
-    begin
-     fillchar(screen[i+30,30],111,0);
-     fillchar(screen[i+130,30],111,0);
-     fillchar(screen[i+30,179],111,0);
-     fillchar(screen[i+130,179],111,0);
-    end;
-   delay(tslice*4);
-   for i:=0 to 40 do
-    begin
-     move(override2^[i],screen[i+30,30],111);
-     move(override2^[i],screen[i+130,30],111);
-     move(override2^[i],screen[i+30,179],111);
-     move(override2^[i],screen[i+130,179],111);
-    end;
-   delay(tslice*9);
-  end;
-end;
-
-procedure makeplanet(t: integer; eclipse: boolean);
-var modth,modtm,modts,curth,curtm,curts: byte;
-label endcheck;
-begin
- asm
-  mov ah, 2Ch
-   int 21h
-  mov modth, ch
-  mov modtm, cl
-  mov modts, dh
- end;
- repeat
-  inc(c,1);
-  if c>240 then c:=c-240;
-  if (eclipse) and (c mod 2=0) then
-   begin
-    inc(ecl);
-    if ecl>340 then ecl:=ecl-340;
-   end;
-  x:=2*r2+10;
-  ofsy:=0;
-  for i:=6 to 2*r2+4 do
-    begin
-     y:=sqrt(radius-sqr(i-r2-5));
-     m:=round((r2-y)*c2);
-     part:=r2/y;
-     inc(ofsy);
-     ofsx:=m;
-     for j:=1 to x do
-      begin
-       index:=round(j*part);
-       if index>x then goto endcheck;
-       inc(ofsx);
-       if ecl>170 then
-        begin
-         if j=1 then alt:=10
-          else alt:=(index-ecl+186) div 2;
-        end
-        else if ecl<171 then
-         begin
-          if index=x then alt:=10
-           else alt:=(ecl-index) div 2
-         end
-        else alt:=0;
-       if alt<0 then alt:=0;
-       if (index+c)>240 then j2:=index+c-240
-        else j2:=index+c;
-       if (alt<6) and (landform^[j2,i]<water) then planet^[ofsy,ofsx]:=waterindex+6-alt
-        else if landform^[j2,i]<water then planet^[ofsy,ofsx]:=waterindex
-        else
-         begin
-          z:=round((landform^[j2,i]-water)*part2);
-          case z of
-           6..31: if z>alt then z:=z-alt else z:=1;
-           0..5: if alt>spcindex[z] mod 16 then z:=1 else z:=spcindex[z]-alt;
-          end;
-          planet^[ofsy,ofsx]:=z;
-         end;
- endcheck:
-      end;
-    end;
-  for i:=1 to 120 do
-   mymove2(planet^[i],screen[i+12,28],30);
-  delay(tslice);
-  asm
-   mov ah, 2Ch
-    int 21h
-   mov curth, ch
-   mov curtm, cl
-   mov curts, dh
-  end;
-  i:=abs(curth-modth)*3600+abs(curtm-modtm)*60+curts-modts;
- until i>t;
-end;
-
-procedure readyencode;
-begin
- for i:=128 to 143 do
-  colors[i]:=colors[random(22)];
- for i:=144 to 159 do
-  colors[i]:=colors[0];
- set256colors(colors);
- for i:=0 to 69 do
-  for j:=0 to 68 do
-   screen[i+40,j+126]:=random(16)+128+(i mod 2)*16;
-end;
-
-procedure charcomstuff(t: integer);
-var modth,modtm,modts,curth,curtm,curts: byte;
-    sd,range,y: integer;
-    pfac,yadj,temp1,temp3: real;
-begin
- asm
-  mov ah, 2Ch
-   int 21h
-  mov modth, ch
-  mov modtm, cl
-  mov modts, dh
- end;
- sd:=500;
- range:=80;
- yadj:=1800/1920;
- repeat
-  for i:=128 to 143 do
-   colors[i]:=colors[random(22)];
-  for i:=144 to 159 do
-   colors[i]:=colors[0];
-  set256colors(colors);
-  delay(tslice div 2);
-  for i:=144 to 159 do
-   colors[i]:=colors[random(16)];
-  for i:=128 to 143 do
-   colors[i]:=colors[0];
-  set256colors(colors);
-  delay(tslice div 2);
-  asm
-   mov ah, 2Ch
-    int 21h
-   mov curth, ch
-   mov curtm, cl
-   mov curts, dh
-  end;
-  i:=abs(curth-modth)*3600+abs(curtm-modtm)*60+curts-modts;
-  delay(tslice div 5);
- until i>t;
-end;
-
-procedure loadscreens;
-var t: pscreentype;
-    a,b: integer;
-    temppal: paltype;
-begin
- fillchar(colors,768,0);
- init320200;
- set256colors(colors);
- new(t);
- for a:=1 to 4 do
-  begin
-   loadscreen('data\blast0'+chr(a+48)+'.vga',t);
-   setpage(a-1);
-   for i:=0 to 199 do
-    for j:=0 to 319 do
-     setpix(j,i,t^[i,j]);
-  end;
- dispose(t);
- b:=0;
- fillchar(temppal,768,0);
- for a:=1 to 24 do
-  begin
-   showpage(b);
-   inc(b);
-   if b=4 then b:=0;
-   for j:=0 to 255 do
-    for i:=1 to 3 do
-     temppal[j,i]:=round(a*colors[j,i]/24);
-   showpage(b);
-   inc(b);
-   if b=4 then b:=0;
-   set256colors(temppal);
-   delay(tslice);
-  end;
- set256colors(colors);
-end;
-
-procedure cycleengines(t: integer);
-var modth,modtm,modts,curth,curtm,curts: byte;
-begin
- asm
-  mov ah, 2Ch
-   int 21h
-  mov modth, ch
-  mov modtm, cl
-  mov modts, dh
- end;
- i:=0;
- set256colors(colors);
- repeat
-  showpage(i);
-  inc(i);
-  if i=4 then i:=0;
-  asm
-   mov ah, 2Ch
-    int 21h
-   mov curth, ch
-   mov curtm, cl
-   mov curts, dh
-  end;
-  delay(tslice div 2);
-  j:=abs(curth-modth)*3600+abs(curtm-modtm)*60+curts-modts;
- until j>t;
-end;
-
-procedure fadecharcom;
-var a: integer;
-    temppal: paltype;
-begin
- index:=0;
- a:=24;
- mymove2(colors,temppal,192);
- repeat
-  inc(index);
-  if a>0 then
-   for j:=0 to 255 do
-    for i:=1 to 3 do
-     colors[j,i]:=round(a*temppal[j,i]/24);
-  for i:=128 to 143 do
-   colors[i]:=colors[random(22)];
-  for i:=144 to 159 do
-   colors[i]:=colors[0];
-  set256colors(colors);
-  delay(tslice div 2);
-  for i:=144 to 159 do
-   colors[i]:=colors[random(16)];
-  for i:=128 to 143 do
-   colors[i]:=colors[0];
-  set256colors(colors);
-  delay(tslice div 2+1);
-  if index mod 2=0 then dec(a);
- until a=0;
-end;
-
-procedure c7logo;
-var t: pscreentype;
-    y,x,a,seed,j,index,max: word;
-    temppal: paltype;
-begin
- new(t);
- tslice:=tslice div 2;
- fillchar(colors,768,0);
- set256colors(colors);
- loadscreen('data\channel7.vga',t);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   screen[i,j]:=random(16)+200+(i mod 2)*16;
- max:=38000;
- index:=0;
- j:=0;
- seed:=159;
- if fastkeypressed then begin dispose(t); exit; end;
- repeat
-  for i:=200 to 215 do
-   colors[i]:=colors[random(22)];
-  for i:=216 to 231 do
-   colors[i]:=colors[0];
-  set256colors(colors);
-  for i:=1 to 70+(90-tslice) do
-   begin
-    inc(index);
-    j:=j+seed;
-    if j>max then j:=j-max;
-    y:=(j div 300)+30;
-    x:=j mod 300+20;
-    if t^[y,x]>0 then screen[y,x]:=t^[y,x];
-   end;
-  for i:=216 to 231 do
-   colors[i]:=colors[random(16)];
-  for i:=200 to 215 do
-   colors[i]:=colors[0];
-  set256colors(colors);
-  delay(tslice div 4);
- until index>max;
- a:=31;
- index:=0;
- if fastkeypressed then begin dispose(t); exit; end;
- repeat
-  inc(index);
-  for i:=200 to 215 do
-   colors[i]:=colors[random(22)];
-  for i:=216 to 231 do
-   colors[i]:=colors[0];
-  set256colors(colors);
-  delay(tslice);
-  for i:=216 to 231 do
-   colors[i]:=colors[random(16)];
-  for i:=200 to 215 do
-   colors[i]:=colors[0];
-  set256colors(colors);
-  delay(tslice div 4);
- until index=75;
- index:=0;
- a:=24;
- mymove2(colors,temppal,192);
- if fastkeypressed then begin dispose(t); exit; end;
- repeat
-  inc(index);
-  if a>0 then
-   for j:=0 to 199 do
-    for i:=1 to 3 do
-     colors[j,i]:=round(a*temppal[j,i]/24);
-  for i:=200 to 215 do
-   colors[i]:=colors[random(22)];
-  for i:=216 to 231 do
-   colors[i]:=colors[0];
-  set256colors(colors);
-  delay(tslice div 2);
-  for i:=216 to 231 do
-   colors[i]:=colors[random(16)];
-  for i:=200 to 215 do
-   colors[i]:=colors[0];
-  set256colors(colors);
-  delay(tslice div 4);
-  if index mod 4=0 then dec(a);
- until a=0;
- dispose(t);
- tslice:=tslice*2;
-end;
-
-procedure scale(startx,starty,sizex,sizey,newx,newy: integer; var s,t);
-var sety, py, pdy, px, pdx, dcx, dcy, ofsy: integer;
-begin
- asm
-  push ds
-  push es
-  les si, [s]         { es: si is our source location }
-  mov [ofsy], si
-  lds di, [t]         { ds: di is our destination }
-  imul di, [starty], 320
-  mov [sety], di
-
-  add di, [startx]
-
-  mov ax, [sizex]
-  xor dx, dx
-  mov cx, [newx]
-  div cx
-  mov [px], ax
-  mov [pdx], dx       { set up py and pdy }
-
-  mov ax, [sizey]
-  xor dx, dx
-  mov cx, [newy]
-  div cx
-  mov [py], ax
-  mov [pdy], dx       { set up py and pdy }
-
-  xor cx, cx
-  mov [dcx], cx
-  mov [dcy], cx
-  mov dx, [newy]
-
- @@iloop:
-  add cx, [py]
-
-  mov ax, [pdy]
-  add [dcy], ax
-  mov ax, [dcy]
-
-  cmp ax, [newy]
-  jl @@nodcychange
-  inc cx
-  sub ax, [newy]
-  mov [dcy], ax
-
- @@nodcychange:
-
-  imul si, cx, 320
-  add si, [ofsy]
-
-  mov bx, [newx]
-
- @@jloop:
-  add si, [px]
-
-  mov ax, [pdx]
-  add [dcx], ax
-  mov ax, [dcx]
-  cmp ax, [newx]
-  jl @@nodcxchange
-
-  inc si
-  sub ax, [newx]
-  mov [dcx], ax
-
- @@nodcxchange:
-
-  mov al, [es: si]
-  mov [ds: di], al     { finally draw it! }
-
-  inc di
-  dec bx
-  jnz @@jloop
-
-  add [sety], 320
-  mov di, [sety]
-  add di, [startx]
-
-  dec dx
-  jnz @@iloop
-
-  pop es
-  pop ds
- end;
-end;
-
-procedure shrinkalienscreen;
-var t: pscreentype;
-    partx,party: real;
-    a,startx,max,starty: integer;
-    temppal: paltype;
-begin
- fillchar(temppal,768,0);
- for i:=0 to 31 do
-  temppal[i]:=colors[i];
- for i:=240 to 255 do
-  temppal[i]:=colors[i];
- new(t);
- mymove2(screen,t^,16000);
- max:=25;
- for a:=1 to max do
-  begin
-   partx:=306-234/max*a;
-   party:=177-142/max*a;
-   starty:=166-round(party);
-   startx:=305-round(partx);
-   scale(startx,starty,305,176,320-startx,200-starty,t^,screen);
-  end;
- for i:=142 to 176 do
-  mymove2(screen[i,234],t^[i,234],18);
- set256colors(temppal);
- loadscreen('data\alien.vga',@screen);
- for i:=142 to 176 do
-  mymove2(t^[i,234],screen[i,234],18);
- dispose(t);
-end;
-
-procedure fadeinalienscreen;
-var a: integer;
-    temppal: paltype;
-begin
- for i:=240 to 255 do temppal[i]:=colors[i];
- for i:=0 to 31 do temppal[i]:=colors[i];
- for a:=1 to 24 do
-  begin
-   for j:=32 to 239 do
-    for i:=1 to 3 do
-     temppal[j,i]:=round(a*colors[j,i]/24);
-   set256colors(temppal);
-   delay(tslice);
-  end;
-end;
-
-procedure fadeinintro2;
-var a: integer;
-    temppal: paltype;
-begin
- fillchar(temppal,768,0);
- for a:=1 to 24 do
-  begin
-   for j:=0 to 31 do
-    for i:=1 to 3 do
-     temppal[j,i]:=round(a*colors[j,i]/24);
-   for j:=49 to 255 do
-    for i:=1 to 3 do
-     temppal[j,i]:=round(a*colors[j,i]/24);
-   set256colors(temppal);
-   delay(tslice);
-  end;
- for a:=0 to 34 do
-  begin
-   for i:=32 to 48 do
-    colors[i,1]:=round((i-32)*a/17);
-   set256colors(colors);
-   delay(tslice);
-  end;
-end;
-
-procedure shipschasing;
-var a,b,x1,y1,x2,y2: integer;
-    dx1,dx2,dy1,dy2: real;
-    t: pscreentype;
-begin
- x1:=60;
- y1:=199;
- x2:=20;
- y2:=240;
- dx1:=4.6;
- dx2:=4.9;
- dy1:=-1;
- dy2:=-1;
- new(t);
- mymove2(screen,t^,16000);
- for a:=0 to 180 do
-  begin
-   mymove2(t^[y1,x1],screen[y1,x1],1);
-   mymove2(t^[y1+1,x1],screen[y1+1,x1],1);
-   dx1:=dx1-0.05;
-   dx2:=dx2-0.05;
-   dy1:=dy1+0.003;
-   dy2:=dy2-0.004;
-   x1:=x1+round(dx1);
-   y1:=y1+round(dy1);
-   if a<165 then
-    begin
-     for b:=0 to random(3) do
-      screen[y1+random(2),x1+random(2)]:=84+random(3);
-     screen[y1,x1]:=17+random(3);
-    end;
-   if y2<200 then
-    begin
-     mymove2(t^[y2,x2],screen[y2,x2],1);
-     mymove2(t^[y2+1,x2],screen[y2+1,x2],1);
-    end;
-   x2:=x2+round(dx2);
-   y2:=y2+round(dy2);
-   if y2<200 then
-    begin
-     for b:=0 to random(3) do
-      screen[y2+random(2),x2+random(2)]:=84+random(3);
-     screen[y2,x2]:=17+random(3);
-    end;
-   delay(round(tslice*1.5));
-  end;
- dispose(t);
-end;
-
-procedure shipanimation;
-var t,bg: pscreentype;
-    a,b,x,y,x2,y2,i2,y3,x3: integer;
-begin
- new(t);
- loadscreen('data\lilship.vga',t);
- set256colors(colors);
- new(bg);
- y3:=69;
- x2:=148;
- mymove2(screen,bg^,16000);
- for a:=0 to 8 do
-  begin
-   x:=(a mod 3)*90;
-   y:=(a div 3)*60;
-   for b:=0 to 5 do
-    begin
-     dec(y3,2);
-     dec(x2,2);
-     for i:=0 to 55 do
-      begin
-       y2:=i+y3;
-       i2:=y+i;
-       if y2>0 then
-        for j:=0 to 82 do
-         if t^[i2,x+j]>0 then screen[y2,x2+j]:=t^[i2,x+j]
-          else screen[y2,x2+j]:=bg^[y2,x2+j];
-       if a<2 then mymove2(bg^[y2,x2+82],screen[y2,x2+82],2);
-      end;
-     if a<2 then
-      begin
-       y2:=69-a*10-b;
-       for i:=56 to 60 do
-        mymove2(bg^[y2+i,x2],screen[y2+i,x2],27);
-      end;
-     delay(tslice div 3);
-    end;
-  end;
- wait(1);
- dispose(t);
- dispose(bg);
-end;
-
-procedure atmosphereanimation;
-var t,bk: pscreentype;
-    a,b,x,y: integer;
-    dx,dy: real;
-begin
- new(t);
- loadscreen('data\world3.vga',t);
- new(bk);
- mymove2(screen,bk^,16000);
- x:=260;
- y:=199;
- dx:=-5.5;
- dy:=-0.970;
- for a:=0 to 100 do
-  begin
-   mymove2(bk^[y,x],screen[y,x],1);
-   mymove2(bk^[y+1,x],screen[y+1,x],1);
-   dx:=dx+0.1;
-   dy:=dy+0.005;
-   x:=x+round(dx);
-   y:=y+round(dy);
-     for b:=0 to random(3) do
-      screen[y+random(2),x+random(2)]:=224+random(3);
-     screen[y,x]:=250+random(3);
-   delay(round(tslice*1.5));
-  end;
- for a:=0 to 15 do
-  begin
-   x:=(a mod 4)*70;
-   y:=(a div 4)*50;
-   for i:=0 to 49 do
-    mymove2(t^[y+i,x],screen[80+i,190],17);
-   delay(tslice*3);
-  end;
- for i:=0 to 49 do
-  mymove2(bk^[80+i,190],screen[80+i,190],17);
- wait(4);
- dispose(t);
- dispose(bk);
-end;
-
-procedure alienscreenwait;
-var modth,modtm,modts,curth,curtm,curts: byte;
-    x1,y1,x2,y2: integer;
-begin
- asm
-  mov ah, 2Ch
-   int 21h
-  mov modth, ch
-  mov modtm, cl
-  mov modts, dh
- end;
- x1:=183;
- y1:=131;
- x2:=62;
- y2:=148;
- screen[y1,x1]:=screen[y1,x1] xor 31;
- screen[y2,x2]:=screen[y2,x2] xor 31;
- for j:=1 to 7 do
-  begin
-   screen[y1,x1]:=screen[y1,x1] xor 31;
-   screen[y2,x2]:=screen[y2,x2] xor 31;
-   dec(x1);
-   inc(y1);
-   inc(y2);
-   screen[y1,x1]:=screen[y1,x1] xor 31;
-   screen[y2,x2]:=screen[y2,x2] xor 31;
-   repeat
-    asm
-     mov ah, 2Ch
-      int 21h
-     mov curth, ch
-     mov curtm, cl
-     mov curts, dh
-    end;
-    i:=abs(curth-modth)*3600+abs(curtm-modtm)*60+curts-modts;
-   until i>j;
-  end;
- for j:=3 downto 1 do
-  begin
-   setcolor(175-j*2);
-   circle(x1,y1,j*3+1);
-   circle(x2,y2,j*3+1);
-   delay(tslice*8);
-  end;
-end;
-
-procedure fadearea(x1,y1,x2,y2,alt: integer);
-begin
- for i:=y1 to y2 do
-  for j:=x1 to x2 do
-   if screen[i,j]>0 then screen[i,j]:=screen[i,j]+alt;
-end;
-
-procedure getbackgroundforis2;
-var backgr: pscreentype;
-begin
- new(backgr);
- loadscreen('data\cloud.vga',backgr);
- loadscreen('data\main3.vga',@screen);
- for j:=0 to 319 do
-  for i:=0 to 199 do
-   if screen[i,j]=255 then screen[i,j]:=backgr^[i,j];
- for i:=1 to 120 do
-  mymove2(screen[i+12,28],planet^[i],30);
- radius:=400;
- c2:=1.30;
- r2:=round(sqrt(radius));
- c:=random(120);
- ecl:=50;
- makeplanet(0,false);
- m1:=291;
- m2:=201;
- m3:=234;
- m4:=280;
- fadearea(186,35,290,45,32);
- fadearea(186,55,200,65,32);
- fadearea(186,75,233,85,32);
- fadearea(186,95,279,105,32);
- dispose(backgr);
-end;
-
-procedure is2wait(alt1,alt2,alt3,alt4: integer);
-var modth,modtm,modts,curth,curtm,curts: byte;
-    x1,y1,x2,y2: integer;
-begin
- asm
-  mov ah, 2Ch
-   int 21h
-  mov modth, ch
-  mov modtm, cl
-  mov modts, dh
- end;
- repeat
-  if m1>190 then
-   begin
-    fadearea(m1+alt1,35,m1-1,45,-32);
-    m1:=m1+alt1;
-   end;
-  if m2>190 then
-   begin
-    fadearea(m2+alt2,55,m2-1,65,-32);
-    m2:=m2+alt2;
-   end;
-  if m3>190 then
-   begin
-    fadearea(m3+alt3,75,m3-1,85,-32);
-    m3:=m3+alt3;
-   end;
-  if m4>190 then
-   begin
-    fadearea(m4+alt4,95,m4-1,105,-32);
-    m4:=m4+alt4;
-   end;
-  delay(tslice*7);
-  asm
-   mov ah, 2Ch
-    int 21h
-   mov curth, ch
-   mov curtm, cl
-   mov curts, dh
-  end;
-  i:=abs(curth-modth)*3600+abs(curtm-modtm)*60+curts-modts;
- until i>1;
-end;
-
-procedure staticscreen;
-begin
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   screen[i,j]:=random(16)+200+(i mod 2)*16;
- repeat
-  for i:=200 to 215 do
-   colors[i]:=colors[random(22)];
-  for i:=216 to 231 do
-   colors[i]:=colors[0];
-  set256colors(colors);
-  delay(tslice);
-  for i:=216 to 231 do
-   colors[i]:=colors[random(16)];
-  for i:=200 to 215 do
-   colors[i]:=colors[0];
-  set256colors(colors);
-  delay(tslice div 4);
- until fastkeypressed;
-end;
-
-procedure runintro;
-var total,a: integer;
-label continue,jumpto;
-begin
- bkcolor:=0;
- tcolor:=22;
- printxy(0,0,'Copywrite 1994 Channel 7, Destiny: Virtual');
- wait(0);
- new(planet);
- new(landform);
- if fastkeypressed then goto continue;
- generateplanet;
- if fastkeypressed then goto continue;
- playmod(true,'sound\intro1.mod');
- ampsetpanning(0,Pan_Surround);
- ampsetpanning(1,Pan_Surround);
- mouse.setmousecursor(1);
- if fastkeypressed then goto continue;
-{PART I. *********************************************************************}
-{#1.1}
- c7logo;
- if fastkeypressed then goto continue;
- loadscreen('data\intro2.vga',@screen);
- fadeinintro2;
- if fastkeypressed then goto continue;
- wait(2);
- fading;
- if fastkeypressed then goto continue;
-{#1.2}
- loadpalette('data\main.pal');
- writestr2('A','Destiny: Virtual','Designed Game');
- if fastkeypressed then goto continue;
- wait(1);
- fading;
- if fastkeypressed then goto continue;
- {#1.3}
- showmars;
- printxy2(145,30,29,'Mars');
- printxy2(133,40,30,'3784 A.D.');
- for a:=0 to 63 do
-  begin
-   setrgb256(29,a,0,0);
-   delay(tslice);
-  end;
- for a:=0 to 63 do
-  begin
-   setrgb256(30,a,0,0);
-   delay(tslice);
-  end;
- colors[29,1]:=63;
- colors[29,2]:=0;
- colors[29,3]:=0;
- colors[30]:=colors[29];
- if fastkeypressed then goto continue;
- wait(2);
- fading;
- if fastkeypressed then goto continue;
-{#1.4}
- loadpalette('data\main.pal');
- writestr2('Code Master:','Robert W.','Morgan III');
- if fastkeypressed then goto continue;
- wait(1);
- fading;
- if fastkeypressed then goto continue;
-{#1.5}
- domainscreen;
- for i:=1 to 120 do
-  mymove2(screen[i+12,28],planet^[i],30);
- makeplanet(0,true);
- fadein;
- tcolor:=31;
- bkcolor:=3;
- printxy(13,151,'Link Established.');
- makeplanet(1,true);
- printxy(13,157,'Security Override ALPHA-C7.');
- makeplanet(1,true);
- printxy(13,163,'Activating IRONSEED Phage.');
- makeplanet(1,true);
- printxy(13,169,'Approach Coordinates:');
- printxy(16,175,'(180.06,29.73,800.41)');
- makeplanet(1,true);
- printxy(13,181,'Autopilot Engaged.');
- makeplanet(1,true);
- scrollmainscreen;
- bkcolor:=0;
- fading;
- if fastkeypressed then goto continue;
-{#1.6}
- loadpalette('data\main.pal');
- writestr2('World Design:','Jeremy','Holt');
- wait(1);
- fading;
- if fastkeypressed then goto continue;
-{#1.7}
- loadscreen('data\breach1.vga',@screen);
- setupbreach1;
- tcolor:=31;
- breach1wait(1);
- printxy(50,20,'Receiving Transmission...');
- breach1wait(1);
- printxy(50,20,'Uploading Encodes to Port 0x96A9...');
- breach1wait(1);
- printxy(50,30,': 0x');
- uploadencodes;
- printxy(50,30,'Transmission Complete.');
- breach1wait(1);
- printxy(50,40,'Holo-Bitscan Phage Detect Virus');
- printxy(50,46,' at Port 0x96A9.');
- overridebreach1;
- printxy(50,56,'Security Breach!');
- printxy(50,62,' Virus Signature: "IRONSEED".');
- wait(1);
- dispose(shippix);
- dispose(override);
- fading;
- if fastkeypressed then goto continue;
-{#1.8}
- loadpalette('data\main.pal');
- writestr2('Soundtrak:','Andrew G. Sega',' Necros of the Psychic Monks');
- wait(1);
- fading;
- if fastkeypressed then goto continue;
-{#1.9}
- loadscreen('data\breach2.vga',@screen);
- setupbreach2;
- fadein;
- breach2wait(2);
- overridebreach2;
- dispose(override2);
- dispose(peoplepix);
- dispose(msgpix);
- wait(1);
- fading;
- if fastkeypressed then goto continue;
-{#1.10}
- loadpalette('data\main.pal');
- writestr2('Design Consultant:','Chris P.','Cash');
- wait(1);
- fading;
- if fastkeypressed then goto continue;
-{#1.11}
- loadscreen('data\charcom.vga',@screen);
- fadein;
- readyencode;
- tcolor:=191;
- printxy(20,153,'Ship IRONSEED to Relay Point:');
- charcomstuff(1);
- printxy(170,153,'Link Established.');
- charcomstuff(1);
- printxy(20,159,'Receiving Encode Variants.');
- powerupencodes;
- charcomstuff(1);
- printxy(20,165,'Wiping Source Encodes.');
- charcomstuff(1);
- printxy(20,171,'Terminating Transmission.');
- charcomstuff(1);
- printxy(20,177,'Control Protocol Transfered to Human Encode "PRIME".');
- charcomstuff(1);
- fadecharcom;
- if fastkeypressed then goto continue;
-{#1.12}
- loadpalette('data\main.pal');
- writestr2('Tech Consultant:','David W.','Rankin Jr.');
- wait(1);
- fading;
- if fastkeypressed then goto continue;
-{#1.13}
- loadscreens;
- cycleengines(3);
- blast(63,63,63);
- setgraphmode(0);
- set256colors(colors);
- loadscreen('data\cloud.vga',@screen);
- set256colors(colors);
- if fastkeypressed then goto continue;
-{#1.14}
- shipanimation;
- fading;
- if fastkeypressed then goto continue;
-{PART II. ********************************************************************}
-{#2.0}
- stopmod;
- playmod(false,'sound\intro2.mod');
- ampsetpanning(0,Pan_Surround);
- ampsetpanning(1,Pan_Surround);
- wait(2);
- fillchar(colors,768,0);
- fillchar(screen,64000,0);
- set256colors(colors);
- printxy2(117,170,254,'Sometime Later...');
- printxy2(80,180,255,'Thousands of Light Years Away...');
- for a:=0 to 63 do
-  begin
-   setrgb256(254,a,0,0);
-   delay(tslice);
-  end;
- wait(3);
- for a:=10 to 63 do
-  begin
-   setrgb256(255,a,0,0);
-   delay(tslice);
-  end;
- for i:=1 to 120 do
-  for j:=1 to 240 do
-   landform^[j,i]:=255-landform^[j,i];
- colors[254,1]:=63;
- colors[255,1]:=63;
- wait(5);
- fading;
- radius:=2000;
- c2:=1.16;
- r2:=round(sqrt(radius));
- c:=random(120);
- ecl:=105;
- if fastkeypressed then goto continue;
-{#2.1}
- loadscreen('data\battle1.vga',@screen);
- for i:=1 to 120 do
-  mymove2(screen[i+12,28],planet^[i],30);
- makeplanet(0,false);
- fadein;
- makeplanet(12,false);
- fading;
- if fastkeypressed then goto continue;
-{#2.2}
- loadscreen('data\ship1.vga',@screen);
- set256colors(colors);
- tcolor:=255;
- wait(2);
- printxy(50,125,'Orders: Approach and Destroy.');
- wait(2);
- printxy(50,135,'Jamming all Emissions.');
- wait(2);
- printxy(50,145,'Targeting...');
- wait(2);
- printxy(50,155,'Locked and Loading...');
- wait(2);
- printxy(50,165,'Closing for Fire...');
- wait(2);
- if fastkeypressed then goto continue;
-{#2.3}
- shrinkalienscreen;
- fadeinalienscreen;
- alienscreenwait;
- fading;
- if fastkeypressed then goto continue;
-{#2.4}
- getbackgroundforis2;
- fadein;
- tcolor:=26;
- printxy(13,160,'Enemy Closing Rapidly..');
- wait(2);
- printxy(13,167,'Shields Imploding...');
- is2wait(-1,0,0,-2);
- wait(1);
- printxy(13,174,'Destruction Immanent.');
- is2wait(-3,0,-1,-1);
- wait(1);
- printxy(13,182,'Attempting Crash Landing.');
- is2wait(-1,-1,0,0);
- wait(1);
- fading;
- if fastkeypressed then goto continue;
-{#2.5}
- radius:=2000;
- c2:=1.16;
- r2:=round(sqrt(radius));
- c:=random(120);
- ecl:=105;
- loadscreen('data\battle1.vga',@screen);
- for i:=1 to 120 do
-  mymove2(screen[i+12,28],planet^[i],30);
- makeplanet(0,false);
- fadein;
- wait(4);
- if fastkeypressed then goto continue;
-{#2.6}
- shipschasing;
- fading;
- if fastkeypressed then goto continue;
-{#2.7}
- loadscreen('data\world2.vga',@screen);
- fadein;
- wait(4);
- atmosphereanimation;
- if fastkeypressed then goto continue;
-{#2.8}
- wait(8);
- blast(63,0,0);
- if fastkeypressed then goto continue;
-{#end}
- fillchar(colors,768,0);
- set256colors(colors);
-                                        { <-- wait here !!!!!}
- loadscreen('data\intro5.vga',@screen);
- fadein;
- while fastkeypressed do readkey;
-{FINAL********************************************************************}
-continue:
- stopmod;
- dispose(landform);
- dispose(planet);
- if fastkeypressed then
-  begin
-   while fastkeypressed do readkey;
-   fillchar(colors,768,0);
-   set256colors(colors);
-   loadscreen('data\intro5.vga',@screen);
-   fadein;
-  end;
- mouseshow;
-end;
-
-procedure checkparams;
-begin
- if (paramstr(1)<>'/showseed') then
-  begin
-   closegraph;
-   writeln('Do not run this program separately.  Please run IS.EXE.');
-   halt(4);
-  end;
- if (paramstr(2)='/done') then
-  begin
-   fillchar(colors,768,0);
-   set256colors(colors);
-   loadscreen('data\intro5.vga',@screen);
-   fadein;
-   mouseshow;
-   mainloop;
-  end
- else if paramcount=10 then
-  begin
-   textmode(co80);
-   writeln(#13+#10+id);
-   halt(0);
-  end
- else
-  begin
-   runintro;
-   mainloop;
-  end;
-end;
-
-begin
- initializemod;
- readygraph;
- tslice:=15;
- checkparams;
- closegraph;
- halt(code);
-end.
-
-
-{asega = andy sega}
-{homebase = me, beta}
-{apeiron = me, beta with music }
\ No newline at end of file
diff --git a/makedata/intro2.cpr b/makedata/intro2.cpr
deleted file mode 100644
index 30a0540..0000000
Binary files a/makedata/intro2.cpr and /dev/null differ
diff --git a/makedata/intro2.pal b/makedata/intro2.pal
deleted file mode 100644
index 813692e..0000000
Binary files a/makedata/intro2.pal and /dev/null differ
diff --git a/makedata/intro3.cpr b/makedata/intro3.cpr
deleted file mode 100644
index a64c5ee..0000000
Binary files a/makedata/intro3.cpr and /dev/null differ
diff --git a/makedata/intro5.cpr b/makedata/intro5.cpr
deleted file mode 100644
index 626c964..0000000
Binary files a/makedata/intro5.cpr and /dev/null differ
diff --git a/makedata/ironplot.txt b/makedata/ironplot.txt
deleted file mode 100644
index b5da573..0000000
--- a/makedata/ironplot.txt
+++ /dev/null
@@ -1,353 +0,0 @@
-OH, MY GOD.....IT'S FULL OF STARS!!!!
-
-Psychometrist is not online.
-You must scavenge a part from the ship on the first planet
-Disassemble first part... one of those three you need to fix the
-psychometrist.  From those parts you also find a part which, when
-researched, will provide you data on the Sengzhac...(mention that they are
-hostile?)  The third item will give you the star map, making the Sector
-Codex usable.
-
-After (X) systems visted or after a certain item is built you encounter the
-Sengzhac.  Speak w/them and they will invariably become enraged (but not
-before revealing essential plot points ..perhaps coordinates)  they will
-probably defeat you easily...board you ship, and not finding any flesh, they
-will leave...thus you can wake up after they are gone and continue...maybe
-with a few components missing.
-
-after meeting the sengzhac, you pick up the transponder beacon of a satellite.
-You find a satellite orbiting a world (it's a buoy left by the other ship..
-it tells you of an abnormal reading they recorded passing by a nearby system
-It is a place in an asteroid field where there is a weakening (actually a
-type of trojan point) in the diminsional continueum.
-
-Contact Void Dwellers.  They offer to sell information. they give you names of
-a few of the major races, so that you can ask the other races about them.
-Vague and ambiguous.  right after you finish meeting with them, your security
-officer writes a program to hide parts of your ship's log from the void
-dwellers scans.
-
-you encounter the Phaedor Moch..."puppet masters"  they are ventriloquists
-<insanity....madness...all is madness (include references to the God's
-Eye...blind vision...vision..)> you are exploring a planet that the void 
-dwellers point you to (it is a rich system...maybe you can find a probot or
-some other tech there), and the Moch's ship just starts attacking you.  
-They have no communications and are very damaged.  they keep attacking you
-(they think that you are the D'pahk who had attacked them before they
-phased out of the system to where you are now.)  You have to shoot them
-down...they crash on a planet, and you send down a bot to communicate. 
-They tell you location of D'pahk...you help them fix their ship <they will
-need two base elements, coolants and radioactives to repair themselves> they
-carefully try to avoid giving you info on their phase drive, but they are
-to insane to keep from mentioning it ) you are given a small panel with some
-writing on it by the once dominant puppet...the panel will eventually lead
-you to their home planet.
-
-encounter D'pahk where Moch told you..they
-take the whole of your ship...<they are massive ships>
-into theirs.  they take you to their homeworld... where they keep 
-speaking of the sun? <it turns out that the sun is the magma>
-<they speak of a shielded world..vague
-references to location...is it habitable?>
-
-you can't get near the world to scan it... shielded.
-you find a device on a planet in the system which you will need to bring the
-shield down.
-
-<hallifax manuever>...you encounter a race performing military manuevers...
-they say it has some major significance.  it involves killing each other
-for no aparrent reason... they don't want to do it... but they have to.
-they ask for your help<weird>
-
-meet the Scavengers...<simple form>...simple communications ..could end in
-battle...<easily destroyed this time>
-
-Meet the Quai pa'loi
-they require lots of (data boards?)... it must be tech.. they require
-salvageable materials... they give you four things...
-one thing per small device
-1. coolants <10>
-2. solonoids <20>
-3. artifact that increases ship's hull points
-4. they give you the girl, Muriel <in stasis>
-
-Quai Pa'loi go to war over free trade with other races when you leave the
-system following the girl's retrieval.
-You discover this the next time you talk to the Quai pa'loi or the D'pahk.
-
-Two factions in war...Pai aloi are against free trade with the other
-races...the Q'ooul are in favor of continuing relations as they were.. The
-Q'ooul have fled their homeworld and set up a base in a nearby system.  The
-Q'ooul are too afraid to fight the disordered Pai Aloi without their secret
-weapon. The Q'ooul offer to give you some great tech on thier homeworld if you
-help them defeat the Pai aloi.  First they ask you to bring them a number of
-weird weapons <goolas> (they will not interface
-with your ship...they will turn out to be a type of goo launchers when
-you find them.  the goo will block up the weapons of the other ship.)
-They tell you to get them from the Guild...but the guild says they are out
-of them.  They send you to the Moch...the masters of all sorts of weird
-tech...unfortunately, you can't find the Moch. (they used the
-phase drive on their entire planet)
-
-To keep her alive out of stasis you'll require some items and things
-to build her interface...<more invented items>
-
-She tells you where her mother <Aria> is...
-
-Ermigen tell you about a trojan gate.  At the other end of it, you encounter
-Guild ships near a dead world... they are in mourning they won't tell you
-why. (destroyed them over an arguement about payment...the guild delivered
-a shipment of damaged goods.  The Yillers thought that they shouldn't have to
-pay for the goods becasue they were useless.  The guild wanted at least some
-payment for their travels expenses, and claim that the goods were in excellent
-shape when they picked them up.  The guild arms their weapons to scare the
-Yillers, but the Yillers don't give in.  A guild member with and itch finger
-accidentally (on purpose) destorys the planet...and you show up.  the void
-dwellers will tell you all about this when you ask about the yillers.)
-
-Return to Muriel's mother's system... enroute you are attacked by
-scavengers they keep attacking you if you continue moving toward the planet 
-she is at... if you continue long enough you will be over powered...
-once this happens you will be towed to a scavenger base...they take many
-useful items out of the ship...including the girl.  You awaken after the
-battle force has left the base.  There is only one scavenger ship left to
-guard the base.  After destroying it, you find that the door will only open
-for a scavenger...your probots can't get in, and you can blast it for fear
-of hurting Murial.  
-
-you escape and find Aria...she tells you that Murial is an android
-and tells you some about ancient earth and the reasons she left...how she
-invented the encoding process and built a very small ship to escape from an
-early lunar colony.  she tells you how she created the scavengers <it's all
-roundabout...you figure it out> and gives you a brain...
-
-integrate the brain and a probot and a desei conduit... the resulting thing
-can be used to rescue the girl.  Rescuing her will give you some
-information on a race... genetic material things like this ...they are
-called the Ylinthelixymn.  You tell Murial that it is too dangerous to have
-a lifeform aboard the ship...she offers to encode herself, but you insist
-that you should take her back to her mother.  She shuts you down and
-encodes herself against your will. 
-
-When your ship enters a certain area, your science officer picks up a
-distress signal from a ship. (make the area quite a few light years wide so
-that the player is certain to enter into it.)  The ship is the Aard, in
-disguise.  They have run out of fuel and ask you to spare some for them.
-After giving them fuel, they reveal themselves as shape shifters.  Your
-science officer afterward tells you that he can make you appear disguised
-as the Aard did and creates the Morph-talk program.
-
-You meet the Titarian... they tell you they see your future... your destiny
-look into the out of for the five....five of what?
-ask the Quai Pa'loi...
-
-Titarian tell you info on a race that worships them.  It is a
-small planet of religeous people.  They fall before you when they see the
-number of the Monks (a 7).  they ask you to consult the monks about something for
-them.  They give you coordinates to find them.  You get to coords and find
-a flashing billboard on the planet (maybe a cambot shot) saying "Welcome to
-...., Home of the Monks...(on another sign tacked underneath the larger
-one) Due to space limitations and two much traffic, we have been forced to
-move to a quieter location.  LEAVE US ALONE!!!"
-
-The Ermigen tell you of how distressed they are the 
-Quai have destroyed themselves... they tell you they feel responsible.
-not unlike the distress felt by the Guild... after this they say no more
-
-The D'pahk will then tell you who the Guild destroyed... and suggest a 
-way to help. Ylinthlixymn.
-
-When you go to the Guild you have the option to give them this genetic
-material.  They become delighted and give you alot of cool stuff including
-a large stasis field generator.
-
-Titerians tell you they have "seen" you find a derilict...inbetween stars...
-and give you its coords.  It has info...
-something about shields(false info planted by the sengzhac)...and an item
-(artifact giving you thermoplast technology) you find there...
-
-Guild sends you to the Icon...to answer all of you quesions about the
-universe.  they are not helpful.. they are unintelligable... no sound..
-just a symbol cypher on the comscrn.
-
-Develop radiation shielding... 
-
-The system where the Titerians predicted a bright spot goes nova while you
-are there... it happens when the planet you are orbiting is in the darkest
-phase and as a result the explosion does not destroy you...but damages you
-muchly!!
-the resulting dead star is another Trojan point...
-and following the destruction you have another vision <death is the life...
-seek vision in death>
-you find a moon where there should be planet...large planetoid that
-escaped the destruction its mother world suffered... lots of debris..
-artifacts? maybe something important...
-
-Next convo w/ the Void Dwellers tells you that they have seen through
-the eye...from the other side... seek out this eye... the eye sees life
-is life...
-
-<vision from the ****> "seek sight in iron"
-
-Develop thermal probe technology...
-
-while scanning a planet in a system, your detect a large explosion on the
-next plant.  science officer suggests you should investigate.
-You find ship buried in some planet with "shunt drive" intact
-someone in the crew says that "it isn't a phase drive...but it has 
-interesting properties..." let's plug it in...
- it doesn't work the first couple tries...
-1.  full power failure
-2. aux power failure
-3. engine damage...and a whale in the sky
-4. shunt to a random location...
-***captain...we've finally got this one to work... but we'll need some
-parts to fix it... I think it requires some kind of focus...it needs for
-energy faster.  suggest to ask guild about it.
-
-"Starhammers" mentioned by guild.... "Thermoprobes and shuntdrives"
-these devices when used on a star will shunt all space around the star
-to elsewhere...nullifying that system...
-it is suggested that if the Scavengers had a homeworld that you could shunt
-them thisway...and be rid of them...
-
-After finding shunt drive, you intercept a communication between the
-titerians saying that the home world of a powerful race <MalZatoir> was just
-destroyed by the scavengers...a signal bouy approaches your ship and asks
-for your presense at the Icon's homeworld.
-
-the icon tell you where to find the Phador Moch(they decipher the panel you
-stole from the Moch ship).  The Moch will give you the guns for the Q'ooul
-if you bring them lots of worthless junk. 
-
-icon tell you how the protectors of the Monks became lost with no point for
-existance after the Monks disappeared.  They were to practice the Hallifax
-Manuver until they were summoned to perform it to reawaken their masters at
-the appropriate time.  The time has now come.  If you take your shield
-lowering device to them and activate it, they will go to the shielded
-world, perform the maneuver, and then strategically position themselves
-around the system to protect it from lawyers, software pirates, and
-deadline screaming publishers.  They ask you to bring them the mobius device
-when you finish it.  "oh, you don't know what a mobius device is...oh, well
-wait a few more turns and you will have a vision about it."
-
-The Q'ooul take the guns and attack the homeworld, regaining it and winning
-the war.  they search for useful tech to reward you with, but can only find
-a multi-imager.
-
-A vision tells you about the "temple"... iron stones... gives you coords
-
-the void dwellers tell you where this pile of stones is...direct
-coordinates.
-
-you use a detonator to get into the temple...once inside it is made clear
-that the ironseed is the god's eye and that one of the races can tell you
-the location of it.  it tells you to use the mobius device
-at the god's eye...you also find an unknown artifact <the channeler>
-
-there is something that the titarian must give you that you must add to 
-the mobius device in order for it to crack the cypher on the God's Eye.
-
-As you leave the temple system, you are robbed of the shunt drive by
-Derraak, the pirate. (the guild have been telling you about how he has been
-stealing from their trading ships.  They tell you that he never attacks
-titerian ships, and they also tell you where his favorite system to hang
-out is...they tell you to avoid it at all cost and that you will never be
-able to find him...he is too good at hiding)  you ask the titerians about
-him.  they tell you that he hides in systems near large trade areas and
-waits for ships to drop into the system to scavenge for fuel.  He waits
-until the ship leaves the system, and all of the crew has gone back into
-stasis.  He then (using his small ship built only for massive
-accelerations) run up alongside the ship and boards.  Most ships systems
-are only programmed to wake the crew if another ship is in range with
-weapons or shields active.  This is why he is not detected when his ship
-nears the victim.  When he detects
-that the stasis field has been deactivated, he runs.  You must use the
-stasis generator to make him think you are in stasis, and have Murial
-program a probot to place a VLS on his ship while derraak is robbing you.
-You must have a VLS (very longrange signal) transmitter (coupled
-with some type of detonator) to use as a homeing device.  You go to his
-favorite system, engage the stasis field, and leave the system.  When he
-attacks you ship, you plant the homing device on him and use it to follow
-him at a distance to his home base (an asteroid in the middle of nowhere). 
-You detonate the homing device so that he can't run, and you raid his base,
-regaining the shunt drive.
-
-After shunt drive is repaired, you find out that your ship cannot provide
-enough energy to activate it properly...crew suggests that maybe you will
-find some other generator that will allow you to channel more energy into
-it. (of course, this never happens)
-
-The ermigen are destroyed by the scavengers...The Icon send you to search
-their home planet.  You find records of the final battle...how the Cargan
-(a powerful ermigen ship with a temporal anchor) was trying to lead the
-scavenger ships into the corona of the sun...they would melt, but the heat
-resistant hull of the Cargan would not be damaged...the sun's radiate
-distorted some navigational reading on the ship, and it accidentally hit
-the surface of the sun. The crash killed the entire crew, but the ship (and
-the temporal anchor) were left intact.  You can get the anchor with a
-thermoplast protected probot.
-
-After discovering thermoplast tech, you talk to the D'pahk they say they
-would give anything to approach
-the sun... flowing iron...the seed... ironseed...sunseed...
-you can give them a fitted thermoprobe...they give you a thaumaturge in
-return.  They will only give it to you after you defeat the scavengers,
-because they need it for their own protection while the scavengers are
-around.
-
-Using the multi-imager and the Morph-talk program, you go to the sengzhac
-homeworld (icons tell you where it is)  You tell them that you are a
-collective being trying to destroy an uprising among a few of your members
-who have escaped from the collective.  You need something more powerful to
-fight them with, because they have all the same tech you do (being from the
-same race, of course they would know all the same things.)  The sengzhac
-give you a doom gate.  You also learn a lot of history from the
-sengzhac...including what happened to the old human ship at the start of
-the game.
-
-You must ask the monks to reduce the number of sengzhac guarding the god's
-eye, there are just too many of them to defeat.  Rob sets the number of
-sengzhac to a manageable level, in exchange for getting to see the mobius
-device.  someone says, "Hey, what does this button do?"  The others yell,
-"NO!" as the screen goes blank.  Then a sigh comes up saying, "Channel 7 is
-experienceing technical difficulties...please stand by."  You send down a
-probot to get back the device, and then head for the eye.
-
-By this time the scavengers have become a serious nuisance.  It is discovered 
-that they have gained control of a trojan gate and now have it in their system
-It is feared that once they have deciphered the entrance codes and mastered
-the control system that they will merge with it.  
-How to destroy them: You must fight your way past their armada
-to the trojan gate.  at this point you must lob the shunt drive into it, and 
-after this is done... move forward into it as fast as possible.  Your terminus
-point will be the center of the star.  You'll get to watch the star dissolve 
-around you as it gets shunted elsewhen.  If you don't enter fast enough, 
-you get shunted along with the whole system.
-
-
-You defeat a large number of sengzhac's and finally get to approach the
-eye.  You activate the device but nothing happens (wait about a minute for
-the player to get mad and say "why didn't it work...aarg, they said it
-would work")...you go blank in a wave of power and recieve a final vision. 
-You are told to place the channeler from the temple in the device.  You
-have your engineer do it, and then activate the device again and watch the
-endgame.
-
-
-
-****reminders******
-
-Make sure to mention in log entry after 4th shunt installation to ask the
-guild about the shunt drive...
-
-Trojan points:
-        There exist points in space that have a gravitational potential         
-which is exactly zero.  Trojan points and center-of-mass points for massive        
-bodies are natural terminus points for shunt tunnels.  Instantaneous travel
-my be had via these devices.  Unfortunately, the majority of these devices
-have either been destroyed or have fallen into disrepair over the last
-100 millenia since their creation.
-
-locations: Scavenger home system. (and wherever else we decide)
-
diff --git a/makedata/itemhint.txt b/makedata/itemhint.txt
deleted file mode 100644
index 0b7cc73..0000000
--- a/makedata/itemhint.txt
+++ /dev/null
@@ -1,122 +0,0 @@
-    ITEM TO CREATE             PART #1             PART #2              PART#3 WORTH LEVELS            
------------------- ------------------- ------------------- ------------------- ----- ------------------
-Dirk                StrataMount         Ion Cache           Flux Lens             58   1  2  2  3  2  1
-Scimitar            Dirk                Solonoid            Ion Cache             98   1  2  3  4  3  2
-Broadsword          Scimitar            Scimitar            StrataMount          218   2  2  4  4  4  2
-Claymore            Broadsword          Steoplast           Plasm Inverter       271   3  2  4  5  4  3
-Blackjack           Solonoid            Flux Lens           Pulse Loom            58   2  2  4  3  3  2
-Whip                Blackjack           Ion Cache           Flux Lens             98   2  3  4  4  4  3
-Flail               Duct Battery        Duct Battery        Whip                 138   3  4  5  7  5  3
-Short Bow           Solonoid            Solonoid            Vac-Feeder            71   2  2  3  5  4  1
-Long Bow            Short Bow           Guidance Strut      Duct Battery         111   3  2  4  5  5  2
-Ballista            Long Bow            Heavy Ions          Magnetics            125   3  3  5  6  6  3
-Hvy. Ballista       Ballista            Liquid Gases        Polymers             139   4  4  6  7  7  3
-Arquebus            Hvy. Ballista       Esper Seeds         Torque Stanchion     192   5  4  7  8  8  4
-Tnglor Eggs         Biosynth            Steoplast           Cyberplasm            84   6  2  5  4  4  3
-Needlers            Pulse Loom          Magnetics           Short Bow             98   3  2  3  4  6  3
-Caltrops            Oxidants            Crystals            Masking Pod           45   2  3  5  5  6  3
-Gyroid Cannons      Solonoid            Ion Cache           Vac-Feeder            71   5  3  6  6  7  3
-Hive                Caltrops            Data Board          Magnetics             72   4  3  6  7  7  3
-Dopplegangers       Masking Pod         Masking Pod         Data Board            84   7  3  5  8  7  8
-Grav-Pulse Launcher Grav-Coupler        Flux Lens           Guidance Strut        71   7  6  6 10  9  7
-Ochre Embryons      Alien Compounds     Radioactives        Mulroid               32   6  3  5  5  6  6
-Ego Neurosynth      Polymers            Duct Battery        Esper Seeds           32   5  3  4  3  6  8
-Id Psychosynth      Ego Neurosynth      Esper Seeds         Duct Battery          59   7  4  4  5  7  9
-Syntax Immobilizers Id Psychosynth      Grav-Coupler        Esper Seeds           99  10  5  6  7  9 10
-Cyrexin Psychotrope Syntax Immobilizers Mulroid             Ceramics             126  13  6  9 10 11 11
-Foom Cannon         Radioactives        Radioactives        Grav-Coupler          45   4  6  7  7  9  4
-Light Raizor        Disei Conduit       Steoplast           Vac-Feeder            97   4  3  4  4  5  3
-Dual Raizor         Light Raizor        Light Raizor        Guidance Strut       216   5  5  5  5  6  4
-Gatling Raizor      Dual Raizor         Torque Stanchion    Data Board           282   3  9  6  6 10  4
-Electron Guerrloid  Magnetics           Masking Pod         Flux Lens             58   5 10  7  7  6  4
-Neutron Guerrloid   Magnetics           Magnetics           Electron Guerrloid    72   8 10  8  8  8  4
-Positron Guerrloid  Neutron Guerrloid   Coolants            Duct Battery          99  11 11 10  9 10  4
-Heavy Ion Guerrloid Positron Guerrloid  Guidance Strut      Ion Cache            139  13 11 13 11 12  5
-Hydra Pulse Array   Heavy Ion Guerrloid StrataMount         Disei Conduit        192  15 12 14 13 14  8
-Null Pulse Cannon   Masking Pod         Grav-Coupler        Dopplegangers        150  17 13 15 15 16 11
-Thynne Vortex       Cyrexin Psychotrope Dopplegangers       Disei Conduit        245  19 15 17 18 19 19
-Sling of David      Grav-Pulse Launcher Masking Pod         Torque Stanchion     150  10 15  8 12 11 12
-Death Weave         Thynne Vortex       ThermoPlast         Grav-Coupler         324  20 17 18 19 19 19
-Dogath Buoy         Esper Seeds         Esper Seeds         Caltrops              59   8  2  6  7  8 12
-Disruptor Cannon    Hydra Pulse Array   Dopplegangers       Liquid Gases         285   8  3 15 10  8  9
-Imbreth Leech       Mulroid             Protoplasm          Cyberplasm            45  10  4  7  9  6 12
-Guerrloid Grapple   Grav-Coupler        Ion Cache           Whip                 151  13 12  5  9 14  5
-Kyn-pox Ichor       Ochre Embryons      Proto-Nutrient      Medicants             59   7  4  6  7  8  8
-Corse Grenades      Oxidants            Oxidants            Caltrops              59   5  4  7  8  7  6
-Heavy Corse Grenade Caltrops            Conductants         Oxidants              59   6  4 10  9  8  8
-Doom Gate           Death Weave         Death Weave         Duct Battery         670  20 18 19 20 20 19
-PyroSnare           Dirk                Blackjack           ThermoPlast          164  18 16 14 17 18 19
-Thaumaturge         PyroSnare           Tnglor Eggs         Quarter Shields      312  20 17 19 18 19 19
-Shade Ward          Catapulse Battery   Dopplegangers       Pulse Loom           378   8 10 12 12 10 11
-Catapulse Battery   Arquebus            Electron Guerrloid  Plasm Inverter       272   6  9  9 10  9  6
-Shadow Kiss         Shade Ward          Kyn-pox Ichor       ThermoPlast          485   9 11 15 14 12 16
-Chain Flail         Whip                Plasm Inverter      Pulse Loom           138   4  5  6  8 10  6
-Philosopher's Stone Torus Shield        Masking Pod         Flux Lens            210  10 12 10 16 11 13
-Wolf Wand           Dopplegangers       Worthless Junk      Vac-Feeder           120   8  6  9  9 10 12
-Purgature           Bolt Glyph          Helical Field       Esper Seeds          209   8 12 12 13 14 15
-Bolt Glyph          Foom Cannon         StrataMount         Duct Battery          85   5 10 10 10 11 15
-Wrath of Shiva      Claymore            Torque Stanchion    Ion Cache            337  14 15 13 16 14 16
-Mobius Device       Temporal Anchor     Doom Gate           Thaumaturge         1830  20 20 20 20 20 20
-Reflective Hull     Steoplast           Steoplast           Polymers              73   1  1  3  3  3  1
-Quarter Shields     Solonoid            Solonoid            Plasm Inverter        60   2  1  5  5  5  1
-Binary Shield       Cyberplasm          Quarter Shields     Disei Conduit        115   2  2  7  7  7  2
-Torus Shield        Binary Shield       Duct Battery        Pulse Loom           157   2  3  9  9 10  2
-Helical Field       Quarter Shields     Flux Lens           Grav-Coupler         115   2  4  9 11 13  2
-Stasis Generator    Duct Battery        Duct Battery        Helical Field        157   3  4 10 13 16  3
-Null Stasis Array   Stasis Generator    Ego Neurosynth      Esper Seeds          200   3  5 11 15 19  3
-NeuroNull Array     Null Stasis Array   Ego Neurosynth      Disei Conduit        269   4  5 12 17 20 10
-Terminex Projection NeuroNull Array     Ion Cache           Mulroid              311   5  7 14 19 20 13
-Shift Distortion    Terminex Projection Esper Seeds         Dopplegangers        406   7  9 15 20 20 16
-Inertial Barrier    Shift Distortion    Stasis Generator    Metal Weave          587  11 13 17 20 20 19
-MultiPhase Inverter Inertial Barrier    Grav-Coupler        ThermoPlast          668  16 16 19 20 20 20
-Temporal Anchor     MultiPhase Inverter ThermoPlast         Cyrexin Psychotrope  844  20 20 20 20 20 20
-Probot              Data Board          Duct Battery        StrataMount           58   1  1  1  1  1  1
-Minebot             Probot              Cyberplasm          Masking Pod          111   3  1  2  3  2  3
-Manufactory         Minebot             Disei Conduit       Mulroid              164   1  2  1  2  3  1
-Fuel Nodules        Radioactives        Strange Particles   Heavy Element         15   1  1  1  1  1  1
-Reinforce Hull      Torque Stanchion    Metal Weave         Guidance Strut        84   2  2  2  2  2  2
-Increase Thrust     Dirk                Dirk                Pulse Loom           138   2  2  2  2  2  2
-Add Cargo Space     Guidance Strut      StrataMount         Torque Stanchion      84   2  2  2  2  2  2
-Install Gun Node    Stasis Generator    Stasis Generator    Thynne Vortex        563   4  4  4  4  4  4
-Mind Enhancers      Proto-Nutrient      Cyberplasm          Biosynth              71   1  1  1  1  1  1
-Solonoid            Magnetics           Coolants            Heavy Ions            18   1  1  1  1  1  1
-Data Board          Ceramics            Liquid Gases        Coolants              18   1  1  1  1  1  1
-CyberPlasm          Organics            Medicants           Electrolytes          18   3  1  2  3  2  3
-Disei Conduit       Flux Lens           Solvents            Electrolytes          31   3  1  2  3  3  3
-SteoPlast           Metal Weave         Heavy Ions          Polymers              31   2  1  2  2  2  2
-Flux Lens           Crystals            Magnetics           Polymers              18   2  1  3  2  2  2
-Metal Weave         Conductants         Radioactives        Ceramics              18   2  1  2  2  3  2
-Pulse Loom          Polymers            Alien Compounds     Radioactives          18   2  1  2  3  2  4
-Biosynth            Organics            Proto-Nutrient      Protoplasm            31   4  1  2  4  4  2
-Plasm Inverter      Crystals            Electrolytes        Alien Isotopes        18   3  1  3  2  1  2
-Grav-Coupler        Pulse Loom          Radioactives        Strange Particles     31   2  2  3  3  2  2
-Torque Stanchion    StrataMount         Guidance Strut      Ceramics              44   2  2  2  3  2  2
-Vac-Feeder          Heavy Ions          Oxidants            Solonoid              31   2  2  3  2  3  2
-Mulroid             Esper Seeds         Coolants            Alien Isotopes        18   4  1  1  3  1  4
-Proto-Nutrient      Protoplasm          Organics            Medicants             18   4  1  2  4  4  2
-Duct Battery        Conductants         Magnetics           Ceramics              18   2  1  3  2  2  1
-Masking Pod         Flux Lens           Crystals            Polymers              31   3  3  5  3  2  1
-Guidance Strut      Heavy Ions          Conductants         Magnetics             18   1  2  2  2  3  1
-StrataMount         Heavy Ions          Solvents            Magnetics             18   1  3  2  2  2  1
-Ion Cache           Polymers            Magnetics           Liquid Gases          18   3  2  3  3  3  2
-Protoplasm          Amino Acid          Carboxylic acid     Amine                  5   1  1  1  1  1  1
-Polymers            Alkene              Alkene              Industrial Chemical    5   1  1  1  1  1  1
-Crystals            Lensing Solid       Lensing Solid       Strong Acid            5   1  1  1  1  1  1
-Oxidants            Base                Transition Metal    Protic liquids         5   1  1  1  1  1  1
-Esper Seeds         Lensing Solid       Heavy Element       Industrial Chemical    5   1  1  1  1  1  1
-Heavy Ions          Transition Metal    Transition Metal    Strong Acid            5   1  1  1  1  1  1
-Coolants            Halogens/Noble Gas  Ether               Aldehydes/Ketone       5   1  1  1  1  1  1
-Solvents            Strong Acid         Strong Acid         Strong Acid            5   1  1  1  1  1  1
-Electrolytes        Base                Base                Strong Acid            5   1  1  1  1  1  1
-Organics            Amino Acid          Amino Acid          Amine                  5   1  1  1  1  1  1
-Alien Isotopes      Heavy Element       Transition Metal    Lensing Solid          5   1  1  1  1  1  1
-Conductants         Transition Metal    Alkyne              Halogens/Noble Gas     5   1  1  1  1  1  1
-Magnetics           Industrial Chemical Transition Metal    Heavy Element          5   1  1  1  1  1  1
-Radioactives        Heavy Element       Heavy Element       Industrial Chemical    5   1  1  1  1  1  1
-Liquid Gases        Halogens/Noble Gas  Halogens/Noble Gas  Aldehydes/Ketone       5   1  1  1  1  1  1
-Medicants           Amino Acid          Volatile compounds  Alkyne                 5   1  1  1  1  1  1
-Ceramics            Industrial Chemical Transition Metal    Lensing Solid          5   1  1  1  1  1  1
-Alien Compounds     Heavy Element       Heavy Element       Amino Acid             5   1  1  1  1  1  1
-Strange Particles   Heavy Element       Heavy Element       Transition Metal       5   1  1  1  1  1  1
-Worthless Junk      Worthless Junk      Worthless Junk      Worthless Junk         1   1  1  1  1  1  1
-ThermoPlast         Heavy Ions          Coolants            Steoplast             44   1  1  1  1  1  1
diff --git a/makedata/itemmake.pas b/makedata/itemmake.pas
index e1fff9e..16ad8e8 100644
--- a/makedata/itemmake.pas
+++ b/makedata/itemmake.pas
@@ -1,4 +1,20 @@
 program getiteminfostuff;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 type
  iteminfotype=
diff --git a/makedata/jeremy.cpr b/makedata/jeremy.cpr
deleted file mode 100644
index 81c46ec..0000000
Binary files a/makedata/jeremy.cpr and /dev/null differ
diff --git a/makedata/jeremy.pal b/makedata/jeremy.pal
deleted file mode 100644
index 445f56d..0000000
Binary files a/makedata/jeremy.pal and /dev/null differ
diff --git a/makedata/land0001.cpr b/makedata/land0001.cpr
deleted file mode 100644
index 0789ef9..0000000
--- a/makedata/land0001.cpr
+++ /dev/null
@@ -1,266 +0,0 @@
-RWMTT			
-
-
-
-
-
-TTT		
-
-
-T			
-
-
-	
-
-
-T		
-
-
-T	
-
-
-T	
-)
-TTT	6
-TTTT	8
-TTTTT	;
-TT 				=
-TT			=
-TT			?
-TT
-	C
-TT
-			G
-`TLTTT					G
-_TTTCTTTT
-	G
-PT
-T/ 8;;8;58	TT'	
-	I
-"T"TTTTTT
-T(B>;;58>>5TTTT	K
-"TTT
-TTT	TTTTTTT	TTTTT@>B>;;584:4.TT	N
-TTTTTTTTTTTTT	TTTTTTT	TTTTT
-   @>>8;;:4421
-TT
-			P
-TTTTT(T;@@@B;C;;;>5.T"
-	Q
-TTT	 BB@@5B>;;B;@>;;>=5::514		R
-TTT>@B  B;BB>5
-;;;B>8>B>>;;;2::=1
-
-	T
- TTT
-@>BBB @@;>;;;>52,;;88585;>@8B >;>@@;;;::8:1:58;		V
-TTTT	> @@B@@ B@>8>;>;@85>',,;>;;55888>;85B >;5;:851	@>@;;;855
-	
-	V
-TTT	;>;@B B B B@ ;;8>8@>>8585;88;8;@>;;>;;;>58242
->> @>82285	K
-	
-		TTTT	T				@>;;>>@   B@@@@B@B@>@;>8@>;}}}2;;;8@;@>;;>;88;555=4
-
- @8>@72142)	B
-	
-	!		
-	>;;;8@>>>@B  B@>>> @@@B@;;@8}8;588@@;@>>;58555/;54/.
-	  > 8;8=5544.11	:
-	
-	!
-	
->;;>@;>;@B@  B@ @ B@;@@@>B>B>@>>;@;@;>;B@58;8;;8515;2
-
- @>>B  C:=71..4.1	4
-	
-
-
- 	 		
-	
-;>BB@@  B@B B@B>>@B@@>8@>8;>> >@828;5.5154121
-
-B @>> AC:74.1.1'	+
-	
-)				
-z		
-@>;BB>@ @B @B @ @ B@@@@ B8>;>@@@@>2858,..541.	
-	@>;> B@>>@CCA5214..+)	
-	
-2	
-							
-;@>8> B@  B  @ @BB@@B B> BB@;B;>>;5252,822/1.
-%
-	@@@>>>  8?74.%)		
-			
-	
-;		}y			
-@@B @B>B;@B>   B@@>B  B  B@Bz8@@ ;88;585,//5,./...+
-	@>B>@B > @  CCA=
-
-+#	
-
-
-D		}}}y}55855	}		558;5@B;>@BB@B;>   B@B B@ B  @BBBBzu>;;>8272/),8,.)/+.+	:;8>?@ C=14.((
-)h		{{}}{@5885}}85;8855>>>@B  B @BB    B B> BB@BB@B>BB}}}>@@@87/,5+,/./5,,5.
-	
-	:;8>;@@;8  87?441
-((.g	@}}y}yy}w2885;558}z}z8;855;>@>@B B@B>   B @B @@BBB@@B}z}aay>;;>88522,+'+,),+85()
-(
-
-/58;> > C:A747141(
-
-'f		B||yy}{wyw,88;/,5>};>;>;;@@@{B B@>B>  B@ @ }B@B@B>B BB}}wwy>>;>;2;58)))'5))2,2+/		%(;5;;;B> C 588:C577(4111
-+
-
-&e		 }|}w}}},;//8,>>;R}8;@>>;>@B}ww@B  B@@>@BB@B>BB@ B  B}}|}@@>@}}}a}}`}}y|}B>;>;28;;,2(+,+
-(/&
-455:58;;:?CCA7>:AA85.17(
-
-.
-(d					a|{w}}}`}|{a{;88]5/5`]`>RR;;>@@@>;_|}y}yB@ @@@   | >@;> @B  >| |}  sx[@ {|}{{{}yy;8>;2@58/,)2')')145
-	)47548>7:ACCA7=AA11
-
-
-(	
-
-
-c					a}}y`|}B@{}}}w]/8}}pp]^>]>@;@B|@@;x}}}w{|@  BBB  @|a`@>v`BB@ BB}}ass8@@  }||},>;>>858@8,)()(%(,1++
-&
-
-.	744825=:C?A=::5?.7/+
-+.&(1((D					}|{a}y|}w{aB @}|}ay}|{{{[,}}{[]__]@>>;|{y @}{}}w|y> @@B@ BB|}|a@B@ B B|}  }5@@[s|}  }}|}|52;;/;@8;,2)2gg&(()+&
-
-(4>88:C>=:A?>5C2?:=471+1+
-
-1)	,<	4	}y
-		}}}}| y}{}}|@@}{{}}}]}yyw{__]>>`xyy}}` `}{{y|B} BRR>a@B}a|x`{>>@B @ }  } @@} 8/[[s[   }}{}}{{``852/5>;;;.),))''')&(+,
-
-&455:=;8:>:4:4=;7.4.
-()+%)	8	4/,		}|{		>		 |||}a|`}|}yy}}}@}}}}}}a|yy}a};8>>>_}{y }}|{w{||aa}a}|BRR>@|``^a|{v>x^@@@^B}}|}}}|>}| @55}|{|}{|}w8882585>;85,5.(2((&	)&.+|}w
-1
-.+5825  ;@;::=72=4+.
-(./(++()
-6	55&	}}}y}y
-		}}||wy}w||}y}|w`;CC|{}`}aw;>;;v{yyy|ww||{}y|}}a}y|{a`||R;`;a>a>``@B|`B^@||a}||}} }      a{ }|{`}}{`8;;55255vnpZ8/)2`}&/%,//}y|+(	77=>;88@;;=7::7=111:,&.4)+,,&	+	C?2(/		}ww}
-		}}}|w}}`{|}y||{|x^^[CC}v|}|}y}`t}5B8{y|}|y}`}}}|}{y}|}}yx@@@ __;aa;``>;>;;}`v`vv|`|}}v} }   @@ | ` }}}a``}|>;;52558,,spZp2}}y'%I),}{y|y(&1	1585>;587>;7854::2>12/41+11(+/+(/'					C=?@5)/),		}w{|
-	 }}`y}|w{a}}|y`xsusC}}{}yw}}}]]`>}}{y}{y|{}y}zv`|yyvz^;`_``;`a;>;|`}sv{x||yy`}} }B B@B } } | `}{{{a;8>852552,nnk(}}}aa{&&}}}{|{}|}
-7:28;4@>8;25>44:55:22:21+..+2,)//&
-$=>?@55,1///22|y{{}w{w>Bx}  {`C}{{{a}|}{^sq{aa{w}}yyw}y}vyvx}}y{{}v`|}C}}}y{vvv}`xx`^xx`^_{s_;`vv|`xy{v|s`|}} {`}@ @||}{}  a}a}|@_;_;;888552nqZ&}}}`}S}{y}}|{y}}{&4;=4;;=;88;;>:582>;1575.14.1+)7+//22&>;@>5/825,22/2/2/2}|}|y{}w	@@vvuuvv }|a}|{}{aa}{}aq}y}ayy`}}ww}{wvy`^{|}v{y{`a|C}{yv{v{x```v{ns|v|avvsvvxvyx}v}v|v{|}}|| @@|x `}}   }}a{}w}8_;s]58855,'5 }aZ}}}}}}y}yw}(/.:x2;2742:>5;:8:=14.4.,(./2//)(>?@>?5/258,2252/2/	|{||}w}wBxx>^^n}  }}|y|}}}}}q}|}{``{}}}|{}yy_]||}|}{yy}y{|xvv|{vyyv`|{vsskqqv]_]`q^v`s||}x}_|}{}}}{}}}|B`|}a| }y}`}q]m555,55)'}}}`|a}}{{}}{{}y}
-+/8;8?5=525:::;4=7/.7/.)252,2/,>??@A?74587858525852///} }ywww{| B}@xx^^n|}`}}yy}}y}|aa`vq}ay`}ww}}w}y_}}}{|yy|}vs|vqvvyy`v_qv_x`qq_`[v|`x|z|{}`}w}aw|B}B@}}}}}{}}y}nZqqnkm;2555'52582`}y}}w}y{{
-mm]5:5?8@;2;:;??7=;4=75//24++2;5,', C>??A?745772>5>>2;88/}{C} {}y{}| _]8]]vkkn}}}C}{}}}|}}Cy|}}nq}wy{}}}}}}|x{v`xvvvyyqvyxx_^vxx`_x`_`{{vy{|}x`z}}}}{|}}}y   @@B|   yw}annqqmmq_s]225552252}|}}||w|}}}w	&m[p47>}}8@8855=?22=:7;>8:/511+1/2//;;,222/CC?>C?>A?78578;>;>>>5;;585222/2|}{yy}}ww{z{`xxqnsskk}vx}Cnqn|}}|`}}}`qq}}}`||q}{}{`}`}|vyv`{vx^`vv`xvvqvyxu{s_x`xx|vvx}vs_x{x{ }{}|yy`@|@a}|| B}}|`{|`ankqqqnn]2825252,,)|}}}|w{y}}tw	mpp4;>||{5;;?2;:7:=;;:55//.7/582/>552'CC??C8A;?782?8;>@>;8>255/,25}|}}yy|w}w|}}}|{{v^^sssqqnnk|}||}CiZ  |}}yy}a}||{}w`}k}||{}`} |xvvy|xsx|`x;_zvqyvvx^`|x_x|``x}a|va} @y{|y}yy{{`|}x}}`x|@}@}}||{{ykniin_sk555/255)22)}}} y}}} }}
-',p[;}||}};258:58::=;@88855)+/'/588525;52&C>??C8A;>7=2?AA>8>@>8>8>;>5552/,{}}} y}w{yx}|||}q^[[ssuxs|}}x{k |}{{}}_}}}}ns{|{y}y{v{yyvax{_@aazv`||s{qvs_x|z`va}|^x|||vax`} }}}}|  w}}w||}}{`| B}  |}||m{{nknninqnnm85825',2/))5}}|}}}y&(pm[}}x}sx25>>2::;888;5B;88285+/,,.(5.888;>5;;888;8*>>?@8A;>7=2CAAA@C,/|}}}||}`|`}vxx^qn^nn}|}}zzu{{v}||}}`}{w|s`axCsnnnqs}}}{yy|vv|yy|vx``@ @`}xa@a|_xz`za}}qax|_`|aa}vxx @B}}}}|A}}wy }B^x `` | }}|v|||^gkqkqkkqq[[88,//'22k'Z') }}{yyt'Z'm2m}|}xxz5:52::;>>2;8;;252>85252225;5;@>@;85888;;52 >@@;;>=2CCAA@xxv{}}vv`{|x|vp[pnvqq}:}vx }a```{aCCsqq^qnvCvyyyvyvya}{{{a}a>@ {@{}v@a`aaaz}}a^xx_x`x}|}xv{}}}|} {yww`BB } {{ }}|{vx|a[innnkZnZs5[8,/88,85mkZ)n}|yywZ'2k}}|}z8558>>5585;;8;5888552)52/.25;8;@>>8>>88>8;>;5;C>C8;@>2Cq|vv{{y{|aaa_sqqq}}}v}}}:ss|ss|}|``|_^u^q^_x>zy|`{{v^v^}xz}a||  > }{}s@;@@ @}a}aaz}a}a}|}};v}|}|}y }}{} @  }w}B}}}|} }y|xvya}xmmiik[SZZq__5558;888m//)i2mi}C||)/,gZZ}v}}|z5>@`>8_]`>>;_`2;585;++2452555;;@;8;8;8;8C;>@8@88;CCC@x{{|y||yv{yvxx|avuvvsqn}xvxs{z}|s_CC  }}{``>_ >aa}||^xx^{}vavax}@  >@ } {}x{|>@}@ @a@;@z@} |}}|;x{}|a}}}| }}}|  }}}w B }}x|y|y_yvva|v__miqknkknZs]5888;855;/p5)k'mkk/,)/)''}}}z|}}}z5>`]]]v];^u;``;,5//44+5575>8;>>;85@;82;58@@@@888;>CC@@}yy{{vvss{yvxz`^svvvm^}}}xxusu}7}v}uu_;CC}@x@}|}a{||y{a^`yvv{|{|{v`| }B;@> {{||{{}} @@a@}}|@a@}}|}}}x{{v}}}}| A}}yywB }}x{|x|zx|}`}|vvyZkgknZkZn]8__;;88;5,5(igZZik').[,p}|}|us}sqv__s]q_qq_^^__k2/5/11557/>;;>>;>;8>;8;;>>8/;;8;>@>>8;>@@@@>>vv`yvvv|v{{zx_@a}>5vq^_|}}{xvqsxuvvssa;CCx}azv|sz}a}`y|z}`}_`|vyy}x{{}} ;@  }||}s{vs> @; @}@ @}}}v}}}v}{v|{|} |}{ AA}|yw}}|{{}}^xzyvax|x^zumZZgqgZZSsZ__;>B8;;8;855+ZpgSZ(S[np/[}|z}}qqav[sq_qmvs_^s,vmk55;),:4>5>;>5>8>88;8;>8/2;8;;>@;;>8>>>C@@@xqqq{{|{vvq`]`va@_5xxupp_^}11v{x}s^__xxvx^xvvv@| }|||`aa``}_v}yvaa;vB}>}@@}}:{:}x{> @;@@  {} |s}|}zz}}||| y}{ww}}wwy}|}}|y{vvxvvvx{_|^`x{sZ(Zguqkq[]8``_;8;888>88/imiiZk[in[ni}xx}sqsvsqss^qknq/k555)254;8>x;[558;;5588585,1C>;;@>>@CCvvqyy{vxusz}}^xx}}^uv;^^q}::}}}x^a}av`v{|   }z{|x{{x{}a|}}_}a}{v|u@}a }}xxx}}}x>>@>>@ @   }x{|{ {}|}{}{{y}w}wy}}{}vyvvqvvyvvs`xvvZZZ&gkkknnp]__8`888;;[m[,iiigZnn[[ikZvn25^}_{zsq^svvkqqsvvpikq,[82524;=;=8 @75;5>;>8;582;CC>@>@@@@@{ssvs{{sv{{|ss^q`v^u^s;;;}|}:}sx{`|xvvx|@ @}|};}|}aaa |>a`}}aav}a@; ` _};}}{}v >>xx };{vx{x{}}}}  }}}@}}|y|}}|}}}}yqv`vv`vv^sZkZ&SknqnZ^nsqq[;vq^s,+1)8igkkk[[SZivqivs;``8uxsxqnnqqpsnZ,//:,+22857=5>:5>>55;/225.	C@C@@@;;>>>@@>>@vvqqqvvvx{|xvvxsqssxua;;;u^>a}}}}xz`x`vvz }}`}|a|`>;;aa  a}a|{za}}x|@@ B@x}|x{xx|{}  `@`@@>{}{|x;}}}{{||}}}}|}}}y}{}vvvqvv`{}xvZk(&SgZqZZ[pkqns^sqqq2m1,kiZZknnpgnngqknisx;88;xxsvu_xsk_v[qZZ/'2//45;77=A4:p252/2/(+/,};;C@@>@:>>vyxx^v{vsnnvsqsvvszxuu^^ax__xxx|v^}||a}{}}}|}|{^a;a}} x{@}}a >>> >    > `}x||}x}}|}|a|` a} }}}|x||{|v{}}z@|}|}}}`|{{|}}}xx|vsvsqv|vyvvvqykZS
-gXZkk[pvnqqqssps,,ks+[)kknninppsiqnkgq;8>>|xuvu__sss^^[Zmknk/272[/p>7}C?477252,/,([,}C;CC;>@@@>::CCC?A>=yvx__qvy^^vyqqqsvqssqs>___x;^@@xz{{_za@|}}|`a`^|{}{`|} @@>@@ | @}|@}{:}}}:}}}|}|`||}`|};;}|xv|{v| {|}}}}y}|}{}{}{|y}vsvqsvvvx_vqvqkkSi
-kgXnnnqqqnqqnqn,ppmm',)Siikqg[[psqkqZi;||B@sx^___[s^uuZmZm+//5?m,p?:=?CC45).2)ImZ`CC@>>@>8;C?AAA?xx`__vxa|qqvsqvvvq}x^^x^_{{@}zz}@@@vz}|ax`|a@    ;}  @@@ @   @ ||x| `}}{}{x:}sv}|}``x||}|>;;;}x|}}{x }}}}y}y}|{{x}  ssqqqvxysqvvuZkZ
-
-mXq^xkmuqmvnqnqpp/)Z,)ikkingZknZgqnZin;xa`a^aaa_]Zmuuupmkk,254,=:C454/1.5.2&)CC>>@@@@?=ACA??C}sx__|v{ssvss||s]v^^a;>^^>@@aaazazaaa@@ x@  a| @@  @ ;  @   >@ @|`  @ @ @55}|}}}aB}}}|}|;}}v}}}s}x B }}{}}}|y}}{}}|}x}}}}sqyxv]us[qiZk
-gmsxqkm[[nq[sqp,2/)p(),[igZkinnSZnskZS|@ @a_;za_]2kZ]m+'2,?m]}ACC4552+55
-&(C@CCa>@@`@=:CACC__x_vsv__[_]u^]8^@}>;>  @@a@@@}@aa@ A @   @@@@ @ @ @@@ @@ @   @ 55   a}`a@ B@@}|}}  sss }}}}{|{vy|}z`x`|{x} |}>qqnxx{]vu[qmkZZSgS_qss[[[][ss,n,14m('p)[i&ikZZZkinmkngia;}}^a_]]]/)m]Z4,+pp,?AC14+/[5(&&C}|}`aa@a@@a=7:ssv``{qqssaaa_>^^;x_@@?@  }}vv@>   @@@ >@>@  @@@  >`@   @  @@ a}_@A  55 @ }a` @@@}}{;}}}|}v{v  }|y|{y{a`xa|}v|x} }}>C u_qqn{sqvqqqZkZk/g[mqkmmp[]pvsmn.14,1
-(ZZi'&ZSZZiZnkmmniS_z}_xp[m/))):]Z'+)/p77AA:5:4+7+)	
-@|}|a}@@}}=?77q}az|assua@;;^x__;x>   >@}@@}vy > @@ >>>    @@   @@ @  `@@ a}`_> >  aaa@ @}}}{|};{{v{xv}}}{|{} |y|}||{yy|{|||{>B}^_qqs^msqspnnnZXkZsmmmq[[pv[51.[,,1('&g'(&kZSkkknZ,nZ,IS>__pp[m/14(+((:_[ACu1)[
-+@C}a}@@@`@?=7?7;a@;;susss>8;;;x@@@ }xyvy|@@ |@ >>>;>>>      ;   @  _|`_|aa}>_      @ } ` }}|}|}{;;}x}}}}|a{}}||}v{{}a{{ u^s^2nZsqqpqsmZ)HS[mm^q[[_s211n,1pm+
-(:
-&gmZksikZZmqq,)(;Aa`a[];}{g+4&5?7}AC=:1.+
-
-@@C}}aaa}a`a`@:74C@?>;;>> [;@>>>;8@  >>   @ @@}}}xvv}va> @@>@;    @  @;;@@@ _``_` }B@@ |    @{|}}x55}{a|}}|}}|}{{}}}y||v|}}z`| 5;2sqqnqnknpmn)&XgSsn[sm__@1sp,,pm++&+(4Zinnikkmmmqq'k&:@`_4_)+}|}}|4
-(C7441//+
-@a}}a}@}aaAz@z:CC>>>;;>>;>;8;@@@>@@AA @}|:}{}{   @ @ @@@>@@ @> @@ @ `  ` `||B   }|      55}}| @}|x}|}a|}{{}}|{z{  B 5;48s;qqnnkq_[k,Sp[Z]m]__1,,2,,p+++1+44.&mk,/k,Zp[[Z,(&@a>1.z}{}zv}
-444:55&&	}}a};@@}=A:=zzu:C@  @ >@@>>;;;AAA  @@@ @ {|xvx{}> `  @  @ @@>   @@>   a`@`|aaa  @>    ||}|}| @|55a} }}||}}|||a`|{{yy{`}{zz|`{|{B >C A;qq;uuZn[Z_Z.gk[]_]__12,2/spm+mZ1447.14)'/mkknpn/,m'a884?,}}}x(g155
-
-`@}}a;|}=A:=|C @>@@?@>>>;;;@ @@@@@> }{}2}xvvvx}@}{vv@@@>@@  @}@ >     @aa |}a@` @@ @   |} @ _   @a55}}|}{}}}``}|}{||a@x{}|B >a>A;2x;q;;/u[nnk,Z]%kSm[___521/5.5./Z+m
-.2/7.1(+)m,];_/,+ZI5?=5.7,}xuxx
-
-41515
-(	@}aa||==x:=@@ @@>@;;@>>;>^``@@>> @ >@@y{||}}}v}{v}y|yv> B @@ @@@  @@|   a}| @@>  @>@ |a| a@||a_|}B || } }a|}|}|}yyvxx`@ B||}`} `5@ss;;;_pnq]_],[',u__522/4.5./m(m(.27.1
-+55,ns//,.,)%8;1;1}|x}v}
-]p1;
-	}aa@=A=za=@ @>>>?>;;>@>>>`@@@ @  @}y{{x}y}}{}yy{y|||{vv|y>B@>@}@ @@|   @@ @>@@@ a`|@ a|`|}`aa|}}}}@a}||}}}{v{{| |}}}@aa  |@;>[sss[;;;__p_;__Z'u;]811714=1/111m
-771(755/8,;:_+)mg84=1}}}zv{u}}.
-]mp14'1C}}a@C?aa5A=|a@@@a__>>@@[>>>^```_  @>>@`}vq|}{y{|}}{{y{v|@B@B @  @  }|||B@B  @@@ @  ||_`}|}}||a|}   @}}}}|}{}x|{}a| }  } |>>uss[qs;8__;_;_8;;5]+..72/;12;5]mm58471::58;88./,+&555}}x}{.++7744p/.42
-	CC@@CA=>5x=|@>>^@>>@_>>>_``__   @@_@@ @}}vx}}}{}<y}{{}}{B>BBBR` @}@B} B@   @>    |} _`|}|a`a@|@     {}|}{|}}|{ |} {|aaB@B @>5_xsss^[q;;s;q;;_828_.2/11>;558@:77445=;8,88/8.)%5;}z}|{xx}{{|7./,42'
-%CC	@=CA:5A>^^^_``_>_@@>_^^@ >>@^__}}}xv}}|}vxyy}{}} }|B>@  _ |>>@@    @     @ @>@ ||aa`}}  {{{}{{}}@|| @ |aa   @A@}}zsx_xssxs=8;;?@;;  a8A@;>>/:7:47:4:57;5=88581.)S}{z}}}u{414.xps..m	CCC@C>=>A::@>;; >>@;>> @@_ @@^@@ };}{8}y}{{}{y{v}|{y{aa>B  B|Ra>@@ @    @ @|| }a@}}    B}}|}| B|B } xz@@ > @}`a__`x__ax@ a@  _@A?>5>?274=4=:=47:8p/888,,[mm}}}{}}}|xvs}
-:]m[p(
->a>@=>C::x;>;  >@@@;@>>>@>> @@>@@ @ } 44>a@@|}}{|}vwvv|}v{aB@BBB} BRPP@ B@ @@   }|   aaa a } }  } |@>@ @  >} x @@@ >;Aa`@``a`x`x}@@a||@=?5>@[[74474:7um7:5588[88;:,pk}=}|z}}{
-=:?=.4,
->C@	Caa@>@?>C?z>>`P``>>>^@@@ @@@ ^^_ @@@BB;44BaQa_y}{vyv{ywv|v}}v@@@B||avPPv | @BAB@}|}a|}`}BB B} @   }   >C > B   A|@@>;>B}|``aa}}xa}@    =@/1788141+51=u_mm;;:8;>s;;;,p,m.}:}}{}}(:p/=7p,+
-	@C@CC@@@>8?=?___`PP;;BBB@``@@@;@@@> |`44_ra_{{}|v|{{{yvv}v}}v` ya|t`  }@ @B  @B}}a|a``      @   @   B @ |    @@>a@>> xaa`     C>81772n+5:::_285;>>@> @ ;;(..:.?7=4:,
-+(@CC>@>@8;=v___|PP>@@a@@@ @@@a;;@@@||ttaoo{r}|}yy{}yyvtv{}{xvx} {{|{y{}aa@@B>>@ @}   |}`|   } BB      @ ?@ @a @@|}}a B       CCA24724.=:;85_85@;;@@> @   A5;8::>
-??47.[+,	>CC>>;a___`__`BBB@ @@   @aBB;``>BBBy``|tttr}}|}}{}v}}vx{{|w|Ry{a||} @B >@|}|@  |}| 
-@R }B   @   @  >>>    `>}@ @||@` >B  }ACCA/.572218;?[_A8;;=@  @ 7==88;;5>8;
-=4774+4++
-CCAC>>8P_``PPaa@;; @  @BB a__`aa_P^^_``lw\r}{|}|}{y||v}}}{vyyww{{taB|}@  B }}`B }Q aa    @  B   @@@   @ @ `|> a @B @@@ BB} |}|ACCA.572211:?===>>; ; @@@|7=85A:;=:n]+C:?14Z[m+ZCCC>=1^^aaa`||aB@@ @@B@||a``R__`|__tll_^^o}}}}}{{yyvyyv}}}y}|w|{voaa}| }B ` } ``{Q |     }B  B@B @   @B B@ @  }@  }B >B } |a`|}  A CC>B24,4[.=??==C>5A;@ A|57A85457=kkn[	u2[p+&+CCC`CC1:__a`QQa|| BB@|BaBaa_^^`_aa`oo\oorttr{|{{}}|}}v}|{yv{}}yw|w`QtaaR  |}|a} BB@ }  B } R|} @|| @@    @@B  B  a>B@  B `` @`` B @  || B@@C   4/4.n?=?85?C=5A_@?>7?A=;4[7_1;,[m.(75/Z+Z
-@`;;7?a___aaa||@|`y\RRa`\\`tta``tttroorttrr}{}}}9}y|vtvtyyywawQywv`R aBRB | y@P>|@ a}a   |}}{}}  ||a@@ }   @@   @@   }vav}Bv^`  |a}    B@    4?C@::C_`]aA]?7?:=?;[7;1;2ppm.+::51C@8;41171
-`[[___`BaaPaa`ttt}twwnnoootoottwrt|ll}}{vv{ytwtaytta}R`|RBB   }{P||y  |a}a}}{} B  BB| aa|B@ a>  @ | @> @   }>B{B _`^`  }|    BBBB    ?C2::Ca`]A7=7A::?:47;4[2[p4:p1m
-@C]8444	`_^``___`aoot\\wttPllrootrrryjjollt}|}v{vt|t{wtw|{vta|B  a@P}B{y{| }   }R{} B@  ``{B ;B@@@{@B; ? @>   @ @>@ _>a` B@ a  @B    >2: C__A7=AA::[_[4_[m41
-475742	CC`@@CCC7:4^_``_a___``_|`rw`wt{w^yy\ttlootw{O{yw^lllyot}}}{y}}}{R}{wyw|`rva{v|}a@RB {{{   | |}a   @@B  }B}`vv` B B@ @}>; ?B>>@ @>@}@`>a}} @ B  ;; C>7:A:A??_[p[]_7m1.=142/15
-Ca@@CC[/7aaQa|`__^vv___rwtt`ytyy_\vt\ootrrttwO^lttrrv}{{}wy{y}yRt|wa{|Rryt{wyv}QQB}a{     B|a|   @B|B@BB} ^y`@  @> B>}}{B@B @>@}@a@a> {a `_a|B}@ B  }CCC>:::A_?}]][[p71.C;241.
-av@C@A72171__^aaQ`ttr__`rrQrrwttorr`ttrt\yrt{}}{r{}{}|}y}|{{vv||{ta_Py|{{yt|}|vtBaQ|}}}|  | |}B  B}@ BBB} B}`^v`^t@| R||>B{}}@ @@@@@B@@aBa| >>{}}|Q }   B} BCCA=|]A_a}];::.}`v`C;@1:71/7:/`__[Qa_ttl__to{ttrrlrrorrrtt}|}y}v}}{{}vyyy`ar_|y{{yta}`tyva{`{yy} @ }|} B  BB@BBB |||}B|}yQ|yvt|QQ>B@| RBPB@a>}BBBB B@a|}RB>}}@Q` B}} BCA|@}ua:74+
-
-a`v`a`5=258/2/pt_OaaQ_\\ryowQtttrtywtotottrr|{}{}}}{}{{|v{}v}xva`rt{{yy{ywt_wytw|_{}  | @ }    }`{ }|  |} } B}yQQ{yy}B_|_R|BP|a O`@a |;@B@`}|RQ|aay}B@ @B
- } B}> }.:7:+(
-
-	tv`};57:=227;k/1.22twooroo\ttoo{o`QRrrtt{rrrt\wttr|}}|}|{}}yv|}{{vxvtt{y|{{w{tytvyy}{BBBB }@|B  ya|BB>  }{||}w}R}}}|avtQ|`||Q_`Qaa`||_ O a`Oaa@@}{||va}y{|v|}@aa`R|}
- a}} . 7/27(
-
-tvaa;A5=7=722;5:p)7{yoovtt\\\ottP{w`rrtytroottrtt}|}y}|yyv}}}|{{v{yt{}y{ty`tyy|{  }|B|@|}}||}a} QBB | v|a}wR }}a|`wyQ^``Q`{```_`aRa|a|a OPa a}r`tw`{v|yv}y{R }B}    a}`C?} 7/2:4
-
-
-^@P]Aa=5?778;51).1
-tt\tta{{loowwwtrttPaatrrP}}}yvyvv|vy{yy{R{{wwry}} }} } ` }`a || }B }{  {QRR{}}ywyyw||vv}{ay_{yQwt{}| |a_^``|Qa_Bv|QP}ya |wrw|wRtw{{yQQ ||a   B}} R}|aQC: @A
-:44
-P`C`==@A[]_]]p74/mCC	\\tttorrorrwttrovtt{ttrw}{{}|v}yt{{|}x{tw{wtyt{}  B  `}{B a||}B  {R|BBy||w|wr}{yyy}`v|aQ_aa||wy|Q |a_``||^_o\t|||y|yyR}RtR|Rw{|tyvy}ay|B }}}a| _|R :A AC(CCA:/41S`}C}CC@;C==>p2/2//m,1A	^^wtttollwwt{rrttottt|trrto\rvv9w}}}wvy}{vv{y{}}}y}ywtwy||y}}||}|}B }|P ||}||} |{ { R RRB}}Ra{R|t|{|w}|w}{y`y^`|}a`w|a||``a|a``t_r|`ywrroRwwrw|`ra|aaywRy|}B} }}__`QR @A;@7.4A CA4I@}}C:;/][/11Awwtrootrrtttllwr{yyrt}||}{}vy|y{ty}y}vw{yya| a }  By{Q  }  }}}|}} }R`R|{ yR  wRwvw{}wy{wywa`t^`|a}}}_aaa`|``a}_`|`a_ttwworrQtwvyraQRatv`yt} |`}}{__`|}R  @ ;C777.427CAACA=1
-	C}CC?/]]/,1,.m1tytrwllyy\rwttnry|QOrtwrttwyy{yw}}ty|wtvy}}|xy}||{rya|aa{ |`a{|w{}a`|}{}}||}y}R|B}|R a{}}|tyaa||ywy{r{tyo|{ytw|a|`a|Pa`` aP`}_yartrtwrrwy{wwryw{{}}}tw}  |`| }}}|yt`|}|  AC=@:777.=?AAC CA;8=::272
-.@C@C?CC[^M)1ttvvtrrlltol\wotry{tQtt^wwOOtvvy}y}|}y{ww}|x|{{}|twyayw{{| }B|w |`|w`{}{}|}{}R{y||y||}{ |v|yww{y||yw{||}t{a`^P^``^`| ``}|r|_tyrtyr^_ywt`twt_}y|}y|} }R} } R|P_a| |` }AAC=@=::77:441.4=AA?C  CA;@;_::272
-
-
-	CCCC8;[M8
-rt_rltroonnnrt|OPtttPwrOQOywtty`}}{}}y{}{}vyyvvyQ}|B|w|| }{ tt}}|y{}wy}yy{wwy}}||a|wyw|wtt|w}{|}}w`P^|_`|a_|``|tr__Qr^ryrtyrtr_}w}tyy R|}}}_|P_a` a`}}BCB@=::77::4411.(47AA?CC  C v5_:m17.
-%CCC:=;22++wr_rrttvrrool\rv_OyOOtrPttP^www{__`R`^}y}}|}|{{|{{|vv{|v{v}vvyyy|{a|{{}| |w{}{}|}}y{ytwB_aaBa  `|y}R`Rrwwyyya}a``_```Q}__`_R|``|wo[t}yowtyywwt{y}}}a}y  {R|R }R}_|a_a}ay}} QBA=:=77:::4411m4=A:?CCC  };]`tm4741(C8=];72+Z	rr`rlooryow|POQrrPtwtytwyt_Q_R`y|wy|}}}{|{{|}{{y||yy}vvvyy|ty{{av}y|||} By}}{|yyP}|_aR}a}ywywwR{Bt}Q{ yyt{yR`|a`Qaw^_`___`aw{wN`{}|ytwrtrwotyy{{wty}y } {}}a a|_xa|`}w}w}}Qa=A==?=77::]441.11(=::]}CC C  };]`2N4[41	CCA^M[/:.2k'
-.1
-ttytorNNrtollwtv|rtytrtwtQ_ryyR`}|w |B{}y}vvv{vvy{{{yw||}{{w}{| {w{yt}|{ww|  }www{ytwyt|{w} _`Q_`^aya`w|war`ato`atorN`awyyrryrtro{{y{|t{}}}}}y}}{} | a^_xQ|R|}|}wy}|zZA:=:?=77:_]/[1.111+_:@]}CC   C   @;aQ`zOnq4
-
-	(@CC[[2425kk(.
-oww\llNOtoroorttortr{t{o\\`Rryy|`|{ |R|{{y{}}v}}y}vvyvy}w{|yy}{}Q |B{|y{y}B|{a^Q  ||tywtyywrwyw{|wyQywt_`aywotrrtywrttoolr_yy|warytr|tt }yyP{y}} y{}  a||aR^_ QB a }ay}^zmA:=?:?=7:__]/[1.1mmmpSS:[;aCC   C   |;]_;]O`Mqn,+m
-		%@CCC[2525+,&'orrt}|}vvv}vvvrrrttoorttO`o\r[_y_| |}{BR|}y{{yt{}|}|}v{yy|v}yvvvwR }yRyR}}Ry{{taRR }``{} {{{t{wwyy{ry{wy{ytrtwtryt{|tw{w|{lwrltlltyytttwrPwttNQ |}`Pwyw  }} }|RBR`P } }a |a|a^z_Z:_??_:?=7:__pm[[].mmmpIg';_@} }      Q|a]_;s_uM^,Z.+
-
-
-			CCC@A[/q55S1
-@CCCor}}{yvvvy||vv{{v}vttrt`Q^l\\tt{|}|a}{Ry}}y{|t{}}}|}yvy}yy}}v |yRa|}}|{}yw{||w}|{}}|}w|tw|wyy{y{rywwowwrwtr`wr{tr`ow`trtow{ytrrtowyorN} |}`|wty}}}  }y{} } aPB_`Py}y }} ||`a^__ZZ_?>A_:A=7:_;pm[[],1,mmp((ZgS_@B } |vv}}Oa_^^s_O^^5\/+
-
-		A[/q5;OZ'ACC}	or}y}{|}v{vyyv}vvyt`[{\rwttww|a|}{y}}{{{y}|y{v{y}||}}v|}v{{}{vyy|{`ay}|}|y|}w} }|ww{{|{}wywrwttww|{||wrrwowtoyrwlrytty|}}y{{rowr{trytorr{rool}}`R{|{}Ba} }  }|w{y|{}}  `aP||v{|y}vy}||_`a`__yZ_C>A_AA=77=;pm[[],Z,pmm(
-ZgS&IBB    }}yy}{{_a^[[]_N]5mZ/.1(
-CAA]nq;]Z'
-ACC}	r}|}}{v{}vyv{|rty\o{w{|R}}{y{{{y{y}|yyv{}}{{vv{v}|yr}{|_w|wywa|}|yyy}|t}y{wyytt|{|twwrorry{totywt}yy|{}}}{yyOrtow`rorol|` ||{}B} { }}}}|w{t}}  `a}}}|vvv}tv{B|_^`|wwwZ=C>]=A=_]5=;;mm[p,Z,pmm(+&gSgf}}vy}}aao[vt]>m//1p
-&&	
-	CCA]nqq]rkg??CCC}}{}}yy}|yvvv}{vvv|}{vxyPPRR}{|yw|{yy|}{|}}}|}}}{}vyvyv{yyvy|y{{y{yRv{{{w|}|yy{|twwyyw|y{|wy{}|{trro{oroor{ro}{}}y}{vyv}}|}xOtttr`yrrtro` R|y|{}}}}yy}{}}|}||wy{|yy}|||vvyv^v|aww{ZC;]=A;_]5];;m_Zpm,,,mm('+'&(Z
-gg'}|}v|y|v^\a\]8p2/11s&.Z
-&
-CA=C[n\`nk'(?>A}}}9{{xxv|{{xxv}}{x{|vx}}{{}{ty{|{t{ywy{}||}}}}}{vv}vy{y|y{yywaR{y {{|}{{Q`Ry{ww_|y{{y|}y{|Rttotwrrr}}y{vx{}v}|v}voytryyttwrl`yR{y{|}} } }}{{yy|{{|}}yy{yvy}{}}|v}yt{yvyvy|r{wC;]=>;_]5];;m_[pm,Zmmpp'+++&'Z')I}}yvyv|y}y^tn_t_721/pn1
-.'(&
-CC@Cq\nklh(>ACCx|{y}{{{xy|{xvx}vvx|{}|}|v{|x{vv{ww}rw{y{y{wyw{||{yvt{<<}{|vy||y{{y}{||w|twa{{|{}}}|||twywyy|`|wyRR|twrwrr}
-}{}|||{{y{vyvvrwottwrrywy{{||}|}R|}}w|{y}{{|}}{w|{wwv{y}vy{yttvyvvytv{w{;^N>;_]]];up[[pm,Zmmpp'+(+'S('Z)&mX|{y}|}v}v{v|vv7/514((m'(%
-SCACC@;\rokli4@@}{x|}}v}}{}{{|{{|{x}{|xv{y|||{yvv|}wwy{yw{{w|||R|yy{vw{yw<<}}}|}|{{}v}y}||wa{t{|{}R|{}}}|aw|ytytwt|yyy{}{wyRB^{wttyo}||y}x}}vx}|{x{yvyttrryw{|w``R{|{Ryy|}}|y}}||}|||wyy{y}w{{vvyyty{y}|tt{ayr^N>__]]][up[[Zmmpmmpp'+(+
-'Z%&+mk(Z'J}}}yy}{}}vvv8/14pZ((&%&'CA@CCa`rooiiS4=?Cx}}x}|}}vvv|x}|}}{}vy|}}vx||}}||{y{ywyy}vw{yy{ww|}}`R<}|{}}yv{}{}|}||w{w}w}w{{}|}}R w{}t{rywwyw{w{}QwyBrw{wrwt}|}y}|}{}{}vy|{}}v|Btww|||``||| |}y{}}}}}y}|{{}yvv}}}{y}}v}{{yvaQt`Ot__^_[[upotrmmpm+',+mSgZZ(,mZZkZ}}||vv{vs8747,.Z'	
-ISZC@}{a@`qoinkI=?CCx}{v|x}}v{{vv}}yyy}}|xv|{|}{{|v}|}vtytwt|  Q{ <}}}v|||{}yvv|{}wy||y|}|wa|{B|{y{{ryrtr|twwy{y{wywrr{rwwr{}}}y}yy|}vy}{vxvv{Byr{|R|{w|}{yy||`} |{}|||{}}||yy}}}v}y}}{t{vvy{QtZOt^a^_[[ynotnjmpmmkmmZ'(+mS&KZ).pZ)ngpg}}jo}}|{{{vv74471.kZ(Z'&SgC@|}{{``v\qnqqg?CC}C}y}}{|}v}}|}}}||}{{yxv{xv{{yy}ww|{yvwvty{B{ywr}|}}{|{}}}|vvv`}|||}|{w|{w{w|{a|{{wwtwwyt{y{w{{rwwryottr}{}{{}v}vvv}xx{v`|Qw||{{{}|w{tw|{`}{|}|}}yy}yy||y||{`Q{}}v}{{}w|vwvvv{ytrZ`^a^_vt{k\\\njmpmkmmZ'(..m).S))Z,mZpnMpgrj|}:741:][1+mp[(m'SSS@|[]``sk^]kmq[[innmnCaaC^C:C}[Cx}|{v{{x}}{}}}|}}|}vvsy}x|wy{}|yvt{vv}t{|Bwy<	}{}|}}`y|y}|}}||a{a}tytyww}y{www{yyRrtwrwtrtw}}}{}|{vv}{}yv{}{v}{yyRQa|{|yyt|}{twyy}}}}}}}}}y{||}||y`{|}}{{{vv}{|y{yvvv{wtyl^t{wtry`vqqnqkiYlljmZ(..,)Z+,,kkppp[nYi}kkMm2[[71:]55np[[[7mSZmS[\[kk[knp[7.k7aa}|{}}x}}}}}}yv||yy}}{yyy}|vvy}{yw}{}_a}<|{t}y}}{y{y}a}{}}||}a}{{}|wtttywQRBw}{{{aRyrrwrtwwy}}|}}}x{}}}v|y}}ww}|{||`{wyw{|yy}}
-}}}|||B|By{y{}}}yv{v}{{}yyvy{ytytlvtwv{^`v^\[qnnkijlkY+SZ,/+mSpmpppmnp[nZnkkkjjZm22[75:=:[[m:m}9}99}}<}}yx}}{}}}|}{w{}}twtvtt|twy_|}<ywrv{|t}v}y{t{}}tr |{{|y}{w||{t{tywQw`w|yyw||PywttoQty9}}}||v}v{}|||ww}{|w`wttwy|y{|||B|yy{y{}}{{}}}9y|vvwyyrrwlrv`\^n^^\[\nnqkYikZ/,[mZn:::77:[::nZ[k[7:::}{{{99|}}<9}{}vyy}}y{}|}{}|{ywy}}<wyt\w{yt{vy{||yw|{{tr |{|ww{w{y{Qtwtyywy`{y{yy|`{_rytowty}|}}{}}}|y|}|}|{Rwy{{}yyRw{{ty|w{|}}}||{}|y}y{|}}}t|{v{y{too|yywq_^n^n^q\nnn[kqqknkkk,[.}}}x{t9t}}<<}}}}v|}}}}y||{{}}tvyt{y|<vttv}wtwyy{w}yy{{w|w|y||{y{|}}Ryttwttw{{{yyywyytr_w_ttvty}}Pvv}t}}}}{}|{}}|{yR}{}||RvRyyRwa}|}|}}|}} |{{}y}}}}yt{|{||yr{ttwyl:[[[vn]n^nmnk[knknnknm:Zx{}}}\\rw{}}}9|{<}|a9}|y|}}|}{|y}y{}}|wy{y<{ww|vw{yw|}yy{{ywyww{w||y|B{twtw|tt{ytwwyro\w`ttwwN`};_O_ttw\}}v}|{}}}{w}y`t{y_OP}} }|}}6}QR|}{wy{}{{vvyy{||trwtt|y`ln:8:n[7[[:7n[
-}ryyr9v`vvtt\}6}xxw9<yyw}}|v{}}yt}}y	}{w}yv<aavvay|yt{{tyy{w|y{{yy{w{yv`{{ywtttwwwt|y{wtyt\rtt\vttt>N`P};tOvtttw}v}\}|}y| w`ytP_{t||| |R}}36BR|}}w}{t{}||}}yyv{{}}yr|yyt|P`wlnl}tr<9`vy^\|x{v}}Qw9<yvv|x|v{wvtwyyyvyyy|}}tyt|yyv<{{y^`||{y{twwyyy}y|Bw|{t{ty|w`{wtttwwwr|wwtywo\nn\tv\ytPvN_`v`a\v{Otvyw}{|{tyyya{ RBw{|tPtr{|a`|Bw|}}}`336{}`|y}|tw}|}}{y}{}vvw}{ryywttPwwykllj\\`<9\\tt\|y}v|{{y9<`^`}tvtwtwt|{w{}{twvtyyyv`|av`t^||`wv\ytw|y{}{{By`w{tr{|vvytvrtrtowwtwytw`ok\\tnn\\P`N{`^^;v`8Ottvrwtt|}xy|||{vw| B@Q|yywP{y `|aw}|}}33a{wy{yty}{{}}}w|yo|y_t\ww{tllrnj,:``{<9\\nn\}}}v``^<<^^^tvoott\twtt{w{v}t\wqt`\```{{v`t{}`tvtrttyB|}{wvyyw{yv{\vtwt\ttortot{n\tv\\nnq`\v{\q^;^`^^ttt9wrtv}||}||}x}\wtBRaQ|yy`P{{y}|} }@{}@}|{33wtttwwytrr	}yt|P_t{tyrtylr\kkK	::>^^\\99\q``{av<<\\vv\\\ooowytyy``^}q\qq^`v``_\`|`\wttor{yay{vyt{ttv\ytvvot\rtrottt\n^qtqnq\\vqqn\q\``\ntq\\^q{{t9||}}}{vttBPy{vy\yytyyvB|} @}@>}||{|39{w\\wyyttwtot}{|}RwytyvtwPyr{w}wtwtlonnkn998_`^^\\vvooolloony^^__`q^[nq[q\\\q_a__`^v``v``vvv\n\orywwtt\v`ytvt\`^v``qtt\\vtv^\^\q\\^`vnn\[`^v\q\v^{y9\}|	}{`\^tv\|va`\tyyyt\^B}B@@;a@>@}{}}}|9vt\oyy{ytwy{w||{{ryrtwwy\\wywwwtrolnjkk
-=^^^\\q\\qqq\\[v```=:n:\n[[n`_```^v^t^^^\t\ovywt\``{vv`v\\\qv\vn^^nqv`\\v^q[qq\\^\^[n\\[[_vv_vqqq\qvv`9}```^y_qq\v\^``t\v\y^q\vt  @} }@>> }}{}`9vtoonw{yrtywtwww||w\vwvw|{yrrvtyrtttnjkklkk775:A_`_^\\^v[qt\[\\y\`vvv_`\\\[\`qq\\v\^\\^^\^\q\nnn^vv[^[[s[n_[x[{_[^\\\`9[v}[\`a{\`_vqv``{vv`\\^\q\qq  |}`>|>{8>||`v9tvtttvty\Ryytww||t\v\|wy\wty{rnrrolljjnnk
-::>>][[]qssq]\\qq[[qq[`_^__^^]sqsvssq[[^sv\vs[\[q[n[n[[[q[^s^=[7:]^\_^^x^^^x9u]s[}[q[q_`^^_v[q_``ssx_[ss^[q[qq |{`>|``8>|^_aa^^^v9t\\ttltr\RQyrw{{vw\\tvtt\wtr\tv{wttonnloook\jk::::`]]_[]ss[ss[su\x[^_][:ns[[75:::n:=:::]^_^uux^suu9^[u[s^[[^s_]_^`sx^^]_xu^mms[q|a__a^``||`a``^\\q9\\ttnkl\loyy||}{vt^\tt{vttv^vv\vt\ottr\\rlokklnkk	
-	::8:=:=:9:^?:[[[naa_`^a|``a``vvv\^9nn\^ll\n\y}v\tt\\`y{vtytvttyt\\\t\\nt\vtinninkn	7:A?Aaa_``__[^^^_9nnknl\\qntn\yv^qqtq\\^vv^^q^t^\\t\\q\\vq\nt\knkqkZ
-	
-
-==??=__]n\[v[9sq\qq^q\sqsqsqn\[[\q\v^\\vv^q^vv\\[[s\qqqtq\q\nqqnqnnn747:		====9u][s[][qs[[[n[^\^^_;^==?=::::[q\^n\qqnnqs:7:	9:=?::n:[[5:		:::								
-
-
-		
-				
-
-					
-	
-					%	
-			
-
-					
-					
-																	
-	
\ No newline at end of file
diff --git a/makedata/land0001.pal b/makedata/land0001.pal
deleted file mode 100644
index c428e4d..0000000
Binary files a/makedata/land0001.pal and /dev/null differ
diff --git a/makedata/land0002.cpr b/makedata/land0002.cpr
deleted file mode 100644
index 36ef0b8..0000000
--- a/makedata/land0002.cpr
+++ /dev/null
@@ -1,174 +0,0 @@
-RWM.58///'22/++1..//)&'%DTCAA>;;>8?=7.1)1.).+')/K##ZO8;@P>;@@?8>5;AAA??A>>?>2/L0++'88411,,4./44(+++11(/..TC;?>;>8=7+,'&)''JIv>Q;>>Q>C@@?AA;ACAAAC@AA>AM8JJ-''((.,1))..44.+III%CA?==A=58://+141,I),/')G#
-
-I	@Q@@>@@@>C@@CAACAC@AC>A>;>28JM	+22&&/1111...//),)EA?=A=7=:::441//4)..1./,),I!TT;%F>@@>P>>@C@A@@CAAACA>A>N;8527(2)+#/1...11,/.(+11+,W#&=>=:::::41,/1+1')SE
-:?=:&&&B@>@?C8AAA@CCCACAAA@>88555=2722%
-+)55'//'11.55)...((2,4(("
-
-4..:.+,1),I.1..,I&%T?=+.#)A
-CC>>@?CCAAAC?CCCAA@>88?=:=77255>KJLK
-).11,221+15),,'..'+144'(+$
-.:::11,14.,/.&/1+,2G'%"?=A=%.+&!CC>@>ACAAAAC?CCCCCAA@>A??::=77255O>2;82N5PQ;8N>Q8))////44I,,+4''+//).444+
-$%	.1::22/111/..)2'I)')41>;>%,,%& CCCC@CC?@;CAAAC?CCCCA@A??::=??88;@;?;>8;Q@@>@@@>;))22))),,1,,,),,22)+//,)).115,,(+(277:::7,'55,2214//,II'")$..=?77",,H%#"@CCC;AAACCCCAACA??=:???8@@A??;A;@>@>C8@88J',,//'..1144/',,,''I.7:'74#(/+'2,44::.2.,)',/.)I,+H
-;7?2/)(			CC>@ACC?AA?CCCACA?=:?AAA?;A?@CA>@?8.,J'')),,,2//2))NI)2''+7.4,,&.27,/2.,1/J)')+
-18+,"&	N5M5		CCCCCACA?ACCA?=:?AAC?AA?CCAC?.,,))'')'+))),MM222M/8'(441444.1::74//1))/.,''I).#+		477:,)&%"$		2;O@5ONO8PIH!	CCCACAACC?=?AACACC',,/,')'2//L55/28588?I(.4,,::5711)2//,)JH'&#
-41,(&$&+,=8;;;>>>@@PQNO;H,L)K	
-			
-
-	
-	CCCCCACCAC),,').2225588;8>??,I11,,.5/(111.7:,//.2,)/,)H'',117778?>A8@>P>@/;,',)K//				
-
-	
-
-	CC	CCCCC')))//.))'''.1882MM;@8>>?;111.555+++	7777,:225,,,,K))#H7777AAA@A@@Q@A;:/,2)//7	
-
-
-
-ACCC''',,S..))),''48255@@>@;=''/,/554747:71724)4741,L,SIS'I
-7:777?CAA@A@@C?A?:,)1+27,,	
-
-
-
-
-CCC))'))')I),,,)).(25,,2@@C@>=++,,,455'177:14..//LL/JJHG&(+:?AAAACCC?=?+4./41.)I	
-CA+)''')))')',)).//44/>>>CC>++.112':1,4474755,/2)LL'KG#:AACCC@;=?,11/HIJJ	
-
-
-
-C@2+)KK),,,//;>AC;;=.,,,2+)'1:411)+44455/55)//2H'#
-::AAC@A=1)124',)K,I	
-
-CC/22)''S'),,2;?=:/44.2)+++&24.441:.24255)/22552JAC@A24,'+/4)21
-
-&CC
-//2')))'II))''',)),55?>55444)55)++11144.44//,:5554KK552,#CC(/2/1.)).+)1
-
-$C
-8/'')//'#'))),)22288;>>77/,,...+))1..((1,5//+55,,///442/252,L'C+,4.1+
-
- ACC522512)''/,,)I))///;>7;/))...1+...1..1.//511+'+744774414474252/,)+I41(,,'(
-
-C	
-25525;,,,)2255,))/;>225;;//),,,),,.4..(+/,2221)
-7744777,112555:12+42(
-
-C	444525../)),55,//;;;88522,,,..1)))'111+'22',...++&,771775:7112
-
-
-AC	
-44;/,11///),,,,;25112,,,111,)+I11+111%))'1774772254:772557+
-+./AC		
-;8821/,1444/)),/552//5,/,,++H1,,,5,1,,,)+
-=17/547745:/:,/.121++.4)
-881122,145,/2),,)/222,5)')'')#,.511&%,),I',5577==722472225:/5447)+7	?C+/2/1,,51/,,))),))25)')))#')2221),+)))I(/1,12445=177:77772/41)4777''71./5
-C
-
-,+1//2/1//11//,)),))'',,5.//),)/HI/)2))+''I(.4411444.1:777:14,4444777+7
-C
-,,8//,/,,4552/,/,//),)//','I',/,)I),''(.,:55:477:54/..11.4/2.7:7
-
-
-CCC4.,4188//,/,',)'/).),,),)I'',)'I+',,'&'),5++47777:52.+1,7,44/777
-CCCCC//.4.,224214/228,),,/II,,),,.')I),,I/)',,,().44,157::47/77471:@CCCC/..17///,2;555;	,@@/,')),,')I'',I/),.,&((,)/51577/::4144411::4ACCC/,2)...71122.5/522852,2/,,//,,,/)//)),)),,))I,I,+///,12/;277277444747787CCCACC	,22).,,881114)2528858//,/,/,,/2,,/,,)),/,)'I')/,21%4//25,4445877747CCC	422/TT++27.115/5;22552.1./244,,@@),,//,,/,)//,),,),),,228/515772577:,47+4C:C
-442/47TT.55452//158//,,.55/552/RR),'}))2,)),),,//),,,)//,),)81544)7777:122772A:@C	447:47.1.7,,25522//88.44/2//5/,22RR///,/}}}/,,,)/),,))/)),)),+14441/4741.1277:;$?7>CC	47:47/444,/y442222822422/11/2/52//R,,,,/))',),'')),))+11,,151447...77:1/;=%',,@A			7:77741{{,/882//888//2552/212;88855,,/u///,,,')''))++(47777/727217:1
-		??=558@@AC::7774/4444{yy|;;8825/5,//2/2>88>;5m22}u/,//,,)),,,,)2/,71@447417.7:7.
-	=@?;;58CACC	7:77:44,4422}y|88[[2k/5522522888522;>;555m}zR@uz2)///',,)',)'11}4444774474?4
-
-A@?>;CC77:44,,,/4}|||}}}2;;/24,55/2;2/;;;/558;255[kp/mz}@},//2)''),'2///u477,2=:8=77C@C>P58@@C7447,.,),;}}}{C}{}2252211/55//88;2/8;25;>///[55}z2//y,,')755z/14)8=?=C;>2P@C7:774,//,22}}}}{yy/,24441.554454;452>528854/snp[2@522|}}w),)@5z74'4%%+5?;=5=CO;;C
-774///12,.}|}}}wy{28288/[m[///;>588;;5;5/885[,n258z/2@}}}`|'),)>}7+1;;;4?CC@@N;@@CC	7=7171,}}}||}}{}}|s85sp2^^2;;;88;828885;8[,22pp}}}a}}@)))>>z27:41,(2;=;@C@@@>2@
-47.14,nm|}}|528588mmss[m[u^s>>2s;>55;/28;52882}`}}y}aR/}zzz(/1==;CC@C@CC	7.144),nm|y}}{{{|/;884ss22s1/sx55x2522/;;;2`225585|}|a }`}R>>z
-%((CAC@>@C741/F,,/p[}CC}mss[s8msvmsss^5^s[u^^85;8_a[p[[]825{}aa}w`y|ywz44(((CC@@>C		17.4]],/mmCC,88/;2^^s4822nm28x55s55>;88;;ppss288}}}{ya`a@@}}{>>4755
-(A@@Q88		4[[k/kpmC[i2;85552>^^8v552s/2>^^s;55888m]mk]`}}} |{}}}@}yy{w@@,//>>).114
-:AACC@;;>CC	mm55_]mmi558;2^xx8vvv5_/qvqqvvqqqk;8sm}}} }w}}@R}}y}}}@}z,,/>,,)71	47
-.CCC@@;8;ACC__55;]]mmmpkmn8;;>v@vmqqvvqqnqqq[^ss[[{||}}|}85@@R2}||}}/,/,2/)):1271511
-CCC@@>;ACCp[Z]__52[mmm_;8;z;pp;_kqmss]k}|}}C||8RR2}}yQyy}}2,/),,/2,47@711?CC@@>;CCp]5]ppm__aa__u_m[pp]]||C `}}}|25255}|}}y}{}/,/)22522a4C?CCC@@;8CCmppm]_,Zp[[u[[u_s[x``_^m]]8CC}}822[[858{}}}y|{y@2///),/,,,2555``	:7?>C?8CCmmm[[__p[pppusx^^^x^xqCC2/m8/85Zm5|y}}{|k52/2/22@a:
-&.=?=,1@>;C
-nnnimm/mssps[xx^^CC85,5/525mp855|{wy{yz[[2225/2/,/2/2@@}
-
-&?=1.)5CCknn,Zki8__m5[[ms[[mn[25m5,pp/{}}}||{mmm[[2m[2//,//`a@}}@	
-=A?//,8;CC22kmmZm,knn[m5qq[[[x`^^kkmk2pk[p2|}}||}{m[[5[m55//{{/2`}uC	+4AC??,,))5C	kknkppZZZ588kk][Zmmpqks[^ssx^m^s^^^pmi[mpp}|}}y|{58m[22/2}}}{25}C	
-7=C=??//5,,	
-nsskppp]58kkppmmk/ssssxssuuu[pmpp{}|||}{528525528mm[2}|/}}}@4CC=2,22/25CCC
-	m2[kkki[[ss[p]]]8pppppqqpsu^xxxoq^___][umpk}||{y{}|5/555/5855mkm|}}}{}2/@@4CC77/8,5
-	kkn//m[m[pp[]8[mns[qk[]]^x``_v_s[Z[[{|{{}|wy}/5255[5252{yywtw}yw@@y}=
-
-/4CA7/882/CCCssm,k,knnZZkkZZZj[[__5[mmkkpn[ss[2q_z``_zz_;sm[{}|{|{}}mm52/525[[]]2|}|||}}|}{}{C:+$(44A>CCA448828/5C
-kkZ,,__nn_pp[[pssZ[]88p_]pqsss58[}a;\\`,[[m[m|C}}||w|mm55/2m52[[|y}wC}{{}y@{}z:4.	7A?CAAA=45258	kssspuu_][[pp[p[k5m[]kmp8[;25;/va;;a}a};_[::mk[CC|y{{}}5552k55//[s}{C}|}}|}v8|`yz2:5'$4.@A>@=5;;>88;58
-uu]]][[[[puu_pkk[5_]]ss;8>;;88;vx``a>a@}|xv:Zmkpkpp}}|}|n2255}}|}|}{|88@}aa}:7:.&&$;>A>?:==8;;=822>C	__][[][Zuu]mm[kp58855/s28;;8;@_``^`xxmm[ZZmpCppp[[]k[[7|C}}|{{5258@}a{a4:2
-2.+(88C@C?::=5=?=;;>5@>5C	ZZu[[[mm[ppkk[n55_:8[827225xx{x@@@>>@@p[kkmkmppmp[[[nC||}{|22mm25a{`}|{{41451+8C?AC:5558?=;>;>>>5[[_[[___]m]]][[Znn585825>5:;@@}x  ;@;;>a;[mpmpkm[pm[|{}|{p[[[i}}|| {aa{[1715+,:CCC@;=4784>;>>>;@;;>2>;C___]_]__[[k8p8858s55:;;@   a@`aa4smmm[]mm::{|s[mmmk}``}}||}|114.O5:CCC@A2/5255@>=;a];>>=CC
-_88_/__;;k]__]8]]]_mii/88/;/77 @@} @}aa	m[[[p2s77ssskm}|CC5|}}|}}||yz@:4,,&aaCC@A85;82;>;=z;@a]]]>=AAC>8_85585]///,n558;2@@}}B}}aa[[8mk:[spp}a}CwwyR|||}|`a:5/,m4`aa@CCCCC>AA;4851;x>;`8;]];?A???=<88>888;;8_22_8_]_nnkm88828@@>}}|@`|x^z4xss^[]585Zkkn[ma||{`a{}}}|yy||:7?8>_,[x@``aCCCCC>CA=485;/p@>;@>;v_sk[}>?==	
-<<88;;;8[8_;8/8;//888pmpp5882`@ ;;>a;;a`;``4_^_^uu77;annZkum[555[7p}}}| }}|}|}}}C{y::788;82kqn`aa@;@C@ACCC>?;858mp@>_>;>_`a8:AA	k8[[888[n8kknnkkn/p/[528;@@@>@aa;@@@>44;;_77;_;;;knq]^[88:}}}{||
-}@:8}``2,iqqC@C>C}}AC}A@ACC@@?>;585[/>;>^|_;;_;=;==zC=9/nn888nn114n/k[nkk2n/k8;;[[8> a>BB>;@@>a>>a;;77;;;8;88sn[m77p}}}|}ap|a}|}k}}}aan^J];;CCz}|CaACACA@>;5;21u8@;>>v_^;@8=;zuuA??=98<nn2[2k/n8//;nkkknkpp[8/;88;n;>>a;>;>8;>>8;8[{}}yww|}||A|}km@}yv}`}{```na}@CaA@C>;821u2;;>a@x>[a;8;:[m]=:=8[p82[[kkk2k[nnknk[[888[q888kn8>a;;>;8s;888>>>;;;[[5;_:7y}{|yymaC}}}{mkp@}}|}`|}}yv}n@@CCaC@>>;8;88[p88;^>@>>=]a_;55]=75<5;;8222nkn888/[[qnkk8558885_85NN8>;888>>8;n;8;88a877[87{}}{}|}CCwmm}}{|}}|{}}@`q}}|CCCa}a@@C>a88;>8[[;/@^;;?==@`sx58=[:=?7:n<k8ppnn;k888=88[qqqii55]5;__]__O88;>;;825_n775pn::}{}n}}}m}|}{C}}||}}{vv^`}@aCa}@@@aa;;@58[s[/m>x8?;a@vq^8:=:==?A:n<kkiikk5p[///[8;;8nn[knnkh[[[888;pn8;577npp}{{{y|nnCC22/nk|||{C}}}av^`}}@@aa@@@^@>C_@_55s[[[2u8;;@;;_;^;==54?==A:Ai<<kkkiikk5n888;8n//kjYYMknn/5pm55pq:{|kCCmny{{}{|}}y;>@|@a}@}CCC;va[sk[[[s;>>;^>=;.5:]z??=M<<iYYhhYY88n/;;;88;//]k,,kqnp5p[5[n::|||wmmpkkmpC}|y}}|}@CaC;va2[s;svv;>@x^z8;8::]u]_A:??p<<nnjjknn;;;_888kkii8_[[kppm[777{55nqq8_8;[[kk}}|}C|@}C@aCzaa_m>nvv>>>@;;;^5882sux_A:=??_
-nnpn[[[6qqnn//8]K
-n;__;]u]8[7w[missnn5[p}{a;_@@C`zxu;a@;@__;82_xa=[=?::_
-[[nL]
-pn[[88;;n;]nn__5sspqkp888:|}@C@x@Caazxaa>u@>8;_>;85;;[_z=_?AA::C
-hhnn966[n[^;;8>8_kn]_;;5ppp[pqk88:885k5:]p77C@`|xx@>az;;\@>`88588;_;z_>??==u:::C
-:	pkY86k[[[q;58;;;__;;;88ppp8558885]777|a|@>a_zz^;?>O885]s;;;>C?_[=u::C	66n[Yn;8;88qq;]88;888:8p5[m8[m558CC_a>;>;8:8/_5;;@=_>^[]p:
-j96nKhhYjjj888;;;88__]]k]88<ss8nkq]__kmmmp77C|_>58[5[s^C=>@8:pmu=CjY99	nnknkYhjjhYjhh98;8;;;8885[[[M5<<m855kk]][[[s88ppp7|aa7[^^58:;;8ssz>;@]?=CChYJhY9999[nYhYlhhYhY[q;_8]8]pN[<8pps]]88p]]uu	8m[;;87>___s_s[588;xx;>;;8AC+YYhYY9kn[nkhhYhhYhhYh^qqn]ONNkn][[[<8nnk;8855,5kYk[[m;8>ss>;vv>>8_pNAAKhhgKYhjkkkn[kkYjYnk^\\qn\qkkki[Ln8nn[kkn][kk585[p[nn588n[;>8_qv@>@okkiiZiYYS<99Yh[[knnnknnhYjjYhijnnq^qnklkk[llnn;;;nnnkkknk8kM558;;58_]n@>;>`;8@@[nkkihjk\n_47hYfKKjkhh[nYn[YYjjhhjhYiin\q\\\ljlhnnnjjjk8;8;_nqkn[6Q^kk5[nqq\aaa@@][t\nkknnnkninniu=4,,kgjjYhjjYhhnnhi^[kkhhYYjYhhhljjYhjll]^^lljljlhi[ijjhhh5888522_8[,_]qn\qnk]knn\kkn__:x`??C:47YkhhYYhgYJZYjjYYYhhjjjhYYYhhhhYYYhiYhhjjjhj^t^jlhlhjlhjljhYlii8]588;8]5M<Y]5nn:n[nkklk\jlkiq_^]]^`a_?x?zA=4pYYhhjYhYhYYgYjjYhhgiihhYYYhhhjhYhjjhjhjjohjjhjYhjYYYJkihYp5[58]]_Orj\lijjnnkqknnmkt\t^\_z?aAC=6hhYYYhYJYhYYhhhYYYhjjhhYhiijhhhkkYYl	jhYhhjn[hYiiYjYjlknnhnokllnnqqqntnttvt`\__`?_C=A7MmZ4YYhhYYYhhYhhYYhYhjjhYjjjhjhhjjjlYYjjYYhYn[knnniYfYYfljklknrnto\nnn\ntt\ttn[_^`??_a=C@AA7.7hYe	YYYYhhhYhhjjYjjjjhjjjYhhjjhYhjhYYlkkknnkYYYYhjjQkkikkkloo\klkp?;::?_[aa_`@@AA=:.5YYhYhhYhYYYhYhhkkYhhnYjhlljjljjjhjhhhjn[[[lYkiilnfYYYhjkikinop[:[;a``AC=_=_55)jj9hhhYhYYkkYhgghYYjjjYnjjhhjljjhhjjjYhhp[[[hjYjkiinkhYY@mpsp^^]AC_[751Z9hhYYheehkYgYhhjjYhhYYYlhjjjhhhYjjhhYn^YhjlnnkjjYinn^[CA[7Zi9jjjY3hhYYhYYhhheYYYhhghYhjjYYhljjjYYjjYhhYhjjihj[nn[YYYhiikk^;;A?YYYhYYkkYYhh	YhjYjjohjYhhhYhhhhhihjhlYhhhY	f^;^]AzjjjYYkknnn<<nhhYYYhheeYYeYhhhjYYhhhhjjjhhllnYhhjlljYhjhhYk\njjjhhkkknn<<n[[nkkhYkkYhhYlhhjhjjjhjhhjjhihhn6@hllhhhnnn<kk[[	nhYhhYeennnYjjhhh99jjlhiik@lhhhYYnnY[[kknkkkhhYhhkkYhljjljiijjjhjYfjjjhhYYnkkknn[[nnknkknnYYhYYYhhYkkY<lhlloljlnllhhlhhYYjjhhhjjjhYnkkjjjnn[[nnkYhhhjjhhhYYYojololollokllhYYjjjYYjhhjjjhn[[nnkknnYhjjYhYlr\otoljjojih6lllhjh[[kkn[[nYYYhYYhhYhYYrojlrrtvorrlllh9jhhjhnnhhhnkkkYhYYhhnjjYYhhYhhhj6	rlrilnororwtjljijjhjjjn[jolohhhllnnnhYhk	nYh
-Y[nkYY	ooorolltotrrjjlljlklhhjjiihjjjlljllljjljjjYYjhYnn[[^^nYYhhjjjhhhYYYhYhhYYYn9h	hhhhhjjrtlororljhhjjhjjhhjjikkjjiiihYYijjhjhii	jhhjhhYYYhn[[[nhYYYnYhhhYhhYhhkkk9hjjhh	hhYYhYjhhjrtr\noorto\jjhhjhjlllkkjhhjhhYYlljjhjjiijkkjhhhijjkjhjihiihkj[[lhjjjhYhjjhhhnn[n[[[kknnknYnkYjhhhYhYn<<hYYhjhjjjihiihjYYhjYYhjrtoortttolo^^iiYhjhljlj[[^^[jhjlYYhjhhjljkkjjjkkiijkkllollloklojllnl]^^^lll^kljhhjllj[[jjjlll[[lhjjjllhhjYYYhYh
-nknkkknn
-Yh<99hhjjjhYjjhYlllhjljhjjjhYYhhYYijrrtrrlrj^_^llllhhjljjlihhkkjj[n[ilhhhjhYYi[jllnolljjjllijiijno]^^o\lklollooolnlljjjljljlk^^jnkkjlnljlhhlljojhhjjjhhhjjjhhhYY	n[[[nn[[nnk[knnkYhYYhh99	jjjYhYYYYjhhljhhYjlllljkllhYhljjjljjYhjllllojlolljlljljlljljhjlhjjjhhliljjijjjihjjhhhiihhllkkii[^][lljo
-ljjjlllkkjjjlllkloollljjlljlkkjih[^kllllll[[[jjjljjjhllhYhn[[[nnhhhnknkYYjjYhjjhjjhYhjYhhhYhhlhojlhhjlljlljjhhhjjjljlhjljolllljj[[lljljlloojlljjljjlliljlljhljiihljjkikiijjhhiiknjqnjjllkkolknlnnnollnljjjhhlkklljjjlnljlkllqn\nnq\[\[\nnqk\jljjoljljjlhYhYYjhYnknn[nnhYYjjhkkYYYnkhYYhhYYh<<hhhjjhhhjjhjjhhjijhjjjhjkkjjkkjkojjoojjjlliijikkjjkkkojljlljjllkljljhklklj[lljjjljjjhljjollj[jlljhhlhjjhjnj[k8k]_85nnn55kkpn[=:::jhhhllljllYhhhjhhhYhhhjhhjhhYYjhhjhhYYYjjYhkknYYYhYhhhjYYhY<<hhjjhoo
-hYhjhljlloljlnonlqnkknnqnkkkikliljjlnjjjloljnknnjkklljjknjjqknqnnqnnqn[nnn[[[nn:	hjlljhhljjhhhjhYhYYhYjjYYhYhYhhjjYhkYjYhjYYh<<hjjYYYijjihjjhjhjjkqqqnn5nnn[72278_;88nnqqn\knqkknn[qn88:5:
-jhhjhhjhhjhhjjjlhhhYYhYYhYhhYhYYhhhYYhYhhYhhhiiih<hhjkkikkYYiijjkkhikhhk[[[jllnnk	llljhjohhjhjhjhhYYhYYYhYYYhYYhYhYhYYhYYYhjjYjeYYhYhhYiYiiYhYjjYYiijjYi<hYYijjkiiikkiikkknnknkiiikhjjjllknnnkkn[[::
-
-ljool	jljjhhjYhjj
-hYYhhjjhjjhYhYhhjhYhiijiYihYhhkkik<ikYiijkkiiikkZZZnkknppn[[n[[:::jhhojjhhljjjhhjjhjjhhjhhYhjhhjjhhhjYYhhYhjjYYhhYhhYikiikkiiikkiiknnkkm	ljljljjjYYjjjhjjhjYYhhjjhjjhjjjYYhjhYYYjYjhhhjjjhhhYYhYhhhikkikkknkm		jlYYjhhlljlhjjlljljjjhhjYYhYjhhYjjhhhjjlhhjihjjjhihjhjhhiiikiiinnkkknkkkmmjnnjljljjjlljllljkklljkkkjjiihllhkkhjYYhYhhjhjihhiYjjihhjjihlhjii
-n[[:jjjljjllnnkjoikikknknnikkikkhiiYYhhjhliihkkijiYYinkkk	nqqq[[[mm[[[
-
-	jjjljjljjlkkjjknnnkkknknnikkkijiijiiijjkkkinllnnnknqqqn]::lljjllkklljjlnjhhjjknqqnknkkknqkknknqqqnnn[nnm[ljjjlnkkiiikkjjknnknnqqnn[nnkknnkkknnkn[nn[[n[[[:::
-jkn\\mm==7:lllnnolkknqqnq[s[p	nqnnqqnnqqnnk[p[[[nn[:
-		
-
-
-
-
-
-					
-		
-				
-
-
-				
-	
-
-
-
-
-
-
-	
-	
-			
-	
-				
-	
-
-		
-		
-
-	
-
-		
-
-
-		
-	
-			
-	
-										
-	
-	
-
-
-
-
-
-	
-
-		
-		
-
-
-
-		
\ No newline at end of file
diff --git a/makedata/land0002.pal b/makedata/land0002.pal
deleted file mode 100644
index c428e4d..0000000
Binary files a/makedata/land0002.pal and /dev/null differ
diff --git a/makedata/land0003.cpr b/makedata/land0003.cpr
deleted file mode 100644
index 6f4f1da..0000000
--- a/makedata/land0003.cpr
+++ /dev/null
@@ -1,86 +0,0 @@
-RWM14-%%%#QF#F&#DGH+(J++JJ11NL?=??OB??B?BB??BB?B@@??>>=>049*14.6.497<6094<<@?@9@?>-60396<994<4.74@B>BB(%GQDE*$&'%(&$G&%+%%*&%&%-%&%$%&%%&(&(&&&(&GHGGF441144''TEGQGIDGF(IIJKKM=?N?:::=?B???B?B?B???B?@??>@==><466.61611779::36916<:=BB<99<376764+-:>BB	(%$#G$**'&&%&%&&&$%&&&$G%%%-%%%$%G%%$&G(&&(&GH(IFG14++EE#GFEGHHJILL7NN:ONL=:?=?B??????BB???=::=:7><<666136>=:447<<><:>@@@B<.7@796966->99<6060=74@-&#FDG%3&'%&%&GG&G&&&G%$%+.%%G%+G&G&&H&H&G&((1((T""#FFD+L..11.7MM77MMM:O=:?O=BB??:????B??@::3:7::<<6661-61771<<4<<1@@B>@7@9B(69991+603@#DDDF&&%%*G(G'G%$&(%(+%&%&((%%%($%&&%+&G(&&&GH&...LL1%%ETTF&&14.7LLKK=77MM=:=M=M=:?OB?B???B??@>7?<=7::94011...449>47:<<<4-<>??@1.B@66999366#D&DF
-'%%$0(G%'%(%&&%%%''&&(%
-%%%$%(&+(&-(+(GG&&(&&.1&&###GRDG1447:7:O==:::MM:K7==??OB??B??BB?@B???B>>7??<774.4400+((''74994?:=49><>>4:=?BB9.161.9@
-'#D&F%%-'%%$(%&%'&%(%GGG%'%$&&%(
-(%(&+((('G(&GGG&H+&...44(((D&DFG&.74:7<7:?:@:?::74?O4:=?N=?B?=??@?BB9??47:447100+(('<:..1<77@>6::7::7M==BB>B>3+.969
-@GDDHFF$'(&$%&%%&G(GG%'(%&&((&$(&%$&((+.((%&&&1(&.&&+((DQQF(..1:7:+<1.?>@>7:>?4===::7NN??BB?=?9<6447:...+++((6617::<=7>:9:744KB?BBB@4<>>@336999496*%G#&&FF$3(G%$$%&%%GG&G((GG&G(((&(G&'$&('&'&(*((&(&(KK+..++DF&G&((499<7747.>>7:>:MM=114744=BBB?BBB=?=4:4:11+.%.:441=44<9><99<44BBB?BBB<<*3693<<6363'(#(HH$%F%%&%%&&%&G(G&&&GG&(%G$G%(+(((%&G&&'''((&.(&1++F&++..1419<<676>@::>:7:M1147=??B??B?==??=?::=:++1'--447:=11=74B>77<1(BBB?BB6<<B>@>+33636611<.41	@%GE&HG%%%
-&%%%'G+((&&&(G+%%G$%&(((G-&+(((G(((&(((.(+(((777.&74=.7:166706>>::7<<:14144@?BB?B?==77:+7111::=7?==1:17<4:B>:4(G=B?BB@B9>=>:31036*9<96-4GG(&G+%$'%%%'G%(+&(&&G((..&G(%&(((%%%&(&G&(&(.&&+&(*((.(1?=?=??><9:<66697<<:<71:.4.+4@??:?BBBBB?=?=::777::?=::===<==BB0:11F-=B?BB9<94@>@>>6666060.493969<%&G&+++%%%
-%&$G(G&(&&%%'%((&((&&(&&%+$G%G&%&&(&&.&&'+(+(&11????=>4<796969><<.@4449114+:?:7???B=?==?==44:777==?===77=?:?>?@B:11&>=@B=B4<:<@=>=6@@>69366..1109416&GG&+.+.$%%%&%&G&(+%&&%&%%&(%G&&&+G&%&%%%&%&&(&&&(-'*+%(+(7B=?::>77<7961<7<9.@11<49114471==???B	==???7=77==?744??7::?BBB.&->@@@<@B@69::@=:4@6=:>911990'669(.96
-GF&&1
-%%%%$&G&G&&%&G%(%%&&%%+&+G&%&%&'%+&+&*'**%*(+(B=?B::>>9<<<699.<<69991<.9+(47::=?BB??=?=7::==77?===4=???::B?B?41%->?=@=@B:74>7:@=>>6===::11.193-031693366
-(F&.1441(%%$&G&G&%&&+%'G&&G&%$&&(%&&&G*'+*&&+++'**++*%'G(&BB?BB@:>@<74<6>7<9374+.47:?=?:BBOBB???77=:?==?:B??=77?=77BB=?44&::?B?B@:74<4:7<=<77>::44*496030.4
-@@&G&.'477(%%
-%(%%(&(''&&%(G&%&&(&&%%&+&0(%'&(%(&&*&('*'(&&&@@>76.<374-..71<==?B?BO11?=?=????==??==?B?@@@11.%'7B>???B@@@7=<177:<=9<=414414496'+06<9-0>@&&%.6'*11(*
-
-&&$%(%%'%%&&&(&G%(&%&%'&%+(%'(%&&%'&+&&'%+(+&BB?@@><99906:7+367:=:???BBB?OO?=???=??7??@=::.1'&17@>BBB@?@@?==::=::>?=7=::4<4196-.6396333>>@>&&&%.((*1-
-
-'%&+&.''G(&&((G%%%&+&(%&&G%($+'(&*((&&('++%%'%+'1+BBB@<<999097'3<7<?4?B???==????=?==??@::..%11@?@?BBB@@?@===4==::=@17?>:.99<6*69<3
-@$((&'+.1.*3.*''%%+G.+(&(&G&&&G%G&(+%%%*%&'$$%0'%*&(&%&'&%G%%&''&GBB@B@<<69<19%<7<<::7??4?BBB??????=???==?@@=@?:1::&14:1<=??@?=?@??@==?===:::=@.>=7=@1<1+6660	66(%..&'+.3100&
-%'''(++.&(G(&$G%(%&(G*&$%'&&''&&('*''&%%&%%G'%(GBB@@@69<6<1+667<7<7>:7BB?BB???B?===??77?==@@:++.:::=???==:@===:===:?@@:=960663660699&%.+-'.0340&%%*%(++.&%&%&G(.GGG(+&$%%
-$%(&%$*'*&%%**'&&%GG(GB@?@:>69><++66<<:7:>7BB?BBB????:=?===?@@@44=:1114:===?===@?=?@?@::==::=?===?:?=t49663693<	00(%&(.'+.10..
-%&'%(&%+1&&(&&G%%&%G&$%G%+%'&%%&*.(&*+&&G(%%&G+%((BBB??@::934300*<79:74:4?BB?BB?::7?@??=7<14744<=:=@=@?@?:??:?==:===?==?=?@?=966146399	&&$%&+'66114%$*&&(&+&&+&G&G%G%&&&G(&%$'%&%'&%'&%+((G&&%%(('%(%BBBBB?=:>=9.673900:9174?BBBB??????777=??=???=<414<<<:?===@=::?:::@:::=?===?=>36613963@@0-&%%&664*6+6'$%&+&+((&(+(G+&$(&&&+&(&G''%&$$%%%+%&''%&*('&+(&G(%%+%%BB@?=:>6396-<<:74441>BBB?BBB???=7==??B?===:44:<<7:==?:?===??==:@4=??yy<<6099<<	@36@@@#1&&%&.6.4*yy+6'*$G+++((&G((&G&G'(&+($%$%*$&%'+&&%%%+%%&&%&G%$%+&%BBBB??:3613-4<7177.+->>BB=???7??BB???=7::777:=?=?:::==@@@?@>339<n30<93
->>6@@=.&+((++796yyy19&%'&&%+(GG.&G&(&(&&&%(%(+$%%&%+G'*%%''%('%&$%%%G%%F$&F'BBB==???:>931%%477477+*>BBBBBB?::???B???=::?7=77==?=??7===?@@??@==??@><3t63<>>>0::@==:77(+1794bby4*&&+%(&G&+G&(G(&(&%G%%&&$GG%++(*(%'(&&%&(%%%&%
-(FFGF'BBB=??@?:7:9>:<-1<9771(43>:BBBB??:::???:???==?7??===:==??@@@@@?@<<<6<<
-69>>0-:@@?=?:?=7'&((&+(&(+&&&++(GGG&(((G&G%(&&&$+(((%%&'(%0&(%(%%%&
-%G(GG&'BBB?@@=4=:?<466-.<7+7(1.:BBBBBBBBB?:==?B???=?:::?::=??B??@@<:<	9>0-::@=??=:=:`y*'$&(&+&+.G(GG&&(&&(&%%%+&(((GGG(%*'(&(&%%(%G&$$%%((G&('BBBBB=@=?<>:1166...177414%
-(BBBBcBB=??===B???==?:???:==?B@@t@6<@	@9<<><*0::>@=????:::y%'&&&%&%GG&&&(&GG&&&(&$++(+((%''G-%&*%%+%(*%%(%%G%&%%%(&G&BBB???=?>:?>:441...71.+40BBc===???=|?====?=??:7::==??=B@y?36@@
-<<<+*'<:==@??w?``aa@--(G&%G&%%G(&+((+(&&&%&&&(G&+(((&(G'''%(&%%&&%-*%%'%%'%%&''%(&GBB??>??:11.(+477.1%%<B@BBB	==????B|????==B=7==??=???==6>a19&1%+'<14::@?7wwa:@GG(&&(%G%((+((+(&&&GG&((G&&GG(''&%(%%&'%$$%%'%%%'%'%&G&BB?BB?c???::1(.7:7711%':@B@BBBB???=|==??BB:==?B?B==@===y>9@@@@@<:9*411-1177=7yyyy`&*%&&(&%G%&&(&+G&G%G&&&(&&&((GG%%'(1'%&%%'($&'%$%($$&B
-B?Bcccby??::147143*0>>@
-?=?==?B?===B??=??BB??=???By>y@@@@%77((*%6&11.177::bbuh%&(G&(%(G.%&(&((&G&&G(&%GG%%%4('%%%-((&%(%$(GBB?Bcyy?77]n.:44:14*60>>?????tBB=??7?????B?=?B==y@
-49[((
-%6003+177:aayyZi%%
-%&%&G&(+(G&%G((G+G&&(&&GG&G&&+%'G%+(+&%'%*
-(%&%$%%'$G($?cuy]]r474::+.--60Bcc???=?B????=B?==?c=@=wy=@@@'>>]1
-%00631(::aaaybFX$%&%(&(++(&%&(+&+G%&(&(&%('($((%%'%'++&&%+&%%$(($(&'&($*?cw``rr444+61*6-<BB????????==?????B==BBc@wy@	9>>@_]+$'6.41aaa`uFX
-
-%&&(&(+++(G%(+&(&+&&&G&(&%G&&%%%''+%&G&
-'%%F&%($&&%%(%&&B??by`777__744.74+3133<>BB?
-B?????c?B?B??==?ccb?:=====??BB?uwb3'69>=@>0_]$%%'&-.ppt::uu$h%
-
-
-((&(&&+&&%+G%.+(++(&(GG&(&((&&G(''(%%%&(+G%&%$1%&
-
-%G%&$%%&%&&&(%&&BcbbbbB__r`1441+31611:BBBBBB?BBB??cc???ccBB?By|yB??cc?:b??????=??BBB???cyb@@9966@y631>==@>0hh\Y++661+41pZ[[:]]$%
-&(((+G&(%.'&+..(+&%&%((&&&+&+&&&('-%%(%(G%(%$$'&%
-$(&&$&%(&%(&(&cBBcBc?yycB:rt1147.63-649:BBBB=BBBc???ccc??cc??cw???=b?==??B??BBccy<<ww990634a==yf[R'++66<4(1h+Z4```pp$0
-3+(.+%&++&%&+&.+(%(&%&+%(+&G(%G%''%%$((&('&%%'&%%%G$%&&%%&%+$((+(+(&&cccBcccyuyy``bbcy\4=74.334<<?BB:@=BBB???c????????=?==?c??B|cccy>9996-4aay@f&%.469+hnnZ_w`tp*%
-.+++&&+&((+.&(.((&(&%+&&('GGG%(&%+(%&&%%%(%%%&%+%&%$$G++%%%$%%$G(($&..+&cub|ywwb?7ccc=147=7909:64<?BBB@B=@??@BBB?B??ccc??c???==?===???cccccccyap999ZZZqb%%44969pk(+((71`]pp(0$.(+++(+&((+(&&'.(((&&'+&&&G&+G&&G.+&&&%%((&%+%%(&&(F(+%G$$%*&G&$(&(+.+cccbBccwb=bbb777=47497:=<>B@@@=@?B@BB???Bbbcc??cccB??t||y==?B==B??ccc|??BBcw_]6]0R+\.:@@u%''4t9_nn4]Z(+..r4ttpp]$-%X+((+((++&+'&&&(((+.(&(%&&'%&%&&(&.(((G$&'&(&%
-++%%&(&&&(+G$$%%%G&+G((G(.(bbcw?c?cB74==74<67:?@>B?:B@@?:B=?BBc?BbbcbbbccBb|||bcb|bB?c?B==B=cc?B|???B?Bwyyyy_]p6'-3]]yauum&%&44`tn`41+%&ZZn3>p+-(+(..+++('&&+('+.&&'&&G%'%GG%&(+(%G%&%%$&((&&+
-$(%*($&$$+(($%&++(.(G(((bbccb::y:]ab=::1=?>B=B@BBB?B:==?B?BBBB?BbccbbcBbccuccbcB?BBb?BBB@wy@yy_?!3]+:u^^mm++(&G&44`tr`tkkh+ZZn+4np.&(&.1((.(1+4&+((..(&(&''%G%GG($$&G(&%&+*%(&+&&+%&+&$+$FG.(&%.%G(&.+G%(&	bcry_`::7::???B??@>=@?B=??BcBBBccbyycc==bBbsbbcbbycccy|?????cyBcy??=@@ytty4??AAA=A!-(+oommY\\hh%77]9Z1k(Z+++6n.7pk(((&1(++(++44&(((++(&.(+&.(''&%%&%&%$&G&(+(((*'%+(%+&&%&$
-$%((&(.++G.+1.%%%+&(GGrra_:u:7=:????BBBB=@>B?:??BBBBBccbBbcwcyybcccbccbcc??ub?ccBB??=y??B=|BOOBy@4.?=AA!??!!mmoom\\ZZ0Gh%h&&\:7pp[k''+*pppnZr((+((+(++(++411(((+(+&+(%$''%&%(&(('%.'%+(%G'G'%$$((++h+.(%&G.G&&c`:7474=??=??BBB<=@?cB==Bcbccb?BcBucBbbbyyc??b|c?cBBB=??bbcBBBccy|BcBBy6uyw744==A!!o\\nG%+f$h((\[]pp[4%''*p(&r++((+++.(.+(1(+++((&+1+%&&$%''&'&%&((&++(&(+((G(((%$(%
-%(h%kh++%+&1uu777==:?7==BB@><:??ccBBB==@cbbccbybcbcBBBcBbbbcBBBc??u|bbc||??cbbbBBcBcccccyyyy4==!??A!\164++&G$%%:t:[]1r]&+n'(G%.l(&..(+((+++(+1(+(1++.+&&1&'GGG%G%%Gy%G$&(%'++&1+%(%%(((&
-$h%kkk...+&&&(((t`:=::=:7a`?BB@@?:?bc:?B??cccbbcc??|ccccycBcBBccBc||cccucbBybccbc?ccccbcBccBBBcByc|444147!A!!??1.Y&++%&&47:p4t(+..G&%(((+.+++(+(11++444+.+.((&+&.G%%G((%&AyyG&$+&G&+1&%''(G(+$h+hh+..+!&+&((??ywrww=?wb:u_=?@@B@:==@b@:bw?ccbbcccc|||ywcBBccc|yyubbcc?ubbbcBccbbbcccccccBccy||ccc444114!?A!?AA!A?!!.(&++%%&47rt7(+.1++(&(&++(+.((&11++417...1(++(&(G&&((($&A|!P+(&%&((&&++%%%&&%%(.k++hkh++7P(++(&yy:yrwr=wb\B@?:cc=@4=w:bybbcaw|||BbbbBcBbcc|||yyyBccc||ybcBcbcccc|cc|c141.+444!!?AA?A!Bn+%Gk&.]t:4(+1+4%&((++((.&'&&1+++11..+1(+&(+&.(+NPPG((.+(+&+(&(%&G%..&%.++h++.11!!+(yy``b?uc?BB=>cc=yc==7cybccybcccc	6ccbcbccc?cccccyyyuccccBbbBccc|c41411++417A?AA!=?!!!!??hkZ&nr`7+7+*'(..+.&.((.(.+(+11.(+.((&+(+(yPP(((++&(&+p&&h.++.+G...+.+!!((.cy|c?u`yaa_.y79c@B@>yccbu@?wccacybccB|99cwcbccbycbbcccubcbbccBBc1::4?!A!!A!AA?!.kk&]t\111((..1.+(((+1..(+11.++.&+(+G((+(+(&((yP%(+.(&(&&++1+%&G+&+(.++..&4++.P(1.+(.+.|wBcba_(=7::?@?@ycu@?w:cabaccycccccbcBcbc|cccbcc@@cbcbB14+11..41144A??!!!A!!!r\n\t:=\I(((.+.1(4++(+&1+(G+.1+PyyPP|+(&(&++1&%G+&&&%+.1.PP+1+4.cByww].7?=BB>>:>c=cyc=`:bcbcyacbcccc||yybbbcuB|rBB?cbcc?bbc11.111.114!!?!?!t[:>::&&+..1.1.1...(.1144((++&1+(+.&(+y!|y((&&+++&%&*.&&+&&(.PP??4:4p1:=?=>>?>`@`?BabbbccccbcBccBbc|cc||6ruu9bbBccuccB?|y|:11..++.4447!AA!AA4.>((&.1..+.1.4(..1.44...+&(&.(((+%1(&|!y(.+++.1%&
-&&%&(.+G:!PP1.cc:].4=B
-c=??b:wc=`bb``cbccc|ccccccBBcctrrcbbB|wccuc||cBbb|3111.(.++(1.11.41!!AA!A!7\__3a%+++..1+((.11|..44+..1+&&+(.(.%G&..yy++|P+...17%'&(&(%(.&...+ban1:4::??c==`=:wc=yyayc``byccwc|c|ccB|cB=b=ruuycByccccbbycccbbcc71.11.1.++11+++.4A!!__]]aa((&.(..1..1(14..xz|.441+441&++(++.+&(.+||PP!+&1&%&.(((&...P1++.(+rrw=:bcBBcBy`=`yc=?yytccwabcwcccBBcB|c|yycB?bbcwwbBcBwccycccccc741...(..(++((++1.7!??A=!]]a&+++&&.111.((4..||..++41.+&(+..&.&..yy|PP?PP&++.&.1.((4..&AAAPPA.+(((+_`]wrc?B?cayc:BcaB|cy|Bcc9BBbbbccywccBBcccc|c7111..((+(.+(.1.1A?!&&.+++(.11.+.(.(4{b|z|4+.&++&.1+.&(||||yy|+1.11.1&&&A:=PP?(&((r`bcB
-B=yyu:c=c?c|cy|y|||ccyybcucc|BBByyc|ccBBc44111++(+&(&&..+.14!AA!+.1(+.&((..1.(((.|..11.1+..++.+1..1.&+.y|..(...41.11===PP1bccBBBB=:bcaB:cbcBcccc|c|b7yyBB|bcccB6cBwccBcBBcycbB41+(+((.&(&(+.1.+4!!AA!!6.+&+.((&..1+.((({zz411.+.+.+..+11..y(MP|(11...A!!7OO=!$bBccBybccBcccyq:?wccccB9c|ybc9byc?bccyBBBbbcccBccbcBB41.((.&&(...+.1+.111..3!!!A!!!!B1..%+&+..(+11..(..|zc|zz11+11.1..++1+..yyP?MPOO41...&:?=#bBBccyccBBcatycww:yBuyc?BBBBb=y::??cccccywy?Bbbc@@ccBy4777411.+.++.++.41+441!A!{AA99++(G&+&++*(...+.+vxz{x{{++44.7.1.++...(+yy?O.1.+.&.A%BcB?c|BB?ycay:uw?Buucb|cc|BcBBB@@?bcbbBBByyB|BcBBBcBBy.711.1.1..(..++.11+1(..111.417!!zz|{!??..+((&...((+(.++.+.vvx|++.417.111...1+.1+y1..+.N:::A%B?BB||BBycty=w=?Bcy|6|cBcbcbccb=cBB?4.1.4..4(.(..1...+++.+..141477Az{{{.+++(++...(111+..+xz||.+..41..411.411yt..AA!!'cBBBBcc:ab:?y?@y?c||cwBBBccb?14.111..+.11...+.+.14.114x{7Az{{|{!Bhh+..(+..((+++..+++z|zz.4.4411.1..444PyNA4.!!::=(BBBBy??\ulc:B=ycyBcbaa??BBBccB==B?11..4114...&.+.&(1+1...((.14z|!{|?Bk++.(+.++..+.zx{zz|cc...411141.4.44yy!??A|!|A1+17?!!=P1[*BBcB``qobby@?cccc||9ByyaacBBBB?bbcB??c?++144..+.+.++((&++&4..+.1zz{z|!B4.(+.++1.+...+{zzz|..111.1.11.1|NNPPPMNNAO!.1.![[Z+y	c?cB===`a`o?yB?c|Bccc|cyyb99yb?bbBBBccbBcbcBcBbc?Bcyb?b1.1.1..1.((.&&++.&(1.(.14|z{{BB4...(+(+++..1.4+..+z|BBz.+...14yyPPMM!!.+4..N++..=!.4\[+Z-BB?Bcy=mlq=?B??cyBBBBBcB?cc@@?b==BBcBcbaacbccbbcBbb??...4.141...&(+(&&(+.+&((1((.1{|!zx|z!.+...111.&441+++.+.zz|@BBB|1.1.4111.11yy|y+||11..:11.=!7[Z[\[[[\[\\,?BBBc?bqqm\b:?B`??ccyBBBbbc?bBc|?Bbbbbubuu...+1+.(((+&+((.(((.(.11(x||xz{{{!!4..+++.++..11({{1.+..+zz{BcB414144.4+(N(PP.1++414+..11?AA.=\\Z[77[440ccB|Bclla^ya?bub^yBcb9B?BcBBBBcc==?b?BycbcsBb((.(.((11(+++.+441(++((14+{||{|z{|{{|!114..+..+...11({z|+...(+.zx{|{14144741414144.1(.:!!.=\4Z[r77472cBccBBBmoq::?bcb^^b?B?y99cBb?BBBcbcBbbbscc??((+1+.(.1(41++.(+&+.4..&+.(..1z{>{|zz{{|>111..&&+..41c1+++.x|||{B114114144474411.1471yP?P=!44BccBB?BmoooqcOcbabb?bbb?Bb?BBBcbB?bbccObccbubbsbbccb?Bb(((++.(.(1&+..1..&.1.(1&1.111{B|{B{{{z|{{|{41...&&..41z{|{(+++xzzBB7.14114411.44.4414114441114]?PPAAy6BBcBoabaab`b?cB??B?cubcBbbBBbBcbbu^bbccb*.(111+.((1..+...+..+.(.1.(..zzz{||Bc{zz4{41(..14|{{zz&+++{{|BB..4111411144..1.1+417]]]1]yAANNN:&cBcB^mm^qmbb^buub?bccBBBccuabb?Byyccbcbbubububb^B.+++1...71++..++..+.1.1xz{z{{|||{|:4||1(1414411{z{b{|c.11x|z{{BB..1.444111.1.1J1+447\\]PIO?.:<cbbuus^ooubbu^^ub^bssccbBbb?bccbb^bbuuccbbybccucubbcb.1(1..+7.++.+++.1..(..(41(({zzzBx{|z447411z|{|11{{{x4...1.44411.1.{{{1.4441[[ZNN41..1P+.414147+1+1=bbuussuss^suu^^sqq^^buubcubbubssbsbbbubBcccBBcccbcuuuub^Ob.+(+9.(1..1.+11..1((+4441+11zz{{zx|z|z{{z|44+41z{|!||c]4xxzz|.411414.1]1]1{xx4R\\\RRZyM..P...744..44++.+\4\\\[\\1>ssubb^usbos^sq^^sssb^bcbubbsbb^bbbbbu^bBccbqq^usbbssuubsubb&&(++11...&...+.411411+1B|zzxxcz{41+144\111z{zB|{{\{z{{z|1.1_]44x{{4\\[k[ytP111..+.7.4\\4r[\+\4[OA4477474.@bcs^^oosb^ouubbubu^bssbsbubub^^sbcbubbubbBBbBcbuuu^ubu^b^sb^c%&&&99.1+.....+141(.(Z{{||zzz{z{1\\\44.74.1c|Bzzxz||77\\[]]]\xzzz||x[1[kZkZNtO|..4.747\\[+\74\OA:777474441.Auub^^^b^qq^uusb^ubuubbuuubuc^^bBbcbccubbbubbbusbbbs^^c&(+.40..+..44+111((.+__|{cx{{{{zz{z>{4[.477+41|{||![z@Bz|\\\][[\{||||]1\[k\\]44\[\\77=rr=!474114417.1.11Cub^^^s^saaabc^uub^Bbcbbusbb^ubbuucccbbb^bbusbbuubb^b^uu++49..914411(1[zczx|z{||4[+.744z{z!!|z|\{{x{{z{z{{1\\[\[\ZR||{z[k[\7I1.y:[\\\r7\\\4==!41114.471.141.Emb^bsbssoucbub^bcucbccububqubububqqbb^u^.91.1961411[x{>Bz{|zz|{xx||[[4cz||{{|{|{|]]\\[z|{z|z|K[.1+:17..yy[\\[:r7\777=A411441441.411..-uuu^bcBucbbuubcsbubbbbuuubb^^bu^us^ssb-611..]44]|xBB{@@b|bz{z{|{|{z4444vv@>z|!|zxx@{|z!||\[\[\|zzz{||{[14:741..1.1.11y4447:\\[\\r[:r:7744=A174147141."b^bbbcubbbs^cbbubbbubbub?bb^bs^ub^cbsu4961_][{zzx{{|z|>|z444+1{b|z!!z|||{z{{B_]1\_xx].J14414.1...4.OA7477[\rrr7:477=447711717744744414174!>bubBBqObcuuucbububbcbc^bbbuubbub`ub\b```bby\\[w`11]_z{xzx|1.1]b{z|zz||czz1{\]1[1\44x||74.1+.11.4OA7474447`:`7:77:7174477:7:74:447744471444 
-^^bcbbObcbuubbbb^bb`buubbqb@bb`bbauba```yrrrt]]\\zx{||{Z44]]]\{|zz||4!!\71444zz.44.+..74441OA477::7:7:744717447144144771.447.11Nsqbuubub^^b^bbuuubb`bbubb@@Ar\\[7[[1411][][[[z|zZ4!!1\1Z]\\\1444{zz|xz|z{|41.1.1+.1714414O!774747:747477:744774747..74.11414741..1.Oqubbcb^^ba]``bbwwbb<<>uu19\t\rr\\\\[__]]\4[\\[\\[!\44[.41!!1\11\\\1774zz{|z@@{14.441474_44O!7=7774774:::7:=741.1.14111.4..111.1.3`bbbabww>>144414?994]\9_]rl\r\[[r]\\\\]\\[[ZZ[[[\]!!14411.4Z1\\]]1177444{x{|x{z|||4.4714144__4_O!7:=47:477.44147:744714.4111..++5>>Ax144744??	]9__r\\\\[\\\]]\]]]\\\[\\!!4111]1\_111447zxx|z|||47714144__]4774474:7?::747..74471474.4414144111.++J
-A?x{441741.41144997_\\p\]_\[[\]\[ZZ\\[]]1\4411441\]]14114447+z{zzz|||7_141_]]]__7444::=:7:77744771147.744141414741441.114111.9P{z7744.1447797]a:a_\prrrr\
-\[[[\\[\11\1\1\\\41144[4++zx{||(|]41]_]]\[\]_74474744747471744747141174777111.1.11'Az|B{4441144477rp:pa]rr\tttrr\\h[[\\]\[\\[\\\1144\&]\\117(++474zxz|zzz{|{1]]_]r[_747477\7:747747747414.7.14744474141141441414140	AA||z{7444[447_t_ra:`rr]]]_\\\[\\\[r[[\\\[\\[[\\\\4\\_1_1Z7[4747{{xzz]r\\]77477:7747:7747:74474.7477:44777441114711.1..1[[r[\7tt_aa77r\\r]]]\\\[r[h[\[[\\\\_]\\[]_4Z[[4777[|||xxx{BB{||{rr]]]44477:7114=4447147444111..4.4!!"/?{77[[trrrr9::a_raa77]\\]__a__]_]]]][\[[[Z[[[\\\\474r4]]xx|z{{rr=444r\:7:7:77:1:47:77:7147Z4Z:47771474744.1!4OAxx=zr\\]`r]p99tt_a477]r]_[[_4aa]\\[[\\[[[\[h[[r][|{z44777_]]h\]\]]4+r=7:\r:\r::777:777=44747441411444ZZ[Z47.41..1$8!?NP{cz|z]rrr\__::a\p\__a77aap_rr77477_]]\
-[Z[444[[zzz{z44[Z\\[]\\144`r\`w`rw=7:444777441474[ZZ1441144414117441447^!b{{{ra7\][p]___4\77a::4pp774_44_\][\\[[[\[4r\z|x|z{t\a]447r:77:rr747:77444_77_]41]7444[[4Z[41447171474477!"7Nxz|zczc_rr\7ar]__:[7:77::77pr:4]]\[[[	[[[[\zz||B|[\\\r[`\\\]]:r77[r\r4774]77a\4].77:7:1[4141147411141777:444%6Axzz{c|{||::77<prm[[]]::7<77\74aa\[f\\\Z[[	[[[]++++7\zzz{|[[\\`[[\]\\7r:7r::447:r7ba__]\aa4447414[4147441444:7744477:"!Az{{zzrz{r:7=:\t\[77<77::prrr::4[[\[\[[(r+[[\7x|||\\\\[]\_`_74r7\`7:a7__wa\_]]]\_444771144[4[Z444147741747::1411;!Abz||z{@`===:tm\aa777prpp\\\[[[[[\[\[z@BB\\\\]]rb`_=7r4]]_\rr\]]__]44r11141Z7[747444771741114114?Azzzzbzx{{|{:a9t\7::777p7\rrpa\rp[\\[\\r[{xzxx>||{`\\r]44a_]]r\\]\]_141411441[[4777414114441415!PPwAxvxc{zxxzaa\\7pppp777rr_7[\\\r{x|z|z>z{{{rr74]_]_]_\]\1]11414441447[4[[:7
-411411711Z=!A|v|{|{|{|{ta::7\777appZ_r\p\\\6363]__p\\p\77z{zz{xzzxz||{{rr_w]a_]_[\\_\]]1714[411747:7j!zbB{{|oaa<r7pp\:::77a__arrk\\]rr\:::7:zx{zxz|x\]_\[[\R]\\\]]]1174144[4:44\4417444111777141:==:37!zz{{ca]r::7p:::777aa_tppjpp]]4.[\7\7azzx{\]]_`[r[\R\\\]44[47477471747:7444174471:4:7::7:7::6{{$zz|{{]<6--67\\p777::77_\\\pp\\t\:06a7a7.777:{|{{z||z[\[r\[\\\]\\__1444[[47:77\7414747477:75z{,z||o**r::777\777:a__t]\\rr]tt]t]r006_a1777.7r:{|\r[\rr\r\[\\]]\__1144[[[\4777474417444777:477711477:::5zz|{zz{|{{a:::::777\\aa___]t]]aa-(4763\]r<177::rr|z|zxxx|{\r`rrr\\\[\r\_]_]1_447\4477:147447447744:477444777::6|$
-
-{|{z{z{=::=_[?<-:7\\a___]]]_]t__(44*33]_k**:77:\\r{{xz{|{{_r\\r\\[\r\\\]14_44477::r7:4147744444::4774744417473x{@{{|{{]`??=!???=`==:777\.1_]_a44<46**a77`p7{x|||r\[[\rr]\]\4]477r:47444477:77:747471+4+414172|z{|$x>?9:7:77++__7___::a77a(*:6ar:7.pp7ra\\zzr`r|{{r``\r\\[[\\r\]\\\]_4_474477rr44441447:74474:744+1141442zz{{|,|zzz>@c!?:77:=77:7a77__a7[7*9<77p\=r\p]p\wBrr\r\\r\\[]\\]\\__]44477rr747414r:]r7747477444111411771Bzz{z|c|!!??::777:::p44a7:77766k<<-+pp\p:7]]r]\\\rrB\`r`rZ[\\r\\[\]]\\]]\__74747r44br]]_r74744411171.4771{z|z{!!cc??9=7::7:\[:7:76(46--ap7r\7r]]Z\rrrB`\{zzrr\\[\\\[\\\__a_7:777447714bb]]__]44444774411.4.144141x|
-||cc!b!33*99:77qy777[[7::77:<:::6066ta:rp7a`r\\rz\[{?|\[\[\\\]r]_]_474477]1]44]_]]`[44[77444...1741.41{zz||@|!!!9::=\\]]\:7\\\7::7::06a4awrr\`\``zz{{{|r\\\[\[\\\]\]]]1444J7474477]]Z]]]]]]_`[[[477.44.14714+.40zxB|{{||``]q``\]\\\:777::446-<rrr[\`\{b{{r\\\[\\r]]]\1144J.4744+77\]]((]R]_+4447.441.444(+4(+/zxz@|||||
-]```]]]\]]:7rr4---446-40<\\\r`\r\z<\r[\\r\\]]_\\1141.1444Z](4Z](Z_]RZ]]744:777414.4141(4/xz{{||q\\qbbb==]==:77r:rr666+-44<<rr\`[\{|\\\]\\\\11]1]1]417++ZZZ(_\]ZZ]71774417714441141.1+44.zzz||
-zzzbzzbb==???=7r+4414-\`z|z{|b-\]]\11]]1]1117]\ZZ\\Zn](+1:7441144141...1:1-zzz>>zz@J!!=?==`rr``r+<4.((krrzz||z\]1\\1\111]1\\RZZ+.++.+47147114141.11.144+-{zzz{{||a!!?==rr::r(67>zB\]]\\1]\1]\r\ZZ+1.+]7(+744114(4144..14++.zz{|{|cc|cczzb==b??yww``6B<r|zz@BB|.+-h\\]\\]\]\\]]\]\]`]]rr\[(Z+++(n.1.1.++.4+4.41+11(14|z@{&||zzbbzz??!bbbwwwbr|||{{||9-9\\r]\\\]\\]_]_]_`rrkkZZ4(n741++4.+44+7114111.1(1+114/||zx||{(!||cczz!!w!!wwyyrr-z{zB|3\rr\r[[]\rr]]_a\r4.4\14.444.+44744++141+7(++(11.{z{|{{'|cc{www{{{wwr-<{{>{{zz{{{9++.r_]\__r\_]]]]+.r.17+477+1(4144147+1+4+.:1-zx{zzxB{7||{{{wyy{{\<<6||{{zB{{{{_r\_]]]Zrr7447711+1.114+41+(711:7++zzx||{xx{{||9b|c{||y{::rr<-{{{z|@\r]rrrZ]\.r7444+(+(+1(11144(4117+7+1471+||{zzz|z||{|'zc!!!{y{{r:Bb{>|BB:+\r]r_774.+(+(++(1+((7+:44(+4+111zzxzz|||@@{z{|	bx|||{::``::::6Batt`]:0Ba__]_BBB\r\rh_\747++(..17r(4+((+(1((+1.){{zBB|||zzz{{|bczbbz|||{{y{{``=:::===::006Battyyy=`rr::y0Ba__z|BB@@[[\[\\\[kr\447411.4111++4+.144.74.1.+)x|BBB>z{{{||{B{|bz{{z||cy=:p06Byabcw::raaa0@Btaa7|z{|@BBz{>@[\\\[h14.4114++1[4+11+..1(1141.414){x{z|B>||zzz{B|{{{{||{z||BB>@|c:==??=::706BBc:ar:a:a0@Br__aa{zzz>>>{{6:[\[[\r++1[444714+47744+Z444+4.1(.411.4*|{{{|||x||{||bzzb>@|:==:=??!?=?y4BBrru\r!=y:77aa0@B````aaa:{{7@||||14\\[ZR]tt171474+4+7+4414144.111411.1144.+{{{BB|	zz>{=zzc??@@z=!!::!!??!!???=yyy4BBrw=w:r===yr``7a0@Brrr::||:{{{B>BB|11:<r]pt\747+++4(44(++.+774..41417447(xzzxzBB{{|||z{z|||bz||||=={b!!??!`7:?|4BB=www:=77appr`rrr::{{az>BB||]p\\:477744(441+47744414111414774(zx{{{{|z{{||zz{||zz{{z@@|c|cB{!|{||?:wb:?w=:yy7::.rrr7rrr:77:77aa{{>BBB*{{-..h]p\Z.4::r774744411`47441414+.44114|{{{x{z{||@{@B{@B==|>>||B!>bbyy{{bb|||yybb=?==?w???===:=:r:``r:==c::777:::aaa||{xBBB||{{{{{p]]4r7774441[[474741114+447{zzz{B{=@!>BB@@?{bybb{bwyw!?=!!=w==rw:==``\\\77:r\77:paa4aa||{@||77:4\\[Z7\[[44114474(414414++4477{{|	|z!@@|>?{@@@czz|c{{y{bb{!!!www:r:r\\`=rru777:77r\\=44a_|{|z||{>1\__7:4\[\\[[Z\\Z+1114441(.144I14+744+:75z{{zz{@@@@BB>!>z|!{{{|b6==:```r:r```=\\:77:p::rppp\\=7::||@{{z{{||RRZ(.4[[ZZ[++441](4.4+1I]11444+474:77!!!)z{||{|{{z==|@B?|||>zzr`r:r```rr\777..7=rrraa__{{ZRhkR]Z.rr4.+1+++_]+](4411+_]]1414:444!!||z{|{{||z{{@@@{||>||!c0rr=r:r``.\777.++:77aaa_a{001pkkRZR]rrr1++++1(]4114]II+4144+	x|zz|||||	{{z!{z{{{||{!cB@6`::r=``\p..\:::+77:77a__z|z||+{||||13kRk\hR+444++4+]111]..II41]4144444+4!
-z||{|||@BBBzz||z|z{z{|||@cccrp.+::7aaa77paa___|{{z|{B{||{|ppRkZkZ(4414[]41]I.J[11]+_47447!!{xx||xzBBB@x{>{{{>|B!|66prp+\\7ppraa7aaa__zx{{{{{|{|p\pk]Z]_aa11\]]4][44]]IJ_I1]11_477474)xz|B|{@{{>>>z{{{|{{{{Bcc00633`\pppp77aaa_ttxzxzxz{xzz{{||ppp]]\]\\]_aaa4]]]4_]4]].J474!'<<z{||{{{|B||{{xB>{BBzz>|c*-rp7a___z{zz|{{|{{|\ppp]]r_4\]\\\__]4\__]]]J\J4447714447
-|||||||
-zzxB{z>>>B@||||{{|066rppa{{|{z{||{x|{||{{{|p\\pp]_r____44]]\]\]\]\]]]\]]\\\_44]1JJ4711447:>>	|||x|{{|{z{>||c|c<----*\\:{|{||{z{\p\\\p]]\]]]___4_]4\]\]\]\\\][]\\44411_7411.4744,>>||xz{{{B{B@cc|3:rrrz|xx{{z{{|||\\\]p\\]a_4]\\]]]\r\\[\r]\\1114]1_4447447.14)z{{{|!!	z|{{|{{B{{|xzz*9693pzzzxz{{zxz{z{zzzBp\rp\\]a_]\\]]]\r\\[[[\\]\111]44\47a747..74.||{||zz:???zz{B!{{zzzc<0rrr]]|||xx|z|{{{Bzpr\\]]_\\]`rr\[\]Z1]]]4\aaa7477.74447447||zxz||||zz{!!|{?!{{zz|{0paa_ttaaa]{xx{|x>>Bzzzz||||\t]]`[rr\[[[]\ZRZ_1]]]\a:474@||zzzxxz{x{||!!BBBzz=@@c||6- r::aa]aa|||{|||{{|z{|{z||{|\]r]h\[\\\k[]]\_11]]4\42|||xxxzzx{>|zz@@@zz{{@||czz*66 _rraa]]{{|z||x{z{|{{|{z{|z{|]rp][[\[[]\]]\\]]]44\747477AA!,zx{|zzz{>>|{zzz{0---066666-a77aar|z||z|{|{|||{{|||rrpr]hk]\[[\]4]_+.+4447447474+.4!xzzz{xz{{zzz{{{6:777_::::444_44|z{|z{]pt\\rpr\\	[k\k\]1_444.+444+444777++4[!>xzxz{zzzz{{|{|?*<000=:aaa::4777|rtr`rt\\[[Rk\p]44_.44+474[4[p44[4\M>@z{{z{{{{|90:8:::44app774a4447`rtw`t\\]\[\ap]___4444+44+4[\p[4\\Dx|zz|Bzzx||{@||-6::744aa:aaa::a7444777rwtrt\\g\\\]\[[\p\__]__]4444++74\[p[[>v{|::xxxB|{B|@@{?|>66
-7::777prr7pprr4::7444:4rrtttg\\p\p]`__]4417477+[[p7p\`[\\\=xzx{xzz@{{B@@|6663777a777yyrrr:::44747:44`]t\\pp\[p\]]]]___4_a7_4447444+ppp\[[\\\
-!/xv{v|	??BB666:;;7a777aa==`rrrr74__t``]arrrjp\\k\]__4_4p44pp\\\\[\.zx{v{>x>xB@@@B||z{>-336=:77[777:r:=74_7bt``r`jr\\p\r]]aaa]]4_4:p4\r\\\\rp[[\!
-/x{vv{z|BBzz{B|||b{|{-:\:7prr77:==:::77u`rrrrra``rrr\ppr\\r\\_]]]aa77__7rrrr\```\[[\[\\!!({xx{vxzx{{z{{|>{|6aa]`==::7==r==:::``rrr]`]]r\t\r\\p\\r\\\]]_7]]4a_77a74pr\\r7rrr[\\7rr\[74\!!!G||zzxzzz{|||||c>``]]\``]]\]]]::===```rww==::]\\]`\\r\\rrp\\p\\]]aa7rr_a44777rr[\7r\[[r77:pp\\r7!!!
-!6
-z|{z{:zz>{{{||600@@30066`]\\]\\]]]==:==rrbbbczut]]]ytwr``\\rr\`\rr\\\rp\\]\tarra7r4p\pppr\777p\\r\rr:4A!!!!Czxzz{xzzzxz>zz||B<3@@306]]]``\\\`\\]:??y::````_ty`a``rr``ww``rr`rrrrr\\rr\p\\]\\ttaa74\rpp\\777[\p44!!!AAD||||zzzz|z{{{|xzzz|{B3@@39]b`]]\\]]```aa|??yyy`__``wrrr`rr````r\\\r\r\p\\\ta7r444pprr\\\p\[[[a[[rppp44!!!!AAA!AFz{zz||{z{{zzz||||'3@--aaa``]]`bby==yyy``uu::ctr`rrr``wr\r\\\p\\ttarrr4r\p\rrr\p\\\[[7[4!!A!!!A!??A{{{|{|z|zz|z|?|@bbbzba\\`::y:yccyyccycctwrrrrww\r\\p\]tt_::aa7r``\p\\\[`p[[[7r4!!!A!!!!!?$'z{{||?	bbzzzbbaaac:=yy:::cccbbccttrwrr``rrr\r\\]]trrr_tta::rr\pp\pp.pr4pppa444:44!AA.
-{{{{
-zbbbcz!||cyycc:yyccbbyc{{yyb``rrrrrr\\\pp]`t`rratatttaraa7a7p77pppr47pp77pp7_7]:a]]!!!+@!?!||??zbcc|yybyybbw````rr`\\p]`tta]a____r77aa7ppp\47444__bbba!!!!1
-@{!|!!!yy!!|b|cc||wwbb``rrr\\]]\]]]\_t]_]_::aa777pp[[pp74]____!!!+	!A!
-Bbb|!??!!!|ccy|cywwwwr\\\\r]]]\\\]_]]:rraa77a[p[[pp_44+4___AA!!
-||@B||c||!!??|{AAcbbcc||cc|cccwbbwr`rrr\rr\\]\]]rrr]_r``arpppp_]+]_aaaAA
-
-!!0<@B!{{!!{{{|{z|bbcywww``ww```rrr\]\]]`rrp7p_4]Zaa]!!(!!|0<@B{{zz||z{{zz|bbwwwbbrr``ww`wr\p]rr]trr7744_]r]]__]]1]Z\]]	!AA!#!!!	|{yy{{zzzcz
-```rrppr]rrr]]_t]rrrr7_4r]11\[\\]]! |{{z{{|||AAccbbw``wwwww`ww``]\\r\]_l__rrrrr]]]]\\R\\_]]AA!!
-
-|{{A|cccbww``wwr\\]\]_ltll__t_rr]\]p\\_]]\\]!	! !!'		||!{cczzcc|	bbw`\\\pr]\_ttlt_```a]]]\\]p\]_]\\Zr!!!!!!!!	!$||{{|||||{ccccww`a`\\rrtllttlt_a``_ZZ\]\\]\\\]]\Z\\!!!!!|||{{c|wwaawrrrt]oooll_t_aaaataaaa__]Zppp\]	\A!!!!!	!!!||{{bb{{{	yywar]]tl[__aaata::aaa__p\\]]\\]\\\[\!!!	!!!!!!!"
-||{zzc{{{ccyywwaawwa]_tollt[t___aa::aa\\p\\\]\[\\Z[!!A"!AA2{{zzc||cbb
-bbywwwbb_tatt__t_aaa\p]p][\\][[\ZZAA!!5{cccbbcyyyybyytattta:t____\p\]]]\]]\[\!?!!'zzccybbb::yaa_aa:t_aarrr]]\\[Z\k\!!!!
-|||{{	bbccyybbcyybbyy__]t_ta___tt__aarr]\\\][\[kk\\f!!!|{bbbcbybb_aaa__ta_\\\]\\[ZZZ[\\
\ No newline at end of file
diff --git a/makedata/land0003.pal b/makedata/land0003.pal
deleted file mode 100644
index 538e3de..0000000
Binary files a/makedata/land0003.pal and /dev/null differ
diff --git a/makedata/land1.cpr b/makedata/land1.cpr
deleted file mode 100644
index 5c74f06..0000000
Binary files a/makedata/land1.cpr and /dev/null differ
diff --git a/makedata/land1.pal b/makedata/land1.pal
deleted file mode 100644
index be457c6..0000000
Binary files a/makedata/land1.pal and /dev/null differ
diff --git a/makedata/land2.cpr b/makedata/land2.cpr
deleted file mode 100644
index 8c4da94..0000000
--- a/makedata/land2.cpr
+++ /dev/null
@@ -1 +0,0 @@
-
\ No newline at end of file
diff --git a/makedata/land2.pal b/makedata/land2.pal
deleted file mode 100644
index 528b767..0000000
Binary files a/makedata/land2.pal and /dev/null differ
diff --git a/makedata/lilship.cpr b/makedata/lilship.cpr
deleted file mode 100644
index ee6bfd4..0000000
Binary files a/makedata/lilship.cpr and /dev/null differ
diff --git a/makedata/log.txt b/makedata/log.txt
deleted file mode 100644
index 6d592d2..0000000
--- a/makedata/log.txt
+++ /dev/null
@@ -1,1331 +0,0 @@
-SENGZHAC
- The references left to us in the first data buoy
-in no way exaggerated the ^Sengzhac^. We found
-them to be single mindedly cold and calculating
-just as the buoy described. A hive mentality
-pervades them. Because of this they claim a
-higher morality. They feel justified eliminating
-anything that might come between them and their
-precious "God's Eye".
- Their fanaticism does, however, betray a note of
-fear. Whatever the God's Eye is, it must be
-enormously powerful to disturb such a stalwart
-race.
-
-
-
-
-
-
-
-
-
-
-
-
-Home World = Zamiu (51.4,9.9,174.3)
-
-D'PAHK
- "The Children of the Sun", as they call
-themselves were strange, worm like creatures.
-Our first dialogue appears to have been a
-success, with stress on the word, "appears."
-Their odd appearance did little to
-make the talks go smoother. I'm sure the
-psychometrist did the best they could when
-transmitting the lingual key, but the tone
-in the ^D'pahk^ cypher-voice makes me
-suspicious. I worry that they were too anxious
-to befriend us so quickly.
-
-
-
-
-
-
-
-
-
-
-
-
-
-Home World = Suenyo (134.6,122.2,131.2)
-
-AARD
- By the dust of the Earth! I would never have
-thought it possible. We have encountered a
-race that matches us genetically. The odds
-for such an encounter are beyond astronomical.
-Surely my eyes do not betray me. Even so, I
-question what I have seen. The blatant rudeness
-they wield is a bit more than I could stomach.
-Unfortunately, the mighty ships they flew kept
-me from responding in kind. I would rather lose
-my pride than my life.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Home World = Unknown
-
-ERMIGEN
- This was the first race that we have
-encountered that did not make me uneasy. Even
-though the ^Ermigen^ were over zealous they
-were straight forward about it. I only hope
-they don't have us on their "list of celestial
-bodies which must be eliminated."
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Home World = Mytuk (116.5,146.0,28.6)
-
-TITARIAN
- Interesting... We have encountered a race of
-clairvoyants. From analyzing the cypher key
-psychometry believes that the ^Titarian^ evolved
-the natural ability to see into 4-space.
-Such innate abilities were limited but with
-implants and genetic manipulation they were
-able to enhance their ability enormously.
-An alliance is in order... especially if we
-find it necessary to call upon their services.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Home World = Rehez (69.1,47.2,210.7)
-
-QUAI PA'LOI
- First contact with the ^Quai Pa'loi^ was truly
-a moment to be remembered. Only in holy books
-have I had to sort through such deep thoughts
-and circular speech. Their syntax must be a
-nightmare for the cypher key to have provided
-such a poor translation of their language.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Home World = Baal (32.1,148.3,138.4)
-
-SCAVENGERS
- What at first seemed to be a derelict
-was instead a manned vessel. A hodge-podge of
-burnt and broken panels covered the hull
-of the ship. Mangled fingers of steoplast
-jutted at odd angles and sections of the
-structure seemed to be missing. Others
-served no observable purpose.
- We were attempting to salvage the craft
-when this transmission was received by
-psychometry, "We assimilate." Even after
-constructing a lingual key communication
-was difficult. These Scavengers, as we have
-come to call them, are assimilators that
-live between stars. From what we were able to
-gather it seems they absorb anything of
-use with which they come in contact.
- They were voracious for input, and in an
-attempt to greet them hospitably we sent them
-the general encyclopedium. I believe now this
-was a mistake. They took what we told them of
-our history and began making warped
-conclusions about morality. Immediately they
-applied these conclusions to themselves and
-attacked our ship. I have the feeling we
-haven't seen the last of them.
-
-ICON
- After what seemed like an eternity psychometry
-finally generated the cypher key. We can only
-call them the ^Icon^. They evolved completely
-without a spoken language and, as a result,
-communication with them was difficult.
- After days of observation we discovered that
-they use an intricate system of body language
-to convey simple thoughts. Longer signals
-require that they "weave" their messages.
- We were confused at first when they sent us
-cloths and fabrics in exchange for our cypher
-key. In a stroke of genius a loom was constructed
-to weave our messages and surprisingly, the
-translation was a success!
- With this tool in hand we proceeded to discuss
-the matter that brought us to them, the
-Scavengers. The Icon told us of an ancient
-alliance called the Kendar. They told us that in
-order to defeat the scourge we would have to
-reunite the Kendar. If the empires continue to
-be as uncooperative as they are unfriendly
-all is lost.
- We can only hope...
-
-Home World = Hadekou (145.4,140.4,8.7)
-
-GUILD
- We have found a market in space! A race whose
-name roughly translates as "^The Guild^"
-approached and hailed us. They transmitted their
-cypher key along with a complete list of
-exchange rates for the last four hundred chrons.
-Bent on making material exchanges with us,
-their introductory speech sounded more like a
-sales pitch than a greeting. I am not, however,
-dissuaded by our new friend's motives.
-We may find our contact mutually beneficial.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Home World = Onan(219.3,27.5,203.2)
-
-VOID DWELLERS
- While flying through a dense cloud of
-dust and rock we happened upon beings
-composed of the very same stuff. They
-called themselves ^Void Dwellers^. Strangely,
-they required no cypher key. They transmitted
-their first message completely without the
-need for translation. The openness with which we
-were greeted put me at ease. I found myself
-to be very comfortable around our new discovery
-and soon we were talking as freely as if they
-were as human as ourselves. Their knowledge
-of our language confuses me, but psychometry
-insists that they can be trusted.
-The universe never ceases to amaze me.
-
-
-
-
-
-
-
-
-
-
-Home World = None
-
-GREETINGS AND HALLUCINATIONS
- At long last we have awakened. A mysterious
-distress call activated the encode power-up 
-sequence. Once the personality matrix was fully 
-powered we discovered that our ship was badly 
-damaged, and the ship to which we had responded,
-was a scorched ^wreck^ on the surface of the 
-planet below.
- Strangely enough, during personality power-up
-there was a power surge in the memory core...
-...I experienced a hallucination, a vision of
-sorts. A shadowy form spoke to me of awakening
-the iron space between thoughts.
- Psychometry assured me that the experience was
-only a malfunction and should be ignored.
- I can't help but wonder...
- Hallucination aside engineering has initiated
-repairs to the ship and has discovered that the
-chronometer failed shortly after leaving Mars.
-It's unknown how many years, decades, centuries
-or millenia we've been adrift for. Astrogation
-has been unable to map the stars we see now to
-what we could see from Mars... We are lost.
- Science has recommend we send probes down to 
-the planet surface to investigate the wreckage.
-I can't help but concur with this ^advice^.
-
-SECTOR CODEX
- We discovered a data buoy left by the other
-ship at (16.6,22.6,3.3). A great deal of the
-information stored was irretrievable.
- Fortunately, the encryption codes were similar
-to our own... Most clusters were lost, but
-a few data chains yielded to our efforts.
- After decoding the information contained within
-the buoy, we discovered the flight logs of the
-Scavenger ship. Interestingly enough we were
-able to use their crash sight as a reference
-point and have since added the stars from these
-logs to our own sector codex.
- It would make sense to follow the trail they
-left us.
- While I have some trepidation about travelling
-into deep space again engineering has assured
-me that the malfunction has been fixed and
-additional failsafes have been added. Regardless
-we have little to gain by remaining in this
-system.
- Of real concern, however, is our low levels of
-fuel. We will need to scavange ^anomalies^ from
-planets and hope we can gather enough to make
-more fuel nodules. Alternatively I could talk to
-engineering about using ^minebots^.
-
-SECOND BUOY LOCATED
- So, it seems that our Scavenger predecessors 
-left us a second buoy discovered at 
-(22.0,47.0,34.0).
- Many of the data clusters cross-checked with
-the other buoy suggest that the two contained
-identical information. We were delighted to
-find that the recoverable data chains were not
-all the same.
- We assembled some of the system notes that
-were to accompany the sector codex we
-retrieved from the original buoy. There were
-several references to a race they encountered.
-The ^Sengzhac^...
-
-
-
-
-
-
-
-
-
-
-
-
-
-HALLIFAX MANEUVER
- While in the Igua system (108.5,110.1,245.6) we
-encountered a group of ships engaged in combat.
-At first we thought we were witnessing a battle
-between rival races; ships from many of the
-empires were mercilessly attacking one another.
-Then, close enough for a full scan, we saw that
-races we had believed to be at peace were
-slaughtering one another.
- We hailed one of the ships and were surprised
-to find that this was not a military action at
-all. The ships were involved in a religious
-rite! Communiques with other ships provided the
-same response. This Hallifax Maneuver, as they
-called it, was to prepare the way for the
-inevitable coming of a group called the
-Papesian Monks.
- While we don't yet know who these monks are
-or why they would encourage such a variety of
-races to exterminate one another we didn't want
-to interfere by interrupting the ritual.
- Disturbed and confused, we finished our scans
-of the system and continued on our way.
-
-
-Hallifax = Igua (108.5,110.1,245.6)
-
-TROJAN GATE
- Trojan points are points in space that have
-zero gravitational potential. It was theorized
-that because of this strange property Trojan
-gates could be used to facilitate a space jump.
-The invention of a "Trojan gate" was still far
-out of our reach, but, to our delight, we
-discovered just such a device. We managed a
-first sweep of it before it activated and were
-puzzled to find it covered with symbols similar
-to those referencing god's eye in cypher
-keys. Perhaps there is some deeply rooted
-connection. Who can tell?
-
-
-
-
-
-
-
-
-
-
-
-
-Trojan Gate = Oetus (238.9,169.5,131.4)
-
-A PLANET'S DESTRUCTION
- While in the Oetus system we were surprised to
-learn that the Guild was responsible for the
-extermination of a native race.
- It seems the Ylinthylixymn as they called
-themselves had been working as indentured
-servants for the Guild in exchange for the
-terraformation of their world. They were hoping
-to turn their world into a paradise.
- Sadly, the process went awry. Some of the
-biomaterials the Guild was using mutated. The
-viral bodies that resulted were similar enough
-to the Ylinth body chemistry to wipe every one
-of them it came into contact with.
- The plague was so swift and unexpected it wiped
-out the entire population. Even those outside
-the system could not escape. Within less than a
-millennium the Ylinth were extinct.
-
-
-
-
-
-
-
-
-
-MONKS OF PAPESIA
- We discovered and were finally able to scan the
-Papesian system. Surprisingly we found no trace
-of the Monks responsible for the Hallifax
-Maneuver. What we did find was a giant hologram.
-Visible from orbit, this strange beacon informed
-would be pilgrims to seek them elsewhere.
-According to the message they had relocated and
-would shortly call forth the followers of
-Hallifax. The message was difficult to take
-seriously. Considering the magnitude of the
-Hallifax and the amount of life lost as a result
-we were appalled to think that these Monks could
-be so whimsical.
- Sentients are strange.
-
-
-
-
-
-
-
-
-
-
-Papesian Monks = Papesia (107.3,117.8,194.3)
-
-DERELICT DISCOVERED
- While entering the Suenyo system scanner sweeps
-detected the presence of a massive ship along
-the outer rim. A full scan revealed a gutted
-hulk the size of a moon. Violently mangled in
-some ancient war the ship was too heavily
-damaged for us to recover any of the data
-storage units. A few other items were recovered,
-however.
- One in particular was a translucent sheet of
-metal that was unaffected by the inferno that
-burnt and blackened the rest of the ship.
- I wonder why the attackers were so thorough in
-this ship's destruction. What reason could they
-have for such overt aggression?
-
-
-
-
-
-
-
-
-
-
-
-
-DEVELOPMENT OF THERMOPLAST TECHNOLOGY
- After much adieu it has been developed. A
-thermally dispersive material so effective that
-even high grade atomics cannot penetrate or melt
-it.
- The tests run so far have shown a consistent
-kinetic dispersion rate of 5 kilojoules per
-square centimeter per second! We now have
-probot designs that incorporate it.
-Thermoplast will ensure that our scans of
-infernal planets will no longer damage our
-probes as they have in the past. The design for
-reflective hull has also been altered to include
-the material.
- Despite my enthusiasm I am worried about the 
-design. While science assures me that the 
-chemical makeup will withstand the most
-torrid infernos I have my doubts about it 
-staying power. The material may spontaneously
-decay leaving our probes vulnerable. This is
-only speculation. Perhaps, I should leave 
-science to scientists.
-
-
-
-
-
-ENCOUNTERED NOVA
- While in the Tyr system the sun's core became
-violently unstable and the result was a nova.
-To the best of our knowledge the sun was
-innocuous when we entered the star. We still
-have no idea how or why the sun would go nova
-in such a short period of time. The chief of
-science is investigating the incident but no one
-is expecting any answers.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Nova = Tyr (247.4,123.3,163.5)
-
-LOCATION OF SHUNT CAPABLE SHIP
- A great deal of time has been spent by our
-science team developing shunt drive technology.
-Once again fate is with us. While scanning a
-planet in the Tetun system we unearthed a
-massive ship imbedded deep beneath the surface.
-Interestingly enough, the ship was designed much
-like the derelict we discovered and was
-similarly gutted. This time, however, the drive
-of the ship was intact. Fortune was ours! It was
-a shunt drive. Science is investigating the
-damaged drive and promises to have some answers
-for us soon.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-DESTRUCTION OF THE MALZATOIR
- Since we first encountered them the Scavengers
-have been a nuisance. Until this point that is
-all they have been, a nuisance. We were recently
-informed that a fledgling race, the Malzatoir,
-were consumed by the Scavengers. We also have
-reason to believe that the Scavengers now have
-every intention of assimilating every race with
-which it comes in contact. This makes them a
-major threat to us.
- We had hoped to learn from them, but it seems
-there is no choice. If we hope to claim for
-ourselves a habitable world we must make sure
-Scavengers do not spread from here.
- The scourge must be eliminated.
-
-
-
-
-
-
-
-
-
-
-
-
-DISCOVERY OF ICON DATA BUOY
- While performing routine scans of our system
-we encountered something very bizarre. A drone
-approached and hailed our ship. We were
-surprised to learn from the message it sent that
-the tiny craft was Iconic. We were being
-summoned by the speechless sages!
- Other than wishing an audience with us the
-transmission was vague. They did not even bother
-relating their homestar coordinates.
- Fortunately, we analyzed the flight path of the
-device and now have an idea where it could have
-originated from.
- Realizing that the Icon would not contact the 
-outside without good reason I have made travel 
-to their system an immediate priority.
-
-
-
-
-
-
-
-
-
-(Either Theta or Delta Sector)
-
-THE GUILD JOIN THE KENDAR
- The Guild showered us with appreciation
-for our efforts today. After retrieving the
-Ylinth genome and bringing in the pirate
-Derraak, their skepticism was washed
-away and we were treated as heroes. After a
-lengthy ceremony inducting us into Guild history
-we were sent an official writ proclaiming the
-Guild as members of the Kendar. I sent them
-a letter of thanks and forwarded their writ to
-the Icon homeworld.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-TEMPLE OF IRON
- We have strayed far from our search to find a
-habitable world. Caught up in what seems like a
-religious crusade we are instead in search of a
-holy relic. Hinted at in the first data buoy
-we recovered, God's eye was described as
-"a fist of black iron some fifty kilometers
-across orbiting the star of the Deol system."
- We had planned to investigate this anomalous
-object after we had found a viable world but the
-events of the past few cycles have made it
-imperative that we study the object first.
- Several cypher keys of races we had encountered
-contained references to a place called the
-temple of iron. As in many cypher keys religious
-references are arbitrary. We considered the
-temple to be ephemeral. Not so!
- Using hints from the Void Dwellers and a
-large explosive device, we unearthed ancient
-ruins far beneath the surface of a planet in the
-Dubofang system. The excavation yielded more
-questions than answers. What is the function of
-the "channeling" device we found? What race was
-responsible for the creation of the temple? And
-why is our fate bound inextricably to this
-mysterious God's eye and its creators?
-
-INSIDE THE PIRATE BASE
- After tracking down the pirate Derraak and
-retrieving the shunt drive we took it upon
-ourselves to pick and choose from the hoard
-that this notorious figure had collected.
- Unqualified to be arbiters ourselves, we
-trusted the Guild to be impartial and notified
-them of the hoard, asking them to parse out
-these items to those to which they belonged.
-I do not envy the Guild. Judging from the number
-of items in the stash it will probably be a long
-and arduous process.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-PIRACY!
- It seems that a craft sped up alongside us
-during transit. The gaping hole in our
-midsection backs that theory. Of all the
-degrading deeds...
- The shunt drive, for which we worked so hard to
-locate has been taken from us.  Derraak and his
-stealth ship are surely responsible for this 
-outrage.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-ICON TRANSMISSION
- A second drone from the Icon has arrived.
-and the message is simple.
-
-
- "They have killed again. Come to us..."
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-ERMIGEN DATA TAPES
- We returned to the Ermigen homestar to find its
-planets purged of life. I pity their dead. The
-Scavenger scourge left nothing living.
- All hardware was stripped from the surface of
-their worlds, and the remaining organics were
-perverse mutations of the originals.
- With the planetary shields down we completed
-our scans. While nothing of use was left on the
-surface we did, however, locate a data storage
-facility buried in the crust of the planet
-wherein their defeat was recounted.
- We were interested to learn that during the
-final battle their flagship, the Cargan, fell
-into their sun trying to evade a wing of
-Scavenger incorporators. It seems the crash
-killed the crew but the ship was shielded by
-a temporal anchor and was unaffected. They gave
-orders to retrieve the ship, but the last of the
-space born fleet was destroyed before receiving
-the message. Shortly thereafter the planetary
-shields were penetrated. Screeches and laser
-fire fill the remainder of the audio data. The
-video... it was too horrific to describe.
-
-
-
-I AM AN IDIOT
-This log exists because we couldn't find
-a better way to structure the plot-log system.
-You see, this log shouldn't exist at all...
-in fact I despise this log. I hate myself for
-knowing that I was somehow responsible for
-it's existence. I only hope that the person
-who is reading this can forgive me for
-allowing the bug to exist that let them see it
-in the first place.
-
-
-
-
-
-
-
-   PLEASE REPRT THIS ERRER 2 CHANNEL7
-
-   KEEP AN EYE OUT FOR OUR NEXT KILLER
-   GAME, FRINJ (IT MUST BURN)
-
-
-
-
-
-
-THE ERMIGEN WERE DESTROYED
- The mighty fist of the Ermigen empire has
-fallen. We received word from the Icon that
-another race had fallen victim to the Scavengers
-and we were frightened to learn that the proud
-shark's kin had fallen. This is indeed a sad
-day. According to the Icon not even a single ship
-remains. It causes me great pain to think that
-an entire race could be hunted down in cold blood
-...systematically destroyed. It is evident that
-no life is safe as long as the scourge lives.
-The Scavengers must be destroyed.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-THE AARD JOIN THE KENDAR
- Not even the most arrogantly powerful are free
-from concern. Having recruited the Sengzhac the
-Aard followed suite by joining as well. The
-Aard would have us believe that the time was
-preordained, that they had no reason to fear the
-scourge, and that now was simply the "right"
-time. We know better. All the arms and technology
-in the universe can buy you security, but it
-can't buy you peace of mind.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-REFORMATION OF THE KENDAR ALLIANCE
- The Icon have summoned us. Originally, our
-mission was to find and populate a habitable
-world... to have our own place in the stars.
-Now everything we have dreamed of is threatened.
-The Icon have summoned us and the news they have
-is grave. The Scavengers have assimilated an
-entire species, the Malzatoir. To make the crime
-more heinous, the Malzatoir weren't even space 
-faring. They were fledgling sapients...
-peaceful.
- According to the Icon, long ago beings of equal
-danger sought to dominate the free worlds...
-An alliance was created to defeat them. This
-alliance was called the Kendar. As the original
-organizers of the Kendar, the Icon have selected
-us to be their liaisons. We are to gather
-together as many of the empires as possible and
-with a united hand we are to crush the Scavenger
-horde.
-
-
-
-
-
-
-
-REPAIR THE ERMIGEN SHIP
- I'm not sure if I would say that the Ermigen
-were pleased because we helped them repair their
-ship. I'm not sure the Ermigen feel much of
-anything.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-ERMIGEN JOIN THE KENDAR
- Confused, we accepted the Ermigen Rod of
-Alliance. Their behavior in the past made
-it seem unlikely that they would, but the
-strange shark people were more than willing
-to join the Kendar. Considering the kind of
-fire power they control I was thrilled to have
-them join.
- Perhaps now that we have one ally the other
-empires will be more apt to discuss a treaty.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-TITARIANS MENTION BRIGHT SPOT?
- I'm unsure what the Titarian seer meant when
-he said he saw a "bright spot" in our future.
-Perhaps our journey is nearly at an end. Could
-it be that our work is almost done?
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-SHUNT DRIVE RESEARCH COMPLETED
- We recently completed research on the shunt-
-drive. Unfortunately, we will not be able to
-implement the device. The technology used to
-design and build it is still beyond us.
-Interestingly enough, it will be possible to use
-it one final time before its circuit integrity
-is compromised. When this journey is over we
-hope to resume our study of the artifact...
-...but until that time the device is of no use.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-GUILD WANTS DERRAAK ELIMINATED
- We had hoped that returning the Ylinth genome
-to the Guild would sate them, that they would
-join us but they are not yet satisfied. They
-wish us to do one more thing before they join.
- A pirate has been causing them a great deal of
-trouble. As a result, trade has all but ceased
-in Epsilon and Zeta sectors. They have made it
-our job to hunt him down and eliminate him.
-My patience grows thin.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-QUAI GO TO WAR
- Has the universe lost its mind? I can see no
-sense in the civil war which has erupted on
-the Quai Pa'loi homeworld... and in a time that
-requires total unity! The Quai had best come to
-terms with themselves. If our victory is in
-jeopardy because they weren't able to lend us
-their fleet I shall personally see to it that
-every last one of them is assimilated by the
-scourge.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-THE MOCH HAVE THE GOOLAS
- I believe we have something that will turn the
-tide in the Quai war. The Guild have informed us
-that the Phaedor Moch possess weapons the Quai
-consider holy. They are called the Goolas. If
-we are to quell the Tetrad to have them join it
-is imperitive that we acquire these Goolas and
-give them to the Quai.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-ENCOUNTER THE PHAEDOR MOCH AND REPAIR THEIR SHIP
- If I have ever said that this race was strange
-or that race was odd I take it back. Today we
-contacted what was by far the most outlandish
-organic species we have ever encountered. Each
-being seemed to radiate several different
-psychic patterns. Their mentations were so
-strange that a single low level scan nearly
-drove our psychometrist insane. We managed a
-cypher key, what little good that did, and
-opened dialogue. This race calls itself the
-Phaedor Moch. Aside from repairing their ship
-we accomplished nothing constructive. Our
-dialogue was meaningless. Unless we show an
-expressed need we won't be speaking with them
-again.
-
-
-
-
-
-
-
-
-
-Home World = Unknown
-
-GUILD TELL YOU HOW AND WHERE TO DEFEAT DERRAAK
- Since our last dialogue the Guild have located
-the pirate they wished us to rid them of. They
-have been gracious enough to transmit his
-coordinates along with a suggested means of
-capture. They cannot guarantee how long he
-will remain where he is so it is imperitive
-that we go as quickly as possible. The Guild
-also tell us that we will require a Homing 
-Device to find and destroy his base.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Pirate Base = Fabexi (153.8,99.0,196.9)
-
-FIND TEMPLE OF IRON
- While scanning a planet in the Dubofang system
-we noticed a strange perturbation on the
-surface. An incredibly dense pocket of iron
-lies buried in the planet's crust. The globule
-is several hundred meters across and, according
-to our scans, is hollow. Our science officer
-considers this a considerable find and suggests
-that, given time, they would like to study it
-further. If only we had a way to unearth it...
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-Temple = Dubofang (4.3,227.8,240.6)
-
-GUILD THANK YOU FOR YLINTH'S GENES
- Had the Guild shoulders a great weight would
-have been lifted from them today. We returned
-the Ylinth genome to the them. They showed
-considerable thanks, but to our consternation
-they still refused to join the Kendar! They
-were indecisive about what else they would have
-us do. They asked us to be patient and wait.
-Be patient and wait?!
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-VOID DWELLERS TELL YOU ABOUT GOD'S EYE
- We have finally been given the exact location
-of the God's eye! The secret which the Sengzhac
-have kept so long will finally be revealed.
-The journey through Sengzhac space will
-perilous at best but if luck is with us I feel
-we can make it.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-God's Eye = Yned (1.9,127.1,88.1)
-
-RECEIVE DOOM GATE
- Our efforts have been rewarded. The Sengzhac
-have joined us in the Kendar. I had thought
-their animosity would be too much to overcome,
-but with the demise of the Malzatoir and then
-the Ermigen no intelligent being could refuse.
-In an attempt to heal old wounds the Sengzhac
-offered us a device called the Doom Gate.
-It is a weapon of awesome destruction as well
-as a piece of the Mobius device.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-RECEIVE THAUMATURGE
- The D'pahk were very helpful in joining the
-Kendar. Not only were they kind enough to lend
-us the better part of their fleet for the final
-assault but they gave us the Thaumaturge.
-It will be interesting to see how effective it
-is in battle.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-TITARIAN JOIN THE KENDAR
- We uploaded what we learned from our study of
-the shunt drive. The Titarians seemed pleased
-and moved to join the Kendar. To each his own,
-I suppose.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-QUAI PA'LOI JOIN KENDAR
- The bitter civil war between the Quai has
-ended. The Goolas given us by the Phaedor Moch
-were crucial in deciding the victor.
- The Q'ooul who were open to free trade (which
-we later learned was the reason for the war)
-cleaned up after we gave them the weapons. I
-realize that doing so gave the Q'ooul an unfair
-advantage but the lives lost are nominal when
-compared to the life that could be lost if we
-do not successfully complete our mission.
-Destroying the scourge is of utmost importance.
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-DISCOVER YLINTH GENES
- While in the Sigonib system we discovered the
-remains of a research facility. We scowered the
-structure for useful materials and found a
-transparent cylinder containing some foreign
-organic material. The canister was labeled
-"Ylinthilixymn Genome Project." How curious.
-
diff --git a/makedata/logmake.pas b/makedata/logmake.pas
deleted file mode 100644
index 4d4f267..0000000
--- a/makedata/logmake.pas
+++ /dev/null
@@ -1,76 +0,0 @@
-program makecomputerlogs;
-
-
-type
- titletype=record
-	      id   : Integer;
-	      text : string[49];
-	   end;	   
- logtype= array[0..24] of string[49];
-
-var
- l: logtype;
- title: titletype;
- ft: text;
-
- i,j,a: integer;
-
- f: file of logtype;
- f2: file of titletype;
-
-begin
-   assign(ft,'makedata\log.txt');
-   reset(ft);
-   assign(f,'data\log.dta');
-   rewrite(f);
-   assign(f2,'data\titles.dta');
-   rewrite(f2);
-   for j:=0 to 49 do
-   begin
-      title.id := j;
-      readln(ft,title.text);
-      if length(title.text)<49 then
-	 for a:=length(title.text)+1 to 49 do title.text[a]:=' ';
-      title.text[0]:=#49;
-      for a:=1 to 49 do
-	 case title.text[a] of
-	   ' ' ..'"': title.text[a]:=chr(ord(title.text[a])-31);
-	   ''''..'?': title.text[a]:=chr(ord(title.text[a])-35);
-	   'A' ..'Z': title.text[a]:=chr(ord(title.text[a])-36);
-	   'a' ..'z': title.text[a]:=chr(ord(title.text[a])-40);
-	   '%'	    : title.text[a]:=#55;
-	   '^'	    : title.text[a]:=#200;
-	   '@'	    : title.text[a]:=#201;
-	 else title.text[a]:=#1;
-	 end;	     
-      writeln(title.text);
-      write(f2,title);
-      
-      for i:=0 to 24 do
-      begin
-	 readln(ft,l[i]);
-	 if length(l[i])<49 then
-	    for a:=length(l[i])+1 to 49 do l[i,a]:=' ';
-	 l[i,0]:=#49;
-
-	 for a:=1 to 49 do
-	    case l[i,a] of
-	      ' ' ..'"': l[i,a]:=chr(ord(l[i,a])-31);
-	      ''''..'?': l[i,a]:=chr(ord(l[i,a])-35);
-	      'A' ..'Z': l[i,a]:=chr(ord(l[i,a])-36);
-	      'a' ..'z': l[i,a]:=chr(ord(l[i,a])-40);
-	      '%'	: l[i,a]:=#55;
-	      '^'	: l[i,a]:=#200;
-	      '@'	: l[i,a]:=#201;
-	    else l[i,a]:=#1;
-	    end;	
-
-	 writeln(l[i]);
-
-      end;
-      readln(ft);
-      write(f,l);
-   end;
-   close(ft);
-   close(f);
-end.
diff --git a/makedata/main2.cpr b/makedata/main2.cpr
deleted file mode 100644
index ebea10b..0000000
Binary files a/makedata/main2.cpr and /dev/null differ
diff --git a/makedata/makeani.pas b/makedata/makeani.pas
deleted file mode 100644
index bfbc5ad..0000000
--- a/makedata/makeani.pas
+++ /dev/null
@@ -1,45 +0,0 @@
-program makeanimationforchar;
-
-
-uses crt, data;
-type
- aniscrtype= array[0..34,0..48] of byte;
- aniarray= array[0..30] of aniscrtype;
-var
- ani: aniscrtype;
- anifile: file of aniscrtype;
- index,i,j: integer;
- allani: ^aniarray;
-
-begin
- loadscreen('makedata\charani.vga');
- assign(anifile,'data\charani.dta');
- rewrite(anifile);
- for index:=0 to 29 do
-  begin
-   for i:=0 to 34 do
-    move(screen[i+(index div 6)*35,(index mod 6)*50],ani[i],49);
-   write(anifile,ani);
-  end;
- index:=0;
-  for i:=0 to 34 do
-   move(screen[i+(index div 6)*35,(index mod 6)*50],ani[i],49);
-  for j:=12 to 35 do
-   for i:=1 to 20 do
-    ani[i,j]:=0;
- write(anifile,ani);
- reset(anifile);
- new(allani);
- for j:=0 to 30 do
-  read(anifile,allani^[j]);
- close(anifile);
- j:=0;
- repeat
-  inc(j);
-  if j=31 then j:=0;
-  for i:=0 to 34 do
-   move(allani^[j,i],screen[i],49);
-  delay(150);
- until fastkeypressed;
- dispose(allani);
-end.
\ No newline at end of file
diff --git a/makedata/makechar.pas b/makedata/makechar.pas
deleted file mode 100644
index a5c726c..0000000
--- a/makedata/makechar.pas
+++ /dev/null
@@ -1,421 +0,0 @@
-program createmakechardisplay;
-uses
-  crt,Graph,gmouse,data;
-type
- displaytype=array[0..193,0..93] of byte;
-var
-  bigimage: pointer;
-  back1,back2: array[1..11,1..52] of byte;
-  Driver, Mode, TestDriver,
-  ErrCode,i,j,m,q,index,x  : Integer;
-  part: real;
-  evenpalette: paltype;
-{$F+}
-
-procedure loadpalette;
-var palfile: file of paltype;
-begin
- assign(palfile,'data\main.pal');
- reset(palfile);
- read(palfile,colors);
- close(palfile);
-end;
-
-procedure save;
-var vgafile: file of screentype;
-    disfile: file of displaytype;
-    tempdis: ^displaytype;
-begin
- mouse.hide;
- assign(vgafile,'data\char.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);
- assign(disfile,'data\char2.dta');
- reset(disfile);
- new(tempdis);
- for j:=105 to 298 do
-  for i:=22 to 115 do
-   tempdis^[j-105,i-22]:=screen[i,j];
- write(disfile,tempdis^);
- close(disfile);
- mouse.show;
-end;
-
-procedure load;
-var vgafile: file of screentype;
-    disfile: file of displaytype;
-    tempdis: ^displaytype;
-begin
- mouse.hide;
- assign(vgafile,'data\char.vga');
- reset(vgafile);
- read(vgafile,screen);
- close(vgafile);
- assign(disfile,'data\char1.dta');
- reset(disfile);
- new(tempdis);
- read(disfile,tempdis^);
- setfillstyle(0,0);
- bar(105,22,298,115);
- for j:=105 to 298 do
-  for i:=22 to 115 do
-   screen[i,j]:=tempdis^[j-105,i-22];
- close(disfile);
- mouse.show;
-end;
-
-
-procedure fadein(n: integer);
-var a: integer;
-begin
- for j:=0 to 255 do for i:=0 to 2 do evenpalette[j,i]:=0;
- for a:=0 to n do
-  begin
-   for j:=0 to 255 do
-    for i:=0 to 2 do
-     evenpalette[j,i]:=evenpalette[j,i] + ((colors[j,i]-evenpalette[j,i]) div 4);
-   set256colors(evenpalette);
-   delay(x);
-  end;
- set256colors(colors);
- delay(x);
-end;
-
-
-procedure curtain(x1,y1,x2,y2: integer);
-begin
- for i:=y1 to (y1+y2 div 2) do
-  begin
-   for j:=x1 to x2 do
-    begin
-     screen[i,j]:=0;
-     screen[y2-i+y1,j]:=0;
-    end;
-   delay(15);
-  end;
-end;
-
-procedure plate(x1,y1,x2,y2:integer);
-var a,c: integer;
-begin
- a:=5; c:=12;
- for j:=x1 to x2 do
-   for i:=y1 to y2 do
-    begin
-     dec(a);
-     if a<5 then
-      begin
-       a:=random(5)*70;
-       c:=c-1;
-       if c<10 then c:=10+random(2)
-        else if c>15 then c:=15-random(2)
-        else c:=c+random(3);
-      end;
-     if screen[i,j]=31 then screen[i,j]:=c;
-    end;
-end;
-
-procedure shiftit(x1,y1,x2,y2,Alt: integer);
-var j: integer;
-begin
- for j:=x2 downto x1 do
-  for i:=y1 to y2 do
-   screen[i,j]:=screen[i,j-2]+alt;
-end;
-
-procedure shiftback(x1,y1,x2,y2,Alt: integer);
-var j,i: integer;
-begin
- for j:=x1 to x2 do
-  for i:=y1 to y2 do
-   screen[i,j]:=screen[i,j+2]+alt;
-end;
-
-procedure glass(x1,y1,x2: integer);
-var index,i,j: integer;
-begin
- setfillstyle(1,80);
- setcolor(82);
- pieslice(x1,y1+5,0,360,6);
- for j:=x1 to x2 do
-  begin
-   index:=87;
-   for i:=y1 to y1+10 do
-    begin
-     if (i-y1)>3 then dec(index,2) else inc(index,2);
-     screen[i,j]:=index;
-   end;
-  end;
-{ for i:=y1 to y1+10 do
-   for j:=x2 downto x1 do
-    screen[i,j]:=screen[i,j-i+y1];}
-end;
-
-procedure button(x1,y1,x2,y2,c1,c2,alt: integer);
-begin
- if c1<c2 then shiftit(x1,y1,x2,y2,alt)
-  else shiftback(x1,y1,x2,y2,alt);
- setcolor(c1);
- line(x1-1,y1-1,x1-1,y2+1);
- line(x1-1,y1-1,x2+1,y1-1);
- setcolor(c2);
- line(x2+1,y1,x2+1,y2+1);
- line(x1,y2+1,x2,y2+1);
-end;
-
-procedure fadearea(x1,y1,x2,y2,alt: integer);
-begin
- for j:=x1 to x2 do
-  for i:=y1 to y2 do
-   screen[i,j]:=screen[i,j]+alt;
-end;
-
-procedure graphit(a,b,c: integer);
-var y,ylast,d: integer;
-    ans: char;
-label ending;
-begin {120,37,294,112}
- setcolor(0);
- line(120,75,294,75);
- ylast:=75;
- setfillstyle(0,0);
- bar(120,37,294,112);
- part:=37/100;
- setcolor(127);
- y:=75-round(a*part);
- line(110,y,114,y);
- y:=75+round(a*part);
- line(110,y,114,y);
- setcolor(198);
- y:=75-round(b*part);
- line(111,y,115,y);
- y:=75+round(b*part);
- line(111,y,115,y);
- setcolor(183);
- y:=75-round(c*part);
- line(112,y,116,y);
- y:=75+round(c*part);
- line(112,y,116,y);
- 
-
-
-
- setcolor(175);
- j:=123;
- for j:=123 to 294 do
- begin
-{  setwritemode(xorput);
-  line(j,37,j,112);
-  delay(x*50);
-  line(j,37,j,112);
-}  inc(j,2);
-   if j>294 then exit;
-{   begin
-    j:=123;
-    putimage(120,37,bigimage^,0);
-   end;
-}  setcolor(64+((j-123) mod 32));
-  setwritemode(0);
-   d:=random(6);
-   case d of
-    0:i:=round(a*part);
-    1:i:=round(b*part);
-    2:i:=round(c*part);
-    3:i:=-round(a*part);
-    4:i:=-round(b*part);
-    5:i:=-round(c*part);
-   end;
-   line(j-2,ylast,j,i+75);
-   ylast:=i+75;
- end;
-end;
-
-
-procedure drawscreen;
-var max,i,j: integer;
-    ans: char;
-label endofline,endofline2;
-
-begin
- setfillstyle(1,31);
- bar(0,0,319,198);
- plate(0,0,319,198);
- button(1,1,318,197,22,8,0);
- button(2,2,317,196,22,8,0);
- button(11,11,308,187,8,22,0);
- button(12,12,307,186,8,22,0);
- button(22,22,88,88,40,54,30);
- button(25,25,85,85,54,40,0);
-
- button(92,127,298,178,40,54,30);
- button(95,130,295,175,54,40,0);
-
-{ fadearea(109,26,302,119,-5);
-{ fadearea(109,26,299,116,+5);}
- button(105,22,298,115,40,54,30);
- button(120,37,295,112,54,40,0);
-{ fadearea(120,37,294,112,-2);}
-
- setwritemode(0);
- for j:=0 to 4 do button(30,100+j*15,80,111+j*15,40,54,30);
-
- settextjustify(centertext,toptext);
- setcolor(0);
- settextstyle(2,horizdir,1);
- setusercharsize(10,6,2,2);
- setcolor(38);
- outtextxy(55,100,'NAME');
- setcolor(38);
- outtextxy(55,115,'STAT');
- setcolor(38);
- outtextxy(55,130,'ICON');
- setcolor(38);
- outtextxy(55,145,'SHIP');
- setcolor(38);
- outtextxy(55,160,'CREW');
-
- setcolor(5);
- outtextxy(54,99,'NAME');
- setcolor(5);
- outtextxy(54,114,'STAT');
- setcolor(5);
- outtextxy(54,129,'ICON');
- setcolor(5);
- outtextxy(54,144,'SHIP');
- setcolor(5);
- outtextxy(54,159,'CREW');
-
- settextstyle(2,0,4);
- setcolor(38);
- outtextxy(175,22,'ELECTROENCENPHALAGRAPH');
- setcolor(5);
- outtextxy(174,22,'ELECTROENCENPHALAGRAPH');
-
- ans:=' ';
- getmem(bigimage,64000);
- getimage(105,22,298,115,bigimage^);
- repeat
-  if keypressed then
-   begin
-    ans:=readkey;
-    if ans=' ' then
-     begin
-       putimage(105,22,bigimage^,0);
-       graphit(random(100),random(100),random(100));
-     end;
-    end;
-  dec(i);
-  i:=i mod 32;
-  for j:=64 to 96 do
-   colors[j]:=colors[j-32+i];
-  set256colors(colors);
-  delay(x);
- until ans=#13;
- freemem(bigimage,64000);
- j:=120;
- i:=0;
- setwritemode(0);
- i:=random(100); j:=random(100);
- if (i+j)>175 then
- graphit(i,j,random(175-i-j));
- setwritemode(xorput);
-
-{ getimage(99,99,151,151,image);
- getimage(99,99,151,151,image2);
- fadearea(104,104,155,155,-1);
- putimage(99,99,image2,copyput);
- button(100,100,150,150,40,54,40);
- readln;
- fadearea(104,104,155,155,+1);
- putimage(99,99,image,copyput);}
-end;
-
-
-procedure test;
-var ans: char;
-begin
- ans:=' ';
- getmem(bigimage,64000);
- getimage(105,22,298,115,bigimage^);
- repeat
-  if keypressed then
-   begin
-    ans:=readkey;
-    if ans=' ' then
-     begin
-       putimage(105,22,bigimage^,0);
-       graphit(random(100),random(100),random(100));
-     end;
-    end;
-  dec(i);
-  i:=i mod 32;
-  for j:=64 to 96 do
-   colors[j]:=colors[j-32+i];
-  set256colors(colors);
-  delay(x);
- until ans=#13;
- freemem(bigimage,64000);
-end;
-
-procedure setpalette;
-begin
- for j:=0 to 31 do for i:=1 to 2 do colors[j,i]:=0;
- index:=1;
- for j:=32 to 63 do
-  begin
-   for i:=0 to 2 do colors[j,i]:=index;
-   inc(index,2);
-  end;
- set256colors(colors);
-end;
-
-procedure changes;
-begin
-{ textcolor:=31;
- backcolor:=255;
- printxy(96,133,'1:');
- printxy(156,133,'2:');
- printxy(216,133,'3:');
- printxy(96,139,'4:');
- printxy(156,139,'5:');
- printxy(216,139,'6:');
- printxy(96,145,'7:');
- printxy(156,145,'8:');
- printxy(216,145,'9:');
- printxy(96,151,'4');
- printxy(96,157,'5');
- printxy(96,163,'6');
- printxy(96,169,'7');
-
- textcolor:=127;
- backcolor:=31;
- printxy(108,133,'ROBERT W MORGAN     ENG');
- setfillstyle(0,0);
- bar(96,131,253,174);
-}
- for j:=0 to 319 do
-  for i:=0 to 199 do
-   if (screen[i,j]>31) and (screen[i,j]<64) then screen[i,j]:=screen[i,j]-32
-   else if screen[i,j]<32 then screen[i,j]:=0;
-end;
-
-begin
-  readygraph;
-  val(paramstr(1),x,m);
-  if m<>0 then x:=125;
-  tcolor:=31;
-  bkcolor:=0;
-  randomize;
-  loadpalette;
-  load;
-{  drawscreen;}
-  changes;
-  mouse.show;
-  test;
-{  save;}
-  Closegraph;
-  mouse.hide;
-end.
-
-
diff --git a/makedata/makeicon.pas b/makedata/makeicon.pas
deleted file mode 100644
index a4e7d2b..0000000
--- a/makedata/makeicon.pas
+++ /dev/null
@@ -1,209 +0,0 @@
-program makeicons;
-uses crt, graph, data;
-
-type
- numtype= array[1..3] of byte;
-const
- max = maxicons;
-var
- index,curx,x,cury,i,j,a,curicon,backcolor,errcode,last,textcolor: integer;
- ans: char;
- lightindex,glowindex: integer;
-
-procedure save;
-var icondata: file of iconarray;
-begin
- assign(icondata,'data\icons.cpr');
- reset(icondata);
- write(icondata,icons^);
- close(icondata);
-end;
-
-procedure load;
-var icondata: file of iconarray;
-begin
- assign(icondata,'data\icons.cpr');
- reset(icondata);
- read(icondata,icons^);
- close(icondata);
- last:=icons^[curicon,curx,cury];
-end;
-
-procedure drawicon;
-begin
- for j:=0 to 16 do
-  for i:=0 to 14 do
-   begin
-    if (curx=j) and (cury=i) then setfillstyle(11,icons^[curicon,j,i])
-     else setfillstyle(1,icons^[curicon,j,i]);
-    bar(j*10+15,i*10+15,j*10+24,i*10+24);
-    screen[i+50,j+250]:=icons^[curicon,j,i];
-   end;
- setfillstyle(1,last);
- bar(250,100,270,120);
-end;
-
-procedure writenum;
-var s: string;
-begin
- str(curicon,s);
- printxy(0,0,s+' ');
-end;
-
-procedure zoom;
-var a,b: integer;
-begin
- setfillstyle(0,0);
- bar(0,0,319,199);
-  for a:=0 to max do
-   for j:=0 to 16 do
-    for i:=0 to 14 do
-     screen[i+(a div 10)*18,j+(a mod 10)*20]:=icons^[a,j,i];
- readkey;
- bar(0,0,319,199);
- writenum;
-end;
-
-procedure copy;
-var number: numtype;
-    cursor,err,target,i,j: integer;
-    strln: string;
-begin
- printxy(0,0,'COPY FROM?');
- cursor:=1;
- for j:=1 to 3 do number[j]:=0;
- repeat
-  for j:=1 to 3 do
-   begin
-    str(number[j],strln);
-    printxy(50+j*5,0,strln);
-   end;
-  ans:=readkey;
-  case ans of
-   '0'..'9':
-    begin
-     val(ans,number[cursor],err);
-     if cursor<3 then inc(cursor);
-    end;
-   #8:
-    begin
-     if cursor>1 then dec(cursor);
-     number[cursor]:=0;
-    end;
-  end;
- until ans=#13;
- target:=number[1]*100+number[2]*10+number[3];
- for j:=0 to 16 do
-  for i:=0 to 14 do
-   icons^[curicon,j,i]:=icons^[target,j,i];
- printxy(0,0,'               ');
-end;
-
-procedure fillit2;
-begin
- randomize;
- for i:=0 to 14 do
-  for j:=0 to 16 do
-   begin
-    a:=random(3);
-    if icons^[curicon,j,i]=last then icons^[curicon,j,i]:=icons^[curicon,j,i]+a;
-   end;
-end;
-
-procedure fillit1;
-begin
- randseed:=5129;
- for i:=0 to 14 do
-  for j:=0 to 16 do
-   begin
-    a:=random(3);
-    if icons^[curicon,j,i]=last then icons^[curicon,j,i]:=icons^[curicon,j,i]+a;
-   end;
-end;
-
-procedure mainloop;
-begin
- drawicon;
- ans:=' ';
- repeat
-  if fastkeypressed then
-   begin
-   ans:=readkey;
-   case upcase(ans) of
-    #0:begin
-        ans:=readkey;
-        case ans of
-         #72:if cury=0 then cury:=14 else dec(cury);
-         #80:if cury=14 then cury:=0 else inc(cury);
-         #75:if curx=0 then curx:=16 else dec(curx);
-         #77:if curx=16 then curx:=0 else inc(curx);
-        end;
-       end;
-    ' ':icons^[curicon,curx,cury]:=last;
-    'C':copy;
-    'S':save;
-    'L':load;
-    '1':begin icons^[curicon,curx,cury]:=0; last:=0; end;
-    '2':begin icons^[curicon,curx,cury]:=16; last:=15; end;
-    '3':begin icons^[curicon,curx,cury]:=32; last:=31; end;
-    '4':begin icons^[curicon,curx,cury]:=48; last:=47; end;
-    '5':begin icons^[curicon,curx,cury]:=64; last:=63; end;
-    '6':begin icons^[curicon,curx,cury]:=80; last:=79; end;
-    '7':begin icons^[curicon,curx,cury]:=96; last:=95; end;
-    '8':begin icons^[curicon,curx,cury]:=112; last:=111; end;
-    '9':begin icons^[curicon,curx,cury]:=128; last:=127; end;
-    '0':begin icons^[curicon,curx,cury]:=128; last:=143; end;
-    'Q':begin icons^[curicon,curx,cury]:=144; last:=159; end;
-    'W':begin icons^[curicon,curx,cury]:=160; last:=175; end;
-    'E':begin icons^[curicon,curx,cury]:=176; last:=191; end;
-    'R':begin icons^[curicon,curx,cury]:=192; last:=207; end;
-    'T':begin icons^[curicon,curx,cury]:=208; last:=223; end;
-    'Y':begin icons^[curicon,curx,cury]:=208; last:=239; end;
-    'U':begin icons^[curicon,curx,cury]:=208; last:=255; end;
-    '+':begin inc(icons^[curicon,curx,cury]); last:=icons^[curicon,curx,cury]; end;
-    '-':begin dec(icons^[curicon,curx,cury]); last:=icons^[curicon,curx,cury]; end;
-    'S':save;
-    'L':load;
-    'Z':zoom;
-    '>':begin if curicon<max then inc(curicon); writenum; end;
-    '<':begin if curicon>0 then dec(curicon); writenum; end;
-    '?':fillit2;
-    '|':fillit1;
-   end;
-   drawicon;
-  end;
- until ans=#59;
-end;
-
-procedure changes;
-begin
-{ for a:=0 to max do
-  for i:=0 to 31 do
-   for j:=0 to 31 do
-    if icons[a,j,i]>63 then icons[a,j,i]:=(icons[a,j,i] mod 31)*2 + (icons[a,j,i] div 31)*31-2;
- }
-{ for a:=0 to max do
-  for i:=0 to 31 do
-   for j:=0 to 31 do
-    if icons[a,j,i] div 32=5 then icons[a,j,i]:=169;
-}
-
-end;
-
-begin
- bkcolor:=0;
- tcolor:=63;
- new(icons);
- randomize;
- textcolor:=31; backcolor:=0;
- curicon:=0; curx:=0; cury:=0;
- tslice:=120;
- setfillstyle(0,0);
- bar(0,0,319,199);
- set256colors(colors);
- load;
- changes;
- writenum;
- mainloop;
- closegraph;
-end.
\ No newline at end of file
diff --git a/makedata/makeintr.pas b/makedata/makeintr.pas
deleted file mode 100644
index 0571658..0000000
--- a/makedata/makeintr.pas
+++ /dev/null
@@ -1,203 +0,0 @@
-program makeintro;
-uses crt,data,graph,voctool;
-{$M 64000,0,32000}
-const
- x: byte=120;
-var
- j,i: integer;
- song: pointer;
- evenpalette: paltype;
- temp: array[0..319,160..199] of byte;
-   
-
-procedure fading(n: integer);
-var a: integer;
-begin
- evenpalette:=colors;
- for a:=0 to n do
-  begin
-   for j:=0 to 255 do
-    for i:=0 to 2 do
-      evenpalette[j,i]:=evenpalette[j,i] - (evenpalette[j,i] div 4);
-   set256colors(evenpalette);
-   if a<n then delay(tslice*3);
-  end;
-  for j:=0 to 255 do for i:=0 to 2 do evenpalette[j,i]:=0;
-  set256colors(evenpalette);
-  delay(tslice*5);
-end;
-
-procedure fadein(n: integer);
-var a: integer;
-begin
- for j:=0 to 255 do for i:=0 to 2 do evenpalette[j,i]:=0;
- for a:=0 to n do
-  begin
-   for j:=0 to 255 do
-    for i:=0 to 2 do
-     evenpalette[j,i]:=evenpalette[j,i] + ((colors[j,i]-evenpalette[j,i]) div 4);
-   set256colors(evenpalette);
-   delay(tslice*3);
-  end;
- set256colors(colors);
- delay(tslice*5);
-end;
-
-procedure plate(x1,y1,x2,y2:integer);
-var a,c,part: integer;
-begin
- a:=5; c:=8;
- for j:=x1 to x2 do
-  begin
-   part:=abs(j-160) div 10;
-   c:=8;
-   for i:=y1 to y2 do
-    begin
-     dec(a);
-     if a<5 then
-      begin
-       a:=(random(5)+1)*100;
-       c:=c-1;
-       if c<(5+part) then c:=5+part+random(3)
-        else if c>(11+part) then c:=11+part-random(3)
-        else c:=c+random(3);
-      end;
-     if screen[i,j]=12 then screen[i,j]:=c;
-    end;
-   end;
-end;
-
-procedure load;
-var vgafile: file of screentype;
-begin
- fading(11);
- if (vocgetbuffer(song,'sound\present2.voc'))
-  and (vocdriverinstalled) then vocoutput(song);
- assign(vgafile,'data\nexus.vga');
- reset(vgafile);
- read(vgafile,screen);
- close(vgafile);
- fadein(13);
- repeat
- until  vocstatusword=0;
- fading(11);
- if (vocgetbuffer(song,'sound\song2.voc'))
-  and (vocdriverinstalled) then vocoutput(song);
- assign(vgafile,'data\intro.vga');
- reset(vgafile);
- read(vgafile,screen);
- close(vgafile);
- for j:=0 to 319 do
-  for i:=160 to 199 do
-   begin
-    temp[j,i]:=screen[i,j];
-    screen[i,j]:=0;
-   end;
- fadein(13);
-end;
-
-procedure save;
-var vgafile: file of screentype;
-begin
- assign(vgafile,'data\intro.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);
-end;
-
-procedure drawgrid;
-begin
- setcolor(0);
- for j:=1 to 19 do line(0,j*10,319,j*10);
- for j:=1 to 31 do line(j*10,0,j*10,199);
-end;
-
-procedure drawscreen;
-begin
- setfillstyle(1,3);
- bar(0,0,319,199);
- setcolor(12);
- setfillstyle(1,12);
- setaspectratio(1,4);
- pieslice(160,75,0,360,131);
- drawgrid;
- settextjustify(lefttext,toptext);
-{ settextstyle(2,horizdir,1);
- setusercharsize(1,1,5,4);}
- settextstyle(5,horizdir,1);
- setcolor(12);
- settextjustify(righttext,toptext);
- outtextxy(149,184,'INTRODUCTION');
- outtextxy(149,164,'BEGIN NEW GAME');
- settextjustify(lefttext,toptext);
- outtextxy(169,164,'CONTINUE GAME');
- outtextxy(169,184,'QUIT TO DOS');
- setcolor(12);
- settextjustify(righttext,toptext);
- outtextxy(150,185,'INTRODUCTION');
- outtextxy(150,165,'BEGIN NEW GAME');
- settextjustify(lefttext,toptext);
- outtextxy(170,165,'CONTINUE GAME');
- outtextxy(170,185,'QUIT TO DOS');
-{ plate(0,0,319,199);}
-end;
-
-procedure changes;
-begin
- for j:=0 to 319 do
-  for i:=0 to 199 do
-   if screen[i,j]=3 then screen[i,j]:=0;
-end;
-
-procedure test;
-var t: integer;
-    index: byte;
-begin
- setcolor(47);
- setlinestyle(0,0,0);
- setwritemode(xorput);
- repeat
- until vocstatusword=0;
- if (vocgetbuffer(song,'sound\intrlzr.voc'))
-  and (vocdriverinstalled) then vocoutput(song);
- for t:=20 to 300 do
-  begin
-   line(120,75,t,160);
-   line(120,75,t,199);
-   line(t,160,t,199);
-   delay(tslice div 8);
-   line(120,75,t,160);
-   line(120,75,t,199);
-   line(t,160,t,199);
-   for j:=160 to 199 do
-    screen[j,t]:=temp[t,j];
-  end;
-{ screen[74,120]:=255;
- screen[75,120]:=255;
- screen[76,120]:=255;
- screen[75,119]:=255;
- screen[75,120]:=255;
- screen[75,121]:=255;
- screen[74,119]:=255;
- screen[76,119]:=255;
- screen[74,121]:=255;
- screen[76,121]:=255;
- index:=0;
- repeat
-  inc(index);
-  index:=index mod 64;
-  if index<32 then t:=index else t:=64-index;
-  setrgb256(255,t+32,t+32,t+32);
-  delay(10);
- until fastkeypressed;}
-end;
-
-
-begin
- load;
-{ drawscreen;}
-{ plate(0,0,319,199);}
- test;
- readln;
- closegraph;
-end.
\ No newline at end of file
diff --git a/makedata/makeland.pas b/makedata/makeland.pas
deleted file mode 100644
index 5945b4f..0000000
--- a/makedata/makeland.pas
+++ /dev/null
@@ -1,25 +0,0 @@
-program makeland;
-
-uses crt,graph,data;
-var vgafile: file of screentype;
-begin
- fillchar(screen,64000,0);
- setcolor(10);
- setlinestyle(0,0,3);
- rectangle(26,11,269,134);
- setcolor(12);
- setlinestyle(0,0,0);
- rectangle(26,11,269,134);
-
- rectangle(269,11,319,51);
- rectangle(269,51,319,91);
- rectangle(269,91,319,131);
- rectangle(269,131,319,171);
-
- assign(vgafile,'data\landform.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);
-
- readkey;
-end.
\ No newline at end of file
diff --git a/makedata/makemain.pas b/makedata/makemain.pas
deleted file mode 100644
index 658b645..0000000
--- a/makedata/makemain.pas
+++ /dev/null
@@ -1,932 +0,0 @@
-program createmaindisplay;
-{$M 64000,0,512000}
-uses crt,graph,data,gmouse;
-type
- fonttype= array[1..3] of byte;
- landtype= array[1..240,1..120] of byte;
- startype= array[1..4] of integer;
- plantype= array[1..120,1..120] of byte;
- imagetype= array[0..125,1..155] of byte;
- toptype=array[0..18,168..300] of byte;
-var
-  evenpalette: paltype;
-  image,image2: ^imagetype;
-  image3,image4: array[1..46,1..52] of byte;
-  back1,back2: array[1..11,1..52] of byte;
-  landform,landform2: ^landtype;
-  i,j,m,q,index,x,y  : Integer;
-  part,f: real;
-  stars: array[0..200] of startype;
-  planet: ^plantype;
-
-{$F+}
-procedure save;
-var vgafile: file of screentype;
-begin
- assign(vgafile,'data\main.vga');
- reset(vgafile);
- if ioresult<>0 then errorhandler('main.vga',1);
- write(vgafile,screen);
- close(vgafile);
-end;
-
-procedure load;
-var vgafile: file of screentype;
-begin
- assign(vgafile,'data\main.vga');
- reset(vgafile);
-  if ioresult<>0 then errorhandler('main.vga',1);
- read(vgafile,screen);
- close(vgafile);
-end;
-
-procedure fading(n: integer);
-var a: integer;
-begin
- evenpalette:=colors;
- for a:=0 to n do
-  begin
-   for j:=0 to 255 do
-    for i:=0 to 2 do
-      evenpalette[j,i]:=evenpalette[j,i] - (evenpalette[j,i] div 4);
-   set256colors(evenpalette);
-   if a<n then delay(2*x);
-  end;
-  for j:=0 to 255 do for i:=0 to 2 do evenpalette[j,i]:=0;
-  set256colors(evenpalette);
-  delay(5*x);
-end;
-
-procedure fadein(n: integer);
-var a: integer;
-begin
- for j:=0 to 255 do for i:=0 to 2 do evenpalette[j,i]:=0;
- for a:=0 to n do
-  begin
-   for j:=0 to 255 do
-    for i:=0 to 2 do
-     evenpalette[j,i]:=evenpalette[j,i] + ((colors[j,i]-evenpalette[j,i]) div 4);
-   set256colors(evenpalette);
-   delay(2*x);
-  end;
- set256colors(colors);
- delay(5*x);
-end;
-
-procedure curtain(x1,y1,x2,y2: integer);
-begin
- for i:=y1 to (y1+y2 div 2) do
-  begin
-   for j:=x1 to x2 do
-    begin
-     screen[i,j]:=2;
-     screen[y2-i+y1,j]:=2;
-    end;
-   delay(x);
-  end;
-end;
-
-procedure fadearea(x1,y1,x2,y2,alt: integer);
-var i,j: integer;
-begin
- for j:=x1 to x2 do
-  for i:=y1 to y2 do
-   screen[i,j]:=screen[i,j]+alt;
-end;
-
-procedure fadearea2(x1,y1,x2,y2,alt: integer);
-var i,j: integer;
-begin
- for j:=x1 to x2 do
-  for i:=y1 to y2 do
-  if screen[i,j]>3 then screen[i,j]:=screen[i,j]+alt;
-end;
-
-procedure unsprinkle(x1,y1,x2,y2,seed: integer);
-var total,j,max,a,b: word;
-begin
- total:=0;
- max:=(x2-x1)*(y2-y1);
- j:=0;
- repeat
-  inc(total);
-  j:=j+seed;
-  if j>max then j:=j-max;
-  a:=j div (x2-x1);
-  b:=j mod (x2-x1);
-  if total<max then screen[y1+a,x1+b]:=image^[a,b];
-  if total mod 50=0 then delay(x div 20);
- until total>=max;
-end;
-
-procedure sprinkle(x1,y1,x2,y2,seed: integer);
-var total,j,max: word;
-begin
- max:=(x2-x1)*(y2-y1);
- total:=0;
- j:=0;
- repeat
-  inc(total);
-  j:=j+seed;
-  if j>max then j:=j-max;
-  screen[y1+j div (x2-x1),x1+j mod (x2-x1)]:=2;
-  if total mod 50=0 then delay(x div 20);
-  until total>max;
-end;
-
-procedure getmainplate;
-begin
- for j:=8 to 162 do
-  for i:=8 to 132 do image^[i-8,j-8]:=screen[i,j];
-end;
-
-procedure getmainplate2;
-begin
- for j:=11 to 160 do
-  for i:=11 to 130 do image2^[i-11,j-11]:=screen[i,j];
-end;
-
-procedure getcube;
-begin
- for j:=215 to 265 do
-  for i:=145 to 189 do
-   image3[i-144,j-214]:=screen[i,j];
-end;
-
-procedure getback;
-begin
- for j:=215 to 265 do
-  for i:=134 to 144 do
-   back1[i-133,j-214]:=screen[i,j];
- for j:=215 to 265 do
-  for i:=190 to 199 do
-   back2[i-189,j-214]:=screen[i,j];
-end;
-
-procedure putcube;
-begin
- for j:=215 to 265 do
-  for i:=145 to 189 do
-   screen[i,j]:=image4[i-144,j-214];
-end;
-
-procedure rotate(x1,y1,x2,y2: integer);
-var i,j,a,n,index: integer;
-begin
- n:=(x2-x1) div 2;
- for a:=1 to 25 do
-  begin
-   for i:=y1 to y2 do
-    begin
-     index:=n+1;
-     for j:=n+x1 downto x1 do
-      if j mod a=0 then
-       begin
-        dec(index);
-        screen[i,index+x1]:=image2^[i-x1,j-y1];
-       end;
-     for j:=index+x1 downto x1 do screen[i,j]:=2;
-     index:=n-1;
-     for j:=n+x1 to x2 do
-      if j mod a=0 then
-       begin
-        inc(index);
-        screen[i,index+x1]:=image2^[i-x1,j-y1];
-       end;
-     for j:=index+x1 to x2 do screen[i,j]:=2;
-    end;
-   if a>25 then exit;
-   a:=round(a*1.2);
-   delay(x);
-  end;
-end;
-
-procedure rotate3(x1,y1,x2,y2: integer);
-var i,j,a,n,index: integer;
-begin
- n:=(x2-x1) div 2;
- for a:=1000 downto 1 do
-  begin
-   for i:=y1 to y2 do
-    begin
-     index:=n+1;
-     for j:=n+x1 downto x1 do
-      if j mod a=0 then
-       begin
-        dec(index);
-        screen[i,index+x1]:=image2^[i-y1,j-x1];
-       end;
-     for j:=index+x1 downto x1 do screen[i,j]:=2;
-     index:=n-1;
-     for j:=n+x1 to x2 do
-      if j mod a=0 then
-       begin
-        inc(index);
-        screen[i,index+x1]:=image2^[i-y1,j-x1];
-       end;
-     for j:=index+x1 to x2 do screen[i,j]:=2;
-    end;
-   a:=a div 2;
-   if a=0 then exit;
-   delay(x);
-  end;
-end;
-
-procedure plate(x1,y1,x2,y2:integer);
-var a,c: integer;
-begin
- a:=5; c:=8;
- for j:=x1 to x2 do
-   for i:=y1 to y2 do
-    begin
-     dec(a);
-     if a<5 then
-      begin
-       a:=random(5)*70;
-       c:=c-1;
-       if c<4 then c:=4+random(4)
-        else if c>12 then c:=12-random(4)
-        else c:=c+random(3);
-      end;
-     if screen[i,j]=31 then screen[i,j]:=c;
-    end;
-end;
-
-procedure shiftit(x1,y1,x2,y2,alt: integer);
-var j: integer;
-begin
- for j:=x2 downto x1 do
-  for i:=y1 to y2 do
-   screen[i,j]:=screen[i,j-2]+alt;
-end;
-
-procedure shiftback(x1,y1,x2,y2,alt: integer);
-var j: integer;
-begin
- for j:=x1 to x2 do
-  for i:=y1 to y2 do
-   screen[i,j]:=screen[i,j+2]+alt;
-end;
-
-procedure glass(x1,y1,x2: integer);
-var index,i,j: integer;
-begin
- setfillstyle(1,7);
- setcolor(5);
- pieslice(x1,y1+5,0,360,6);
- for j:=x1 to x2 do
-  begin
-   index:=7;
-   for i:=y1 to y1+10 do
-    begin
-     if (i-y1)>3 then dec(index,2) else inc(index,2);
-     screen[i,j]:=index;
-   end;
-  end;
-end;
-
-procedure button(x1,y1,x2,y2,c1,c2,alt: integer);
-begin
- if c1<c2 then shiftit(x1,y1,x2,y2,alt)
-  else shiftback(x1,y1,x2,y2,alt);
- setcolor(c1);
- line(x1-1,y1-1,x1-1,y2+1);
- line(x1-1,y1-1,x2+1,y1-1);
- setcolor(c2);
- line(x2+1,y1,x2+1,y2+1);
- line(x1,y2+1,x2,y2+1);
-end;
-
-procedure sbutton(x1,y1,x2,y2,cs,c1,c2: integer);
-begin
- setfillstyle(1,cs);
- bar(x1,y1,x2,y2);
- setcolor(c1);
- line(x1-1,y1-1,x1-1,y2+1);
- line(x1-1,y1-1,x2+1,y1-1);
- setcolor(c2);
- line(x2+1,y1,x2+1,y2+1);
- line(x1,y2+1,x2,y2+1);
-end;
-
-procedure erasestars;
-begin
- for j:=0 to 200 do
-  if stars[j,4]=0 then screen[stars[j,2],stars[j,1]]:=2;
-end;
-
-procedure drawstars(x1,y1: integer);
-var x,y: integer;
-begin
- for j:=0 to 200 do
-  begin
-   x:=stars[j,1]+x1;
-   y:=stars[j,2]+y1;
-   if y>150 then y:=y-150
-    else if y<0 then y:=y+150;
-   if x>310 then x:=x-310
-    else if x<0 then x:=x+310;
-   stars[j,1]:=x;
-   stars[j,2]:=y;
-   if screen[y,x]=2 then stars[j,4]:=0
-    else stars[j,4]:=1;
-   if stars[j,4]=0 then screen[y,x]:=stars[j,3];
-  end;
-end;
-
-{****************************************************************************}
-procedure drawscreen;
-var max,a,b: integer;
-begin
- setfillstyle(1,2);
- bar(0,0,319,199);
- 
- setcolor(31);
- rectangle(0,0,299,199);
- rectangle(1,1,298,198);
- setfillstyle(solidfill,31);
- bar(0,140,319,199);
- bar(160,120,319,140);
- bar(300,0,319,160);
- max:=19;
- for j:=160 to 180 do
-  begin
-   for i:=120 to 120+max do screen[i,j]:=2;
-   dec(max);
-  end;
- setcolor(26);
- line(3,139,160,139);
- setcolor(20);
- line(160,140,180,120);
- line(159,139,179,119);
- line(160,140,179,119);
- line(159,139,180,120);
- setcolor(26);
- line(180,120,298,120);
- line(181,119,298,119);
- line(297,119,297,4);
- setcolor(6);
- line(2,2,298,2);
- line(3,3,298,3);
- setcolor(8);
- line(2,2,2,140);
- line(3,3,3,140);
- setcolor(26);
- line(298,120,298,3);
- line(2,140,160,140);
- setfillstyle(1,10);
- bar(303,8,315,43);
-
- plate(0,0,319,199);
-
- shiftback(5,145,175,195,2);
- sbutton(11,149,172,191,3,24,8);
-
- for j:=0 to 2 do
-  button(186,131+j*20,203,139+j*20,22,8,0);
- for j:=0 to 2 do
-  button(280,131+j*20,297,139+j*20,22,8,0);
- tcolor:=31;
- printxy(183,132,'PSY');
- printxy(183,152,'ENG');
- printxy(183,172,'SCI');
- printxy(277,132,'SEC');
- printxy(277,152,'AST');
- printxy(277,172,'MED');
-
- for j:=0 to 2 do
-  for i:=0 to 2 do
-   sbutton(216+j*17,136+i*15,230+j*17,148+i*15,199,203,194);
-
-{  for b:=0 to 25 do
-   print(11+b*5,151,chr(b+65));
-  print(11,157,' !"''()*+,-./0123456789:;<=>?');
-  print(11,163,'HELLO THERE!');
-  print(11,169,'DOES IT WORK?');
-  print(11,175,'TRY AGAIN....');
-  print(11,181,'123456789012345678901234567890');
-}
- setcolor(26);
- line(6,145,177,145);
- line(6,145,6,195);
- setcolor(8);
- line(177,145,177,195);
- line(7,195,177,195);
- setfillstyle(1,224);
- bar(304,9,314,18);
- setfillstyle(1,227);
- bar(305,10,315,19);
- setfillstyle(1,228);
- bar(304,21,314,30);
- setfillstyle(1,231);
- bar(305,22,315,31);
- setfillstyle(1,232);
- bar(304,33,314,42);
- setfillstyle(1,235);
- bar(305,34,315,43);
-
- setcolor(224);
- for j:=0 to 6 do
-  begin
-   setcolor(236+j);
-   setfillstyle(1,236+j);
-    pieslice(310,65+j*20,0,360,4);
-   setcolor(8);
-   arc(310,65+j*20,45,260,4);
-   setcolor(20);
-   arc(310,65+j*20,260,360,4);
-   arc(310,65+j*20,0,45,4);
-  end;
- tcolor:=47;
- bkcolor:=255;
- printxy(298,55,'PWR');
- printxy(298,75,'SHD');
- printxy(298,95,'WEA');
- printxy(298,115,'ENG');
- printxy(298,135,'LIF');
- printxy(298,155,'COM');
- printxy(298,175,'CPU');
- tcolor:=31;
-
-{ setfillstyle(1,2);
- bar(10,10,160,130);
- setcolor(42);
- setlinestyle(0,0,3);
- setcolor(45);
- rectangle(9,9,161,131);
- setcolor(47);
- setlinestyle(0,0,0);
- rectangle(9,9,161,131);}
-
-{ setfillstyle(1,3);
- bar(170,10,290,110);}
-{ for j:=0 to 3 do
-  glass(178,20+j*20,288);
-}
-{debug!!!}
-{fadearea(178,20,250,30,+32);
- fadearea(178,40,200,50,+80);
- fadearea2(173,20,177,30,+32);
- fadearea2(173,40,177,50,+80);
-}
-{ tcolor:=10;
- print(173,13,'HULL INTEGRITY');
- print(173,33,'PRIMARY POWER');
- print(173,53,'SECONDARY POWER');
- print(173,73,'SHIELD STRENGTH');
- print(173,95,'STARDATE:');
- print(173,103,'LOCATION:');
- 
- tcolor:=31;
- print(172,12,'HULL INTEGRITY');
- print(172,32,'PRIMARY POWER');
- print(172,52,'SECONDARY POWER');
- print(172,72,'SHIELD STRENGTH');
- print(172,94,'STARDATE:');
- print(172,102,'LOCATION:');
-}
-
-{ setlinestyle(0,0,3);
- setcolor(83);
- rectangle(169,9,291,112);
- setcolor(85);
- setlinestyle(0,0,0);
- rectangle(169,9,291,112);}
-end;
-{****************************************************************************}
-
-procedure changes;
-var temp: array[0..20,0..130] of byte;
-    tempptr: pointer;
-    a,b: integer;
-    temp2: toptype;
-    temp2file: file of toptype;
-begin
-{ for j:=0 to 20 do
-  for i:=0 to 130 do
-   temp[j,i]:=screen[j+120,i+170];
- for j:=0 to 20 do
-  for i:=0 to 130 do
-   screen[j,i+170]:=temp[20-j,i];
- setfillstyle(0,0);
- bar(180,2,295,16);
- print(177,3,'PLANETARY SCAN:');
- print(177,9,'  IN PROGRESS..FFEE');
-
- getmem(tempptr,12000);
- getimage(175,140,210,190,tempptr^);
- putimage(175,145,tempptr^,0);
- getimage(275,140,300,190,tempptr^);
- putimage(275,145,tempptr^,0);
- getimage(175,122,300,140,tempptr^);
- putimage(175,0,tempptr^,0);
- freemem(tempptr,16000);
-  setfillstyle(0,0);
- bar(180,124,295,138);
-
- for a:=0 to 2 do
-  for i:=144 to 218 do
-   begin
-    b:=screen[i,276-a];
-    for j:=276-a to 300-a do
-     screen[i,j]:=screen[i,j+1];
-    screen[i,300-a]:=b;
-   end;
- setcolor(24);
- line(162,149,162,191);
-}
-{ assign(temp2file,'data\toppanel.vga');
- reset(temp2file);
- for j:=168 to 300 do
-  for i:=0 to 18 do
-   temp2[i,j]:=screen[i,j];
- write(temp2file,temp2);
- close(temp2file);
- for j:=0 to 3 do
-  begin
-   glass(292,35+j*20,297);
-   fadearea(293,34+j*20,297,46+j*20,6);
-  end;}
-{ for a:=0 to 99 do
-  for j:=186+a to 192+a do
-   for i:=1 to 4 do
-    for b:=0 to 10 do
-     screen[i*20+15+b,j-1]:=screen[i*20+15+b,j];
-}
-{ bkcolor:=255;
-  tcolor:=10;
- printxy(192,37,'HULL INTEGRITY');
- printxy(192,57,'PRIMARY POWER');
- printxy(192,77,'SECONDARY POWER');
- printxy(192,97,'SHIELD STRENGTH');
- tcolor:=31;
- printxy(191,36,'HULL INTEGRITY');
- printxy(191,56,'PRIMARY POWER');
- printxy(191,76,'SECONDARY POWER');
- printxy(191,96,'SHIELD STRENGTH');
-}
-
- for a:=0 to 2 do
-  for j:=185 to 195 do
-   for i:=0 to 10 do
-    screen[35+a*20+i,j]:=screen[i+95,j];
-
-
-{  for a:=0 to 99 do
- for j:=292 downto 186+a do
-  for i:=1 to 4 do
-   for b:=0 to 10 do
-    screen[i*20+15+b,j]:=screen[i*20+15+b,j-1];
-}
-end;
-
-procedure testcube;
-var t: integer;
-label skip1,skip2,skip3;
-begin  {218,144}
- getcube;
- for j:=1 to 51 do for i:=1 to 45 do image4[i,j]:=image3[i,j];
- setfillstyle(0,0);
- for t:=1 to 31 do
-  begin
-  for i:=215 to 232 do
-   begin
-    q:=round(sin(t/20)*45);
-    m:=round(51*(sqrt(2)-1)*0.5*sin(t/10));
-    part:=45/q;
-    for j:=134 to 144-m do screen[j,i]:=back1[j-133,i-214];
-    for j:=1 to q do
-     begin
-      index:=round(j*part);
-      if index<46 then screen[j+144-m,i]:=image4[index,i-214];
-     end;
-    if (45+2*m-q)=0 then goto skip1;
-    part:=45/(45+2*m-q);
-    for j:=144-m+q to 189+m do
-     begin
-      index:=round((j-143+m-q)*part);
-      if index<46 then screen[j,i]:=image3[index,i-214];
-     end;
-skip1:
-    for j:=179+m to 189 do screen[j,i]:=back2[j-178-m,i-214];
-   end;
-  for i:=233 to 249 do
-   begin
-    for j:=134 to 144-m do screen[j,i]:=back1[j-133,i-214];
-    q:=round(sin((31-t)/20)*45);
-    if q=0 then goto skip2;
-    part:=45/q;
-    for j:=1 to q do
-     begin
-      index:=round(j*part);
-      if index<46 then screen[j+144-m,i]:=image4[index,i-214];
-     end;
-    if (45+2*m-q)=0 then goto skip2;
-    part:=45/(45+2*m-q);
-    for j:=144-m+q to 189+m do
-     begin
-      index:=round((j-143+m-q)* part);
-      if index<46 then screen[j,i]:=image3[index,i-214];
-     end;
-skip2:
-    for j:=179+m to 189 do screen[j,i]:=back2[j-178-m,i-214];
-   end;
-  for i:=250 to 265 do
-   begin
-    q:=round(sin(t/20)*45);
-    part:=45/q;
-    for j:=134 to 144-m do screen[j,i]:=back1[j-133,i-214];
-    for j:=1 to q do
-     begin
-      index:=round(j*part);
-      if index<46 then screen[j+144-m,i]:=image4[index,i-214];
-     end;
-    if (45+2*m-q)=0 then goto skip3;
-    part:=45/(45+2*m-q);
-    for j:=144-m+q to 189+m do
-     begin
-      index:=round((j-143+m-q)* part);
-      if index<46 then screen[j,i]:=image3[index,i-214];
-     end;
-skip3:
-    for j:=179+m to 189 do screen[j,i]:=back2[j-178-m,i-214];
-   end;
-  end;
- putcube;
-end;
-
-procedure makesphere(x1,x2,y2,r,water,ecl: integer);
-var y,part2,part3,c: real;
-    j2,r2,alt: integer;
-label endcheck;
-begin
- part2:=32/(255-water);
- if r<900 then c:=1.30
-  else if r>2000 then c:=1.09
-  else c:=1.15;
- r2:=round(sqrt(r));
- for i:=6 to 2*r2+4 do
-   begin
-    y:=sqrt(r-sqr(i-r2-5));
-    m:=round((r2-y)*c);
-    part:=r2/y;
-    alt:=0;
-    for j:=1 to 2*r2+10 do
-     begin
-      index:=abs(round(j*part));
-      if ((ecl>170) and (index>(ecl-170))) then alt:=(index-ecl+170) div 2
-       else if (ecl<171) and (index<ecl) then alt:=(ecl-index) div 2
-       else alt:=0;
-      if alt<0 then alt:=0;
-      if (index+x1)>240 then j2:=index+x1-240
-       else j2:=index+x1;
-      if index>2*r2+10 then goto endcheck;
-      if (alt<5) and (landform^[j2,i]<water) then planet^[i,j+m]:=38-alt
-       else if landform^[j2,i]<water then planet^[i,j+m]:=33
-       else if alt>round(landform^[j2,i]*part2) then planet^[i,j+m]:=1
-       else planet^[i,j+m]:=round(landform^[j2,i]*part2)-alt;
-endcheck:
-     end;
-   end;
- mouse.hide;
- for j:=1 to 120 do
-  for i:=1 to 120 do
-   if planet^[i,j]<>0 then screen[i+y2,j+x2]:=planet^[i,j];
- mouse.show;
-end;
-
-procedure makesphere2(x1,x1b,x2,y2,r,water,ecl: integer);
-var y,part2,part3,c: real;
-    j2,j3,r2,alt: integer;
-label endcheck;
-begin
- part2:=32/(255-water);
- if r<900 then c:=1.30
-  else if r>2000 then c:=1.09
-  else c:=1.15;
- r2:=round(sqrt(r));
- for i:=6 to 2*r2+4 do
-   begin
-    y:=sqrt(r-sqr(i-r2-5));
-    m:=round((r2-y)*c);
-    part:=r2/y;
-    alt:=0;
-    for j:=1 to 2*r2+10 do
-     begin
-      index:=abs(round(j*part));
-      if ((ecl>170) and (index>(ecl-170))) then alt:=(index-ecl+170) div 2
-       else if (ecl<171) and (index<ecl) then alt:=(ecl-index) div 2
-       else alt:=0;
-      if alt<0 then alt:=0;
-      if (index+x1)>240 then j2:=index+x1-240
-       else j2:=index+x1;
-      if index>2*r2+10 then goto endcheck;
-
-      if (index+x1b)>240 then j3:=index+x1b-240
-       else j3:=index+x1b;
-      if landform2^[j3,i]>water then planet^[i,j+m]:=round(landform2^[j3,i]*part2)
-       else if (alt<5) and (landform^[j2,i]<water) then planet^[i,j+m]:=38-alt
-       else if landform^[j2,i]<water then planet^[i,j+m]:=33
-       else if alt>round(landform^[j2,i]*part2) then planet^[i,j+m]:=1
-       else planet^[i,j+m]:=round(landform^[j2,i]*part2)-alt;
-endcheck:
-     end;
-   end;
- mouse.hide;
- for j:=1 to 120 do
-  for i:=1 to 120 do
-   if planet^[i,j]<>0 then screen[i+y2,j+x2]:=planet^[i,j];
- mouse.show;
-end;
-
-procedure test;
-var ans: char;
-    index,i,c,ecl,c2: integer;
-begin
- index:=8; i:=0;
-{  rotate(11,11,159,129);
-  curtain(50,11,100,129);
-  sprinkle(8,8,163,133,21);}
- for j:=236 to 255 do colors[j]:=colors[3];
- while keypressed do ans:=readkey;
- ans:='3';
-{ unsprinkle(8,8,163,133,137);} {139,137,123,271,297}
- mouse.show;
- for j:=1 to 120 do
-  for i:=1 to 120 do planet^[i,j]:=0;
- ecl:=16;
- repeat
-  if keypressed then ans:=readkey;
-  inc(index);
-  inc(i);
-  if i>6 then i:=0;
-  if index=15 then index:=8;
-  if ans=' ' then testcube;
-  if ans='1' then
-   begin
-    for j:=0 to 3 do colors[228+j]:=colors[112+j];
-    for j:=0 to 3 do colors[232+j]:=colors[48+j];
-    for j:=0 to 3 do colors[224+j]:=colors[index+78+j];
-   end else
-  if ans='2' then
-   begin
-    for j:=0 to 3 do colors[228+j]:=colors[110+j+index];
-    for j:=0 to 3 do colors[232+j]:=colors[48+j];
-    for j:=0 to 3 do colors[224+j]:=colors[80+j];
-   end else
-  if ans='3' then
-   begin
-    for j:=0 to 3 do colors[228+j]:=colors[112+j];
-    for j:=0 to 3 do colors[232+j]:=colors[46+j+index];
-    for j:=0 to 3 do colors[224+j]:=colors[80+j];
-   end else
-   begin
-    for j:=0 to 3 do colors[228+j]:=colors[112+j];
-    for j:=0 to 3 do colors[232+j]:=colors[48+j];
-    for j:=0 to 3 do colors[224+j]:=colors[80+j];
-   end;
-  set256colors(colors);
-  for j:=0 to 6 do if i=j then colors[236+j]:=colors[35]
-   else colors[236+j]:=colors[3];
-  inc(c);
-  if c>240 then c:=c-240;
-  if c mod 2=0 then inc(ecl);
-  if c mod 3=0 then inc(c2);
-  if c2>320 then c2:=c2-320;
-  if ecl>320 then ecl:=ecl-320;
-  makesphere(c,25,10,3025,20,ecl);
-  delay(x*10);
- until ans=#13;
-end;
-
-procedure createplanet(xc,yc: integer);
-var x1,y1: integer;
-    a: longint;
-begin
- x1:=xc;
- y1:=yc;
- for a:=1 to 80000 do
-  begin
-   x1:=x1-1+random(3);
-   y1:=y1-1+random(3);
-   if x1>240 then x1:=1 else if x1<1 then x1:=240;
-   if y1>120 then y1:=1 else if y1<1 then y1:=120;
-   if landform^[x1,y1]<245 then landform^[x1,y1]:=landform^[x1,y1]+5;
-  end;
-end;
-
-procedure createplanet2(xc,yc: integer);
-var x1,y1: integer;
-    a: longint;
-begin
- x1:=xc;
- y1:=yc;
- for a:=1 to 20000 do
-  begin
-   x1:=x1-1+random(3);
-   y1:=y1-1+random(3);
-   if x1>240 then x1:=1 else if x1<1 then x1:=240;
-   if y1>120 then y1:=1 else if y1<1 then y1:=120;
-   if landform2^[x1,y1]<245 then landform2^[x1,y1]:=255;
-  end;
-end;
-
-procedure revcreateplanet(xc,yc: integer);
-var x1,y1: integer;
-    a: longint;
-begin
- x1:=xc;
- y1:=yc;
- for a:=1 to 240000 do
-  begin
-   x1:=x1-1+random(3);
-   y1:=y1-1+random(3);
-   if x1>240 then x1:=1 else if x1<1 then x1:=1;
-   if y1>120 then y1:=1 else if y1<1 then y1:=1;
-   if landform2^[x1,y1]>3 then landform2^[x1,y1]:=landform2^[x1,y1]-3;
-  end;
-end;
-
-procedure planet2;
-var c,x2: integer;
-    temp: byte;
-begin
- c:=100;
- for i:=1 to 240 do
-   for j:=1 to 120 do
-    begin
-     c:=c-2+random(5);
-     landform2^[i,j]:=c;
-    end;
-{ c:=1;
- for x2:=2 to 120 do
- for j:=x2 to 120 do
-  begin
-   temp:=landform^[1,j];
-   for i:=1 to 239 do
-     landform2^[i,j]:=landform2^[i+1,j];
-   landform2^[240,j]:=temp;
-  end;}
-end;
-
-procedure testball;
-var water,c: integer;
-    y,part2,part3,c2: real;
-    x2,y2,j2,r2,alt,ecl,r: integer;
-    label endcheck;
-begin
- for j:=0 to 200 do
-   begin
-    stars[j,1]:=random(320);
-    stars[j,2]:=random(150);
-    stars[j,3]:=random(20);
-   end;
- c:=128;
- for i:=1 to 240 do
-   for j:=1 to 120 do
-     landform^[i,j]:=2;
- createplanet(200,90);
- createplanet(30,30);
- createplanet(120,60);
- createplanet2(200,90);
- createplanet2(30,30);
- createplanet2(120,60);
- water:=20+random(20);
- printxy(11,163,'ORBIT ACHIEVED...');
- part:=22/(255-water);
- c:=50;
- ecl:=10;
- r:=3025;
- part2:=22/(255-water);
- if r<900 then c2:=1.30
-  else if r>2000 then c2:=1.09
-  else c2:=1.15;
- r2:=round(sqrt(r));
- x2:=25; y2:=10;
- drawstars(0,0);
-end;
-
-begin
-  new(landform);
-  new(landform2);
-  new(planet);
-  new(image);
-  new(image2);
-  val(paramstr(1),x,j);
-  if j<>0 then x:=120;
-  x:=0;
-  tcolor:=31;
-  randomize;
-  evenpalette:=colors;
-  for j:=1 to 255 do evenpalette[j]:=evenpalette[0];
-  load;
-  changes;
-  getback;
-  tcolor:=31;
-  bkcolor:=3;
-  printxy(11,157,'TESTING PLANET GENERATION....');
-  testball;
-  test;
-  Closegraph;
-  mouse.hide;
-end.
\ No newline at end of file
diff --git a/makedata/makemap.pas b/makedata/makemap.pas
deleted file mode 100644
index bc9716c..0000000
--- a/makedata/makemap.pas
+++ /dev/null
@@ -1,111 +0,0 @@
-program testmap;
-uses crt,data,graph,saveload,gmouse;
-
-const
- n: byte = 250;
- tslice: byte = 125;
- posx= 0;
- posy= 0;
- posz= 0;
-type
- planettype=
-  record
-   system,orbit,psize,water,state: byte;
-   seed,lastdate,visits: integer;
-  end;
-var
- a,b,c,t,t2: real;
- j,i,curplan: integer;
- index: byte;
- x1,y1: real;
- ans: char;
- planets: array[1..250] of planettype;
- screen2: array[10..180,50..190] of byte;
-
-procedure generatesystems;
-begin
- curplan:=0;
- for j:=1 to 250 do
-  begin
-   systems[j].x:=random(100)-50;
-   systems[j].y:=random(100)-50;
-   systems[j].z:=random(100)-50;
-   systems[j].numplanets:=random(8)+1;
-   for i:=1 to systems[j].numplanets do
-    begin
-     inc(curplan);
-     with planets[curplan] do
-      begin
-       system:=j;
-       water:=random(50);
-       seed:=random(65535);
-      end;
-    end;
-   if systems[j].x=0 then dec(j);
-   if systems[j].y=0 then dec(j);
-   if systems[j].z=0 then dec(j);
-  end;
-end;
-
-function coordx(x,y,z: integer): integer;
-var e: real;
-begin
-   if (x=0) or (z=0) then begin coordx:=0; exit; end;
-   a:=x/sin(arctan(x/z));
-   b:=a/2;
-   t2:=arctan(z/(2*x));
-   x1:=a*cos(t+t2);
-   y1:=b*sin(t+t2)+y;
-  coordx:=round(x1);
-end;
-
-function coordy(x,y,z: integer): integer;
-var f: real;
-begin
-  if (y=0) or (z=0) then begin coordy:=0; exit; end;
-  a:=x/sin(arctan(x/z));
-   b:=a/2;
-   t2:=arctan(z/(2*x));
-   x1:=a*cos(t+t2);
-   y1:=b*sin(t+t2)+y;
-   coordy:=round(y1);
-end;
-
-procedure drawsystems(x,y: integer);
-label skip2;
-begin
- fillchar(screen2,sizeof(screen2),0);
- for j:=1 to n do
-  begin
-      if systems[j].x=0 then goto skip2;
-   a:=systems[j].x/sin(arctan(systems[j].x/systems[j].z));
-   b:=a/2;
-      if systems[j].x=0 then goto skip2;
-   t2:=arctan(systems[j].z/(2*systems[j].x));
-   x1:=a*cos(t+t2);
-   y1:=b*sin(t+t2)+systems[j].y;
-   screen2[y-round(y1),x-round(x1)]:=31;
-skip2:
-  end;
- for i:=10 to 180 do
-  move(screen2[i,50],screen[i,50],140);
-end;
-
-begin
- randomize;
- generatesystems;
- mouse.hide;
- t:=0; t2:=0.785;
- ans:='1';
- repeat
-  if keypressed then ans:=readkey;
-  if ans='1' then begin t:=t+0.01; end
-   else if ans='2' then begin t:=t-0.01; end;
-  inc(index);
-  index:=index mod 8;
-  if t>6.28 then t:=0;
-  if t<0 then t:=6.28;
-  drawsystems(120,100);
- until ans=#59;
- closegraph;
-end.
\ No newline at end of file
diff --git a/makedata/makename.pas b/makedata/makename.pas
index e26310d..63cb4fd 100644
--- a/makedata/makename.pas
+++ b/makedata/makename.pas
@@ -1,4 +1,20 @@
 program makenames;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 var
  i,j,a,b: integer;
diff --git a/makedata/makescr.pas b/makedata/makescr.pas
deleted file mode 100644
index 752d402..0000000
--- a/makedata/makescr.pas
+++ /dev/null
@@ -1,340 +0,0 @@
-program makescreen;
-uses graph, crt;
-
-{$L vga256}
-type
- colortype= array[1..3] of byte;
- paltype= array[0..255] of colortype;
- screentype= array[0..199,0..319] of byte;
- fonttype= array[0..2] of byte;
- fontarray= array[1..84] of fonttype;
- pscreentype= ^screentype;
-const
- fontmax= 2;
- font: array[0..fontmax] of fontarray=
- (((0,0,0),(102,96,96),(85,0,0),(34,0,0),(36,68,32),
-   (66,34,64),(9,105,0),(4,228,0),(0,2,36),(0,240,0),
-   (0,0,32),(1,36,128),(107,221,96),(98,34,240),(241,104,240),
-   (241,33,224),(153,241,16),(248,113,224),(248,249,240),(241,17,16),
-   (249,105,240),(249,241,16),(102,6,96),(102,6,98),(18,66,16),
-   (15,15,0),(132,36,128),(105,32,32),(121,185,144),(249,169,240),
-   (248,136,240),(233,153,224),(240,200,240),(248,232,128),(248,153,240),
-   (153,249,144),(114,34,112),(241,25,96),(158,153,144),(136,136,240),
-   (159,153,144),(233,153,144),(249,153,240),(249,184,128),(105,154,80),
-   (249,169,144),(132,33,224),(114,34,32),(153,153,240),(153,149,32),
-   (153,187,96),(153,105,144),(153,113,16),(242,72,240),(9,36,144),
-   (8,66,16),(7,155,144),(15,169,240),(15,136,240),(14,153,224),
-   (14,12,224),(15,140,128),(15,137,240),(9,159,144),(7,34,112),
-   (15,25,96),(9,233,144),(8,136,240),(9,249,144),(14,153,144),
-   (15,153,240),(15,155,128),(15,155,240),(15,154,144),(4,33,224),
-   (15,34,32),(9,153,96),(9,149,32),(9,155,96),(9,105,144),
-   (9,151,16),(15,36,240),(53,170,83),(202,17,172)),
-
-   ((0,0,0),(102,96,96),(85,0,0),(34,0,0),(36,68,32),
-   (66,34,64),(9,105,0),(4,228,0),(0,2,36),(0,240,0),
-   (0,0,32),(1,36,128),(107,221,96),(98,34,240),(105,104,240),
-   (105,41,96),(19,95,16),(248,225,224),(104,233,96),(241,36,128),
-   (105,105,96),(105,113,96),(2,2,0),(2,2,36),(18,66,16),
-   (15,15,0),(132,36,128),(105,32,32),(105,249,144),(233,233,224),
-   (105,137,96),(233,153,224),(248,232,240),(248,232,128),(104,185,96),
-   (153,249,144),(114,34,112),(241,25,96),(158,153,144),(136,136,240),
-   (159,153,144),(233,153,144),(105,153,96),(233,232,128),(105,155,112),
-   (233,233,144),(120,97,224),(242,34,32),(153,153,96),(153,149,32),
-   (153,187,96),(153,105,144),(153,113,96),(242,72,240),(9,36,144),
-   (8,66,16),(6,153,112),(142,153,224),(7,136,112),(23,153,112),
-   (6,158,112),(105,200,128),(6,151,150),(142,153,144),(32,34,32),
-   (16,17,150),(137,233,144),(34,34,32),(9,249,144),(14,153,144),
-   (6,153,96),(14,153,232),(6,153,113),(6,152,128),(7,66,224),
-   (39,34,32),(9,153,96),(9,149,32),(9,155,96),(9,105,144),
-   (9,151,22),(15,36,240),(53,170,83),(202,17,172)),
-
-   ((0,0,0),(34,32,32),(85,0,0),(34,0,0),(36,68,32),
-   (66,34,64),(9,105,0),(2,114,0),(0,2,36),(0,240,0),
-   (0,0,32),(1,36,128),(107,221,96),(38,34,112),(241,248,240),
-   (241,113,240),(170,175,32),(248,241,240),(248,249,240),(241,17,16),
-   (249,105,240),(249,241,240),(2,2,0),(2,2,36),(18,66,16),
-   (15,15,0),(132,36,128),(249,48,32),(249,249,144),(249,233,240),
-   (249,137,240),(233,153,224),(248,232,240),(248,232,128),(248,185,240),
-   (153,249,144),(114,34,112),(241,25,240),(158,153,144),(136,136,240),
-   (159,153,144),(157,185,144),(249,153,240),(249,248,128),(249,155,240),
-   (249,233,144),(120,97,224),(242,34,32),(153,153,240),(153,149,32),
-   (153,187,96),(153,105,144),(153,241,240),(242,72,240),(9,36,144),
-   (8,66,16),(15,155,208),(143,153,240),(15,136,240),(31,153,240),
-   (15,188,240),(249,200,128),(15,151,159),(143,153,144),(32,34,32),
-   (16,17,159),(137,233,144),(34,34,32),(9,249,144),(14,153,144),
-   (15,153,240),(15,153,248),(15,153,241),(15,152,128),(7,66,224),
-   (39,34,32),(9,153,240),(9,149,32),(9,155,96),(9,105,144),
-   (9,159,31),(15,36,240),(53,170,83),(202,17,172)));
-var
- colors: paltype;
- screen: screentype absolute $A000:0000;
- tcolor,bkcolor,index,curx,cury,i,j,backcolor,last,under,textcolor: integer;
- ans: char;
- vgastr: string[40];
-
-procedure vgadriver; external;
-
-procedure errorhandler(s: string; errtype: integer);
-begin
- textmode(co80);
- writeln;
- writeln;
- case errtype of
-  1: writeln('Opening File Error: ',s);
-  5: writeln('Read/Write File Error: ',s);
-  6: writeln('Program Error: ',s);
-  7: writeln('DOS Error: ',s);
- end;
- halt;
-end;
-
-procedure loadpal(s: string);
-var palfile: file of paltype;
-begin
- assign(palfile,s);
- reset(palfile);
- if ioresult<>0 then errorhandler(s,1);
- read(palfile,colors);
- if ioresult<>0 then errorhandler(s,5);
- close(palfile);
-end;
-
-{$F+}
-function testit : integer; assembler;
-{$F-}
-asm
- mov ax, 1A00h
-  int 10h
- cmp al, 1Ah
- jne @@nope
- mov ax, 1
- jmp @@done
-@@nope:
- mov ax, 0
-@@done:
-end;
-
-procedure readygraph;
-var testdriver,driver,mode,errcode: integer;
-begin
- testdriver:=installuserdriver('vga256',@testit);
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeLn('Error Installing VGA Driver:',errcode);
-   halt(4);
-  end;
- registerbgidriver(@vgadriver);
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeLn('Error Registering VGA Driver:',errcode);
-   halt(4);
-  end;
- driver:=detect;
- initgraph(driver,mode,'');
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeln('Video Initialization Failure: ',errcode);
-   halt(4);
-  end;
- setgraphbufsize(0);
- checksnow:=false;
-end;
-
-procedure setrgb256(palnum,r,g,b: byte); assembler;
-asm
- mov dx, 03c8h
- mov al, [palnum]
- out dx, al
- inc dx
- mov al, [r]
- out dx, al
- mov al, [g]
- out dx, al
- mov al, [b]
- out dx, al
-end;
-
-procedure set256Colors(pal: paltype); assembler;
-asm
- push es
- xor di, di
- les si, [pal]
- mov dx, 03C8h
- xor ax, ax
- out dx, al
- inc dx
-@@loop:
- mov al, [es:si]
- out dx, al
- mov al, [es:si+1]
- out dx, al
- mov al, [es:si+2]
- out dx, al
- add si, 3
- inc di
- cmp di, 256
- jl @@loop
- pop es
-end;
-
-procedure printxy(fontn,x1,y1: integer; s: string);
-var letter,a,x,y: integer;
-begin
- x:=x1;
- for j:=1 to length(s) do
-  begin
-   x:=x+5;
-   case s[j] of
-     'a'..'z': letter:=ord(s[j])-40;
-    'A' ..'Z': letter:=ord(s[j])-36;
-    ' ' ..'"': letter:=ord(s[j])-31;
-    ''''..'?': letter:=ord(s[j])-35;
-    '%': letter:=55;
-    '\': letter:=56;
-    #1: letter:=83;
-    #2: begin
-         letter:=84;
-         dec(x);
-        end;
-    else letter:=1;
-   end;
-   y:=y1;
-   for i:=0 to 5 do
-    begin
-     inc(y);
-     for a:=4 to 7 do
-      if font[fontn,letter,i div 2] and (1 shl a)>0 then screen[y,x+3-a]:=tcolor
-       else if bkcolor<255 then screen[y,x+3-a]:=bkcolor;
-     inc(y);
-     inc(i);
-     for a:=0 to 3 do
-      if font[fontn,letter,i div 2] and (1 shl a)>0 then screen[y,x-1-a]:=tcolor
-       else if bkcolor<255 then screen[y,x-1-a]:=bkcolor;
-    end;
-   if bkcolor<255 then for i:=1 to 6 do screen[y1+i,x]:=bkcolor;
-  end;
-end;
-
-function fastkeypressed: boolean; assembler;
-asm
- push ds
- mov ax, 40h
- mov ds, ax
- cli
- mov ax, [1Ah]
- cmp ax, [1Ch]
- sti
- mov ax, 0
- jz @nopress
- inc ax
-@nopress:
- pop ds
-end;
-
-procedure save;
-var vgadata: file of screentype;
-begin
- screen[cury,curx]:=under;
- assign(vgadata,vgastr+'.vga');
- reset(vgadata);
- if ioresult<>0 then errorhandler(vgastr+'.vga',1);
- write(vgadata,screen);
- close(vgadata);
-end;
-
-procedure load;
-var vgadata: file of screentype;
-begin
- assign(vgadata,vgastr+'.vga');
- reset(vgadata);
- if ioresult<>0 then errorhandler(vgastr+'.vga',1);
- read(vgadata,screen);
- close(vgadata);
- last:=screen[cury,curx];
- under:=screen[cury,curx];
-end;
-
-procedure readpalette;
-var palfile: file of paltype;
-begin
- assign(palfile,vgastr+'.pal');
- reset(palfile);
- if ioresult<>0 then
-  begin
-   loadpal('data\main.pal');
-   colors[255]:=colors[0];
-  end
- else read(palfile,colors);
- close(palfile);
- set256colors(colors);
-end;
-
-procedure mainloop;
-begin
- repeat
-   inc(screen[cury,curx],2);
-   if fastkeypressed then
-   begin
-   ans:=readkey;
-   case upcase(ans) of
-    #0:begin
-        ans:=readkey;
-        screen[cury,curx]:=under;
-        case ans of
-         #72:if cury=0 then cury:=199 else dec(cury);
-         #80:if cury=199 then cury:=0 else inc(cury);
-         #75:if curx=0 then curx:=319 else dec(curx);
-         #77:if curx=319 then curx:=0 else inc(curx);
-         #71:begin curx:=(curx div 10) - 1; curx:=curx*10 mod 320; end;
-         #79:begin curx:=(curx div 10) + 1; curx:=curx*10 mod 320; end;
-         #73:begin cury:=(cury div 10) - 1; cury:=cury*10 mod 200; end;
-         #81:begin cury:=(cury div 10) + 1; cury:=cury*10 mod 200; end;
-        end;
-        under:=screen[cury,curx];
-       end;
-    ' ':under:=last;
-    'S':save;
-    'L':load;
-    '1':begin under:=0; last:=0; end;
-    '2':begin under:=16; last:=16; end;
-    '3':begin under:=32; last:=32; end;
-    '4':begin under:=48; last:=48; end;
-    '5':begin under:=64; last:=64; end;
-    '6':begin under:=80; last:=80; end;
-    '7':begin under:=96; last:=96; end;
-    '8':begin under:=112; last:=112; end;
-    '9':begin under:=128; last:=128; end;
-    'Q':begin under:=144; last:=144; end;
-    'W':begin under:=160; last:=160; end;
-    'E':begin under:=176; last:=176; end;
-    'R':begin under:=192; last:=192; end;
-    'T':begin under:=208; last:=208; end;
-    'Z':begin under:=224; last:=224; end;
-    'X':begin under:=228; last:=228; end;
-    'C':begin under:=232; last:=232; end;
-    '+':begin inc(under); last:=under; end;
-    '-':begin dec(under); last:=under; end;
-    'S':save;
-    'L':load;
-   end;
-   end;
- until ans=#59;
-end;
-
-begin
- vgastr:=paramstr(1);
- randomize;
- textcolor:=31;
- backcolor:=0;
- curx:=0;
- cury:=0;
- readygraph;
- load;
- readpalette;
- ans:=' ';
- mainloop;
- closegraph;
-end.
diff --git a/makedata/makescr2.pas b/makedata/makescr2.pas
deleted file mode 100644
index 6d233d3..0000000
--- a/makedata/makescr2.pas
+++ /dev/null
@@ -1,200 +0,0 @@
-program makescreen;
-uses graph, crt, gmouse, data;
-
-type
- icontype= array[1..17,1..15] of byte;
- fonttype= array[1..3] of byte;
- aniscrtype= array[0..34,0..49] of byte;
-const
-  font: array[1..54] of fonttype=(
-(0,0,0),       { }(102,96,96),   {!}(85,80,0),     {"}(34,0,0),      {'}
-(36,68,32),    {(}(66,34,64),    {)}(9,105,0),     {*}(4,228,0),     {+}
-(0,2,36),      {,}(0,240,0),     {-}(0,6,96),      {.}(1,36,128),    {/}
-(107,221,96),  {0}(38,34,112),   {1}(105,36,240),  {2}(225,97,224),  {3}
-(53,241,16),   {4}(248,113,224), {5}(36,233,96),   {6}(241,36,128),  {7}
-(105,105,96),  {8}(105,113,32),  {9}(102,6,96),    {:}(102,6,98),    {;}
-(18,66,16),    {<}(15,15,0),     {=}(132,36,128),  {>}(105,32,32),   {?}
-
-(105,249,144), {a}(233,233,224), {b}
-(105,137,96),  {c}(233,153,224), {d}(248,232,240), {e}(248,232,128), {f}
-(105,139,96),  {g}(153,249,144), {h}(114,34,112),  {i}(17,25,96),    {j}
-(154,202,144), {k}(136,136,240), {l}(159,153,144), {m}(157,185,144), {n}
-(105,153,96),  {o}(233,232,128), {p}(105,155,112), {q}(233,234,144), {r}
-(120,97,224),  {s}(114,34,32),   {t}(153,153,96),  {u}(153,150,96),  {v}
-(153,187,96),  {w}(153,105,144), {x}(153,114,64),  {y}(242,72,240))  {z};
-
-var
- tdelay,index,curx,x,cury,i,j,backcolor,
- testdriver,mode,driver,errcode,last,under,textcolor: integer;
- ans: char;
- vgastr: string;
- aniscr: aniscrtype;
-
-procedure save;
-var vgadata: file of screentype;
-begin
- screen[cury,curx]:=under;
- assign(vgadata,vgastr+'.vga');
- reset(vgadata);
- write(vgadata,screen);
- close(vgadata);
-end;
-
-procedure load;
-var vgafile: file of screentype;
-begin
- assign(vgafile,vgastr+'.vga');
- reset(vgafile);
- read(vgafile,screen);
- close(vgafile);
- last:=screen[cury,curx];
- under:=screen[cury,curx];
-end;
-
-procedure savepalette;
-var palfile: file of paltype;
-begin
- assign(palfile,vgastr+'.pal');
- reset(palfile);
- write(palfile,colors);
- close(palfile);
- set256colors(colors);
-end;
-
-procedure myswap(a,b: byte);
-var c: colortype;
-begin
- c:=colors[a];
- colors[a]:=colors[b];
- colors[b]:=c;
-end;
-
-procedure readpalette;
-var palfile: file of paltype;
-begin
- assign(palfile,vgastr+'.pal');
- reset(palfile);
- read(palfile,colors);
- close(palfile);
- set256colors(colors);
-end;
-
-procedure showani;
-var index: integer;
-begin
- for i:=0 to 34 do
-  move(screen[i],aniscr[i],50);
- index:=-1;
- repeat
-  for index:=0 to 29 do
-   begin
-    if index>0 then
-     for i:=0 to 34 do
-      move(screen[i+(index div 6)*35,(index mod 6)*50],screen[i],50)
-    else for i:=0 to 34 do
-     move(aniscr[i],screen[i],50);
-    delay(tslice);
-   end;
-  delay(tslice*4);
-  for index:=29 downto 0 do
-   begin
-    if index>0 then
-    for i:=0 to 34 do
-     move(screen[i+(index div 6)*35,(index mod 6)*50],screen[i],50)
-    else for i:=0 to 34 do
-     move(aniscr[i],screen[i],50);
-    delay(tslice);
-   end;
-  delay(tslice*4);
- until fastkeypressed;
- for i:=0 to 34 do
-  move(aniscr[i],screen[i],50);
-end;
-
-procedure mainloop;
-begin
- repeat
-   inc(screen[cury,curx],3);
-   if fastkeypressed then
-   begin
-   ans:=readkey;
-   case upcase(ans) of
-    #0: begin
-         ans:=readkey;
-         screen[cury,curx]:=under;
-         case ans of
-          #72: if cury<1 then cury:=199 else dec(cury);
-          #80: if cury>198 then cury:=0 else inc(cury);
-          #75: if curx<1 then curx:=319 else dec(curx);
-          #77: if curx>318 then curx:=0 else inc(curx);
-          #71: begin
-                if curx<0 then curx:=0;
-                curx:=(curx div 10) - 1;
-                if curx<0 then curx:=31;
-                curx:=(curx*10) mod 320;
-               end;
-          #79: begin
-                if curx>319 then curx:=319;
-                curx:=(curx div 10) + 1;
-                curx:=(curx*10) mod 320;
-               end;
-          #73: begin
-                if cury<0 then cury:=0;
-                cury:=(cury div 10) - 1;
-                if cury<0 then cury:=19;
-                cury:=(cury*10) mod 200;
-               end;
-          #81: begin
-                if cury>199 then cury:=199;
-                cury:=(cury div 10) + 1;
-                cury:=(cury*10) mod 200;
-               end;
-          #61: showani;
-          #65: fillchar(screen,64000,under);
-          #67: fillchar(screen[cury,curx],320-curx,under);
-          #68: for j:=cury to 199 do
-                screen[j,curx]:=under;
-         end;
-         under:=screen[cury,curx];
-        end;
-    ' ': under:=last;
-    'S': save;
-    'L': load;
-    '1': begin under:=0; last:=0; end;
-    '2': begin under:=16; last:=16; end;
-    '3': begin under:=32; last:=32; end;
-    '4': begin under:=48; last:=48; end;
-    '5': begin under:=64; last:=64; end;
-    '6': begin under:=80; last:=80; end;
-    '7': begin under:=96; last:=96; end;
-    '8': begin under:=112; last:=112; end;
-    '9': begin under:=128; last:=128; end;
-    'Q': begin under:=144; last:=144; end;
-    'W': begin under:=160; last:=160; end;
-    'E': begin under:=176; last:=176; end;
-    'R': begin under:=192; last:=192; end;
-    'T': begin under:=208; last:=208; end;
-    '+': begin inc(under); last:=under; end;
-    '-': begin dec(under); last:=under; end;
-    'S': save;
-    'L': load;
-   end;
-   end;
- until ans=#59;
-end;
-
-begin
- tslice:=120;
- vgastr:=paramstr(1);
- val(paramstr(1),x,j);
- if j<>0 then x:=125;
- randomize;
- textcolor:=31; backcolor:=0;
- curx:=0;
- cury:=0;
- load;
- readpalette;
- ans:=' ';
- mainloop;
- closegraph;
-end.
\ No newline at end of file
diff --git a/makedata/makeship.pas b/makedata/makeship.pas
deleted file mode 100644
index bcfb92b..0000000
--- a/makedata/makeship.pas
+++ /dev/null
@@ -1,113 +0,0 @@
-program makeship;
-uses crt,graph,data,gmouse;
-type
- icontype= array[1..17,1..15] of byte;
- fonttype= array[1..3] of byte;
- shpimg=array[0..57,0..74] of byte;
-var
- tdelay,index,curx,x,cury,i,j,backcolor,
- testdriver,mode,driver,errcode,last,under,textcolor: integer;
- ans: char;
- vgastr: string;
- image: shpimg;
-
-procedure save;
-var vgadata: file of shpimg;
-begin
- screen[cury,curx]:=under;
- assign(vgadata,vgastr+'.dta');
- reset(vgadata);
- for j:=0 to 57 do
-  for i:=0 to 74 do
-   if screen[i,j]=38 then screen[i,j]:=0;
- for j:=0 to 57 do
-  for i:=0 to 74 do
-   image[j,i]:=screen[i,j];
- write(vgadata,image);
- close(vgadata);
-end;
-
-procedure load;
-var vgadata: file of shpimg;
-begin
- assign(vgadata,vgastr+'.dta');
- reset(vgadata);
- read(vgadata,image);
- for j:=0 to 57 do
-  for i:=0 to 74 do
-   screen[i,j]:=image[j,i];
- close(vgadata);
- last:=screen[cury,curx];
- under:=screen[cury,curx];
-end;
-
-procedure mainloop;
-begin
- repeat
-   inc(screen[cury,curx]);
-   if keypressed then
-   begin
-   ans:=readkey;
-   case upcase(ans) of
-    #0:begin
-        ans:=readkey;
-        screen[cury,curx]:=under;
-        case ans of
-         #72:if cury=0 then cury:=74 else dec(cury);
-         #80:if cury=74 then cury:=0 else inc(cury);
-         #75:if curx=0 then curx:=174 else dec(curx);
-         #77:if curx=174 then curx:=0 else inc(curx);
-         #71:begin curx:=(curx div 10) - 1; curx:=curx*10 mod 175; end;
-         #79:begin curx:=(curx div 10) + 1; curx:=curx*10 mod 175; end;
-         #73:begin cury:=(cury div 10) - 1; cury:=cury*10 mod 75; end;
-         #81:begin cury:=(cury div 10) + 1; cury:=cury*10 mod 75; end;
-        end;
-        under:=screen[cury,curx];
-       end;
-    ' ':under:=last;
-    'S':save;
-    'L':load;
-    '1':begin under:=0; last:=0; end;
-    '2':begin under:=16; last:=16; end;
-    '3':begin under:=32; last:=32; end;
-    '4':begin under:=48; last:=48; end;
-    '5':begin under:=64; last:=64; end;
-    '6':begin under:=80; last:=80; end;
-    '7':begin under:=96; last:=96; end;
-    '8':begin under:=112; last:=112; end;
-    '9':begin under:=128; last:=128; end;
-    'Q':begin under:=144; last:=144; end;
-    'W':begin under:=160; last:=160; end;
-    'E':begin under:=176; last:=176; end;
-    'R':begin under:=192; last:=192; end;
-    'T':begin under:=208; last:=208; end;
-    '+':begin inc(under); last:=under; end;
-    '-':begin dec(under); last:=under; end;
-    'S':save;
-    'L':load;
-   end;
-   end;
- until ans=#59;
-end;
-
-function testit : integer;
-begin testit:=1; end;
-
-begin
- vgastr:=paramstr(1);
- val(paramstr(1),x,j);
- if j<>0 then x:=125;
- randomize;
- textcolor:=31; backcolor:=0;
- curx:=0; cury:=0;
- set256colors(colors);
- setfillstyle(1,43);
- bar(0,0,319,199);
- setfillstyle(0,0);
- bar(0,0,57,74);
- load;
- loadpal('data\char.pal');
- set256colors(colors);
- mainloop;
- closegraph;
-end.
\ No newline at end of file
diff --git a/makedata/makestat.pas b/makedata/makestat.pas
deleted file mode 100644
index 03aee99..0000000
--- a/makedata/makestat.pas
+++ /dev/null
@@ -1,18 +0,0 @@
-program generatestatic;
-uses crt;
-var
- j: word;
- i: byte;
- datafile: file of byte;
-
-begin
- randomize;
- assign(datafile,'sound\static.dta');
- reset(datafile);
- for j:=1 to 40000 do
-  begin
-   i:=random(256);
-   write(datafile,i);
-  end;
- close(datafile);
-end.
diff --git a/makedata/marland.pal b/makedata/marland.pal
deleted file mode 100644
index 1717d22..0000000
Binary files a/makedata/marland.pal and /dev/null differ
diff --git a/makedata/marland.sga b/makedata/marland.sga
deleted file mode 100644
index 1ee211e..0000000
Binary files a/makedata/marland.sga and /dev/null differ
diff --git a/makedata/marland2.cpr b/makedata/marland2.cpr
deleted file mode 100644
index 73070b6..0000000
--- a/makedata/marland2.cpr
+++ /dev/null
@@ -1,54 +0,0 @@
-________________________________________
-		
-	
-
-
-
-			
-
-	
-
-			
-	
-
-
-		
-		
-	
-
-
-
-
-
-
-
-
-
-
-	
-
-
-	
-
-	
-	
-
-		
-		
-
-
-	
-
-
-
-
-
-
-
-
-
-	
-
-
-
-                                                                                                                                                                                                                                                                                                                                
\ No newline at end of file
diff --git a/makedata/marland2.pal b/makedata/marland2.pal
deleted file mode 100644
index 1911593..0000000
Binary files a/makedata/marland2.pal and /dev/null differ
diff --git a/makedata/mars.cpr b/makedata/mars.cpr
deleted file mode 100644
index e65c4b8..0000000
Binary files a/makedata/mars.cpr and /dev/null differ
diff --git a/makedata/mars.pal b/makedata/mars.pal
deleted file mode 100644
index 2105f24..0000000
Binary files a/makedata/mars.pal and /dev/null differ
diff --git a/makedata/mars2.cpr b/makedata/mars2.cpr
deleted file mode 100644
index ae8bdb9..0000000
Binary files a/makedata/mars2.cpr and /dev/null differ
diff --git a/makedata/midipl.pas b/makedata/midipl.pas
deleted file mode 100644
index a7faf8d..0000000
--- a/makedata/midipl.pas
+++ /dev/null
@@ -1,225 +0,0 @@
-
-{ ---------------------------------------
-
-   Plays Format-0 Midi-Files
-   using Soundblaster-Midi-Interface
-   (Format-1-Midi-Files are played
-   track-chunk by track-chunk)
-
-  ---------------------------------------
-
-   This program should only demonstrate
-   how to write data to the Soundblaster-
-   Midi-Interface.
-
-  ---------------------------------------
-
-   Eckhard Koch & Juergen Witte,
-   MicroConsult, Oldenburg, Germany
-
-   CompuServe-Adress:
-     100037,313 (Eckhard Koch)
-
-  -------------------------------------- }
-
-program midiplay;
-uses dos,crt;
-const dsp_reset  = $226;    { The second digit could be from 1 to 6, }
-      dsp_read   = $22A;    { e.g.  $216 to $226, $21A to $26A etc.  }
-      dsp_write  = $22C;
-      dsp_avail  = $22E;
-
-      dsp_ready  = $AA;
-
-var f:file of byte;
-    cl:longint;
-
-procedure sb_reset;
-begin
-  port[dsp_reset]:=1;
-  delay(3);
-  port[dsp_reset]:=0;
-  while (port[dsp_avail] and $80)=0 do ;
-  if port[dsp_read]<>dsp_ready then ;
-end;
-
-procedure write_midi(b:byte);
-begin
-  while (port[dsp_write] and $80)>0 do ;
-  port[dsp_write]:=$38;
-  while (port[dsp_write] and $80)>0 do ;
-  port[dsp_write]:=b;
-end;
-
-{ Midi-Funktionen }
-function ReadDeltatime : longint;
-var i:array[1..4] of byte; count,n:byte; multi:word; result:longint;
-begin
-  count:=1;
-  read(f,i[count]);
-  while i[count]>$80 do begin
-    inc(count);
-    read(f,i[count]);
-  end;
-  multi:=1;
-  if count>1 then
-    for n:=2 to count do
-      multi:=multi*$80;
-  result:=0;
-  n:=1;
-  repeat
-    result:=result+multi*(i[n] and $7F);
-    inc(n);
-    if n<=count then multi:=multi div $80;
-  until n>count;
-  cl:=cl+count;
-  ReadDeltatime:=result;
-end;
-
-function ReadLength : longint;
-var i:byte; sum:longint;
-begin
-  read(f,i);
-  sum:=$1000000*i;
-  read(f,i);
-  sum:=sum+$10000*i;
-  read(f,i);
-  sum:=sum+$100*i;
-  read(f,i);
-  sum:=sum+i;
-  ReadLength:=sum;
-  cl:=cl+4;
-end;
-
-function ReadWord : word;
-var i:byte; sum:longint;
-begin
-  read(f,i);
-  sum:=$100*i;
-  read(f,i);
-  sum:=sum+i;
-  ReadWord:=sum;
-  cl:=cl+2;
-end;
-
-function ReadByte : byte;
-var i:byte;
-begin
-  read(f,i);
-  ReadByte:=i;
-  cl:=cl+1;
-end;
-
-function ReadString(l:word) : string;
-var s:string; i,n:byte;
-begin
-  s:='';
-  for n:=1 to l do begin
-    read(f,i);
-    s:=s+chr(i);
-  end;
-  ReadString:=s;
-end;
-
-procedure SkipOver(l:longint);
-var n:longint; i:byte;
-begin
-  if l>0 then for n:=1 to l do read(f,i);
-  cl:=cl+l;
-end;
-
-const No_Midi = 'This is no standard-midi-file';
-
-var i:byte;
-    channel:byte; note:byte; deltatime:longint;
-
-{ Data from Midi-Header (mthd) }
-
-var HeaderLength:longint;
-    format, trackchunks, division : word;
-    ms_deltatime : word;
-    tc : word;
-
-{ Data from Midi-Chunk }
-
-var ChunkLength,rl:longint;
-    status,firstval,value:byte;
-    midifile:string;
-
-begin
-  clrscr;
-  writeln('Play Midi-Files',#13#10);
-  write('Filename: ');
-  readln(midifile);
-  sb_reset;
-  assign(f,midifile);
-  reset(f);
-
-  if ReadString(4)<>'MThd' then begin
-    writeln(no_midi);
-    close(f); exit;
-  end;
-
-  HeaderLength:=ReadLength;
-  format:=ReadWord;
-  trackchunks:=ReadWord;
-  division:=ReadWord;
-
-  ms_deltatime:=3;
-
-  SkipOver(HeaderLength-6);
-
-
-  for tc:=1 to TrackChunks do begin
-    SkipOver(4);
-    ChunkLength:=ReadLength;
-    cl:=0;
-    repeat
-      deltatime:=ReadDeltatime;
-      delay(deltatime*ms_deltatime);
-      read(f,firstval); inc(cl);
-      if firstval>=$F0 then
-        status:=firstval
-      else
-       if firstval>=$80 then begin
-         status:=firstval;
-         read(f,firstval); inc(cl);
-         write_midi(status);
-       end;
-      case status of
-        $80..$9F: begin            { Note on/Note off }
-          write_midi(firstval);
-          read(f,value); inc(cl);
-          write_midi(value);
-        end;
-        $A0..$BF: begin            { Key-Pressure und Parameter }
-          write_midi(firstval);
-          read(f,value); inc(cl);
-          write_midi(value);
-        end;
-        $C0..$DF: begin            { Program und Channel }
-          write_midi(firstval);
-        end;
-        $E0..$EF: begin            { Pitch Wheel }
-          write_midi(firstval);
-          read(f,value); inc(cl);
-          write_midi(value);
-        end;
-        $F0: begin
-          SkipOver(ReadByte);
-        end;
-        $F7: begin
-          SkipOver(ReadByte);
-        end;
-        $FF: begin
-          SkipOver(1);
-          SkipOver(ReadByte);
-        end;
-      end;
-    until cl=ChunkLength;
-  end;
-
-  close(f);
-
-end.
-
diff --git a/makedata/midtool.pas b/makedata/midtool.pas
deleted file mode 100644
index 7523bf2..0000000
--- a/makedata/midtool.pas
+++ /dev/null
@@ -1,640 +0,0 @@
-UNIT MIDTool;
-{* Unit for reading SMF info *}
-INTERFACE
-Uses Dos, Crt;
-CONST
-   MIDToolVersion = 'v1.0';
-   MChunkH = 'MThd';
-   MChunkT = 'MTrk';
-TYPE
-   ChunkName = ARRAY[0..3] OF CHAR;
-   ChunkSize = ARRAY[0..3] OF BYTE;
-   DeltaType = RECORD
-                Data : ARRAY[0..3] OF BYTE;
-                Count: BYTE;
-                END;
-{ Data type for all necessary chunk information }
-   MIDChunkInfo = RECORD
-             ckID   : ChunkName;
-             ckSize : ChunkSize;
-             END;
-{ Data type  - all SMF header chunk data needed for typecast accesses }
-   MIDChunkHeader = RECORD
-             ckID   : ChunkName;
-             ckSize : ChunkSize;
-             Format : WORD;
-             Tracks : WORD;
-             Divis  : WORD;
-             END;
-{ MIDFiletype is the standard file type }
-   MIDFileType = FILE;
-VAR
-   MIDErrStat  : WORD;
-   MIDFormat   : WORD;
-   MIDTracks   : WORD;
-   MIDDivis    : WORD;
-PROCEDURE PrintMIDErrMessage;
-FUNCTION  MIDGetBuffer(VAR MIDBuffer:Pointer;
-                           MIDFilename:String):BOOLEAN;
-FUNCTION  MIDFreeBuffer (VAR MIDBuffer : Pointer):BOOLEAN;
-FUNCTION  MIDCalcSize(MSize : ChunkSize): LongInt;
-FUNCTION  MIDCalcDeltaValue(DeltaVal:DeltaType):LongInt;
-PROCEDURE MIDIncrementPtr(VAR MIDBuffer : Pointer;
-                              InternSize : LongInt);
-PROCEDURE MIDSkipChunk(VAR MIDBuffer : Pointer);
-PROCEDURE MIDReadDeltaValue(VAR MIDBuffer:Pointer;
-                            VAR DVal:DeltaType);
-PROCEDURE MIDScanMetaEvent(VAR MIDBuffer : Pointer);
-PROCEDURE MIDScanMIDIEvent(VAR MIDBuffer : Pointer);
-PROCEDURE MIDInterpretChunk(VAR MIDBuffer : Pointer);
-FUNCTION  MIDBuildScript(MIDFilename : String; Flag : BYTE):BOOLEAN;
-
-IMPLEMENTATION
-VAR
-   Regs        : Registers;
-   MIDFileSize : LongInt;
-   MIDGlobSize : LongInt;
-   MIDLoclSize : LongInt;
-   M           : Text;
-PROCEDURE PrintMIDErrMessage;
-{* INPUT    : None
- * OUTPUT   : None
- * PURPOSE  : Displays MID error text without changing error status. }
-BEGIN
-   CASE MIDErrStat OF
-      200 : Write(' MID file not found ');
-      210 : Write(' No memory free for MID file ');
-      220 : Write(' File is not in MID format ');
-      300 : Write(' Memory allocation error occurred ');
-      END;
-   END;
-FUNCTION Exists (Filename : STRING):BOOLEAN;
-{* INPUT    : Filename as string
- * OUTPUT   : TRUE, if file exists, otherwise FALSE
- * PURPOSE  : Checks whether a file already exists, returns a Boolean exp. }
-VAR
-   F : File;
-BEGIN
-   Assign(F,Filename);
-{$I-}
-   Reset(F);
-   Close(F);
-{$I+}
-   Exists := (IoResult = 0) AND (Filename <> '');
-   END;
-PROCEDURE AllocateMem (VAR Pt : Pointer; Size : LongInt);
-{* INPUT    : Buffer variable as pointer, buffer size as LongInt
- * OUTPUT   : Pointer to buffer in variable or NIL
- * PURPOSE  : Reserves as many bytes as specified by size and then
- *            places the pointer in the Pt variable. If not enough
- *            memory is available, then Pt points to NIL. }
-VAR
-   SizeIntern : WORD; { Size of buffer for internal calculation }
-BEGIN
-   Inc(Size,15);
-   SizeIntern := (Size shr 4);
-   Regs.AH := $48;
-   Regs.BX := SizeIntern;
-   MsDos(Regs);
-   IF (Regs.BX <> SizeIntern) THEN Pt := NIL
-   ELSE Pt := Ptr(Regs.AX,0);
-   END;
-FUNCTION  MIDGetBuffer(VAR MIDBuffer:Pointer;
-                       MIDFilename:String):BOOLEAN;
-{* INPUT    : Variable for buffer as pointer, filename as string
- * OUTPUT   : Pointer to buffer with MID data, TRUE/FALSE
- * PURPOSE  : Loads a file into memory and returns a value of TRUE
- *            if successfully loaded, otherwise returns FALSE. }
-VAR
-   FPresent   : BOOLEAN;
-   MIDFile    : MIDFileType;
-   Segs       : WORD;
-   Read       : WORD;
-BEGIN
-   FPresent := Exists(MIDFilename);
-{ MID file not found }
-   IF Not(FPresent) THEN BEGIN
-      MIDGetBuffer := FALSE;
-      MIDErrStat   := 200;
-      EXIT
-      END;
-   Assign(MIDFile,MIDFilename);
-   Reset(MIDFile,1);
-   MIDFileSize := Filesize(MIDFile);
-   AllocateMem(MIDBuffer, MIDFileSize);
-{ Not enough memory for MID file }
-   IF (MIDBuffer = NIL) THEN BEGIN
-      Close(MIDFile);
-      MIDGetBuffer := FALSE;
-      MIDErrStat   := 210;
-      EXIT;
-      END;
-   Segs := 0;
-   REPEAT
-      Blockread(MIDFile,Ptr(Seg(MIDBuffer^)+4096*Segs,
-                Ofs(MIDBuffer^))^,$FFFF,Read);
-      Inc(Segs);
-      UNTIL Read = 0;
-   Close(MIDFile);
-{ File not in MID format }
-   IF ( MIDChunkInfo(MIDBuffer^).ckID <> MChunkH) THEN BEGIN
-      MIDGetBuffer := FALSE;
-      MIDErrStat := 220;
-      EXIT;
-      END;
-{ Load successful }
-   MIDGetBuffer := TRUE;
-   MIDErrStat   := 0;
-{ Read MIDI file type in global variable }
-   MIDFormat := Swap(MIDChunkHeader(MIDBuffer^).Format);
-{ Read number of tracks contained in global variable }
-   MIDTracks := Swap(MIDChunkHeader(MIDBuffer^).Tracks);
-{ Read division value in global variable }
-   MIDDivis  := Swap(MIDChunkHeader(MIDBuffer^).Divis);
-   END;
-FUNCTION MIDFreeBuffer (VAR MIDBuffer : Pointer):BOOLEAN;
-{* INPUT    : Pointer to buffer as pointer
- * OUTPUT   : None
- * PURPOSE  : Releases memory allocated by the MID data. }
-BEGIN
-   Regs.AH := $49;
-   Regs.ES := seg(MIDBuffer^);
-   MsDos(Regs);
-   MIDFreeBuffer := TRUE;
-   IF (Regs.AX = 7) OR (Regs.AX = 9) THEN BEGIN
-      MIDFreeBuffer := FALSE;
-      MIDErrStat := 300
-      END;
-   END;
-FUNCTION MIDCalcSize(MSize : ChunkSize): LongInt;
-{* INPUT    : 32 bit number as 4 byte array
- * OUTPUT   : Real 32 bit value as LongInt
- * PURPOSE  : Converts the reflected 32-bit value of the MID file
- *            to a real 32-bit LongInt value.}
-VAR
-   Power : REAL;
-   Dummy : LongInt;
-   Count : BYTE;
-  BEGIN
-   Dummy := 0;
-   FOR Count := 3 DOWNTO 0 DO BEGIN
-    Power := Exp(Count * Ln(256));
-    Dummy := Dummy + (Trunc(Power)*MSize[3-Count]);
-    END;
-   MIDCalcSize := Dummy;
-   END;
-FUNCTION  MIDCalcDeltaValue(DeltaVal:DeltaType):LongInt;
-{* INPUT    : DeltaVal as a record of DeltaType
- * OUTPUT   : Real Delta value as LongInt
- * PURPOSE  : Calculates the real value from the scanned Delta byte
- *            by masking the highest bit and then raising the values
- *            to corresponding higher values. This routine is used
- *            for determining Meta event sizes and DeltaTimes. }
-VAR
-   Power : REAL;
-   Dummy : LongInt;
-   Loop  : BYTE;
-BEGIN
-   Dummy := 0;
-   WITH DeltaVal DO BEGIN
-      FOR Loop := (Count-1) DOWNTO 0 DO BEGIN
-       Power := Exp(Loop * Ln(128));
-       Dummy := Dummy+(Trunc(Power)*(Data[(Count-1)-Loop] AND $7F));
-       END;
-      END;
-   MIDCalcDeltaValue := Dummy;
-   END;
-PROCEDURE MIDIncrementPtr(VAR MIDBuffer : Pointer;
-                              InternSize : LongInt);
-{* INPUT    : Pointer variable to current position in the MID data
- *            as reference parameter, increment value as LongInt
- * OUTPUT   : None (new pointer from reference)
- * PURPOSE  : Increments the value of the passed pointer by the value
- *            InternSize. Increases beyond a segment limit are taken
- *            into account. }
-VAR
-  Segment    : WORD;
-  Offset     : WORD;
-  Offnew     : WORD;
-  SegCount   : LongInt;
-BEGIN
-{ Negative increment not allowed }
-  IF (InternSize < 0) THEN Exit;
-  Segment := Seg(MIDBuffer^);
-  Offset  := Ofs(MIDBuffer^);
-{ How many segments must be incremented? }
-  SegCount := (InternSize DIV $10000);
-{ Calculate new offset address }
-  Offnew  := Offset+InternSize;
-{ Was the increment value smaller than a segment, but the results  }
-{ still exceed the segment limit? Increment segment by 1.          }
-  IF ((Offnew <= Offset) AND (SegCount = 0) AND (InternSize > 0))
-  THEN SegCount := 1;
-  INC(Segment, SegCount*$1000);
-  MIDBuffer := Ptr(Segment,Offnew);
-  INC(MIDGlobSize,InternSize);
-  INC(MIDLoclSize,InternSize);
-  END;
-PROCEDURE MIDSkipChunk(VAR MIDBuffer : Pointer);
-{* INPUT    : Pointer variable to current position in the MID data as
- *            reference parameter
- * OUTPUT   : None (new pointer from reference)
- * PURPOSE  : Skips the adjacent chunk with the help of the size
- *            information in the chunk itself. }
-VAR
-  InternSize : LongInt;
-  Segment    : WORD;
-  Offset     : WORD;
-BEGIN
-{ Determine the size of the data, and then add the 8 bytes for }
-{ the ID bytes and the size bytes                              }
-  InternSize := MIDCalcSize(MIDChunkInfo(MIDBuffer^).ckSize)+8;
-  MIDIncrementPtr(MIDBuffer,InternSize);
-  END;
-PROCEDURE MIDReadDeltaValue(VAR MIDBuffer:Pointer; VAR DVal:DeltaType);
-{* INPUT    : Pointer variable to current position in MID data as
- *            reference parameter, record for DeltaTime as reference
- * OUTPUT   : (new pointer from reference)
- *            (filled array in record from reference)
- *            (number of scanned Delta bytes in reference record)
- * PURPOSE  : Selects the size coded Delta values from the MID data
- *            and writes them to the passed array of the record. }
-VAR
-   ActData  : BYTE;
-   ActDelta : BYTE;
-BEGIN
-{ Delete passed array, so that there are no longer any "false" }
-{ byte scontained. This is only a cosmetic improvement.        }
-   FOR ActDelta := 0 to 3 DO DVal.Data[ActDelta] := 0;
-{ Set bit 7 }
-   ActData  := 128;
-   ActDelta := 0;
-{ while bit 7 is set, read Delta bytes }
-   WHILE ((ActData AND $80)=$80) DO BEGIN
-      ActData := BYTE(MIDBuffer^);
-      DVal.Data[ActDelta] := ActData;
-      INC(ActDelta);
-      MIDIncrementPtr(MIDBuffer,1);
-      END;
-   DVal.Count := ActDelta;
-   END;
-PROCEDURE MIDScanSysExEvent(VAR MIDBuffer : Pointer);
-{* INPUT    : Pointer variable to current position in MID data
- *            as reference parameter
- * OUTPUT   : None (new pointer from reference)
- * PURPOSE  : If the passed pointer points to a SysEx event in the
- *            MID data in memory, then the message is displayed here,
- *            and the rest of the events are skipped. }
-VAR
-   DeltaTime : DeltaType;
-   SysExSize : LongInt;
-BEGIN
-   WriteLn(M,'System Exclusive (');
-   MIDIncrementPtr(MIDBuffer,1);
-{ Determine size of the Meta event }
-   MIDReadDeltaValue(MIDBuffer, DeltaTime);
-   SysExSize := MIDCalcDeltaValue(DeltaTime);
-   WriteLn(SysExSize,' Bytes)');
-   MIDIncrementPtr(MIDBuffer, SysExSize);
-   END;
-PROCEDURE MIDScanMetaEvent(VAR MIDBuffer : Pointer);
-{* INPUT    : Pointer variable to current position in the MID data
- *            as reference parameter
- * OUTPUT   : None (new pointer from reference)
- * PURPOSE  : If pointer passed points to Meta event in the MID data
- *            in memory, then the event is interpreted according to
- *            its data, and the appropriate text is displayed. }
-TYPE
-  Overhead = ARRAY[0..5] OF BYTE;
-VAR
-   ActEvent : BYTE;
-   EventType: BYTE;
-   DeltaVal: DeltaType;
-   MetaSize : LongInt;
-   MetaWord : WORD;
-   MetaLong : LongInt;
-   ActCount : LongInt;
-BEGIN
-   Write(M,'Meta event : ');
-   ActEvent  := Overhead(MIDBuffer^)[0];
-   EventType := Overhead(MIDBuffer^)[1];
-   MIDIncrementPtr(MIDBuffer,2);
-{ Determine size of Meta event }
-   MIDReadDeltaValue(MIDBuffer, DeltaVal);
-   MetaSize := MIDCalcDeltaValue(DeltaVal);
-   CASE EventType OF
-{ Event 0 - Sequence number }
-   00 : BEGIN
-         MetaWord := Swap(WORD(MIDBuffer^));
-         WriteLn(M,'Sequence number : ',MetaWord);
-         MIDIncrementPtr(MIDBuffer, MetaSize);
-         END;
-{ Event 1 - General text }
-   01 : BEGIN
-         Write(M,'Text : ');
-         FOR ActCount := 0 TO (MetaSize-1) DO BEGIN
-            Write(M,CHAR(MIDBuffer^));
-            MIDIncrementPtr(MIDBuffer, 1);
-            END;
-         WriteLn(M);
-         END;
-{ Event 2 - Copyright text }
-   02 : BEGIN
-         Write(M,'Copyright : ');
-         FOR ActCount := 0 TO (MetaSize-1) DO BEGIN
-            Write(M,CHAR(MIDBuffer^));
-            MIDIncrementPtr(MIDBuffer, 1);
-            END;
-         WriteLn(M);
-         END;
-{ Event 3 - Track name as text }
-   03 : BEGIN
-         Write(M,'Track Name : ');
-         FOR ActCount := 0 TO (MetaSize-1) DO BEGIN
-            Write(M,CHAR(MIDBuffer^));
-            MIDIncrementPtr(MIDBuffer, 1);
-            END;
-         WriteLn(M);
-         END;
-{ Event 4 - Instrument name as text }
-   04 : BEGIN
-         Write(M,'Instrument : ');
-         FOR ActCount := 0 TO (MetaSize-1) DO BEGIN
-            Write(M,CHAR(MIDBuffer^));
-            MIDIncrementPtr(MIDBuffer, 1);
-            END;
-         WriteLn(M);
-         END;
-{ Event 5 - Song text }
-   05 : BEGIN
-         Write(M,'Lyric : ');
-         FOR ActCount := 0 TO (MetaSize-1) DO BEGIN
-            Write(M,CHAR(MIDBuffer^));
-            MIDIncrementPtr(MIDBuffer, 1);
-            END;
-         WriteLn(M);
-         END;
-{ Event 6 - Marker value }
-   06 : BEGIN
-         Write(M,'Marker : ');
-         FOR ActCount := 0 TO (MetaSize-1) DO BEGIN
-            Write(M,CHAR(MIDBuffer^));
-            MIDIncrementPtr(MIDBuffer, 1);
-            END;
-         WriteLn(M);
-         END;
-{ Event 7 - Cue Point for video / film }
-   07 : BEGIN
-         Write(M,'Cue Point : ');
-         FOR ActCount := 0 TO (MetaSize-1) DO BEGIN
-            Write(M,CHAR(MIDBuffer^));
-            MIDIncrementPtr(MIDBuffer, 1);
-            END;
-         WriteLn(M);
-         END;
-{ Events 8-15 - not yet allocated, but reserved }
-   08, 09, 10, 11, 12, 13, 14, 15
-       : BEGIN
-          WriteLn(M,'Reserved but unallocated.');
-          MIDIncrementPtr(MIDBuffer, MetaSize);
-          END;
-{ Event 33 - Channel selector ID }
-   31  : BEGIN
-          Write(M,'Channel Prefix Data ');
-          WriteLn(M,BYTE(MIDBuffer^));
-          MIDIncrementPtr(MIDBuffer, 1);
-          END;
-{ Event 47 - Display end of track }
-   47  : BEGIN
-          WriteLn(M,'End of Track');
-          END;
-{ Event 81 - Microsecond per quarter note for MIDI clock }
-   81  : BEGIN
-          Write(M,'Set Tempo ');
-          MetaLong := 65536 * Overhead(MIDBuffer^)[0];
-          INC(MetaLong,256 * Overhead(MIDBuffer^)[1]);
-          INC(MetaLong,Overhead(MIDBuffer^)[2]);
-          WriteLn(M,MetaLong,' Microsecs. per quarter note');
-          MIDIncrementPtr(MIDBuffer, 3);
-          END;
-{ Event 84 - SMPTE parameters }
-   84  : BEGIN
-          Write(M,'SMPTE Offset ');
-          Write(M,Overhead(MIDBuffer^)[0],'hr ');
-          Write(M,Overhead(MIDBuffer^)[1],'min ');
-          Write(M,Overhead(MIDBuffer^)[2],'sec ');
-          Write(M,Overhead(MIDBuffer^)[3],'Frames ');
-          WriteLn(M,Overhead(MIDBuffer^)[4],' 1/100 frames');
-          MIDIncrementPtr(MIDBuffer, 5);
-          END;
-{ Event 88 - Parameters for MIDI clock }
-   88  : BEGIN
-          WriteLn(M,'Time Signature ');
-          WriteLn(M,'             Numerator   : ',Overhead(MIDBuffer^)[0]);
-          WriteLn(M,'             Denominator : ',Overhead(MIDBuffer^)[1]);
-          WriteLn(M,'             MIDI Clocks : ',Overhead(MIDBuffer^)[2]);
-          WriteLn(M,'             32/4  : ',Overhead(MIDBuffer^)[3]);
-          MIDIncrementPtr(MIDBuffer, 4);
-          END;
-{ Event 127 - Parameters for MIDI clock }
-  127  : BEGIN
-          Write(M,'Sequencer Specific - ');
-          WriteLn(M,'Format Unknown');
-          MIDIncrementPtr(MIDBuffer, MetaSize);
-          END
-{ Event unknown - will not be interpreted }
-   ELSE BEGIN
-       WriteLn(M,'Event Unknown');
-       MIDIncrementPtr(MIDBuffer, MetaSize);
-       END;
-      END;
-   END;
-PROCEDURE MIDScanMIDIEvent(VAR MIDBuffer : Pointer);
-{* INPUT    : Pointer variable to current position in the MID data
- *            as reference parameter
- * OUTPUT   : None (new pointer from reference)
- * PURPOSE  : If pointer passed points to MIDI event in the MID data
- *            in memory, then the event is interpreted according to
- *            its data and an appropriate text is displayed. }
-TYPE
-   Overhead = ARRAY[0..5] OF BYTE; { Type for necessary typecast }
-VAR
-   ActEvent : BYTE;  { Contains number of current MIDI event }
-   ActData  : BYTE;
-BEGIN
-   Write(M,'(MIDI) ');
-   ActEvent := Overhead(MIDBuffer^)[0];
-{ Note Off event for all 16 channels }
-   IF (ActEvent IN [128..128+15]) THEN BEGIN
-      Write(M,'Note Off       : ');
-      Write(M,'Pitch = ',Overhead(MIDBuffer^)[1]:3,',  ');
-      WriteLn(M,'Volume = ',Overhead(MIDBuffer^)[2]);
-      MIDIncrementPtr(MIDBuffer,3);
-      Exit;
-      END;
-{ Note On event for all 16 channels }
-   IF (ActEvent IN [144..144+15]) THEN BEGIN
-      Write(M,'Note On        : ');
-      Write(M,'Pitch = ',Overhead(MIDBuffer^)[1]:3,',  ');
-      WriteLn(M,'Volume = ',Overhead(MIDBuffer^)[2]);
-      MIDIncrementPtr(MIDBuffer,3);
-      Exit;
-      END;
-{ Aftertouch event for all 16 channels }
-   IF (ActEvent IN [160..160+15]) THEN BEGIN
-      Write(M,'Aftertouch     : ');
-      Write(M,'Pitch = ',Overhead(MIDBuffer^)[1]:3,',  ');
-      WriteLn(M,'Volume ',Overhead(MIDBuffer^)[2]);
-      MIDIncrementPtr(MIDBuffer,3);
-      Exit;
-      END;
-{ Control change event for all 16 channels }
-   IF (ActEvent IN [176..176+15]) THEN BEGIN
-      Write(M,'Control change : ');
-      Write(M,'Number ',Overhead(MIDBuffer^)[1]:3,',  ');
-      WriteLn(M,'Value   ',Overhead(MIDBuffer^)[2]);
-      MIDIncrementPtr(MIDBuffer,3);
-      Exit;
-      END;
-{ Program change event for all 16 channels }
-   IF (ActEvent IN [192..192+15]) THEN BEGIN
-      Write(M,'Program change : ');
-      WriteLn(M,'Number ',Overhead(MIDBuffer^)[1]:3);
-      MIDIncrementPtr(MIDBuffer,2);
-      Exit;
-      END;
-{ Aftertouch event for all 16 channels }
-   IF (ActEvent IN [208..208+15]) THEN BEGIN
-      Write(M,'Aftertouch     : ');
-      WriteLn(M,'Volume ',Overhead(MIDBuffer^)[1]);
-      MIDIncrementPtr(MIDBuffer,2);
-      Exit;
-      END;
-{ Pitch bend event for all 16 channels }
-   IF (ActEvent IN [224..224+15]) THEN BEGIN
-      Write(M,'Pitch Bender   : ');
-      Write(M,'Low Byte ',Overhead(MIDBuffer^)[1]:3,',  ');
-      WriteLn(M,'High Byte ',Overhead(MIDBuffer^)[2]);
-      MIDIncrementPtr(MIDBuffer,3);
-      Exit;
-      END;
-   END;
-PROCEDURE MIDInterpretChunk(VAR MIDBuffer : Pointer);
-{* INPUT    : Pointer variable to current position in the MID data
- *            as Reference parameter
- * OUTPUT   : None (new pointer from reference)
- * PURPOSE  : Scans chunk data and checks for known chunk IDs. When a
- *            header chunk is found, header data is displayed. When a
- *            track chunk is found, the data are interpreted by the
- *            function above for the different events. }
-VAR
-   ActSize  : LongInt;
-   ActChunk : Chunkname;
-   ActData  : BYTE;
-   ActTime  : LongInt;
-   DeltaVal : DeltaType;
-   SizeCount: LongInt;
-   SaveStart: Pointer;
-BEGIN
-   SizeCount:= 0;
-   ActData  := 0;
-{ Determine the type of the chunk }
-   ActChunk := MIDChunkInfo(MIDBuffer^).ckID;
-{ Determine the size of the chunk }
-   ActSize  := MIDCalcSize(MIDChunkInfo(MIDBuffer^).ckSize);
-{ Header chunk has been found }
-   IF (ActChunk = MChunkH) THEN BEGIN
-      WriteLn(M,'========================================================');
-      WriteLn(M,'MIDI header chunk');
-      Write(M,'Chunk type    : ',(MIDChunkInfo(MIDBuffer^).ckID));
-      WriteLn(M,'(',ActSize,' Bytes)');
-      WriteLn(M,'MIDI file type : ', MIDFormat:1);
-      WriteLn(M,'Track number  : ', MIDTracks);
-      MIDSkipChunk(MIDBuffer);
-      END
-   ELSE
-{ Track chunk has been found }
-   IF (ActChunk = MChunkT) THEN BEGIN
-      WriteLn(M,'========================================================');
-      WriteLn(M,'MIDI track chunk');
-      Write(M,'Chunk type  : ',(MIDChunkInfo(MIDBuffer^).ckID));
-      WriteLn(M,'(',ActSize,' Bytes)');
-      WriteLn(M,'--------------------------------------------------------');
-      MIDIncrementPtr(MIDBuffer,SizeOf(MIDChunkInfo));
-      SaveStart := MIDBuffer;
-{ New chunk has been started, so set MIDLoclSize to 0 }
-      MIDLoclSize := 0;
-      WHILE (MIDLoclSize < ActSize) DO BEGIN
-{ Read DeltaTime of event }
-         MIDReadDeltaValue(MIDBuffer, DeltaVal);
-         ActTime  := MIDCalcDeltaValue(DeltaVal);
-{ What kind of event is it ? }
-         ActData  := BYTE(MIDBuffer^);
-{ It is a MIDI event }
-         IF (ActData IN [$80..$EF]) THEN BEGIN
-            Write(M,'Delta = ',ActTime:7,'-> ');
-            MIDScanMIDIEvent(MIDBuffer);
-            END;
-{ It is a Meta event }
-         IF (ActData = $FF) THEN MIDScanMetaEvent(MIDBuffer);
-{ It is a System Exclusive event }
-         IF (ActData IN [$F0, $F7]) THEN MIDScanSysExEvent(MIDBuffer);
-         END;
-      END
-{ No chunk recognized }
-   ELSE
-    MIDSkipChunk(MIDBuffer);
-   END;
-FUNCTION MIDBuildScript(MIDFilename : String; Flag : BYTE):BOOLEAN;
-{* INPUT    : Filename of desired MIDI file as string
- * OUTPUT   : None
- * PURPOSE  : Creates script file in SMF format from MIDI file, in
- *            which the events are broken down into details. }
-VAR
-   MIDBuffer : Pointer; { Variable for MID data in memory    }
-   MIDIntern : Pointer; { Copy of variable above for processing }
-   Check     : BOOLEAN;
-   WorkStr   : String;
-BEGIN
-   IF (Flag = 1) THEN BEGIN
-      IF (Pos('.',MIDFileName) > 0) THEN
-         WorkStr := Copy(MIDFileName,1,Pos('.',MIDFileName)-1);
-      Assign(M,WorkStr+'.TXT');
-      END
-   ELSE AssignCrt(M);
-   ReWrite(M);
-   MIDBuildScript := FALSE;
-{ Read MID file into memory }
-   Check := MIDGetBuffer(MIDBuffer, MIDFilename);
-{ If error occurred and file was already in memory, release memory }
-   IF (Check = FALSE) THEN BEGIN
-      IF (MIDErrStat = 220) THEN Check := MIDFreeBuffer(MIDBuffer);
-      Exit;
-      END;
-{ Display header }
-   WriteLn(M,'MIDSCRIPT  -  A MIDI File Scripter');
-   WriteLn(M,'----------------------------------');
-   WriteLn(M,'Name of MIDI file  : ', MIDFilename);
-   WriteLn(M,'File size in bytes : ', MIDFileSize);
-   WriteLn(M);
-{ Initialize global variable }
-   MIDGlobSize := 0;
-{ Make copy of pointer variable }
-   MIDIntern := MIDBuffer;
-{ Until end of data has been reached, continue taking data }
-{ from memory and interpret it according to SMF standards. }
-   REPEAT
-      MIDInterpretChunk(MIDIntern);
-      WriteLn('   ',(MIDGlobSize*100/MIDFileSize):3:2,'%  finished');
-      Gotoxy(1, WhereY-1);
-      UNTIL (MIDGlobSize >= MIDFileSize);
-   WriteLn;
-{ Finished working, free memory }
-   Check := MIDFreeBuffer(MIDBuffer);
-   Close(M);
-   IF (Check = TRUE) THEN MIDBuildScript := TRUE;
-   END;
-
-BEGIN
-   MIDErrStat := 0;
-   END.
diff --git a/makedata/mkintro.pas b/makedata/mkintro.pas
deleted file mode 100644
index 82c3602..0000000
--- a/makedata/mkintro.pas
+++ /dev/null
@@ -1,237 +0,0 @@
-program makeintroscreen;
-
-uses crt,data,graph;
-
-const
- cd: byte=2*16-2;
-var
- i,j,a: integer;
- vgafile: file of screentype;
- temppal: paltype;
-
-procedure savepalette(s: string);
-var palfile: file of paltype;
-begin
- assign(palfile,s);
- rewrite(palfile);
- write(palfile,colors);
- close(palfile);
- set256colors(colors);
-end;
-
-procedure part1;
-begin
- loadscreen('makedata\intro.vga');
- loadpal('makedata\intro.pal');
- set256colors(colors);
- tslice:=200;
-{ for a:=0 to 15 do
-  for i:=40 to 90 do
-   for j:=170 downto a do screen[i,j]:=screen[i,j-1];
-}
- for j:=0 to 319 do
-  for i:=0 to 199 do
-   if screen[i,j] div 64=1 then screen[i,j]:=0;
-
- for j:=32 to 52 do
-  begin
-   colors[j,1]:=round((j-31)*2.2);
-   colors[j,2]:=round((j-31)*2.0);
-   colors[j,3]:=round((j-31)*3.0);
-  end;
- tslice:=200;
- set256colors(colors);
- for a:=18 downto 2 do
- for j:=0 to 319 do
-  for i:=0 to 199 do
-   if (screen[i,j]<>0) and ((screen[i,j]<2+cd) or (screen[i,j]>a+cd)) then
-    begin
-     if screen[i,j-1]<2 then screen[i,j-1]:=a+cd;
-     if screen[i,j+1]<2 then screen[i,j+1]:=a+cd;
-     if screen[i-1,j]<2 then screen[i-1,j]:=a+cd;
-     if screen[i+1,j]<2 then screen[i+1,j]:=a+cd;
-    end;
-
- readkey;
-
-{ mymove(colors,temppal,192);
- for a:=29 downto 1 do
-  begin
-   for j:=0 to 255 do
-    if j<>51 then
-     begin
-      for i:=1 to 3 do
-       temppal[j,i]:=round(a*colors[j,i]/30);
-     end
-    else
-     begin
-      if a>20 then
-       begin
-        for i:=1 to 3 do
-         temppal[51,i]:=round((a-20)*colors[51,i]/10);
-       end
-      else
-       begin
-        temppal[51,1]:=round(63/20*(20-a));
-       end;
-     end;
-   set256colors(temppal);
-   delay(tslice);
-  end;
- fillchar(temppal,768,0);
- set256colors(temppal);
- delay(tslice);
-}
- assign(vgafile,'data\intro2.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);
-end;
-
-procedure part5;
-begin
- loadscreen('makedata\c7.vga');
-{ for j:=0 to 319 do
-  for i:=0 to 199 do
-   if screen[i,j]>0 then screen[i,j]:=(screen[i,j] mod 16) + 64;
-
- for j:=64 to 95 do
-  begin
-   colors[j,1]:=round((j-63)*1.0);
-   colors[j,2]:=round((j-63)*2.0);
-   colors[j,3]:=round((j-63)*3.0);
-  end;
-
-} for j:=32 to 47 do
-  begin
-   colors[j,1]:=round((j-31)*2.0);
-   colors[j,2]:=round((j-31)*2.0);
-   colors[j,3]:=round((j-31)*4.0);
-  end;
- set256colors(colors);
-
- for a:=14 downto 2 do
- for j:=0 to 319 do
-  for i:=0 to 199 do
-   if (screen[i,j]>a+cd) then
-    begin
-     if screen[i,j-1]<2 then screen[i,j-1]:=a+cd;
-     if screen[i,j+1]<2 then screen[i,j+1]:=a+cd;
-     if screen[i-1,j]<2 then screen[i-1,j]:=a+cd;
-     if screen[i+1,j]<2 then screen[i+1,j]:=a+cd;
-
-     if screen[i,j-2]<2 then screen[i,j-1]:=a+cd;
-     if screen[i,j+2]<2 then screen[i,j+1]:=a+cd;
-     if screen[i-2,j]<2 then screen[i-1,j]:=a+cd;
-     if screen[i+2,j]<2 then screen[i+1,j]:=a+cd;
-    end;
- readkey;
- savepalette('data\channel7.pal');
- assign(vgafile,'data\channel7.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);
-end;
-
-procedure part2;
-var temp: ^screentype;
-begin
- new(temp);
- assign(vgafile,'data\intro2.vga');
- reset(vgafile);
- read(vgafile,temp^);
- close(vgafile);
- loadpal('data\intro2.pal');
- set256colors(colors);
- for a:=15 downto 2 do
-  begin
-  for j:=0 to 319 do
-   begin
-    for i:=0 to 199 do
-     begin
-      setfillstyle(1,temp^[i,j]);
-      bar(j- a div 2,i-a div 2,j+a div 2,i+a div 2);
-      i:=i+a;
-      if i>199 then i:=199;
-     end;
-    j:=j+a;
-    if j>319 then j:=319;
-   end;
-   delay(tslice div 4);
-  end;
- screen:=temp^;
- readkey;
- for a:=2 to 15 do
-  begin
-  for j:=0 to 319 do
-   begin
-    for i:=0 to 199 do
-     begin
-      setfillstyle(1,temp^[i,j]);
-      bar(j-a div 2,i-a div 2,j+a div 2,i+a div 2);
-      i:=i+a;
-      if i>199 then i:=199;
-     end;
-    j:=j+a;
-    if j>319 then j:=319;
-   end;
-  delay(tslice div 4);
- end;
- fillchar(screen,64000,0);
- readkey;
- dispose(temp);
-end;
-
-procedure part3;
-var temp: ^screentype;
-begin
- new(temp);
- for a:=0 to 9 do
-  begin
-   setfillstyle(1,16);
-   bar(0,a*20,319,a*20+19);
-   setcolor(22);
-   line(0,a*20,319,a*20);
-   line(0,a*20,0,a*20+19);
-   setcolor(8);
-   line(0,a*20+19,319,a*20+19);
-   line(319,a*20,319,a*20+19);
-  end;
- readkey;
- temp^:=screen;
- for a:=9 downto 0 do
-  begin
-   for i:=18 downto 1 do
-    begin
-     move(screen[a*20+i],screen[a*20+i+1],320);
-    end;
-   delay(tslice);
-  end;
- readkey;
- dispose(temp);
-end;
-
-procedure part4;
-var temp: ^screentype;
-begin
- new(temp);
- loadscreen('data\main.vga');
- temp^:=screen;
- for a:=2 to 10 do
-  begin
-  for j:=0 to 319 do
-   begin
-    for i:=0 to 199 do
-     begin
-      setfillstyle(1,temp^[i,j]);
-      bar(j*a,i*a,j*a+a,i*a+a);
-     end;
-   end;
-  end;
- readkey;
- dispose(temp);
-end;
-
-begin
- part1;
-end.
diff --git a/makedata/mochcon2.txt b/makedata/mochcon2.txt
deleted file mode 100644
index de217a6..0000000
--- a/makedata/mochcon2.txt
+++ /dev/null
@@ -1,96 +0,0 @@
-PRE-ALPHA VERSION (.5)
-PHAEDOR MOCH
-FRIENDLY
-AT THE HOMEWORLD
-
-257     20000   1       4       HI HELLO GREETINGS HYA HIYA SALUTATIONS WELCOME
--1      -1      1       1       HI HELLO GREETINGS HYA HIYA SALUTATIONS WELCOME
--1      20000   1       2       BYE GOOD-BYE GOODBYE OVER OUT 10-4 QUIT
--1      -1      1       5       VOID DWELLERS
--1      -1      1       5       D'PAHK WORMS
--1      -1      1       5       SENGZHAC BUGS BUGGERS
--1      -1      1       5       GUILD
--1      -1      1       9       PHAEDOR MOCH PUPPET
--1      -1      1       5       ERMIGEN
--1      -1      1       5       QUAI PA'LOI
--1      -1      1       5       PAI ALOI
--1      -1      1       5       Q'OOUL
--1      -1      1       5       ICON
--1      -1      1       6       TITERIAN
--1      -1      1       5       YLINTHLIXYMN YILLER
--1      -1      1       5       SCAVENGERS SCAVS
--1      -1      1       5       AARD
--1      -1      1       5       MALZATOIR
--1      -1      1       5       **** NAMELESS
--1      -1      1       23      TROJAN GATE GATES
--1      -1      1       24      MONKS MONK
--1      -1      1       25      HOMEWORLD HOME WORLD
-258     -1      1       26      SELL BUY TRADE TRADERS
-214     20007   1       27      SELL BUY TRADE TRADERS
--1      20111   1       28      *YES.ANSWER
--1      -1      1       29      *NO.ANSWER
--1      -1      1       26      SELL BUY TRADE TRADERS
--1      -1      1       22      SHUNT
--1      -1      1       30      PHASE
--1      -1      1       31      GOD'S EYE
--1      -1      1       32      IRONSEED
-258     -1      1       11      GOOLAS
-214     -1      1       10      GOOLAS
-
--500
-
-HI
-1       HELLO.
-
-BYE
-2       BYE.
-
-HI
-4       P4> OH LOOK, SOMEONE IS HERE FOR THE PARTY.#P2> HEY, DO YOU HAVE AN APPOINTMENT?  WELL THEN GET OUT OF HERE BEFORE I DECIDE TO BLAST YOU.
-
-RACES
-5       WE HAVE BEEN AWAY TO LONG TO KNOW ANYTHING RECENT.
-
-TITERIANS
-6       THEY WERE ALWAYS CONCERNED WITH US.  RATHER NICE GALS TOO.
-
-PUPPET
-9       WE ARE HERE.
-
-GOOLAS
-10      WE WILL _TRADE_ THEM WITH YOU FOR SOME JUNK...WHATEVER YOU MIGHT HAVE.  WE HAVE USES FOR SUCH THINGS.
-
-GOOLAS
-11      WE ALREADY GAVE THEM TO YOU.
-
-SHUNT
-22      THAT SOUNDS INTERESTING...MAYBE WE WILL BE ABLE TO DEVELOP SOMETHING LIKE THAT.
-
-GATES
-23      THEY ARE CONVIENINT FOR HIDING BEHIND.
-
-MONKS
-24      THEY ARE NICE.
-
-HOME WORLD
-25      WE HAD TO HIDE IT HERE.
-
-TRADE
-26      WE HAVE NOTHING THAT WOULD INTEREST YOU.
-
-TRADE
-27      WOULD YOU LIKE TO TRADE SOME JUNK FOR GOOLAS?
-
-YES ANSWER
-28      *should be blank*
-
-NO ANSWER
-29      OK, WELL IF YOU DECIDE YOU WANT THEM WE HAVE THEM.
-
-PHASE
-30      P6> I CAN'T TALK ABOUT THAT...THEY WILL NOTICE#P2> WHAT WAS THAT?#P1> SOUNDED LIKE LOWLEY.  GEE, IT HAS BEEN A LONG TIME SINCE HE VISITED.
-
-GOD'S EYE
-31      COULD BE A TYPE OF TEMPORAL GATE.
-
--500
\ No newline at end of file
diff --git a/makedata/modplay.pas b/makedata/modplay.pas
deleted file mode 100644
index 1e01a95..0000000
--- a/makedata/modplay.pas
+++ /dev/null
@@ -1,73 +0,0 @@
-unit modplay;
-
-interface
-
-var
- stat: integer;
- playing: boolean;
-
-procedure moddevice(var device:integer);
-procedure modsetup(var status:integer;device,mixspeed,pro,loop:integer;var str:string);
-procedure modstop;
-procedure modinit;
-procedure modvolume(v1,v2,v3,v4:integer);
-procedure playmod(s: string; loop: integer);
-procedure fademusic;
-
-implementation
-
-uses crt, data;
-
-{$L MOD-OBJ}
-{$F+}
-procedure moddevice(var device:integer); external ;
-procedure modsetup(var status:integer;device,mixspeed,pro,loop:integer;var str:string); external ;
-procedure modstop; external ;
-procedure modinit; external;
-procedure modvolume(v1,v2,v3,v4:integer); external ;
-{$F-}
-
-procedure playmod(s: string;loop: integer);
-var f: file;
-    smp: integer;
-begin
- if ship.options[3]=0 then
-  begin
-   tslice:=ship.options[2];
-   exit;
-  end;
- assign(f,s);
- reset(f);
- if ioresult<>0 then errorhandler(s,1);
- close(f);
- modvolume(255,255,255,255);
- case ship.options[3] of
-  1: smp:=8000;
-  2: smp:=12000;
-  3: smp:=18000;
- end;
- modsetup(stat,7,smp,0,loop,s);
- playing:=true;
-end;
-
-procedure fademusic;
-var j: integer;
-begin
- if not playing then exit;
- playing:=false;
- if ship.options[3]=0 then
-  begin
-   modstop;
-   exit;
-  end;
- for j:=255 downto 0 do
-  begin
-   modvolume(j,j,j,j);
-   delay(tslice div 8);
-  end;
- modstop;
-end;
-
-begin
-{ modinit;}
-end.
\ No newline at end of file
diff --git a/makedata/mousedit.pas b/makedata/mousedit.pas
deleted file mode 100644
index 7a82397..0000000
--- a/makedata/mousedit.pas
+++ /dev/null
@@ -1,105 +0,0 @@
-program mouseeditor;
-
-uses crt, graph, data;
-
-var
- mouse: array[1..2,1..16,1..16] of byte;
- i,j,a,b,x,y,color: integer;
- ans: char;
-
-procedure init;
-begin
- for a:=1 to 2 do
-  for j:=1 to 16 do
-   for i:=1 to 16 do
-    mouse[a,j,i]:=2-a;
- setcolor(31);
- rectangle(9,9,111,111);
- x:=1;
- y:=1;
-end;
-
-procedure draw;
-begin
- for j:=1 to 16 do
-  for i:=1 to 16 do
-   begin
-    color:=37;
-    if mouse[1,j,i]=0 then color:=0;
-    if mouse[2,j,i]=1 then color:=31;
-    if mouse[1,j,i]=1 then color:=color+16;
-    if (j=x) and (i=y) then setfillstyle(11,color)
-     else setfillstyle(1,color);
-    bar(j*10,i*10,j*10+10,i*10+10);
-    screen[i+50,j+200]:=color;
-   end;
-end;
-
-procedure mainloop;
-begin
- repeat
-  draw;
-  ans:=readkey;
-  case ans of
-   #0:begin
-      ans:=readkey;
-      case ans of
-       #72:if y=1 then y:=16 else dec(y);
-       #80:if y=16 then y:=1 else inc(y);
-       #75:if x=1 then x:=16 else dec(x);
-       #77:if x=16 then x:=0 else inc(x);
-      end;
-     end;
-   '1':begin   {background}
-        mouse[1,x,y]:=1;
-        mouse[2,x,y]:=0;
-       end;
-   '2':begin   {black}
-        mouse[1,x,y]:=0;
-        mouse[2,x,y]:=0;
-       end;
-   '3':begin   {white}
-        mouse[1,x,y]:=0;
-        mouse[2,x,y]:=1;
-       end;
-   '4':begin   {funky}
-        mouse[1,x,y]:=1;
-        mouse[2,x,y]:=1;
-       end;
-  end;
- until ans=#59;
-end;
-
-procedure convert;
-var index,b: byte;
-begin
- textmode(co80);
- writeln;
- writeln;
- for a:=1 to 2 do
-   for i:=1 to 16 do
-    begin
-     b:=0;
-     index:=128;
-     for j:=9 to 16 do
-      begin
-       if mouse[a,i,j]=1 then b:=b+index;
-       index:=index div 2;
-      end;
-     write(b,' ');
-     b:=0;
-     index:=128;
-     for j:=1 to 8 do
-      begin
-       if mouse[a,i,j]=1 then b:=b+index;
-       index:=index div 2;
-      end;
-     write(b,'| ');
-   end;
-end;
-
-begin
- init;
- mainloop;
- convert;
-end.
\ No newline at end of file
diff --git a/makedata/namemake.pas b/makedata/namemake.pas
deleted file mode 100644
index a91b570..0000000
--- a/makedata/namemake.pas
+++ /dev/null
@@ -1,28 +0,0 @@
-program namemake;
-
-type
- nametype= string[15];
-var
- i,j: integer;
- name: nametype;
- ft: text;
- f: file of nametype;
-
-begin
- assign(ft,'makedata\newnames.txt');
- reset(ft);
- assign(f,'data\planname.txt');
- rewrite(f);
- for i:=1 to 750 do
-  begin
-   readln(ft,name);
-   if length(name)<15 then
-    for j:=length(name)+1 to 15 do name[j]:=' ';
-   name[0]:=#12;
-   write(f,name);
-   writeln(name);
-  end;
- close(ft);
- close(f);
-end.
-
diff --git a/makedata/names3.txt b/makedata/names3.txt
deleted file mode 100644
index 2eab1fe..0000000
--- a/makedata/names3.txt
+++ /dev/null
@@ -1,750 +0,0 @@
-HOBYXONID
-EUAVECK
-FYFOZAD
-IXOFUZANE
-EYZI
-OMYON
-FYLOFOE
-DREAMERS
-ANOLUCESYA
-PYLAZ
-OXIELU
-ZEORB
-LEVIZE
-URUE
-KEKEEZOX
-MYBEJYSA
-DENYVN
-XYD
-YTAIL
-BOZYK
-LEVI
-UXOY
-MYHATL
-ELAS
-BENOI
-UPAGA
-NYGA
-CYINITE
-ISOYBOLIN
-IAROKEN
-IMAZOY
-KAKOVIO
-AVILYNIXODA
-RUE
-UDAE
-KUSYO
-UQURECS
-OBACHUS
-FOCUMARUDA
-OVEISEKORAA
-XEJIE
-ZALUKOA
-JILAZUS
-FESAROGA
-GODOVA
-CYA-SORABID
-LANYDE
-RIL OBYK
-PUPOK
-NIL'RYNTH
-KOYNOSUR
-OGOADEEKU
-UXYA
-OILOYOMU
-AXAHI
-CILOC
-EKURJ
-WIZAGO
-HETUMOE
-DELORGEME
-UTOY
-PATONIN
-OORE
-KYGA
-TULAIZIN
-BYCAPUS
-VIMAFORD
-QUXALOR
-AGORIMETA
-EHEDIPI
-BIBIZUUK
-OBRAFEI
-ANAKELORT
-ATUJO
-WANIBORK
-ASYRUKAK
-UGYNISU
-IZYDMOY
-ESYLEKUWU
-ANUSAT
-URV
-GYBEX
-JIKANEM
-HIMUX
-VOHAUT
-GAFAUHU
-MAUGINYPU
-GUEXYT
-FEUFEDA
-BIOHYXIA
-KEUI
-HUNAFIXOGYK
-UDOHODEX
-UVOZARA
-JEOH
-ITOMYHA
-DIBUGH
-OLAGYPULORU
-EKUVENOFER
-GIXE
-PEMYGA
-RYTOGH
-UNYZOROZ
-MICATYOZ
-GENAO
-XILY
-ITOXOBYCEA
-UKARORE
-OKUDER
-OLYLI
-GUK
-OJU
-QUOB
-CIKEODICERK
-YSAE
-AIBUR
-JILUMO
-JEUXIM
-XEDYSY
-ZEVENAT
-EPASUPEKI
-OROAA
-SYKUIDUH
-OJUFIKU
-FALADOSH
-SIMOCUS
-EBOI
-ZEPZ
-QUESEVI
-GOTABE
-ZYTUG
-XYGI
-UGUR
-FELOG
-PEYKEPODYA
-POKEGI
-BEUBYXS
-RELIVY
-BUTATEBA
-UXYNOTH
-IBUAURO
-UWOZEA
-XAO
-UVES
-HEZAXOKIE
-ZEBOAHANOO
-SELEDABYLAO
-ASAT
-ARUMITA
-XYGONA
-NECRONTHILA
-ORAMYLECA
-NYONI
-UVEHR
-IOULR
-ROMAZOUI
-SEVAB
-YHEM
-EDIRY
-SOTIY
-EGOBOPEX
-ITICOZIL
-YDARYE
-LULABU
-ISIXEU
-EROJOZEU
-NUJUPAZERA
-SIAREYMOKOR
-OWARIENIKER
-SOYGIRO
-DERENUJEXY
-IGUKAMA
-NYBO
-QUFIZIEE
-QUKOMA
-AEXUS
-ARU
-EFAZOYT
-CYORAZEEM
-NOXIMILE
-NOGUI
-RESYNALEO
-OEBENY
-AMATYGON
-GYLIYA
-YORION
-ODYOSEZESE
-MOVINES
-YUSA
-NEOSPIA
-UAXIDEE
-XUYDYA
-PEJAV
-ALORID
-HYRII
-XENI
-ULIHEME
-BUMUS
-NEUXOBISU
-REGOU
-QUSOS
-KONIBA
-EDIMIA
-IKIEZO
-KUZUR
-ORUSIOK
-YNOX
-ASYMA
-POY
-MAAX
-XITAU
-MEKAIBA
-OHARASU
-RYOKYUTU
-YZIER
-ERANYKO
-AZEREMIR
-KIAHADA
-OVOLAS
-EILOY
-NAUROKA
-NERUFUT
-LAFIA
-KAMAI
-LYRUJATU
-VALUZIA
-XONUZYL
-TYTYHN
-BYLUVUZ
-FEJYNESO
-CATOBO
-KAFUEHOR
-ORYM
-ROFIZU
-EYGOKO
-OZARIMEGI
-FALUZR
-EDUJO
-UETIR
-RYA
-RUGAI
-UZIKIO
-GODEPINA
-TEURODORAS
-HESUNIKIVA
-IRYXI
-DYHEDO
-MAGUS
-JYZORB
-DYBOLEVAU
-ATIQUNE
-JOISERU
-JEBIE
-ILALUL
-UGE
-FUMYLOI
-UTUHYXA
-DYFOKUA
-IVEJARU
-TODU
-OLUNOELOO
-SICATU
-AQULIE
-UTEZUA
-YRONU
-SONOH
-IMAO
-KIDUVO
-YRIXEDA
-IRAYU
-FYMO
-TUSYE
-IVUXOL
-MYU
-APUDA
-SEZINOXU
-ZYX
-PEXOR
-IZUNITAHIU
-XULE
-CUZAE
-DENKAFER
-YDOTURIU
-UDEG
-XODORYTE
-XIDOM
-WOPESULO
-TOJUCEGIO
-MEODEKIEN
-KOKYXOI
-EBADII
-SYEGEHUR
-NUREY
-ESUE
-EORIGUR
-YOQUC
-JESAGULOK
-BIYEX
-KIBEC
-KOVONEO
-YREO
-DASEA
-DYZA
-BOLIRX
-HALOUKA
-SELUKANI
-XEMARUM
-TYSEZU
-NUMOZYBALON
-ATIR
-XIS
-CASEJO
-UWAL
-UDIZEI
-IJAYTI
-IRA
-UVEST
-SIOPELERIS
-NYMID
-URETIE
-KUROSORI
-YMILO
-BODIO
-MEDOZ
-YGIREE
-MEOZOVOR
-EJOCIA
-TATUPEE
-HAJUZIKUA
-ONARUDEA
-ABEGIO
-GOI
-YULAZICO
-ZOHUA
-YPUXOL
-OZEXU
-NALITYR
-ACOMA
-GUEZA
-YXUR
-LOSAL
-KIQUEX
-QULUA
-MOILEAE
-TEHG
-OKOHYRE
-YUSIVO
-UDR
-OYDYSO
-ULOMOE
-NABEROA
-RILANOE
-ACEXES
-AADYEN
-USINYRI
-OMELID
-KAZUTEJURESI
-MUJECIDU
-LEANOSI
-UZICES
-KUXETE
-ALEDAKEO
-JARODUSAEX
-JUYRO
-ZAMIKUSA
-GUMUK
-ZITU
-NIPEKIS
-DAHH
-DEYSUROM
-NOMUBETIKI
-XEDASA
-YOLIT
-BAVIDUM
-UHAR
-VOPOCA
-BELIOCK
-HUAK
-ESAPON
-LAKAWN
-SETOCAS
-YUT
-ULD
-UROIT
-ASILN
-YTOL
-TEBESYI
-OHYDEE
-VIBEZU
-BYNEPECIA
-IGUA
-UTAREO
-EJEMOK
-OETASA
-YCIES
-OKEK
-KEGUFACA
-UTEH
-IZU
-UPAKENY
-ACUMIZEN
-AGOILA
-IXYUL
-TOI
-UPULEHET
-BODAHETII
-HYCOH
-TAPEI
-KUFENU
-KYRIRO
-NYDOPIK
-OJES
-JUSUCA
-BEFUA
-APECYLA
-KORAR
-LUSASEK
-ULM
-YOXUD
-DYZIRYN
-MUTOIZO
-OLOGURU
-NALOKIE
-DOCIX
-VOLYG
-AGOPEV
-PYHURE
-OOZIER
-NUJEU
-ICUDA
-BASUK
-MISOTAPOMA
-SEJIA
-UGOMA
-XARALA
-TYPOPOXA
-TITRAN
-AKOZADI
-ZYBUD
-UZEA
-AKOLIXYIE
-LEREE
-GISOAN
-ZEESO
-EXOLAY
-GELYI
-OLYMEZAU
-ECONU
-FAVISINIA
-UGALYELS
-VOKIXE
-KULUSU
-IYROOSU
-IVIHO
-YABU
-SOZUJ
-KIWUSIA
-ACEDYI
-DENONEMI
-IUZEHEKO
-QUEZ
-BOSUK
-PEUR
-ZERESA
-BILYO
-UNUTAE
-LUAHAK
-SOEKEHUL
-ELONOU
-WUFEXEL
-EHUGULEVYX
-SEWA
-ZAMYFANIL
-ETEPITY
-HOROTAY
-LEPUT
-BUCOPAA
-MOKANA
-JOHA
-QUBIKYES
-SIELAY
-RAQUZELO
-SOMAXALE
-NIRADIKUPE
-BYXUOK
-XEKIHL
-FADERO
-NEFOD
-OLELD
-MISATEXAKE
-FYRAUG
-JOHYA
-XYZIRYU
-KYINA
-KEGENEYU
-IVEI
-DEI
-COGYEZAN
-KADUYO
-IFAMY
-ENEBOI
-SIGINOFY
-OZAKAT
-JAFYIFI
-BACOHU
-JUZOLE
-CUXOE
-ROGAO
-NELUPEA
-YROLADR
-GUOI
-ACIPOA
-SUGYADE
-HYSUVA
-TUGILEX
-UCEBI
-OZA QUI
-IXIHI
-GOJEI
-VUGI
-MUMIOT
-RUJID
-RYDUKADO
-YMYEK
-MIZON
-XOLAS
-ZARANG
-LOTIG
-MEDULAZ
-DUMU
-VETULE
-DYILUCK
-KEKETI
-JEGAVESY
-TYFOLAN
-SUPOUGEA
-RUEKERE
-KAXEFU
-UMX
-XUTE
-SYXIAPARA
-AXYLAI
-SOLYLYA
-ENAW
-IDULO
-SYPIGANE
-YZETC
-AHEMEBG
-VEDIAB
-DOHA
-LIXASIE
-CYXR
-ENINAI
-OYZU
-ECAZOXA
-DYTE
-IJOUROA
-CYPIR
-AZEU
-YUG
-YUNUMIRAZ
-QULU
-CEXOR
-UGO
-JIVIZEA
-CYEI
-YAPAC
-YLARI
-KUSOAS
-MUZE
-ARUSAVIE
-NUDEK
-IUPE
-MEZUK
-YMIEK
-UNICIU
-UREC
-OXUXEO
-GOY
-HEMUXORUA
-TECENATEA
-KORT
-YAXOT
-METIVUX
-ILECY
-IDARU
-AYLOX
-BYGO
-OREVOULO
-EJUSAY
-FOLUM
-TEFRON
-XYRESUE
-TAXUA
-UTASS
-YGUI
-EREVATO
-KOCEI
-DYROLUZ
-YEXI
-EVANIO
-YMEN
-YUSELL
-UHAN
-ETARO
-NAT
-MURAPASI
-BAVUZA
-EVOA
-TYPYHL
-UWEK
-SEPTID
-BAZOGS
-YZES
-TYLAVI
-NARK NARK
-YLUO
-KUNOLUD
-YDEN
-RECOTT
-WILAREE
-XUSH
-OYDUG
-ZYLOQUE
-ZYENG
-NODUPI
-EBEREFEZI
-ETUSE
-SEPOLACEE
-UNIVERU
-GOLO
-GIUSI
-EMAUS
-ISICE
-ITYS
-MOKOI
-XEPEU
-UNOM
-OOBULEST
-ZUNX
-SUNIC
-SIGUSTUS
-IROQUA
-ENADI
-TOVECO
-ZYSTEU
-BUXAE
-MUOG
-LURTH
-OGADI
-UBADULST
-SUAL
-AMAOZAR
-INEAXUR
-OKAHIT
-ENUALERU
-XUREZ
-EDOSK
-MECONAE
-ENIZP
-AXUST
-YLEN
-BAALYOD
-GAXODUSE
-CHOIZESAS
-ZEGE
-AMULAT
-OHEL
-ATANS
-BRUNIXE
-EHEFUNA
-NAUMZ
-RAYELYN
-IZOE
-URNST
-YKOI
-SYGUNDA
-DOZUVAIN
-BOLZ
-LIVALX
-ROBIAMAHIZA
-THUVAHEXASH
-CYDUKA
-NABIK
-METHELUSDA
-ILISK
-XOZODESIU
-EVURIA
-NULP
-QUMEXI
-ALUX
-JEDAVOY
-OSAZORY
-DANE-BYOM
-GEPALIV
-COAZEST
-ALUGA
-ZODER
-YIVER
-KUFISH
-INYRAX
-YZIHAD
-NEMI
-XUER
-UNYKI
-XAO
-ALINOA
-PYJICUR
-MEDUMAR
-XYRY
-IYESYRILUI
-KUHORU
-ABVORING
-OBEJU
-VOKE
-BAZT
-YRIFA
-FANEXI
-ALEYL
-NILACIAST
-BIELEST
-MOCOR
-DIENTH
-TRALAM
-DEISTO 
-MIPETH DIO
-SAMTRA
-KELRITH
-JENTRIX
-FI-INDRO
-DELTRIGH
-IANDOSOMN
-THEZINORAG
-OST YLN
-AG LIN OMFEOR
-GOALST
-ASTRINOG
-DIVESTI
-PROMLOTH
-VOYTRA
-EST JANELLPUR
-GHOT
-UMBRA
-URNST
-MLERNE
-TERMIG
-OTHLOS
-BLEGHIM
-ZY AGLOM
-QUWERI
diff --git a/makedata/namesx.txt b/makedata/namesx.txt
deleted file mode 100644
index bdf6fd0..0000000
--- a/makedata/namesx.txt
+++ /dev/null
@@ -1,152 +0,0 @@
-OBELOS
-ONNEKI
-WIOTUN
-FILAWO
-MUZUSU
-HEZOKK
-UTAI
-ODEGYHE
-DOTYOXODA
-SIGONIB
-EFEMIRAZ
-TAQUL
-UMEG
-UPYZEI
-OGUIMOI
-IGUA
-FEMOLEK
-AZIACOR
-FULONOI
-TEVIX
-TAXIKANE
-RYOGEI
-LUESO
-ENYS
-YTES
-SUENYO
-ZIGEH
-ASOREK
-SOUBIEK
-ULYDRLE
-QUAG
-BIFYDIZA
-YUNYIN
-JUPAQURI
-AESELOM
-OBAN
-NONEI
-VIFT
-KILIV
-OOXIRK
-RAHULO
-CYBYDEISH
-GAFAEMA
-REBASHYERS
-OSANERIG
-NEFI
-FEVAVETU
-UMIEDU
-ZOI
-MENYIXI
-UMALODEVAN
-JALAKEM
-LYLOZA
-KOFEST
-YDO
-TYR
-OKUAR
-JAHAI
-IVOZID
-IPESUDOI
-URAMA
-LEXIVAZI
-HADEKOU
-JATIR
-IXRAEL
-NEM
-YLONAK
-OLEZIAS
-IUKISIJIP
-OXURYI
-ZEI
-EDYNOK
-PEJISI
-ZAYIX
-YNED
-NYASET
-UBAMISAI
-EPIRAO
-WULIR
-AGOYSEI
-LUKAS
-HAZUS
-XEI
-YRIN
-ONAN
-OBIGI
-UZIKYR
-SUXTAK
-ZEDA
-MAKODE
-RUAG
-SIDHE
-JOGAM
-EMULAZ
-NUSA
-AELOYA
-IYRAFOX
-UMEX
-TEMABORG
-DULEVIS
-ODIPET
-OMATISE
-DESOL
-ERYOPOD
-EDAUM
-INUMUR
-OZU
-ULOI
-MEREXA
-NEMES
-ZAHYGL
-EXOPID
-ICOSA
-YJEDI
-REHEZ
-YSEI
-KEBIONG
-AERAXIE
-ULYNINE
-GOUR
-REL
-MYONIREN
-YLUN
-TETUN
-RIMOV
-SEKA
-TENOCOT
-HOR
-PYREIL
-LICEO
-PAPESIA
-ONEXL
-XURL
-SEZOMEG
-NITO
-ZOG
-LEXAD
-YTOK
-EFYU
-DAYNUR
-ROMA
-AKALIA
-EPUNOX
-ROMEN
-ASOI
-SYID
-DEOL
-GYEL
-PENUZUL
-NISOT
-VEKOI
-FYFOZAD
diff --git a/makedata/newevent.txt b/makedata/newevent.txt
deleted file mode 100644
index e533877..0000000
--- a/makedata/newevent.txt
+++ /dev/null
@@ -1,197 +0,0 @@
-Wacky New Event List
-
-big wacky logs for meetin' aliens
-
-0 SENGZHAC
-1 D'PAHK
-2 AARD
-3 ERMIGEN
-4 TITARIAN
-5 QUAI PA'LOI
-6 SCAVENGERS
-7 ICON
-8 GUILD
-9 VOID DWELLERS
-10 GREETINGS AND HALLUCINATIONS
-11 SECTOR CODEX
-12 SECOND BUOY LOCATED
-13 HALLIFAX MANEUVER
-14 TROJAN GATE
-15 A PLANET'S DESTRUCTION
-16 MONKS OF PAPESIA
-17 DERELICT DISCOVERED
-18 DEVELOPMENT OF THERMOPLAST TECHNOLOGY
-19 ENCOUNTERED NOVA (INCLUDE VISION OF TEMPLE COORD)
-20 LOCATION OF SHUNT CAPABLE SHIP
-21 DESTRUCTION OF THE MALZATOIR
-22 DISCOVERY OF ICON DATA BUOY
-23 THE GUILD JOIN THE KENDAR
-24 INSIDE THE TEMPLE OF IRON
-25 INSIDE THE PIRATE BASE
-26 PIRACY!
-27 ICON TRANSMISSION
-28 ERMIGEN DATA TAPES
-29 LAST SCAVENGER TRANSMISSION
-30 THE ERMIGEN WERE DESTROYED
-31 THE AARD JOIN THE KENDAR
-32 ICON URGE YOU TO REFORM THE KENDAR
-33 REPAIR THE ERMIGEN SHIP
-34 ERMIGEN JOIN THE KENDAR
-35 TITARIANS MENTION BRIGHT SPOT?
-36 SHUNT DRIVE RESEARCH COMPLETED
-37 GUILD WANTS DERRAAK ELIMINATED
-38 QUAI GO TO WAR
-39 THE GUILD TELL YOU THAT THE MOCH HAVE THE GOOLAS
-40 ENCOUNTER THE PHAEDOR MOCH AND REPAIR THEIR SHIP
-41 GUILD TELL YOU HOW AND WHERE TO DEFEAT DERRAAK(THE PIRATE)
-42 FIND TEMPLE OF IRON
-43 GUILD THNK YOU FOR YLINTH'S GENES
-44 VOID DWELLERS TELL YOU ABOUT GOD'S EYE
-45 RECEIVE DOOM GATE
-46 RECEIVE THERMATURGE
-47 TITARIAN JOIN THE KENDAR
-48 QUAI PALOI JOIN KENDAR
-49 DISCOVER YLINTH GENES(describe it in case the player doesn't know who they are)
-
-Sengzhac
-what do they want?      what do they give?      statement?
-0.LOG45                 NOTHING                 WE HAVE NOTHING MORE TO SAY TO YOU...
-1.LOG34                 NOTHING                 still WE DO not think you Are worthy... do more for us.
-2.log24                 doom gate(log45)        we will be joining your silly kendar. EXPLAIN WHY THE TEMPLE IS SIGNIFIGANT.
-3.log0                  nothing                 YOU RETURN? DIE, LITTLE PIGGY
-4.
-5.
-6.
-7.
-8.
-9.
-
-D'phak
-what do they want?      what do they give?      statement?
-0.LOG 46                NOTHING                 FINAL HELLO...
-1.log18                 thermaturge(LOG46)      join the kendar
-2.LOG43                 NOTHING                 AHHH... YOU HAVE RETURNED
-3.log30                 NOTHING                 d'pahk suggest giving yiller genes to the guild
-4.LOG 34                NOTHING                 YOU HAVE NO MERIT... WE WILL NOT JOIN (THE ERMIGEN HAVE NOT JOINED)
-5.log1                  nothing                 ahhh... you have returned.
-6.
-7.
-8.
-9.
-
-Aard
-what do they want?      what do they give?      statement?
-0.LOG45                 LOG31                   HELLO SIGNIFYING THAT THEY ARE NOW MEMBERS...
-1.LOG27(ERMIGEN DEATH)  NOTHING                 YOU MUST HURRY AND GATHER TOGETHER THE KENDAR
-2.
-3.
-4.
-5.
-6.
-7.
-8.
-9.
-
-Ermigen
-what do they want?      what do they give?      statement?
-3.LOG34                 NOTHING                 HELLO AGAIN FELLOW MEMBER.
-2.LOG32                 LOG34                   WE WILL JOIN(INCLUDE THEM TELLING YOU ABOUT THE TROJAN GATE.)
-1.LOG33                 NOTHING                 HELLO AGAIN.
-0.TORQUE STANCHION      LOG33                   THANKS.
-4.
-5.
-6.
-7.
-8.
-9.
-
-Titarian
-what do they want?      what do they give?      statement?
-0.LOG47                 NOTHING                 LAST HELLO...
-1.LOG36                 LOG47                   WE JOIN THE KENDAR
-2.LOG35                 NOTHING                 THEY MENTION THE DERELICT (MAYBE THE LOCATION?)
-3.LOG4                  LOG35                   WE FORESEE A BRIGHT SPOT
-4.LOG25                 NOTHING                 PIRATE IS DEAD RESPONSE
-5.LOG37                 NOTHING                 WE TELL YOU WHERE THE PIRATE IS
-6.
-7.
-8.
-9.
-
-Quai Pa'loi
-what do they want?      what do they give?      statement?
-0.SILLY PART 1          GOOD PART 1             THANKS 1
-1.SILLY PART 2          GOOD PART 2             THANKS 2
-2.SILLY PART 3          GOOD PART 3             THANKS 3
-3.LOG 48                NOTHING                 FINAL HELLO
-4.GOOLAS                MULTI-IMAGER(LOG48)     END WAR JOIN KENDAR?
-5.LOG38                 NOTHING                 WE'RE HAVING A WAR ALREADY...SHEESH. GO AWAY.
-6.LOG13                 LOG38(QUAI WAR)         QUAI WAR...
-7.LOG30(ERMGN DEAD)     NOTHING                 TENSION MOUNTS... THE PLOT THICKENS
-8.LOG21                 NOTHING                 STRANGE THINGS ARE AFOOT AT THE CIRCLE K
-9.LOG 5                 NOTHING                 HELLO AGAIN
-
-Scavengers
-what do they want?      what do they give?      statement?
-0.LOG30                 NOTHING                 WE ARE NEW IMPROVED VERY EVIL SCAVENGERS... WE WILL DESTROY YU ALL (CACKLES)
-1.LOG21                 NOTHING                 A BIT MORE AGRESSIVE
-2.LOG6                  NOTHING                 THE OTHER HELLO...
-3.
-4.
-5.
-6.
-7.
-8.
-9.
-
-Icon
-what do they want?      what do they give?      statement?
-0.GLYPTIC SCYTHE        NOTHING                 WE DECYPHERED THE WORD CUTTER... AND THE MOCH STAND FOR...
-1.LOG21                 NOTHING                 GO FORTH AND SPEAK FOR US THAT THE KENDAR MIGHT BE AGAIN!
-2.
-3.
-4.
-5.
-6.
-7.
-8.
-9.
-
-The Guild
-what do they want?      what do they give?      statement?
-0.IF LOG39 EXISTS THEN SKIP NEXT IF LOG SCAN
-1.LOG38                 LOG39                   THE MOCH HAVE THE GOOLAS
-2.LOG44                 NOTHING                 FINAL HELLO (HERE'S HOW YOU KILL THE SCAVENGERS)
-3.LOG25                 LOG44                   WE JOIN YOU NOW... THIS KENDAR OF YOURS.
-4.LOG43                 LOG41                   WE KNOW WHAT WE WANT YOU TO DO... KILL DERRAAK
-5.LOG49                 LOG43                   NOW... BEFORE WE JOIN, WE NEED TO YOU NO KILL DERRAAK.
-6.LOG8                  NOTHING                 HELLO... I BELIEVE WE'VE MET.
-7.
-8.
-9.
-
-Phaedor Moch
-what do they want?      what do they give?      statement?
-3.LOG48(QUAI WAR ENDS)  NOTHING                 FINAL HELLO
-1.LOG39             GOOLAS(IF DON'T HAVE THEM)  AND WE HAVE THE GOOLAS!!
-0.LOG40                 NOTHING                 OTHER HELLO
-2.NOTHING               GLYPTIC SCYTHE(LOG40)   HAPPY? I THOUGHT SO.(TAKE IT TO THE ICON)
-4.
-5.
-6.
-7.
-8.
-9.
-
-Void Dwellers
-what do they want?      what do they give?      statement?
-0.LOG44                 NOTHING                 FINAL HELLO
-1.LOG19                 LOG44                   VOID DWELLERS TELL YOU ABOUT GOD EYE... IT'S SIGNIFIGANCE.
-2.LOG9                  NOTHING                 OTHER HELLO
-3.
-4.
-5.
-6.
-7.
-8.
-9.
diff --git a/makedata/newnames.txt b/makedata/newnames.txt
deleted file mode 100644
index ff7f2ac..0000000
--- a/makedata/newnames.txt
+++ /dev/null
@@ -1,750 +0,0 @@
-Hobyxonid   
-Euaveck     
-Fyfozad     
-Ixofuzane   
-Eyzi        
-Omyon       
-Fylofoe     
-Dreamers    
-Anolucesya  
-Pylaz       
-Oxielu      
-Zeorb       
-Levize      
-Urue        
-Kekeezox    
-Mybejysa    
-Denyvn      
-Xyd         
-Ytail       
-Bozyk       
-Levi        
-Uxoy        
-Myhatl      
-Elas        
-Benoi       
-Upaga       
-Nyga        
-Cyinite     
-Isoybolin   
-Iaroken     
-Imazoy      
-Kakovio     
-Avilynixoda 
-Rue         
-Udae        
-Kusyo       
-Uqurecs     
-Obachus     
-Focumaruda  
-Oveisekoraa 
-Xejie       
-Zalukoa     
-Jilazus     
-Fesaroga    
-Godova      
-CyaMsorabid 
-Lanyde      
-Ril Obyk
-Pupok
-NilGrynth
-Koynosur
-Ogoadeeku
-Uxya
-Oiloyomu
-Axahi
-Ciloc
-Ekurj
-Wizago
-Hetumoe
-Delorgeme
-Utoy
-Patonin
-Oore
-Kyga
-Tulaizin
-Bycapus
-Vimaford
-Quxalor
-Agorimeta
-Ehedipi
-Bibizuuk
-Obrafei
-Anakelort
-Atujo
-Wanibork
-Asyrukak
-Ugynisu
-Izydmoy
-Esylekuwu
-Anusat
-Urv
-Gybex
-Jikanem
-Himux
-Vohaut
-Gafauhu
-Mauginypu
-Guexyt
-Feufeda
-Biohyxia
-Keui
-Hunafixogyk
-Udohodex
-Uvozara
-Jeoh
-Itomyha
-Dibugh
-Olagypuloru
-Ekuvenofer
-Gixe
-Pemyga
-Rytogh
-Unyzoroz
-Micatyoz
-Genao
-Xily
-Itoxobycea
-Ukarore
-Okuder
-Olyli
-Guk
-Oju
-Quob
-Cikeodicerk
-Ysae
-Aibur
-Jilumo
-Jeuxim
-Xedysy      
-Zevenat     
-Epasupeki   
-Oroaa       
-Sykuiduh    
-Ojufiku     
-Faladosh    
-Simocus     
-Eboi        
-Zepz        
-Quesevi     
-Gotabe      
-Zytug       
-Xygi        
-Ugur        
-Felog       
-Peykepodya  
-Pokegi      
-Beubyxs     
-Relivy      
-Butateba    
-Uxynoth     
-Ibuauro     
-Uwozea      
-Xao         
-Uves        
-Hezaxokie   
-Zeboahanoo  
-Seledabylao 
-Asat        
-Arumita     
-Xygona      
-Necronthila 
-Oramyleca   
-Nyoni       
-Uvehr       
-Ioulr       
-Romazoui    
-Sevab       
-Yhem        
-Ediry       
-Sotiy       
-Egobopex    
-Iticozil    
-Ydarye      
-Lulabu      
-Isixeu      
-Erojozeu    
-Nujupazera  
-Siareymokor 
-Owarieniker 
-Soygiro     
-Derenujexy  
-Igukama     
-Nybo        
-Qufiziee    
-Qukoma      
-Aexus       
-Aru         
-Efazoyt     
-Cyorazeem   
-Noximile    
-Nogui       
-Resynaleo   
-Oebeny      
-Amatygon    
-Gyliya      
-Yorion      
-Odyosezese  
-Movines     
-Yusa        
-Neospia     
-Uaxidee     
-Xuydya      
-Pejav       
-Alorid      
-Hyrii       
-Xeni        
-Uliheme     
-Bumus       
-Neuxobisu   
-Regou       
-Qusos       
-Koniba      
-Edimia      
-Ikiezo      
-Kuzur       
-Orusiok     
-Ynox        
-Asyma       
-Poy         
-Maax        
-Xitau       
-Mekaiba     
-Oharasu     
-Ryokyutu    
-Yzier       
-Eranyko     
-Azeremir    
-Kiahada     
-Ovolas      
-Eiloy       
-Nauroka     
-Nerufut     
-Lafia       
-Kamai       
-Lyrujatu    
-Valuzia     
-Xonuzyl     
-Tytyhn      
-Byluvuz     
-Fejyneso    
-Catobo      
-Kafuehor    
-Orym        
-Rofizu      
-Eygoko      
-Ozarimegi   
-Faluzr      
-Edujo       
-Uetir       
-Rya         
-Rugai       
-Uzikio      
-Godepina    
-Teurodoras  
-Hesunikiva  
-Iryxi       
-Dyhedo      
-Magus       
-Jyzorb      
-Dybolevau   
-Atiqune     
-Joiseru     
-Jebie       
-Ilalul      
-Uge         
-Fumyloi     
-Utuhyxa     
-Dyfokua     
-Ivejaru     
-Todu        
-Olunoeloo   
-Sicatu      
-Aqulie      
-Utezua      
-Yronu       
-Sonoh       
-Imao        
-Kiduvo      
-Yrixeda     
-Irayu       
-Fymo        
-Tusye       
-Ivuxol      
-Myu         
-Apuda       
-Sezinoxu    
-Zyx         
-Pexor       
-Izunitahiu  
-Xule        
-Cuzae       
-Denkafer    
-Ydoturiu    
-Udeg        
-Xodoryte    
-Xidom       
-Wopesulo    
-Tojucegio   
-Meodekien   
-Kokyxoi     
-Ebadii      
-Syegehur    
-Nurey       
-Esue        
-Eorigur     
-Yoquc       
-Jesagulok   
-Biyex       
-Kibec       
-Kovoneo     
-Yreo        
-Dasea       
-Dyza        
-Bolirx      
-Halouka     
-Selukani    
-Xemarum     
-Tysezu      
-Numozybalon 
-Atir        
-Xis         
-Casejo      
-Uwal        
-Udizei      
-Ijayti      
-Ira         
-Uvest       
-Siopeleris  
-Nymid       
-Uretie      
-Kurosori    
-Ymilo       
-Bodio       
-Medoz       
-Ygiree      
-Meozovor    
-Ejocia      
-Tatupee     
-Hajuzikua   
-Onarudea    
-Abegio      
-Goi         
-Yulazico    
-Zohua       
-Ypuxol      
-Ozexu       
-Nalityr     
-Acoma       
-Gueza       
-Yxur        
-Losal       
-Kiquex      
-Qulua       
-Moileae     
-Tehg        
-Okohyre     
-Yusivo      
-Udr         
-Oydyso      
-Ulomoe      
-Naberoa     
-Rilanoe     
-Acexes      
-Aadyen      
-Usinyri     
-Omelid      
-Kazutejuresi
-Mujecidu    
-Leanosi     
-Uzices      
-Kuxete      
-Aledakeo    
-Jarodusaex  
-Juyro       
-Zamikusa    
-Gumuk       
-Zitu        
-Nipekis     
-Dahh        
-Deysurom    
-Nomubetiki  
-Xedasa      
-Yolit       
-Bavidum     
-Uhar        
-Vopoca      
-Beliock     
-Huak        
-Esapon      
-Lakawn      
-Setocas     
-Yut         
-Uld         
-Uroit       
-Asiln       
-Ytol        
-Tebesyi     
-Ohydee      
-Vibezu      
-Bynepecia   
-Igua        
-Utareo      
-Ejemok      
-Oetasa      
-Ycies       
-Okek        
-Kegufaca    
-Uteh        
-Izu         
-Upakeny     
-Acumizen    
-Agoila      
-Ixyul       
-Toi         
-Upulehet    
-Bodahetii   
-Hycoh       
-Tapei       
-Kufenu      
-Kyriro      
-Nydopik     
-Ojes        
-Jusuca      
-Befua       
-Apecyla     
-Korar       
-Lusasek     
-Ulm         
-Yoxud       
-Dyziryn     
-Mutoizo     
-Ologuru     
-Nalokie     
-Docix       
-Volyg       
-Agopev      
-Pyhure      
-Oozier      
-Nujeu       
-Icuda       
-Basuk       
-Misotapoma  
-Sejia       
-Ugoma       
-Xarala      
-Typopoxa    
-Titran
-Akozadi     
-Zybud       
-Uzea        
-Akolixyie   
-Leree       
-Gisoan      
-Zeeso       
-Exolay      
-Gelyi       
-Olymezau    
-Econu       
-Favisinia   
-Ugalyels    
-Vokixe      
-Kulusu      
-Iyroosu     
-Iviho       
-Yabu        
-Sozuj       
-Kiwusia     
-Acedyi      
-Denonemi    
-Iuzeheko    
-Quez        
-Bosuk       
-Peur        
-Zeresa      
-Bilyo       
-Unutae      
-Luahak      
-Soekehul    
-Elonou      
-Wufexel     
-Ehugulevyx  
-Sewa        
-Zamyfanil   
-Etepity     
-Horotay     
-Leput       
-Bucopaa     
-Mokana      
-Joha        
-Qubikyes    
-Sielay      
-Raquzelo    
-Somaxale    
-Niradikupe  
-Byxuok      
-Xekihl      
-Fadero      
-Nefod       
-Oleld       
-Misatexake  
-Fyraug      
-Johya       
-Xyziryu     
-Kyina       
-Kegeneyu    
-Ivei        
-Dei         
-Cogyezan    
-Kaduyo      
-Ifamy       
-Eneboi      
-Siginofy    
-Ozakat      
-Jafyifi     
-Bacohu      
-Juzole      
-Cuxoe       
-Rogao       
-Nelupea     
-Yroladr     
-Guoi        
-Acipoa      
-Sugyade     
-Hysuva      
-Tugilex     
-Ucebi       
-Oza Qui
-Ixihi       
-Gojei       
-Vugi        
-Mumiot      
-Rujid       
-Rydukado    
-Ymyek       
-Mizon       
-Xolas       
-Zarang      
-Lotig       
-Medulaz     
-Dumu        
-Vetule      
-Dyiluck     
-Keketi      
-Jegavesy    
-Tyfolan     
-Supougea    
-Ruekere     
-Kaxefu      
-Umx         
-Xute        
-Syxiapara   
-Axylai      
-Solylya     
-Enaw        
-Idulo       
-Sypigane    
-Yzetc       
-Ahemebg     
-Vediab      
-Doha        
-Lixasie     
-Cyxr        
-Eninai      
-Oyzu        
-Ecazoxa     
-Dyte        
-Ijouroa     
-Cypir       
-Azeu        
-Yug         
-Yunumiraz   
-Qulu        
-Cexor       
-Ugo         
-Jivizea     
-Cyei        
-Yapac       
-Ylari       
-Kusoas      
-Muze        
-Arusavie    
-Nudek       
-Iupe        
-Mezuk       
-Ymiek       
-Uniciu      
-Urec        
-Oxuxeo      
-Goy         
-Hemuxorua   
-Tecenatea   
-Kort        
-Yaxot       
-Metivux     
-Ilecy       
-Idaru       
-Aylox       
-Bygo        
-Orevoulo    
-Ejusay      
-Folum       
-Tefron      
-Xyresue     
-Taxua       
-Utass       
-Ygui        
-Erevato     
-Kocei       
-Dyroluz     
-Yexi        
-Evanio      
-Ymen        
-Yusell      
-Uhan        
-Etaro       
-Nat         
-Murapasi    
-Bavuza      
-Evoa        
-Typyhl      
-Uwek        
-Septid      
-Bazogs      
-Yzes        
-Tylavi      
-Nark Nark
-Yluo        
-Kunolud     
-Yden        
-Recott      
-Wilaree     
-Xush        
-Oydug       
-Zyloque     
-Zyeng       
-Nodupi      
-Eberefezi   
-Etuse       
-Sepolacee   
-Univeru     
-Golo        
-Giusi       
-Emaus       
-Isice       
-Itys        
-Mokoi       
-Xepeu       
-Unom        
-Oobulest    
-Zunx        
-Sunic       
-Sigustus    
-Iroqua      
-Enadi       
-Toveco      
-Zysteu      
-Buxae       
-Muog        
-Lurth       
-Ogadi       
-Ubadulst    
-Sual        
-Amaozar     
-Ineaxur     
-Okahit      
-Enualeru    
-Xurez       
-Edosk       
-Meconae     
-Enizp       
-Axust       
-Ylen        
-Baalyod     
-Gaxoduse    
-Choizesas   
-Zege        
-Amulat      
-Ohel        
-Atans       
-Brunixe     
-Ehefuna     
-Naumz       
-Rayelyn     
-Izoe        
-Urnst       
-Ykoi        
-Sygunda     
-Dozuvain    
-Bolz        
-Livalx      
-Robiamahiza 
-Thuvahexash 
-Cyduka      
-Nabik       
-Methelusda  
-Ilisk       
-Xozodesiu   
-Evuria      
-Nulp        
-Qumexi      
-Alux        
-Jedavoy     
-Osazory     
-DaneMbyom   
-Gepaliv     
-Coazest     
-Aluga       
-Zoder       
-Yiver       
-Kufish      
-Inyrax      
-Yzihad      
-Nemi        
-Xuer        
-Unyki       
-Xao         
-Alinoa      
-Pyjicur     
-Medumar     
-Xyry        
-Iyesyrilui  
-Kuhoru      
-Abvoring    
-Obeju       
-Voke
-Bazt        
-Yrifa       
-Fanexi      
-Aleyl       
-Nilaciast   
-Bielest     
-Mocor       
-Dienth      
-Tralam      
-Deisto
-Mipeth Dio
-Samtra
-Kelrith
-Jentrix
-FiMindro
-Deltrigh
-Iandosomn
-Thezinorag
-Ost Yln
-Ag Lin Omfeo
-Goalst
-Astrinog
-Divesti
-Promloth
-Voytra
-Est Janellpu
-Ghot
-Umbra
-Urnst
-Mlerne
-Termig
-Othlos
-Bleghim
-Zy Aglom
-Quweri
\ No newline at end of file
diff --git a/makedata/newsound.pas b/makedata/newsound.pas
deleted file mode 100644
index e47c554..0000000
--- a/makedata/newsound.pas
+++ /dev/null
@@ -1,61 +0,0 @@
-program newwaves;
-uses crt,voctool;
-type
- buffertype= array[0..32000] of byte;
-var
- j,i: integer;
- buffer: ^buffertype;
-
-
-procedure savebuf;
-var datafile: file of buffertype;
-begin
- assign(datafile,'sound\test.voc');
- reset(datafile);
- write(datafile,buffer^);
- close(datafile);
- writeln('Saved!');
-end;
-
-procedure sinewave;
-var a,index,index2: integer;
-begin
-{ for j:=0 to 1600 do
-  if j mod 2=0 then
-   for i:=1 to 20 do buffer^[j*20+i]:=128+round(127*sin(j/320)*-1)
-  else for i:=1 to 20 do buffer^[j*20+i]:=128+round(127*sin(j/320));}
-{ j:=0;
- i:=0;
- repeat
-  inc(index);
-  index:=index mod 3000;
-  inc(index2);
-  index2:=index2 mod 2000;
-  for i:=1 to round(100*sin(index/1500)) do
-   begin
-    inc(j);
-    if j mod 2=0 then buffer^[j]:=128 else
-     buffer^[j]:=128+round(127*sin(index2/1000));
-   end;
- until j>31900;}
- j:=0;
- index:=0;
- repeat
-  inc(j);
-  for i:=1 to round(20*sin(index/4000) + 30*sin(j/100)) do
-   begin
-    inc(index);
-    if j mod 2=0 then buffer^[index]:=64
-     else buffer^[index]:=192;
-   end;
- until index>31950;
-
- writeln('Done!');
-end;
-
-begin
- new(buffer);
- sinewave;
- savebuf;
- dispose(buffer);
-end.
diff --git a/makedata/oldintro.pas b/makedata/oldintro.pas
deleted file mode 100644
index a458926..0000000
--- a/makedata/oldintro.pas
+++ /dev/null
@@ -1,488 +0,0 @@
-program intro;
-{$M 2000,120000,120000}
-
-uses crt, graph, data, emstool, gmouse, modplay;
-
-var
- song: pointer;
- i,j,cursor,permx,permy,code: integer;
- temp2: array[0..319,160..199] of byte;
- keymode,quit: boolean;
- key: char;
- modth,modtm,modts,
- curth,curtm,curts: byte;
- vgahandles: array[0..8] of word;
-
-{$L scroller}
-{$L v3220pa}
-{$F+}
-procedure upscroll(tseg,tofs: word); external;
-{$F-}
-procedure init320200;                            external;
-procedure setpix32(x,y: integer; pcolor: byte ); external;
-function  getpix32(x,y: integer ): byte ;        external;
-procedure setpage32(page: byte );                external;
-procedure showpage32(page: byte );               external;
-
-procedure runintro; forward;
-
-procedure blast(c1,c2,c3: integer);
-var a: integer;
-begin
- for a:=1 to 25 do
-  begin
-   for j:=0 to 255 do
-    begin
-     colors[j,1]:=colors[j,1] + round(a*(c1-colors[j,1])/25);
-     colors[j,2]:=colors[j,2] + round(a*(c2-colors[j,2])/25);
-     colors[j,3]:=colors[j,3] + round(a*(c3-colors[j,3])/25);
-    end;
-   set256colors(colors);
-   delay(tslice*2);
-  end;
- set256colors(colors);
- delay(tslice);
-end;
-
-procedure startit;
-begin
- case cursor of
-  1: code:=1;
-  2: runintro;
-  3: code:=2;
-  4: quit:=true;
- end;
-end;
-
-procedure drawcursor;
-begin
- if cursor=0 then exit;
- mousehide;
- case cursor of
-  1:rectangle(25,158,159,177);
-  2:rectangle(43,178,159,197);
-  3:rectangle(159,158,283,177);
-  4:rectangle(159,178,267,197);
- end;
- mouseshow;
-end;
-
-procedure findmouse;
-var button: boolean;
-begin
- if mouse.getstatus(left) then button:=true else button:=false;
- if (permx<>mouse.x) or (permy<>mouse.y) then keymode:=false;
- if (keymode) and (not button) then exit;
- case mouse.y of
-  158..177: case mouse.x of
-           25..159: cursor:=1;
-           160..283: cursor:=3;
-           else cursor:=0;
-          end;
-  178..197: case mouse.x of
-           43..159: cursor:=2;
-           160..267: cursor:=4;
-           else cursor:=0;
-          end;
-  else if not keymode then cursor:=0;
- end;
- if (button) and (cursor>0) then startit;
-end;
-
-procedure checkkey(c: char);
-begin
- case c of
-  #72: if cursor=0 then cursor:=1
-       else if cursor=1 then cursor:=4 else dec(cursor);
-  #80: if cursor=0 then cursor:=1
-       else if cursor=4 then cursor:=1 else inc(cursor);
-  #75: if cursor>2 then cursor:=cursor-2
-       else cursor:=cursor+2;
-  #77: if cursor>2 then cursor:=cursor-2
-       else cursor:=cursor+2;
- end;
-end;
-
-procedure mainloop;
-begin
- code:=0;
- cursor:=0;
- keymode:=false;
- quit:=false;
- repeat
-  findmouse;
-  if fastkeypressed then
-   begin
-    keymode:=true;
-    permx:=mouse.x;
-    permy:=mouse.y;
-    key:=readkey;
-    if key=#0 then checkkey(readkey);
-    if key=#13 then startit;
-   end;
-  setcolor(207);
-  drawcursor;
-  delay(tslice*2);
-  setcolor(0);
-  drawcursor;
- until (quit) or (code>0);
- if quit then
-  begin
-   blast(63,63,63);
-   fading;
-   closegraph;
-   textmode(co80);
-   halt(4);
-  end;
-end;
-
-procedure showmars;
-var vgafile: file of screentype;
-    temp: ^screentype;
-begin
- fillchar(colors,768,0);
- set256colors(colors);
- loadscreen('data\cloud2.vga');
- new(temp);
- assign(vgafile,'data\world.vga');
- reset(vgafile);
- if ioresult<>0 then errorhandler('data\world.vga',1);
- read(vgafile,temp^);
- if ioresult<>0 then errorhandler('data\world.vga',5);
- close(vgafile);
- loadpal('data\world.pal');
- set256colors(colors);
- upscroll(seg(temp^),ofs(temp^));
- dispose(temp);
-end;
-
-procedure focus;
-var temp: ^screentype;
-    a: integer;
-    vgafile: file of screentype;
-begin
- new(temp);
- mymove(screen,temp^,16000);
- for a:=2 to 17 do
-  begin
-  for j:=0 to 319 do
-   begin
-    for i:=0 to 199 do
-     begin
-      setfillstyle(1,temp^[i,j]);
-      bar(j-a div 2,i-a div 2,j+a div 2,i+a div 2);
-      i:=i+a;
-      if i>199 then i:=199;
-     end;
-    j:=j+a;
-    if j>319 then j:=319;
-   end;
-   delay(tslice div 2);
-  end;
- assign(vgafile,'data\destiny.vga');
- reset(vgafile);
- read(vgafile,temp^);
- close(vgafile);
- loadpal('data\destiny.pal');
- for a:=17 downto 2 do
-  begin
-  if a=8 then set256colors(colors);
-  for j:=0 to 319 do
-   begin
-    for i:=0 to 199 do
-     begin
-      setfillstyle(1,temp^[i,j]);
-      bar(j-a div 2,i-a div 2,j+a div 2,i+a div 2);
-      i:=i+a;
-      if i>199 then i:=199;
-     end;
-    j:=j+a;
-    if j>319 then j:=319;
-   end;
-  delay(tslice div 2);
- end;
- screen:=temp^;
- dispose(temp);
-end;
-
-procedure gettime; assembler;
-asm
- mov ah, 2Ch
-  int 21h
- mov modth, ch
- mov modtm, cl
- mov modts, dh
-end;
-
-function timewait(t: integer): boolean;
-begin
- asm
-  mov ah, 2Ch
-   int 21h
-  mov curth, ch
-  mov curtm, cl
-  mov curts, dh
- end;
- i:=abs(curth-modth)*3600+abs(curtm-modtm)*60+curts-modts;
- if i>t then timewait:=true else timewait:=false;
-end;
-
-procedure loadhighspeedscreens;
-var temp: ^screentype;
-    a: integer;
-begin
- temp:=ptr(ems.frame0,0);
- init320200;
- set256colors(colors);
- ems.handle:=vgahandles[8];
- ems.restoremap;
- for j:=0 to 319 do
-  for i:=0 to 199 do
-   setpix32(j,i,temp^[i,j]);
- loadpal('data\land2.pal');
- set256colors(colors);
- ems.savemap;
- for a:=1 to 3 do
-  begin
-   ems.handle:=vgahandles[a];
-   ems.restoremap;
-   setpage32(a);
-   for j:=0 to 319 do
-    for i:=0 to 199 do
-     setpix32(j,i,temp^[i,j]);
-   ems.savemap;
-  end;
-end;
-
-procedure displayflares;
-var temp: ^screentype;
-    a: integer;
-begin
- temp:=ptr(ems.frame0,0);
- loadpal('data\flare0.pal');
- set256colors(colors);
- for j:=0 to 3 do
-  begin
-   ems.handle:=vgahandles[j+4];
-   ems.restoremap;
-   if ems.error<>0 then errorhandler(ems.getemserrmessage,4);
-   mymove(temp^,screen,16000);
-   ems.savemap;
-   if ems.error<>0 then errorhandler(ems.getemserrmessage,4);
-   delay(tslice*4);
-  end;
-end;
-
-procedure loadlasthighspeed;
-var temp: ^screentype;
-begin
- temp:=ptr(ems.frame0,0);
- fillchar(colors,768,0);
- set256colors(colors);
- setpage32(0);
- ems.handle:=vgahandles[0];
- ems.restoremap;
- for j:=0 to 319 do
-   for i:=0 to 199 do
-    setpix32(j,i,temp^[i,j]);
- loadpal('data\highspd.pal');
- set256colors(colors);
- ems.savemap;
-end;
-
-procedure removeems;
-begin
- for j:=0 to 7 do
-  begin
-   ems.handle:=vgahandles[j];
-   ems.restoremap;
-   ems.freemem;
-  end;
-end;
-
-procedure readyems;
-var vgafile: file of screentype;
-    str1: string[1];
-    temp: ^screentype;
-begin
- temp:=ptr(ems.frame0,0);
- for j:=0 to 8 do
-  begin
-   ems.getmem(4);
-   if ems.error<>0 then errorhandler(ems.getemserrmessage,4);
-   for i:=0 to 3 do ems.setmapping(i,i);
-   if ems.error<>0 then errorhandler(ems.getemserrmessage,4);
-   ems.savemap;
-   if ems.error<>0 then errorhandler(ems.getemserrmessage,4);
-   vgahandles[j]:=ems.handle;
-   if j<4 then
-    begin
-     ems.restoremap;
-     str(j,str1);
-     assign(vgafile,'data\highspd'+str1+'.vga');
-     reset(vgafile);
-     if ioresult<>0 then errorhandler('highspd'+str1+'.vga',1);
-     read(vgafile,temp^);
-     if ioresult<>0 then errorhandler('highspd'+str1+'.vga',5);
-     close(vgafile);
-     ems.savemap;
-    end
-   else if j<8 then
-    begin
-     ems.restoremap;
-     str(j-4,str1);
-     assign(vgafile,'data\flare'+str1+'.vga');
-     reset(vgafile);
-     if ioresult<>0 then errorhandler('flare'+str1+'.vga',1);
-     read(vgafile,temp^);
-     if ioresult<>0 then errorhandler('flare'+str1+'.vga',5);
-     close(vgafile);
-     ems.savemap;
-    end;
-  end;
- ems.restoremap;
- assign(vgafile,'data\land2.vga');
- reset(vgafile);
- if ioresult<>0 then errorhandler('land2.vga',1);
- read(vgafile,temp^);
- if ioresult<>0 then errorhandler('land2.vga',5);
- close(vgafile);
- ems.savemap;
-end;
-
-procedure runintro;
-var total,a: integer;
-label startintro,continue;
-begin
- ship.options[2]:=120;
- ship.options[3]:=1;
- ship.options[4]:=1;
- fading;
- readyems;
-
-
- loadpal('data\channel7.pal');
- loadscreen('data\channel7.vga');
- fadein;
- gettime;
- repeat until timewait(1);
-
- gettime;
- focus;
- repeat until timewait(4);
-
- gettime;
- playmod('sound\techno.mod',2,14500);
- showmars;
- fillchar(colors,768,0);
- repeat
-  if fastkeypressed then goto continue;
- until timewait(10);
-
- set256colors(colors);
- loadpal('data\flare4.pal');
- loadscreen('data\flare4.vga');
- fadein2;
- repeat
-  if fastkeypressed then goto continue;
- until timewait(15);
-
- displayflares;
- fillchar(colors,768,0);
- set256colors(colors);
- loadpal('data\land1.pal');
- loadscreen('data\land1.vga');
- repeat
-  if fastkeypressed then goto continue;
- until timewait(18);
-
- fadein2;
- fillchar(colors,768,0);
- repeat
-  if fastkeypressed then goto continue;
- until timewait(22);
-
- loadhighspeedscreens;
- repeat
-  if fastkeypressed then goto continue;
- until timewait(29);
-
- loadlasthighspeed;
- a:=-1;
- repeat
-  inc(a);
-  if a=4 then a:=0;
-  showpage32(a);
-  delay(tslice*2);
- until (timewait(46)) or (fastkeypressed);
- if fastkeypressed then goto continue;
-
- blast(63,0,0);
- setgraphmode(0);
- fading;
- loadpal('data\char.pal');
- loadscreen('data\spy.vga');
- repeat
-  if fastkeypressed then goto continue;
- until timewait(76) or (fastkeypressed);
-
- fadein;
- repeat
-  if fastkeypressed then goto continue;
- until timewait(105) or (fastkeypressed);
-
- fillchar(colors,768,0);
- set256colors(colors);
- loadpal('data\intro.pal');
- loadscreen('data\intro.vga');
- repeat
-  if fastkeypressed then goto continue;
- until timewait(115);
-
- fadein2;
- repeat
-  if fastkeypressed then goto continue;
- until timewait(144);
-
-{************************************}
-continue:
- modstop;
- removeems;
- if fastkeypressed then
-  begin
-   setgraphmode(0);
-   while fastkeypressed do readkey;
-   fillchar(colors,768,0);
-   set256colors(colors);
-   loadscreen('data\intro.vga');
-   loadpal('data\intro.pal');
-   set256colors(colors);
-  end;
- mouseshow;
-end;
-
-begin
- tslice:=60;
- if paramstr(1)<>'/showseed' then
-  begin
-   closegraph;
-   writeln('Invalid Passcode!');
-   halt(4);
-  end;
- if paramstr(2)='/done' then
-  begin
-   fillchar(colors,768,0);
-   set256colors(colors);
-   loadscreen('data\intro.vga');
-   loadpal('data\intro.pal');
-   fadein2;
-   mouseshow;
-   mainloop;
-  end
- else
-  begin
-   runintro;
-   mainloop;
-  end;
- halt(code);
-end.
\ No newline at end of file
diff --git a/makedata/pix1.cpr b/makedata/pix1.cpr
deleted file mode 100644
index 78e37be..0000000
Binary files a/makedata/pix1.cpr and /dev/null differ
diff --git a/makedata/pix2.cpr b/makedata/pix2.cpr
deleted file mode 100644
index 6df28fd..0000000
Binary files a/makedata/pix2.cpr and /dev/null differ
diff --git a/makedata/places.txt b/makedata/places.txt
deleted file mode 100644
index 4ce1001..0000000
--- a/makedata/places.txt
+++ /dev/null
@@ -1,29 +0,0 @@
-sys     place
----     -----------
-211     satellite from is2
-119     phaedor moch 1st encounter
-129     hallifax place
-        trojan gate to lix *need coords*
-31      lix
-123     aria
-169     aard ship in distress
-205     titerian worshipers
-98      monks
-138     derelict with thermoplast
-164     nova
-229     shunt ship
-28      temple
-33      derraak
-14      derraak base
-23      scavs gathering place near end
-247     god's eye
-        void dwellers   55,113,89  and in all asteroid fields
-93      sengzhac 1st encounter
-138     d'pahk
-        trojan gate to moch *need coords*
-78      quai pa'loi
-191     guild
-171     icon
-221     titerian
-45      ermigen
-
diff --git a/makedata/planicon.cpr b/makedata/planicon.cpr
deleted file mode 100644
index b4301ea..0000000
Binary files a/makedata/planicon.cpr and /dev/null differ
diff --git a/makedata/playing.pas b/makedata/playing.pas
deleted file mode 100644
index 13e3f4e..0000000
--- a/makedata/playing.pas
+++ /dev/null
@@ -1,32 +0,0 @@
-program testdata;
-
-uses crt;
-
-type
- buffer= array[0..3075] of char;
-
-var
- b: buffer;
- f: file of buffer;
- j: integer;
- i: char;
-
-begin
- clrscr;
- assign(f,'d:\games\tsn2\twinion\twinchar.dat');
- reset(f);
- read(f,b);
- close(f);
- for j:=0 to 3075 do
-  begin
-   i:=b[j];
-
-   i:=chr(ord(i)+16);
-
-   b[j]:=i;
-  end;
-
- for j:=0 to 1075 do
-  write(b[j]);
- readkey;
-end.
\ No newline at end of file
diff --git a/makedata/portrait.pas b/makedata/portrait.pas
deleted file mode 100644
index c615bc3..0000000
--- a/makedata/portrait.pas
+++ /dev/null
@@ -1,78 +0,0 @@
-program grabportrait;
-
-uses crt, graph, data;
-const
- maxx=69;
- maxy=69;
-type
- portraittype= array[0..maxy,0..maxx] of byte;
-var
- portrait: ^portraittype;
- i,j,x,y: integer;
- ans: char;
- datafile: file of portraittype;
- vgafile: file of screentype;
- ratio: real;
-
-procedure convert;
-begin
- for j:=0 to 319 do
-  for i:=0 to 199 do
-   screen[i,j]:=screen[i,j] div 4;
- for j:=0 to 319 do
-  for i:=0 to 199 do
-   if screen[i,j]>31 then screen[i,j]:=screen[i,j]+128;
-end;
-
-procedure saveit;
-begin
- assign(datafile,'data\'+paramstr(2)+'.vga');
- rewrite(datafile);
- write(datafile,portrait^);
- close(datafile);
-end;
-
-procedure mainloop;
-begin
- repeat
-  ans:=readkey;
-  rectangle(x,y,x+round(maxx*ratio),y+round(maxy*ratio));
-  case upcase(ans) of
-    #0: begin
-         ans:=readkey;
-         case ans of
-          #72: if y>0 then dec(y) else y:=199;
-          #80: if y<199 then inc(y) else y:=0;
-          #75: if x>0 then dec(x) else x:=319;
-          #77: if x<319 then inc(x) else x:=0;
-         end;
-        end;
-   'S': saveit;
-   '+': ratio:=ratio+0.1;
-   '-': ratio:=ratio-0.1;
-  end;
-  for j:=0 to maxx do
-   for i:=0 to maxy do
-    portrait^[i,j]:=screen[round(i*ratio)+y,round(j*ratio)+x];
-  for i:=0 to maxy do
-   move(portrait^[i],screen[i+130,250],maxx);
-  rectangle(x,y,x+round(ratio*maxx),y+round(ratio*maxy));
- until ans=#27;
-end;
-
-begin
- new(portrait);
- x:=0;
- y:=0;
- ratio:=1;
- loadscreen(paramstr(1),@screen);
- loadpal('\save\data\char.pal');
- setcolor(191);
- set256colors(colors);
- convert;
- setwritemode(xorput);
- rectangle(x,y,x+maxx,y+maxy);
- mainloop;
- closegraph;
-end.
-
diff --git a/makedata/printsys.pas b/makedata/printsys.pas
deleted file mode 100644
index fd8fdf8..0000000
--- a/makedata/printsys.pas
+++ /dev/null
@@ -1,26 +0,0 @@
-program displaysystems;
-
-type
- systemtype=
-  record
-   name: string[12];
-   x,y,z,datey,visits: integer;
-   numplanets,notes,datem,mode: byte;
-  end;
- systemarray= array[1..250] of systemtype;
-var
- systems: systemarray;
- f: file of systemarray;
- i,j: integer;
-
-begin
- assign(f,'save5\systems.dta');
- reset(f);
- read(f,systems);
- close(f);
- for i:=1 to 250 do
-  with systems[i] do
-   begin
-    writeln(i:3,' ',name,x:5,y:5,z:5);
-   end;
-end.
\ No newline at end of file
diff --git a/makedata/quacon2.txt b/makedata/quacon2.txt
deleted file mode 100644
index 645c956..0000000
--- a/makedata/quacon2.txt
+++ /dev/null
@@ -1,73 +0,0 @@
-UNCOMPLETE ALPHA (0.5)
-QUAI PA'LOI
-PAI ALOI DURING THE WAR
-
--1      -1      1       1       HI HELLO GREETINGS HYA HIYA SALUTATIONS WELCOME
--1      20000   1       2       BYE GOOD-BYE GOODBYE OVER OUT 10-4 QUIT
--1      -1      1       3       HELP
--1      -1      1       5       VOID DWELLERS
--1      -1      1       5       D'PAHK WORMS
--1      -1      1       5       SENGZHAC BUGS BUGGERS
--1      -1      1       5       GUILD
--1      -1      1       5       PHAEDOR MOCH PUPPET
--1      -1      1       5       ERMIGEN
--1      -1      1       11      QUAI PA'LOI
--1      -1      1       12      PAI ALOI
--1      -1      1       13      Q'OOUL
--1      -1      1       5       ICON
--1      -1      1       5       TITERIAN
--1      -1      1       5       YLINTHLIXYMN YILLER
--1      -1      1       5       SCAVENGERS SCAVS
--1      -1      1       5       AARD
--1      -1      1       5       MALZATOIR
--1      -1      1       5       **** NAMELESS
--1      -1      1       5       TROJAN GATE GATES
--1      -1      1       5       MONKS MONK
--1      -1      1       5       HOMEWORLD HOME WORLD
--1      -1      1       26      SELL BUY TRADE TRADERS
--1      -1      1       5       HALLIFAX MANUEVER
--1      -1      1       5       NOVA
--1      -1      1       5       SHUNT
--1      -1      1       5       PHASE
--1      -1      1       5       GOD'S EYE
--1      -1      1       14      IRONSEED
--1      -1      1       5       THERMOPLAST
--1      -1      1       5       CARGAN
--1      -1      1       5       MOBEUS
--1      -1      1       5       KENDAR
-
--500
-
-GENERIC RESPONSE
-0       WHAT?
-
-HI
-1       HELLO, THERE IS A WAR ON, WE DON'T HAVE MUCH TIME TO TALK.
-
-BYE
-2       YES, LEAVE US ALONE, WE ARE BUSY.
-
-HELP
-3       WE NEED EVERYTHING FOR OURSELVES.  WE DON'T HAVE ANYTHING TO SPARE.
-
-MOST RACES
-5       WE DON'T HAVE TIME FOR GOSSIP, THERE IS A WAR GOING ON.
-
-QUAI PA'LOI
-11      WE HAVE FINALLY GAINED POWER.  NOW WE WILL BE ABLE TO SET STRAIGHT THE WRONGS OF THE Q'OOUL.
-
-PAI ALOI
-12      WE ARE NOW IN CHARGE HERE.
-
-Q'OOUL
-13      THEY HAVE RUN FROM US.  THEY ARE HIDING SOMEWHERE NEAR HERE.  IT IS ONLY A MATTER OF TIME BEFORE WE FIND THEM AND DESTROY THEM COMPLETELY.
-
-IRONSEED
-14      THAT IS THE NAME OF OUR OPERATION TO PROTECT OUR RESOURCES.  WE CANNOT TELL YOU ANY MORE THAN THAT.
-
-TRADE
-26      WE WILL NOT TRADE WITH OUTSIDERS.  OUR RESOURCES ARE TOO VALUEABLE.
-
-
-
--500
\ No newline at end of file
diff --git a/makedata/quacon3.txt b/makedata/quacon3.txt
deleted file mode 100644
index 3257292..0000000
--- a/makedata/quacon3.txt
+++ /dev/null
@@ -1,62 +0,0 @@
-CONV BEGIN
-
--1      -1      1       1       HI HELLO GREETINGS HYA HIYA SALUTATIONS WELCOME
--1      20000   1       2       BYE GOOD-BYE GOODBYE OVER OUT 10-4 QUIT
-215     -1      1       4       HELP
--1      214     1       3       HELP
--1      -1      1       5       VOID DWELLERS
--1      -1      1       5       D'PAHK WORMS
--1      -1      1       5       SENGZHAC BUGS BUGGERS
--1      -1      1       5       GUILD
--1      -1      1       5       PHAEDOR MOCH PUPPET
--1      -1      1       5       ERMIGEN
--1      -1      1       11      QUAI PA'LOI
--1      -1      1       12      PAI ALOI
--1      -1      1       13      Q'OOUL
--1      -1      1       5       ICON
--1      -1      1       5       TITERIAN
--1      -1      1       5       YLINTHLIXYMN YILLER
--1      -1      1       5       SCAVENGERS SCAVS
--1      -1      1       5       AARD
--1      -1      1       5       MALZATOIR
--1      -1      1       5       **** NAMELESS
--1      -1      1       24      MONKS MONK
--1      -1      1       26      SELL BUY TRADE TRADERS
--1      -1      1       5       HALLIFAX MANUEVER
-
--500
-
-GENERIC
-0       WHAT?
-
-HELLO
-1       HI.  WE NEED ^HELP^ BADLY.
-
-BYE
-2       BYE.  COME BACK AND ^HELP^ US SOON.
-
-HELP
-3       WE NEED GOOLAS.  THEY ARE BIG WEAPONS THAT WE CAN USE TO ATTACK THE PAI ALOI SHIPS.  WITHOUT THEM, WE WILL HAVE TO HIDE HERE.  THE GUILD PROBABLY HAS SOME.  YOU CAN FIND THE GUILD AT ********************.
-
-HELP
-4       WE NEED GOOLAS.  PLEASE TRY TO GET THEM FOR US.
-
-VOID
-5       WE HAVEN'T HEARD ANYTHING ABOUT THEM RECENTLY.  WE HAVEN'T GOTTEN OUT MUCH SINCE WE WENT INTO HIDING.
-
-QUAI PA'LOI
-11      IT IS SAD THAT OUR RACE HAS RESORTED TO GURILLA TACTICS IN ORDER TO RESOLVE OUR DIFFERENCES.
-
-PAI ALOI
-12      THEY ARE DANGEROUS AND UNPREDICABLE.  WE WILL NOT BE ABLE TO GO AGAINST THEM WITHOUT ^HELP^.
-
-Q'OOUL
-13      MAYBE WE WILL BE ABLE TO RETURN FROM OUR EXILE SOON.  WE ARE QUITE UNHAPPY HERE AWAY FROM OUR PRECIOUS HOME.
-
-MONKS
-24      DIDN'T THEY GO TO CUBA OR SOMETHING.
-
-SELL
-26      WE HAVE NOTHING HERE TO TRADE WITH.  WE WISH WE COULD THOUGH.
-
--500
\ No newline at end of file
diff --git a/makedata/quacon4.txt b/makedata/quacon4.txt
deleted file mode 100644
index f6d8612..0000000
--- a/makedata/quacon4.txt
+++ /dev/null
@@ -1,60 +0,0 @@
-CONV BEGIN
-
-264     -1      1       4       HI HELLO GREETINGS HYA HIYA SALUTATIONS WELCOME
--1      20107   3       1       HI HELLO GREETINGS HYA HIYA SALUTATIONS WELCOME
--1      20000   1       2       BYE GOOD-BYE GOODBYE OVER OUT 10-4 QUIT
--1      -1      1       3       HELP
--1      -1      1       5       VOID DWELLERS
--1      -1      1       5       D'PAHK WORMS
--1      -1      1       5       SENGZHAC BUGS BUGGERS
--1      -1      1       5       GUILD
--1      -1      1       5       PHAEDOR MOCH PUPPET
--1      -1      1       5       ERMIGEN
--1      -1      1       6       QUAI PA'LOI
--1      -1      1       7       PAI ALOI
--1      -1      1       8       Q'OOUL
--1      -1      1       5       ICON
--1      -1      1       5       TITERIAN
--1      -1      1       5       YLINTHLIXYMN YILLER
--1      -1      1       5       SCAVENGERS SCAVS
--1      -1      1       5       AARD
--1      -1      1       5       MALZATOIR
--1      -1      1       5       **** NAMELESS
--1      -1      1       5       MONKS MONK
--1      -1      1       25      HOMEWORLD HOME WORLD
--1      -1      1       26      SELL BUY TRADE TRADERS
-
--500
-
-HI
-1       HELLO AGAIN.  WE HAVE REGAINED OUR HOME.  YOU DESERVE A REWARD FOR YOUR HELP.  WE THOUGHT THAT THERE WOULD BE MORE OF OUR HOMEWORLD LEFT, BUT THE PAI ALOI HAVE DESTROYED ALMOST EVERYTHING...THE ENVIRONMENT, THE INDUSTRIES, THE QUI BALL STADIUMS,
-1       EVERYTHING.  I GUESS THAT IS NOT YOUR CONCERN THOUGH.  WELL, THE ONLY POTENTIALLY USEFUL OBJECT WE CAN FIND IS THIS ARTIFACT HERE.  WE ARE NOT SURE EXACTLY WHAT IT DOES, BUT YOU MIGHT BE ABLE TO FIND SOMETHING TO DO WITH IT.
-
-BYE
-2       WE ARE SORRY THAT WE COULD NOT HELP YOU MORE.
-
-HELP
-3       WE CANNOT ASK YOU FOR ANY MORE HELP.  WE WILL HAVE TO WORK THINGS OUT FOR OURSELVES.
-
-HI
-4       HELLO.  WE WILL NOT BE ABLE TO BE MUCH HELP TO YOU.  OUR WAR RECOVERY EFFORT HAS NOT BEEN VERY FRUITFUL.  OUR PLANET IS IN BAD SHAPE.
-
-RACES
-5       WE DO NOT HAVE TIME TO GOSSIP.
-
-QUAI PA'LOI
-6       WE ARE DOING THE BEST WE CAN CONSIDERING THE CURRENT STATE OF OUR PLANET.
-
-PAI ALOI
-7       THEY LEFT THIS PLACE IN A WRECK.
-
-Q'OOUL
-8       WE WON, BUT EXACTLY WHAT DID WE WIN IS THE QUESTION.
-
-HOMEWORLD
-25      IT IS A WRECK.
-
-TRADE
-26      WE WISH THAT WE COULD, BUT WE DON'T HAVE ANYTHING WORTH TRADEING...BESIDES, WE ARE TOO BUSY RECONSTRUCTING OUR PLANET TO PLAY WITH NEW TECH.
-
--500
\ No newline at end of file
diff --git a/makedata/research.cpr b/makedata/research.cpr
deleted file mode 100644
index e3f4102..0000000
Binary files a/makedata/research.cpr and /dev/null differ
diff --git a/makedata/reverse.pas b/makedata/reverse.pas
deleted file mode 100644
index 6e86759..0000000
--- a/makedata/reverse.pas
+++ /dev/null
@@ -1,67 +0,0 @@
-program testsb;
-
-{$M 64000,0,160000}
-
-uses voctool,crt,graph;
-type
-  buffertype= array[0..64000] of byte;
-
-var
- vocfile: file of byte;
- buffer1,buffer2: ^buffertype;
- i,j,vseg,vofs: word;
- length: word;
-
-begin
- closegraph;
- new(buffer1);
- new(buffer2);
- assign(vocfile,paramstr(1));
- reset(vocfile);
- clrscr;
- for j:=0 to 25 do
-  begin
-   read(vocfile,buffer1^[j]);
-   write(chr(buffer1^[j]));
-  end;
- writeln;
- writeln('------------------------------------');
- for j:=0 to 5 do read(vocfile,buffer2^[j]);
- writeln('Block type:',buffer2^[0]);
- length:=buffer2^[1]+buffer2^[2]*256;
- writeln('Block length:',length);
- writeln('Sample rate:',buffer2^[4]);
- writeln('Pack Byte:',buffer2^[5]);
- for j:=1 to length-2 do read(vocfile,buffer2^[j+5]);
- buffer2^[length+4]:=0;
- VOCSetSpeaker(TRUE);
- VSeg := Seg(Buffer2^);
- VOfs := Ofs(Buffer2^);
- ASM
-  MOV       BX,6
-  MOV       ES,VSeg
-  MOV       DI,VOfs
-  CALL      VOCPtrToDriver
- END;
- writeln('------------------------------------');
- for j:=length+3 downto 6 do buffer1^[length+9-j]:=buffer2^[j];
- for j:=0 to 5 do buffer1^[j]:=buffer2^[j];
- buffer1^[length+4]:=0;
- repeat until vocstatusword=0;
- VSeg := Seg(Buffer1^);
- VOfs := Ofs(Buffer1^);
- ASM
-  MOV       BX,6
-  MOV       ES,VSeg
-  MOV       DI,VOfs
-  CALL      VOCPtrToDriver
- END;
- repeat until vocstatusword=0;
- reset(vocfile);
- seek(vocfile,26);
- for j:=0 to length+4 do write(vocfile,buffer1^[j]);
- close(vocfile);
-
- dispose(buffer1);
- dispose(buffer2);
-end.
diff --git a/makedata/rob.mod b/makedata/rob.mod
deleted file mode 100644
index 06c2639..0000000
Binary files a/makedata/rob.mod and /dev/null differ
diff --git a/makedata/rob2.mod b/makedata/rob2.mod
deleted file mode 100644
index db1d293..0000000
Binary files a/makedata/rob2.mod and /dev/null differ
diff --git a/makedata/rob3.mod b/makedata/rob3.mod
deleted file mode 100644
index 4e63d39..0000000
Binary files a/makedata/rob3.mod and /dev/null differ
diff --git a/makedata/sbjoin.pas b/makedata/sbjoin.pas
deleted file mode 100644
index dd91ac3..0000000
--- a/makedata/sbjoin.pas
+++ /dev/null
@@ -1,161 +0,0 @@
-program testsb;
-
-{$M 64000,0,220000}
-
-uses crt, voctool;
-type
-  buffertype= array[0..64000] of byte;
-
-var
- vocfile: file of byte;
- buffer1,buffer2: ^buffertype;
- j,vseg,vofs: word;
- length1,length2: word;
- i: integer;
-
-procedure savebuf(num: byte);
-begin
- if num=1 then
-  begin
-   assign(vocfile,paramstr(1));
-   reset(vocfile);
-   seek(vocfile,26);
-   for j:=0 to length1+4 do write(vocfile,buffer1^[j]);
-   close(vocfile);
-  end;
- if num=2 then
-  begin
-   assign(vocfile,paramstr(1));
-   reset(vocfile);
-   seek(vocfile,26);
-   for j:=0 to length2+4 do write(vocfile,buffer2^[j]);
-   close(vocfile);
-  end;
-end;
-
-procedure combine;
-begin
- if length1>length2 then
-  begin
-   for j:=6 to length1 do
-    begin
-     i:=buffer1^[j]+buffer2^[j]-128;
-     if i<0 then i:=0;
-     if i>255 then i:=255;
-     buffer1^[j]:=i;
-    end;
-    VSeg := Seg(Buffer1^);
-    VOfs := Ofs(Buffer1^);
-    ASM
-     MOV       BX,6
-     MOV       ES,VSeg
-     MOV       DI,VOfs
-     CALL      VOCPtrToDriver
-    END;
-    savebuf(1);
-  end
- else
-  begin
-   for j:=6 to length2 do
-    begin
-     i:=buffer1^[j]+buffer2^[j]-128;
-     if i<0 then i:=0;
-     if i>255 then i:=255;
-     buffer2^[j]:=i;
-    end;
-   VSeg := Seg(Buffer2^);
-   VOfs := Ofs(Buffer2^);
-   ASM
-    MOV       BX,6
-    MOV       ES,VSeg
-    MOV       DI,VOfs
-    CALL      VOCPtrToDriver
-   END;
-   savebuf(2);
-  end;
-end;
-
-procedure combine2;
-var length: longint;
-    buffer3: ^buffertype;
-    index: integer;
-begin
- new(buffer3);
- for j:=0 to 5 do buffer3^[j]:=buffer1^[j];
- length:=length1+length2;
- buffer3^[2]:=length div 256;
- buffer3^[1]:=length mod 256;
- index:=6;
- buffer3^[length+4]:=0;
- buffer3^[4]:=round(buffer3^[4]*1.35);
- for j:=6 to length do
-  if j mod 2=0 then buffer3^[j]:=buffer1^[index]
-  else
-   begin
-    buffer3^[j]:=buffer2^[index];
-    inc(index);
-   end;
- VSeg := Seg(Buffer3^);
- VOfs := Ofs(Buffer3^);
- ASM
-  MOV       BX,6
-  MOV       ES,VSeg
-  MOV       DI,VOfs
-  CALL      VOCPtrToDriver
- END;
- dispose(buffer3);
-end;
-
-begin
- textmode(co80);
- new(buffer1);
- new(buffer2);
- for j:=0 to 64000 do buffer1^[j]:=128;
- for j:=0 to 64000 do buffer2^[j]:=128;
- assign(vocfile,paramstr(1));
- reset(vocfile);
- clrscr;
- for j:=0 to 25 do
-  begin
-   read(vocfile,buffer2^[j]);
-   write(chr(buffer2^[j]));
-  end;
- writeln;
- writeln('------------------------------------');
- for j:=0 to 5 do read(vocfile,buffer2^[j]);
- writeln('Block type:',buffer2^[0]);
- length1:=buffer2^[1]+buffer2^[2]*256;
- writeln('Block length:',length1);
- writeln('Sample rate:',buffer2^[4]);
- writeln('Pack Byte:',buffer2^[5]);
- for j:=1 to length1-2 do read(vocfile,buffer2^[j+5]);
- buffer2^[length1+4]:=0;
- buffer2^[length1+5]:=0;
- writeln('------------------------------------');
- close(vocfile);
- assign(vocfile,paramstr(2));
- reset(vocfile);
- for j:=0 to 25 do
-  begin
-   read(vocfile,buffer1^[j]);
-   write(chr(buffer1^[j]));
-  end;
- writeln;
- writeln('------------------------------------');
- for j:=0 to 5 do read(vocfile,buffer1^[j]);
- writeln('Block type:',buffer1^[0]);
- length2:=buffer1^[1]+buffer1^[2]*256;
- repeat until vocstatusword=0;
- writeln('Block length:',length2);
- writeln('Sample rate:',buffer1^[4]);
- writeln('Pack Byte:',buffer1^[5]);
- for j:=1 to length2-2 do read(vocfile,buffer1^[j+5]);
- buffer1^[length2+4]:=0;
- buffer1^[length2+5]:=0;
- writeln('------------------------------------');
- close(vocfile);
- combine2;
- repeat until vocstatusword=0;
- dispose(buffer1);
- dispose(buffer2);
-end.
diff --git a/makedata/scanmake b/makedata/scanmake
deleted file mode 100755
index 30a7d58..0000000
Binary files a/makedata/scanmake and /dev/null differ
diff --git a/makedata/scanmake.pas b/makedata/scanmake.pas
index 4cd82d9..1b4eea7 100644
--- a/makedata/scanmake.pas
+++ b/makedata/scanmake.pas
@@ -1,4 +1,20 @@
 program generatecargodata;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 type
  cargotype=
@@ -21,7 +37,7 @@ begin
  assign(ft,'\ironseed\makedata\scandata.txt');
  reset(ft);}
  assign(f,'data/scan.dta');
- reset(f);
+ rewrite(f);
  assign(ft,'makedata/scandata.txt');
  reset(ft);
  for i:=1 to 17 do
diff --git a/makedata/sengcon2.txt b/makedata/sengcon2.txt
deleted file mode 100644
index 4f2528c..0000000
--- a/makedata/sengcon2.txt
+++ /dev/null
@@ -1,87 +0,0 @@
-CONV BEGIN
-
--1      20109   1       1       HI HELLO GREETINGS HYA HIYA SALUTATIONS WELCOME
--1      20000   1       2       BYE GOOD-BYE GOODBYE OVER OUT 10-4 QUIT
--1      -1      1       3       HELP
--1      -1      1       5       VOID DWELLERS
--1      -1      1       5       D'PAHK WORMS
--1      -1      1       5       SENGZHAC BUGS BUGGERS
--1      -1      1       5       GUILD
--1      -1      1       5       PHAEDOR MOCH PUPPET
--1      -1      1       5       ERMIGEN
--1      -1      1       5       QUAI PA'LOI
--1      -1      1       5       PAI ALOI
--1      -1      1       5       Q'OOUL
--1      -1      1       5       ICON
--1      -1      1       5       TITERIAN
--1      -1      1       5       YLINTHLIXYMN YILLER
--1      -1      1       5       SCAVENGERS SCAVS
--1      -1      1       5       AARD
--1      -1      1       5       MALZATOIR
--1      -1      1       20      **** NAMELESS
--1      -1      1       5       MONKS MONK
--1      -1      1       26      SELL BUY TRADE TRADERS
--1      -1      1       5       HALLIFAX MANUEVER
--1      -1      1       31      GOD'S EYE
--1      -1      1       32      IRONSEED
--1      -1      1       35      MOBEUS
--1      -1      3       36      KENDAR
--1      -1      1       54
--1      -1      1       55
--1      -1      3       56
-281     -1      1       57      DOOM GATE
--1      20110   1       4       DOOM GATE
-
--500
-
-HI
-1
-
-BYE
-2       GOOD LUCK, BROTHER KRANZHAC.
-
-HELP
-3       HOW CAN WE HELP YOU?
-
-DOOM GATE
-4       THAT IS A VERY POWERFUL WEAPON INDEAD.  THEY ARE QUITE DIFFICULT TO ACQUIRE.  I THINK THAT I CAN SPARE ONE FOR YOU THOUGH.  HERE YOU GO.  BE CAREFUL WITH IT, FOR IT IS QUITE DANGEROUS.
-
-RACES
-5       AS LONG AS THEY AVOID THE _GOD'S EYE_, I DO NOT PAY MUCH ATTENTION TO THE NON-COLECTIVE RACES.  I GOT TIRED OF GOSSIPING WITH MYSELF AGES AGO.
-
-****
-20      I REMEMBER THEM WELL.  THEY CAUSED FEAR EVEN TO ME.  THEY DESTROYED MANY OF MY BEST LIMBS.  I PREFER NOT TO DISCUSS THEM.  IT IS TOO PAINFUL.
-
-TRADE
-26      I ALREADY TOLD YOU THAT I WOULD HELP YOU ANY WAY I CAN.  YOU NEED NOT REPAY ME.  I EXPECT YOU MIGHT DO THE SAME FOR ME IN A FEW MILLENIA.
-
-GOD'S EYE
-31      IT IS AN ANCEINT EVIL AND IS BETTER LEFT UNDISCUSSED.  I GUESS YOU COULD SAY THAT I PROTECT IT FROM HARM AND MISUSE.
-
-IRONSEED
-32      AH YES.  THE HOME OF THE FIRST LIMB...WHERE OUR ANCESTORS, YOURS AND MINE, SPREAD FROM AND CREATED ALL OF THE COLLECTIVE BEINGS.  HOW WONDERFUL THOSE MEMORIES ARE, DON'T YOU THINK?
-
-MOBEUS
-35      DO NOT SPEAK OF SUCH THINGS.  EVIL DEVICES ARE NOT WELCOME HERE.
-
-KENDAR
-36      THAT WAS THE LAST TIME THAT I HAD ANY REAL CONTACT WITH NON-COLLECTIVE RACES.  I HAD TO DO SOMETHING OR ELSE THE **** MIGHT HAVE CONTINUED THEIR REIGN OF TERROR, BUT WITH THE KNOWLEDGE AND NUMBERS OF THE NON-COLLECTIVE RACES, I WAS ABLE TO FINALLY
-36      DEFEAT THEM.  THE OTHER RACES CAN BE INTERESTING SOMETIMES, BUT IT IS BETTER NOT TO GIVE YOUR LIMBS ANY IDEAS.
-
-
-HI BATTLE
-54      STUPID EARTHLING.  YOU CANNOT DEFEAT ME AT MY HOME WORLD.  I WILL FINISH YOU OFF NOW.
-
-HI PEACE
-55      HELLO BROTHER BUG.  WE ARE BUSY RIGHT NOW, SO UNLESS YOU HAVE A CONCERN FOR US, WE DON'T HAVE TIME TO TALK.
-
-HI BINGO
-56      GREETINGS BROTHER BUG.  CAN I HELP YOU.##YOU> GREETINGS BROTHER SENGZHAC.  YOU MAY NOT KNOW ME, BUT I AM KRANZHAC, A COLLECTIVE BEING MUCH LIKE YOURSELF.  RECENTLY A NUMBER OF MY LIMBS FOUND A WAY TO BREAK AWAY FROM THE COLLECTIVE.  THEY HAVE
-56      SINCE BEEN TERROIZING ME, TRYING TO FREE THEIR BROTHER LIMBS.  THEY KNOW HOW I THINK, ALL OF MY TACTICS, ALL OF MY TECHNOLOGY.  I NEED SOMETHING NEW THAT I CAN USE AGAINST THEM...SOMETHING THAT THEY WON'T BE PREPARED FOR.  I NEED SOMETHING THAT
-56      WILL ALLOW ME TO WIPE THEM OUT QUICKLY BEFORE THEY CAN DESTROY ME.  PLEASE HELP ME BROTHER SENGZHAC.##I FEEL FOR YOU GREATLY.  I TOO ONCE HAD SOME LIMBS GAIN FREEDOM.  I WAS FORCED TO SQUASH THEM QUICKLY BEFORE THEY COULD TURN ON ME.  I WILL
-56      AID YOU WITH WHATEVER I CAN SPARE.  WHAT IS IT THAT YOU SEEK, BROTHER?
-
-DOOM GATE
-57      I HAVE ALREADY GIVEN YOU ONE.  I CANNOT SPARE ANYMORE.  SORRY.
-
--500
\ No newline at end of file
diff --git a/makedata/sep.pas b/makedata/sep.pas
deleted file mode 100644
index a52b872..0000000
--- a/makedata/sep.pas
+++ /dev/null
@@ -1,1913 +0,0 @@
-program screeneditorforportaits;
-{$M 2048,0,145000,145000}
-{$L vga256}
-{$L mover2}
-
-{**************************************************************************
-
- VGA RAW DATA SCREEN EDITOR
-
-    - 1.000 MAIN ROUTINES
-    - 1.100 x10 PEL JUMPS/BUGFIXES/ERROR CHECKING
-    - 1.500 PALMODE TOGGLE/BUGFIXES/OPTIMIZED
-    - 1.600 PALEDIT
-    - 1.610 MEMORY RESTRICTIONS/COSMETICS
-    - 1.620 CHANGED UNDERPALMODE TO HEAP NOT DATA
-    - 1.700 CIRCLES ADDED
-    - 1.710 CIRCLE BUGFIX
-    - 1.730 COSMETICS/COORDINATE MODE/MULTIPLE PALCOLOR MODE
-    - 1.740 BUGFIX IN PALADJUSTMENTS
-    - 1.800 LINE SUPPORT ADDED
-    - 1.810 BAR SUPPORT
-    - 1.820 RECTANGLE SUPPORT
-    - 1.840 PALEDIT ALLOWS EDITING OF MORE THAN 16 COLORS
-    - 1.845 BUGFIX
-    - 1.900 BETTER ERROR CHECKING/REMEMBERS TO CREATE NEW PAL IF NECESSARY
-    - 1.950 MORE INFO IN STATUS/PALSTR/BUGFIX IN WRAPPING
-    - 1.955 SUPPORTS ELLIPSES
-    - 2.000 PALEDIT SUPPORTS <16 COLOR EDITING
-    - 2.051 BUGFIXES
-    - 2.100 VERTICAL FLIP
-    - 2.200 HORIZONTAL FLIP
-    - 2.300 MOVE/COPY BLOCKS SUPPORTED
-    - 2.400 MASSIVE OVERHAUL, MODULARIZED ALL GENERAL EFFECTS(OPTIONS)
-    - 2.450 MOVE OPERATIONS FIXED
-    - 2.500 BUGFIXES IN UNDER COLOR/DO ALT ON AN AREA
-    - 2.600 ROTATE 90 SUPPORTED
-    - 2.650 BUGFIX IN PAL PARTITIONING
-    - 2.651 'Z' PICKS UP UNDER COLOR
-    - 2.700 HELP SCREEN/COSMETICS
-    - 2.710 BUGFIX IN FADE AREA
-    - 2.800 DOS SHELL SUPPORTED
-    - 2.900 PARTITIONING(RESIZING) SUPPORTED/COSMETICS IN DOS SHELL
-    - 2.910 COSMETICS
-    - 2.920 DEFAULT PALETTE MUST BE IN EXECUTED DIRECTORY/COSMETICS
-    - 2.930 LOTS OF LITTLE STUFF
-    - 2.931 MORE AND MORE LITTLE STUFF
-    - 2.935 NASTY BUG IN PALEDIT CAUSING FUNNY COLORS
-
-    * UNREGISTERED VERSION 1 HAS ALL FUNCTIONS BUT SHRINKS, FADES, FLIPS,
-       ROTATES, COPY, AND DOSSHELL
-
-    - 2.937 PATERN FILLS SUPPORTED/CHANGED A FEW OF THE HELP DESCRIPTIONS
-    - 2.939 DIFFERENT LINE STYLES SUPPORTED/CHARANI REMOVED/SETRGB256 ADDED/GARBAGE REMOVED
-    - 2.940 BUGFIXES/COSMETICS/MORE MEMORY!
-    - 2.941 RECTANGLES ALSO ALLOW LINE STYLES
-    - 2.943 FILLED CIRCLES
-    - 2.944 FILL PATTERNS FOR CIRCLES
-    - 2.945 MINOR INTERNALS
-    - 2.946 MINOR STUPID INSECTOID
-    - 2.948 NO LONGER CREATES FILES THAT ARE NOT FOUND
-    - 2.950 LIMITED MOUSE SUPPORT
-    - 2.960 MOUSE SUPPORT IN GENERAL OPTIONS (FIRST LEVEL ONLY)
-    - 2.970 MOUSE SUPPORT IN GENERAL OPTIONS (ALL LEVELS) AND CIRCLES
-    - 2.980 ABILITY TO ENTER TEXT MESSAGES USING DEFAULT FONT
-    - 2.981 BUG FIX IN WRITING TEXT
-    - 2.982 BUG FIX IN WRITING TEXT/MOVER CHANGED TO NEAR PROC (FASTER)
-    - 2.983 HIGHLIGHT COLOR DARKER
-    - 2.985 BETTER PARTITIONING/WAIT PROC REMOVED/TITLE AT END NOW
-    - 2.990 LOAD COMMAND ALLOWS LOADING OTHER FILES
-    - 3.000 CLIPBOARD FUNCTIONS
-    - 3.100 SAVE CLIPBOARD TO FILE/VIEWING CLIPBOARD/LOTS OF COSMETICS
-    - 3.150 LITTLE BIT LARGER STATUS BAR (MORE SPACE FOR INFO)
-    - 3.200 SAVE CLIPBOARD ONLY ON CHANGE/EXIT WARNING/BUGS IN STATUS BAR
-    - 3.201 LONGER VGA AND PAL STRINGS/COSMETICS
-    - 3.202 FULL DOCS WRITTEN!/A FEW KEY CHANGES
-    - 3.203 HEAP OVERFLOW ERROR ON EXIT
-    - 3.21  RECTANGLES AND BARS MERGED/CLIPBOARD Y 1 LARGER/,. IN FUNCTIONS
-    - 3.22  ABILITY TO FADE,BRIGHTEN WHILE MOVING BLOCK/MOVE BLOCK STARTS AT
-             CURSOR POS RATHER THAN CENTER
-    - 3.23  CLIPBOARD ERROR WITH SIZE/PARTITIONING OF PALETTE SMALLER
-    - 3.233 MASKING FUNCTION IN MOVE BLOCK/BUG IN PARTITIONING WITH MOUSE
-    - 3.234 MASKING FUNCTION AND FADE,BRIGHTEN IN GRAB BLOCK
-    - 3.235 KEY CHANGES
-    - 3.236 PARTITIONING USING BITMAP SCALING/CLIPBOARD BUG FIXED (MAYBE)
-
-  Robert Morgan
-  Channel 7
-  Destiny: Virtual
-
-  (C) Dec. 31, 1993
-
-**************************************************************************}
-
-uses graph, crt, dos;
-const
- maxpaly= 23;
- maxyonpal= 176;
- cordofs= 6;
- tick1= 3;
- tick2= 13;
- graycolor= 26;
-type
- underpaltype= array[0..maxpaly,0..319] of byte;
- colortype= array[1..3] of byte;
- paltype= array[0..255] of colortype;
- screentype= array[0..199,0..319] of byte;
- fonttype= array[1..3] of byte;
- portraittype= array[0..69,0..69] of byte;
-const
- cr= #13#10;
- version= 3.236;
- font: array[1..55] of fonttype=
-  ((0,0,0),       { } (102,96,96),   {!} (85,80,0),     {"} (34,0,0),      {'}
-   (36,68,32),    {(} (66,34,64),    {)} (9,105,0),     {*} (4,228,0),     {+}
-   (0,2,36),      {,} (0,240,0),     {-} (0,0,32),      {.} (1,36,128),    {/}
-   (107,221,96),  {0} (98,34,240),   {1} (241,104,240), {2} (241,33,224),  {3}
-   (153,241,16),  {4} (248,113,224), {5} (248,249,240), {6} (241,17,16),   {7}
-   (249,105,240), {8} (249,241,16),  {9} (102,6,96),    {:} (102,6,98),    {;}
-   (18,66,16),    {<} (15,15,0),     {=} (132,36,128),  {>} (105,32,32),   {?}
-   (121,185,144), {a} (249,169,240), {b} (248,136,240), {c} (233,153,224), {d}
-   (240,200,240), {e} (248,232,128), {f} (248,153,240), {g} (153,249,144), {h}
-   (114,34,112),  {i} (241,25,96),   {j} (158,153,144), {k} (136,136,240), {l}
-   (159,153,144), {m} (233,153,144), {n} (249,153,240), {o} (249,152,128), {p}
-   (105,155,112), {q} (249,169,144), {r} (132,33,224),  {s} (114,34,32),   {t}
-   (153,153,240), {u} (153,153,96),  {v} (153,187,96),  {w} (153,105,144), {x}
-   (153,113,16),  {y} (242,72,240),  {z} (9,36,144));   {%}
-var
- curx,cury,i,j,backcolor,paly,palcur,tcolor,bkcolor,multimode,
-  r,rx,ry,mdx,mdy,multimode2,clipx,clipy: integer;
- under,last,change: byte;
- vgastr,palstr: string[40];
- pathstr,curpath: string[79];
- underpal: ^underpaltype;
- mouseinstalled,palmodeon,done,donepal,coordon,palchange,
-  clipboardchange: boolean;
- colors: paltype;
- screen: screentype absolute $A000:0000;
- ans: char;
- clipboard,t: ^screentype;
- str1,str2: string[3];
-
-procedure vgadriver; external;
-procedure mymove2(var src,tar; count: integer); external;
-
-procedure drawtitlemessage;
-begin
- textcolor(5);
- writeln(cr,cr,cr,cr,' CHANNEL 7, DESTINY: VIRTUAL');
- textcolor(9);
- writeln('        ROBERT MORGAN');
- textcolor(14);
- writeln('     Screen Edit  v',version:0:3,cr);
- textcolor(15);
-end;
-
-procedure errorhandler(s: string; errtype: integer);
-begin
- closegraph;
- writeln;
- writeln;
- case errtype of
-  1: writeln('Opening File Error: ',s);
-  5: writeln('Read/Write File Error: ',s);
-  6: writeln('Program Error: ',s);
-  7: writeln('DOS Error: ',s);
- end;
- halt(4);
-end;
-
-{$F+}
-function testit : integer; assembler;
-{$F-}
-asm
- mov ax, 1A00h
-  int 10h
- cmp al, 1Ah
- jne @@nope
- mov ax, 1
- jmp @@done
-@@nope:
- mov ax, 0
-@@done:
-end;
-
-procedure readygraph;
-var testdriver,driver,mode,errcode: integer;
-begin
- testdriver:=installuserdriver('vga256',@testit);
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeLn('Error Installing VGA Driver:',errcode);
-   halt(4);
-  end;
- registerbgidriver(@vgadriver);
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeLn('Error Registering VGA Driver:',errcode);
-   halt(4);
-  end;
- driver:=detect;
- initgraph(driver,mode,'');
- errcode:=graphresult;
- if errcode<>grok then
-  begin
-   writeln('Video Initialization Failure: ',errcode);
-   halt(4);
-  end;
- setgraphbufsize(0);
- checksnow:=false;
-end;
-
-function fastkeypressed: boolean; assembler;
-asm
- push ds
- mov ax, 40h
- mov ds, ax
- cli
- mov ax, [1Ah]
- cmp ax, [1Ch]
- sti
- mov ax, 0
- jz @nopress
- inc ax
-@nopress:
- pop ds
-end;
-
-procedure setrgb256(palnum,r,g,b: byte); assembler;
-asm
- xor bh, bh
- mov bl, palnum
- mov ax, 1010h
- mov dh, r
- mov ch, g
- mov cl, b
-  int 10h
-end;
-
-procedure set256Colors(pal: paltype); assembler;
-asm
- mov ax, 1012h
- mov bx, 0
- mov cx, 256
- les dx, Pal
-  int 10h
-end;
-
-function testbit(b,bit: byte) : boolean; assembler;
-asm
- mov cl, bit
- mov bl, 1
- shl bl, CL
- mov al, 0
- test b, bl
- jz @@no
- inc al
-@@no:
-end;
-
-procedure printxy(x1,y1: integer; s: string);
-var letter,a,index: integer;
-begin
- for j:=1 to length(s) do
-  begin
-   case s[j] of
-    ' ' ..'"':letter:=ord(s[j])-31;
-    ''''..'?':letter:=ord(s[j])-35;
-    'A' ..'Z':letter:=ord(s[j])-36;
-    '%': letter:=55;
-    '\': letter:=12;
-    else letter:=1;
-   end;
-   index:=1;
-   for i:=1 to 6 do
-    begin
-     for a:=4 to 7 do
-      if testbit(font[letter,index],a) then screen[y1+i,x1+j*5+7-a]:=tcolor
-       else if bkcolor<255 then screen[y1+i,x1+j*5+7-a]:=bkcolor;
-     inc(i);
-     for a:=0 to 3 do
-      if testbit(font[letter,index],a) then screen[y1+i,x1+j*5+3-a]:=tcolor
-       else if bkcolor<255 then screen[y1+i,x1+j*5+3-a]:=bkcolor;
-     inc(index);
-    end;
-    if bkcolor<255 then for i:=1 to 6 do screen[y1+i,x1+j*5+4]:=bkcolor;
-  end;
-end;
-
-procedure drawpaleditscreen;
-begin
- for i:=4 to 176 do
-  fillchar(screen[i,34],172,0);
- setcolor(255);
- rectangle(35,5,204,175);
- rectangle(37,7,202,173);
- for j:=0 to 255 do
-  for i:=0 to 8 do
-   fillchar(screen[(j div 16)*10+i+10,(j mod 16)*10+40],9,j);
- palcur:=last;
- for i:=74 to 126 do
-  fillchar(screen[i,214],92,0);
- rectangle(215,75,304,125);
- rectangle(217,77,302,123);
- printxy(240,82, '+ Q  W  E');
- printxy(240,112,'- A  S  D');
-end;
-
-procedure writecolorstats;
-var str1,str2,str3: string[3];
-begin
- str(colors[palcur,1]:3,str1);
- str(colors[palcur,2]:3,str2);
- str(colors[palcur,3]:3,str3);
- printxy(240,97,str1+str2+str3);
-end;
-
-procedure undocursor;
-begin
- if multimode=0 then
-  begin
-   fillchar(screen[((palcur-multimode2+1) div 16)*10+9,((palcur-multimode2+1) mod 16)*10+39],1+10*multimode2,0);
-   fillchar(screen[((palcur-multimode2+1) div 16)*10+19,((palcur-multimode2+1) mod 16)*10+39],1+10*multimode2,0);
-   for i:=0 to 10 do
-    begin
-     screen[((palcur-multimode2+1) div 16)*10+9+i,((palcur-multimode2+1) mod 16)*10+39]:=0;
-     screen[(palcur div 16)*10+9+i,(palcur mod 16)*10+49]:=0;
-    end;
-  end
- else
-  begin
-   fillchar(screen[(palcur div 16)*10+9-10*(multimode-1),39],161,0);
-   fillchar(screen[(palcur div 16)*10+9+10*multimode-10*(multimode-1),39],161,0);
-   for i:=0 to 10*multimode do
-    begin
-     screen[(palcur div 16)*10-10*(multimode-1)+9+i,39]:=0;
-     screen[(palcur div 16)*10-10*(multimode-1)+9+i,199]:=0;
-    end;
-  end;
-end;
-
-procedure drawcursor;
-begin
- if multimode=0 then
-  begin
-   fillchar(screen[((palcur-multimode2+1) div 16)*10+9,((palcur-multimode2+1) mod 16)*10+39],1+10*multimode2,255);
-   fillchar(screen[((palcur-multimode2+1) div 16)*10+19,((palcur-multimode2+1) mod 16)*10+39],1+10*multimode2,255);
-   for i:=0 to 10 do
-    begin
-     screen[((palcur-multimode2+1) div 16)*10+9+i,((palcur-multimode2+1) mod 16)*10+39]:=255;
-     screen[(palcur div 16)*10+9+i,(palcur mod 16)*10+49]:=255;
-    end;
-   for i:=0 to 11 do
-    fillchar(screen[94+i,230],15,palcur);
-  end
- else
-  begin
-   fillchar(screen[(palcur div 16)*10+9-10*(multimode-1),39],161,255);
-   fillchar(screen[(palcur div 16)*10+9+10*multimode-10*(multimode-1),39],161,255);
-   for i:=0 to 10*multimode do
-    begin
-     screen[(palcur div 16)*10-10*(multimode-1)+i+9,39]:=255;
-     screen[(palcur div 16)*10-10*(multimode-1)+i+9,199]:=255;
-    end;
-   for i:=0 to 11 do
-    fillchar(screen[94+i,230],15,palcur);
-  end;
-end;
-
-procedure setpal(a,b,c: integer);
-var part1,part2,part3: real;
-begin
- if (colors[palcur,1]=63) and (a=1) then colors[palcur,1]:=0
-  else if (colors[palcur,1]=0) and (a=-1) then colors[palcur,1]:=63
-  else colors[palcur,1]:=colors[palcur,1]+a;
- if (colors[palcur,2]=63) and (b=1) then colors[palcur,2]:=0
-  else if (colors[palcur,2]=0) and (b=-1) then colors[palcur,2]:=63
-  else colors[palcur,2]:=colors[palcur,2]+b;
- if (colors[palcur,3]=63) and (c=1) then colors[palcur,3]:=0
-  else if (colors[palcur,3]=0) and (c=-1) then colors[palcur,3]:=63
-  else colors[palcur,3]:=colors[palcur,3]+c;
- if multimode>0 then
-  begin
-   part1:=colors[palcur,1]/(16*multimode+3);
-   part2:=colors[palcur,2]/(16*multimode+3);
-   part3:=colors[palcur,3]/(16*multimode+3);
-   for i:=1 to 16*multimode-1 do
-    begin
-     colors[palcur-i,1]:=round(part1*(16*multimode-i)+3);
-     colors[palcur-i,2]:=round(part2*(16*multimode-i)+3);
-     colors[palcur-i,3]:=round(part3*(16*multimode-i)+3);
-     for j:=1 to 3 do
-      if colors[palcur-i,j]>63 then colors[palcur-i,j]:=63;
-    end;
-  end
- else if multimode2>1 then
-  begin
-   part1:=colors[palcur,1]/(multimode2+3);
-   part2:=colors[palcur,2]/(multimode2+3);
-   part3:=colors[palcur,3]/(multimode2+3);
-   for i:=1 to multimode2-1 do
-    begin
-     colors[palcur-i,1]:=round(part1*(multimode2-i+3));
-     colors[palcur-i,2]:=round(part2*(multimode2-i+3));
-     colors[palcur-i,3]:=round(part3*(multimode2-i+3));
-    end;
-  end;
- set256colors(colors);
-end;
-
-procedure processpalkey;
-begin
- ans:=readkey;
- case upcase(ans) of
-   #0: begin
-        undocursor;
-        ans:=readkey;
-        case ans of
-         #77: if (multimode=0) and (multimode2=1) then inc(palcur)
-               else if (multimode=0) and (palcur mod 16<15) then inc(palcur);
-         #75: if (multimode=0) and (multimode2=1) then dec(palcur)
-               else if (multimode=0) and ((palcur-multimode2+1) mod 16>0) then dec(palcur);
-         #80: inc(palcur,16);
-         #72: dec(palcur,16);
-        end;
-        if palcur<0 then palcur:=palcur+256
-        else if palcur>255 then palcur:=palcur-256;
-        if (multimode>0) and ((palcur-multimode*16+1)<0) then palcur:=255;
-      end;
-  #27: donepal:=true;
-  'Q': setpal(1,0,0);
-  'W': setpal(0,1,0);
-  'E': setpal(0,0,1);
-  'A': setpal(-1,0,0);
-  'S': setpal(0,-1,0);
-  'D': setpal(0,0,-1);
-  '+': if multimode>0 then
-        begin
-         undocursor;
-         inc(multimode);
-         if multimode>16 then multimode:=16;
-         palcur:=multimode*16-1;
-        end
-       else
-        begin
-         undocursor;
-         inc(multimode2);
-         if multimode2=17 then
-          begin
-           multimode:=2;
-           multimode2:=15;
-           palcur:=31;
-          end
-         else palcur:=multimode2-1;
-        end;
-  '-': if multimode>0 then
-        begin
-         undocursor;
-         dec(multimode);
-         if multimode=0 then palcur:=14;
-        end
-       else
-        begin
-         undocursor;
-         dec(multimode2);
-         if multimode2=0 then multimode2:=1;
-         palcur:=multimode2-1;
-        end;
- end;
- writecolorstats;
-end;
-
-procedure paledit;
-var temppal: ^paltype;
-begin
- new(t);
- new(temppal);
- temppal^:=colors;
- mymove2(screen,t^,16000);
- drawpaleditscreen;
- donepal:=false;
- multimode:=0;
- multimode2:=1;
- palcur:=last;
- writecolorstats;
- repeat
-  drawcursor;
-  if fastkeypressed then processpalkey;
- until donepal;
- mymove2(t^,screen,16000);
- dispose(t);
- last:=palcur;
- if not palchange then
-  begin
-   i:=0;
-   for i:=0 to 255 do
-    for j:=1 to 3 do
-     if colors[i,j]<>temppal^[i,j] then
-      begin
-       palchange:=true;
-       dispose(temppal);
-       exit;
-      end;
-  end;
- dispose(temppal);
-end;
-
-procedure redrawpalmode;
-begin
- for i:=0 to maxpaly do
-  fillchar(screen[i+paly],320,0);
- setcolor(255);
- rectangle(0,paly+1,319,paly+maxpaly-1);
- for j:=0 to 255 do
-  for i:=cordofs to cordofs+5 do
-   screen[i+paly,j+2]:=j;
- under:=screen[cury,curx];
- rectangle(298,4+paly,317,19+paly);
- for i:=6 to 17 do
-  fillchar(screen[i+paly,300],16,last);
- screen[paly+tick2,change+2]:=0;
- screen[paly+tick2,last+2]:=255;
- screen[paly+tick1,change+2]:=0;
- screen[paly+tick1,last+2]:=255;
- screen[paly+tick2+1,change+2]:=0;
- screen[paly+tick2+1,last+2]:=255;
- screen[paly+tick1+1,change+2]:=0;
- screen[paly+tick1+1,last+2]:=255;
- printxy(-3,paly+maxpaly-8,'VGA='+vgastr);
- printxy(145,paly+maxpaly-8,'PAL='+palstr);
-end;
-
-function checkmousegeneraloption: integer;
-label done;
-begin
- asm
-  mov ax, 5
-  mov bx, 0
-   int 33h
-  test bx, 1
-  jnz done
-  mov ax, 0Bh
-   int 33h
-  mov mdx, cx
-  mov mdy, dx
- end;
- if (mdx=0) and (mdy=0) then
-  begin
-   checkmousegeneraloption:=0;
-   exit;
-  end;
- rx:=rx+mdx;
- if rx>319 then rx:=319
-  else if rx<0 then rx:=0;
- ry:=ry+mdy;
- if ry>199 then ry:=199
-  else if ry<0 then ry:=0;
- checkmousegeneraloption:=1;
- exit;
-done:
- checkmousegeneraloption:=2;
-end;
-
-procedure doacircle;
-var mouse,alt: integer;
-    dx,dy: word;
-    filled: boolean;
-begin
- new(t);
- mymove2(screen,t^,16000);
- setcolor(last);
- setfillstyle(1,last);
- donepal:=false;
- if palmodeon then
-  begin
-   for i:=0 to maxpaly do
-    mymove2(underpal^[i],screen[i+paly],80);
-  end;
- screen[cury,curx]:=under;
- mymove2(screen,t^,16000);
- getaspectratio(dx,dy);
- filled:=false;
- alt:=1;
- rx:=curx;
- ry:=cury;
- circle(rx,ry,r);
- repeat
-  mouse:=0;
-  repeat
-   if mouseinstalled then mouse:=checkmousegeneraloption;
-  until (fastkeypressed) or (mouse>0);
-  if mouse=0 then ans:=readkey
-   else if mouse=2 then ans:=#13
-   else ans:=' ';
-  mymove2(t^,screen,16000);
-  case upcase(ans) of
-    #0: begin
-         ans:=readkey;
-         case ans of
-          #80: if dy>1 then dec(dy,50);
-          #72: inc(dy,50);
-          #75: if dx>1 then dec(dx,50);
-          #77: inc(dx,50);
-         end;
-         setaspectratio(dx,dy);
-        end;
-   #13: begin
-         if not filled then circle(rx,ry,r)
-          else pieslice(rx,ry,0,360,r);
-         dispose(t);
-         if palmodeon then
-          begin
-           for i:=0 to maxpaly do
-            mymove2(screen[i+paly],underpal^[i],80);
-           redrawpalmode;
-          end;
-         exit;
-        end;
-   #27: begin
-         dispose(t);
-         if palmodeon then
-          begin
-           for i:=0 to maxpaly do
-            mymove2(screen[i+paly],underpal^[i],80);
-           redrawpalmode;
-          end;
-         exit;
-        end;
-   'F': if not filled then filled:=true else filled:=false;
-   'Z': begin
-         if alt<11 then inc(alt) else alt:=0;
-         setfillstyle(alt,last);
-        end;
-   '.': inc(r);
-   ',': dec(r);
-   '+': begin
-         dec(last);
-         setcolor(last);
-         setfillstyle(alt,last);
-        end;
-   '-': begin
-         inc(last);
-         setcolor(last);
-         setfillstyle(alt,last);
-        end;
-  end;
-  if not filled then circle(rx,ry,r)
-   else pieslice(rx,ry,0,360,r);
- until donepal;
- dispose(t);
-end;
-
-procedure gettarget(x1,y1,x2,y2: integer);
-var quit,masking: boolean;
-    mouse,a1,b1,a2,b2,alt: integer;
-    a: byte;
-begin
- quit:=false;
- rx:=x1;
- ry:=y1;
- if x1>x2 then begin a1:=x2; a2:=x1; end
-  else begin a1:=x1; a2:=x2; end;
- if y1>y2 then begin b1:=y2; b2:=y1; end
-  else begin b1:=y1; b2:=y2; end;
- for i:=b1 to b2 do
-  move(t^[i,a1],screen[ry+i-b1,rx],a2-a1+1);
- alt:=0;
- masking:=false;
- repeat
-  mouse:=0;
-  repeat
-   if mouseinstalled then mouse:=checkmousegeneraloption;
-  until (fastkeypressed) or (mouse>0);
-  if mouse=0 then ans:=upcase(readkey)
-   else if mouse=2 then ans:=#13
-   else ans:=' ';
-  mymove2(t^,screen,16000);
-  case ans of
-   #0: begin
-        ans:=upcase(readkey);
-        case ans of
-         #72: if ry<1 then ry:=199 else dec(ry);
-         #80: if ry>198 then ry:=0 else inc(ry);
-         #75: if rx<1 then rx:=319 else dec(rx);
-         #77: if rx>318 then rx:=0 else inc(rx);
-         #71: begin
-               if rx<0 then rx:=0;
-               rx:=(rx div 10) - 1;
-               if rx<0 then rx:=31;
-               rx:=(rx*10) mod 320;
-              end;
-         #79: begin
-               if rx>319 then rx:=319;
-               rx:=(rx div 10) + 1;
-               rx:=(rx*10) mod 320;
-              end;
-         #73: begin
-               if ry<0 then ry:=0;
-               ry:=(ry div 10) - 1;
-               if ry<0 then ry:=19;
-               ry:=(ry*10) mod 200;
-              end;
-         #81: begin
-               if ry>199 then ry:=199;
-               ry:=(ry div 10) + 1;
-               ry:=(ry*10) mod 200;
-              end;
-        end;
-       end;
-   ',','-': dec(alt);
-   '.','+': inc(alt);
-   'M': if masking then masking:=false else masking:=true;
-   #13: begin
-         if masking then
-          begin
-           for i:=0 to b2-b1 do
-            for j:=0 to a2-a1 do
-             begin
-              a:=alt+t^[i+b1,j+a1];
-             if a<>255 then screen[ry+i,rx+j]:=a;
-             end;
-          end
-         else
-          for i:=0 to b2-b1 do
-           for j:=0 to a2-a1 do
-            screen[ry+i,rx+j]:=t^[i+b1,j+a1]+alt;
-         exit;
-        end;
-   #27: quit:=true;
-  end;
-  if masking then
-   begin
-    for i:=0 to b2-b1 do
-     for j:=0 to a2-a1 do
-      begin
-       a:=alt+t^[i+b1,j+a1];
-      if a<>255 then screen[ry+i,rx+j]:=a;
-      end;
-   end
-  else
-   for i:=0 to b2-b1 do
-    for j:=0 to a2-a1 do
-     screen[ry+i,rx+j]:=t^[i+b1,j+a1]+alt;
- until quit;
- mymove2(t^,screen,16000);
-end;
-
-procedure scale(startx,starty,sizex,sizey,newx,newy: integer; var s,t);
-var sety, py, pdy, px, pdx, dcx, dcy: integer;
-begin
- asm
-  push ds
-  push es
-  les si, [s]         { es: si is our source location }
-  lds di, [t]         { ds: di is our destination }
-  imul di, [starty], 320
-  mov [sety], di
-  add di, [startx]
-
-  mov ax, [sizex]
-  xor dx, dx
-  mov cx, [newx]
-  div cx
-  mov [px], ax
-  mov [pdx], dx       { set up py and pdy }
-
-  mov ax, [sizey]
-  xor dx, dx
-  mov cx, [newy]
-  div cx
-  mov [py], ax
-  mov [pdy], dx       { set up py and pdy }
-
-  xor cx, cx
-  mov [dcx], cx
-  mov [dcy], cx
-  mov dx, [newy]
-
- @@iloop:
-  add cx, [py]
-
-  mov ax, [pdy]
-  add [dcy], ax
-  mov ax, [dcy]
-
-  cmp ax, [newy]
-  jl @@nodcychange
-  inc cx
-  sub ax, [newy]
-  mov [dcy], ax
-
- @@nodcychange:
-
-  imul si, cx, 320
-
-  mov bx, [newx]
-
- @@jloop:
-  add si, [px]
-
-  mov ax, [pdx]
-  add [dcx], ax
-  mov ax, [dcx]
-  cmp ax, [newx]
-  jl @@nodcxchange
-
-  inc si
-  sub ax, [newx]
-  mov [dcx], ax
-
- @@nodcxchange:
-
-  mov al, [es: si]
-  mov [ds: di], al     { finally draw it! }
-
-  inc di
-  dec bx
-  jnz @@jloop
-
-  add [sety], 320
-  mov di, [sety]
-  add di, [startx]
-
-  dec dx
-  jnz @@iloop
-
-  pop es
-  pop ds
- end;
-end;
-
-procedure gettarget2(x1,y1,x2,y2: integer);
-var quit: boolean;
-    curx,cury,a1,b1,a2,b2,mouse: integer;
-begin
- quit:=false;
- curx:=160;
- cury:=100;
- if x1>x2 then begin a1:=x2; a2:=x1; end
-  else begin a1:=x1; a2:=x2; end;
- if y1>y2 then begin b1:=y2; b2:=y1; end
-  else begin b1:=y1; b2:=y2; end;
- rx:=a1;
- ry:=b1;
- for i:=b1 to b2 do
-  move(t^[i,a1],clipboard^[i-b1],a2-a1+1);
- clipy:=b2-b1;
- clipx:=a2-a1;
- repeat
-  mouse:=0;
-  repeat
-   if mouseinstalled then mouse:=checkmousegeneraloption;
-  until (fastkeypressed) or (mouse>0);
-  if mouse=0 then ans:=readkey
-   else if mouse=2 then ans:=#13
-   else
-    begin
-      mymove2(t^,screen,16000);
-      scale(rx,ry,clipx,clipy,a2-a1+1,b2-b1,clipboard^,screen);
-      ans:=' ';
-    end;
-  case ans of
-    #0: begin
-         mymove2(t^,screen,16000);
-         ans:=readkey;
-         case ans of
-          #72: if b2>b1+1 then dec(b2);
-          #80: inc(b2);
-          #75: if a2>a1+1 then dec(a2);
-          #77: inc(a2);
-          #71: if a2-a1>10 then dec(a2,10);
-          #79: inc(a2,10);
-          #73: if b2-b1>10 then dec(b2,10);
-          #81: inc(b2,10);
-         end;
-         scale(rx,ry,clipx,clipy,a2-a1+1,b2-b1,clipboard^,screen);
-        end;
-   #13: begin
-         scale(rx,ry,clipx,clipy,a2-a1+1,b2-b1,clipboard^,screen);
-         quit:=true;
-        end;
-   #27: begin
-         mymove2(t^,screen,16000);
-         quit:=true;
-        end;
-  end;
- until quit;
-end;
-
-procedure generaloption(opt: integer);
-var mouse,x1,x2,y1,y2,alt: integer;
-    masking: boolean;
-    a: byte;
-begin
- if (opt=10) and (clipx=0) and (clipy=0) then exit;
- new(t);
- rx:=curx;
- ry:=cury;
- masking:=false;
- if opt<3 then
-  begin
-   setcolor(last);
-   setfillstyle(1,last);
-  end
- else
-  begin
-   setrgb256(255,48,0,0);
-   setwritemode(xorput);
-   setcolor(255);
-  end;
- donepal:=false;
- if palmodeon then
-  begin
-   for i:=0 to maxpaly do
-    mymove2(underpal^[i],screen[i+paly],80);
-  end;
- screen[cury,curx]:=under;
- mymove2(screen,t^,16000);
- case opt of
-  1: alt:=1;
-  6..8: alt:=3;
-  else alt:=0;
- end;
- if opt=10 then
-  for i:=0 to clipy do
-   move(clipboard^[i],screen[ry+i,rx],clipx);
- repeat
-  mouse:=0;
-  repeat
-   if mouseinstalled then mouse:=checkmousegeneraloption;
-  until (fastkeypressed) or (mouse>0);
-  if mouse=0 then ans:=upcase(readkey)
-   else if mouse=2 then ans:=#13
-   else ans:=' ';
-  mymove2(t^,screen,16000);
-  case ans of
-    #0: begin
-         ans:=readkey;
-         case ans of
-          #72: if ry>0 then dec(ry) else ry:=199;
-          #80: if ry<199 then inc(ry) else ry:=0;
-          #75: if rx>0 then dec(rx) else rx:=319;
-          #77: if rx<319 then inc(rx) else rx:=0;
-          #71: begin
-                if rx<0 then rx:=0;
-                rx:=(rx div 10) - 1;
-                if rx<0 then rx:=31;
-                rx:=(rx*10) mod 320;
-               end;
-          #79: begin
-                if rx>319 then rx:=319;
-                rx:=(rx div 10) + 1;
-                rx:=(rx*10) mod 320;
-               end;
-          #73: begin
-                if ry<0 then ry:=0;
-                ry:=(ry div 10) - 1;
-                if ry<0 then ry:=19;
-                ry:=(ry*10) mod 200;
-               end;
-          #81: begin
-                if ry>199 then ry:=199;
-                ry:=(ry div 10) + 1;
-                ry:=(ry*10) mod 200;
-               end;
-         end;
-        end;
-   #13: begin
-         setwritemode(copyput);
-         setrgb256(255,graycolor,graycolor,graycolor);
-         if cury>ry then begin y1:=ry; y2:=cury; end
-          else begin y1:=cury; y2:=ry; end;
-         if curx>rx then begin x1:=rx; x2:=curx; end
-          else begin x1:=curx; x2:=rx; end;
-         case opt of
-          0: line(curx,cury,rx,ry);
-          1: bar(curx,cury,rx,ry);
-          2: rectangle(curx,cury,rx,ry);
-          3: for i:=y1 to y2 do
-              move(t^[i,x1],screen[y2-i+y1,x1],x2-x1+1);
-          4: for i:=y1 to y2 do
-              for j:=x1 to x2 do
-               screen[i,x2-j+x1]:=t^[i,j];
-          5: gettarget(curx,cury,rx,ry);
-          6: for i:=y1 to y2 do
-              for j:=x1 to x2 do
-               screen[i,j]:=screen[i,j]+alt;
-          7: for i:=0 to alt do
-              for j:=0 to alt do
-               screen[cury+i,curx+j]:=t^[alt-j+cury,curx+i];
-          8: gettarget2(curx,cury,rx,ry);
-          9: begin
-              for i:=y1 to y2 do
-               move(screen[i,x1],clipboard^[i-y1],x2-x1+1);
-              clipx:=x2-x1;
-              clipy:=y2-y1;
-              clipboardchange:=true;
-             end;
-         10: if masking then
-              begin
-               for i:=0 to clipy do
-                for j:=0 to clipx do
-                 begin
-                  a:=alt+clipboard^[i,j];
-                 if a<>255 then screen[ry+i,rx+j]:=a;
-                 end;
-              end
-             else
-              for i:=0 to clipy do
-               for j:=0 to clipx do
-                screen[ry+i,rx+j]:=clipboard^[i,j]+alt;
-         end;
-         dispose(t);
-         if palmodeon then
-          begin
-           for i:=0 to maxpaly do
-            mymove2(screen[i+paly],underpal^[i],80);
-           redrawpalmode;
-          end;
-         setlinestyle(0,0,0);
-         exit;
-        end;
-   #27: begin
-         setlinestyle(0,0,0);
-         setrgb256(255,graycolor,graycolor,graycolor);
-         dispose(t);
-         if palmodeon then
-          begin
-           for i:=0 to maxpaly do
-            mymove2(screen[i+paly],underpal^[i],80);
-           redrawpalmode;
-          end;
-         exit;
-        end;
-   ',': case opt of
-         0,2: begin
-             if alt>0 then dec(alt) else alt:=7;
-             if alt div 4=0 then setlinestyle(alt,0,1)
-              else setlinestyle(alt mod 4,0,3);
-            end;
-         1: begin
-             if alt>0 then dec(alt) else alt:=11;
-             setfillstyle(alt,last);
-            end;
-        end;
-   '.': case opt of
-         0,2: begin
-             if alt<7 then inc(alt) else alt:=0;
-             if alt div 4=0 then setlinestyle(alt,0,1)
-              else setlinestyle(alt mod 4,0,3);
-            end;
-         1: begin
-             if alt<11 then inc(alt) else alt:=0;
-             setfillstyle(alt,last);
-            end;
-        end;
-   'M': if opt=10 then
-         begin
-          if masking then masking:=false else masking:=true;
-         end;
-   'F': if opt=1 then opt:=2
-         else if opt=2 then opt:=1;
-   '+': case opt of
-         0..2: begin
-                inc(last);
-                setcolor(last);
-                setfillstyle(alt,last);
-               end;
-         6,7,8,10: inc(alt);
-        end;
-   '-': case opt of
-         0..2: begin
-                dec(last);
-                setcolor(last);
-                setfillstyle(alt,last);
-               end;
-         6,7,8,10: dec(alt);
-        end;
-  end;
-  case opt of
-    0: line(curx,cury,rx,ry);
-    1: bar(curx,cury,rx,ry);
-    6: begin
-        if cury>ry then begin y1:=ry; y2:=cury; end
-         else begin y1:=cury; y2:=ry; end;
-        if curx>rx then begin x1:=rx; x2:=curx; end
-         else begin x1:=curx; x2:=rx; end;
-        for i:=y1 to y2 do
-         for j:=x1 to x2 do
-          screen[i,j]:=screen[i,j]+alt;
-       end;
-    7: rectangle(rx,ry,rx+alt,ry+alt);
-   10: if masking then
-        begin
-         for i:=0 to clipy do
-          for j:=0 to clipx do
-           begin
-            a:=alt+clipboard^[i,j];
-           if a<>255 then screen[ry+i,rx+j]:=a;
-           end;
-        end
-       else
-        for i:=0 to clipy do
-         for j:=0 to clipx do
-          screen[ry+i,rx+j]:=clipboard^[i,j]+alt;
-   else rectangle(curx,cury,rx,ry);
-  end;
- until donepal;
- setlinestyle(0,0,0);
- setrgb256(255,graycolor,graycolor,graycolor);
-end;
-
-procedure saveclipboard;
-var vgafile: file of screentype;
-begin
- if (clipboardchange) and (clipx>0) and (clipy>0) then
-  begin
-   if clipy<199 then
-    for i:=clipy+1 to 199 do
-     fillchar(clipboard^[i],320,0);
-   if clipx<319 then
-    for i:=0 to clipy do
-     fillchar(clipboard^[i,clipx+1],319-clipx,0);
-   assign(vgafile,pathstr+'clip.vga');
-   rewrite(vgafile);
-   if ioresult<>0 then errorhandler('Saving Clipboard failure.',1);
-   write(vgafile,clipboard^);
-   if ioresult<>0 then errorhandler('Saving Clipboard failure.',5);
-   close(vgafile);
-  end;
- clipboardchange:=false;
-end;
-
-procedure savepalette;
-var palfile: file of paltype;
-begin
- palstr:=vgastr;
- assign(palfile,vgastr+'.pal');
- reset(palfile);
- if ioresult<>0 then
-  begin
-   rewrite(palfile);
-   if ioresult<>0 then errorhandler(vgastr+'.PAL, creating',5);
-  end;
- write(palfile,colors);
- if ioresult<>0 then errorhandler(vgastr+'.PAL, writing',5);
- close(palfile);
- set256colors(colors);
- palchange:=false;
-end;
-
-procedure save;
-var vgadata: file of portraittype;
-    p: ^portraittype;
-begin
- saveclipboard;
- if palchange then savepalette;
- if palmodeon then
-  begin
-   for i:=0 to maxpaly do
-    mymove2(underpal^[i],screen[i+paly],80);
-  end;
- screen[cury,curx]:=under;
- new(p);
- for i:=0 to 69 do
-  move(screen[i],p^[i],70);
- assign(vgadata,vgastr+'.vga');
- reset(vgadata);
- if ioresult<>0 then
-  begin
-   rewrite(vgadata);
-   if ioresult<>0 then errorhandler(vgastr+'.VGA, creating',1);
-  end;
- write(vgadata,p^);
- dispose(p);
- if ioresult<>0 then errorhandler(vgastr+'.VGA, writing',5);
- close(vgadata);
- if palmodeon then redrawpalmode;
-end;
-
-function getnewfilename: boolean;
-var tempstr: string[40];
-begin
- new(t);
- if palmodeon then
-  begin
-   for i:=0 to maxpaly do
-    mymove2(underpal^[i],screen[i+paly],80);
-  end;
- mymove2(screen,t^,16000);
- for i:=90 to 109 do
-  fillchar(screen[i,45],220,0);
- setcolor(255);
- rectangle(45,90,264,109);
- rectangle(47,92,262,107);
- tempstr:=vgastr;
- rx:=length(tempstr)+1;
- if rx>40 then rx:=40;
- if length(tempstr)<30 then
-  for j:=length(tempstr)+1 to 40 do tempstr[j]:=' ';
- tempstr[0]:=#40;
- setrgb256(254,63,0,0);
- tcolor:=255;
- bkcolor:=0;
- printxy(51,96,tempstr);
- tcolor:=255;
- repeat
-  repeat
-   bkcolor:=254;
-   printxy(46+rx*5,96,tempstr[rx]);
-   delay(50);
-   bkcolor:=0;
-   printxy(46+rx*5,96,tempstr[rx]);
-   delay(50);
-  until fastkeypressed;
-  ans:=upcase(readkey);
-  case ans of
-   'A'..'Z',' ','0'..'9','''','\':
-       begin
-        if rx<40 then
-         begin
-          for j:=40 downto rx do tempstr[j]:=tempstr[j-1];
-          tempstr[rx]:=ans;
-          inc(rx);
-         end else tempstr[rx]:=ans;
-       end;
-   #8: begin
-        if rx>1 then dec(rx);
-        for j:=rx to 39 do tempstr[j]:=tempstr[j+1];
-        tempstr[40]:=' ';
-       end;
-   #0: begin
-         ans:=readkey;
-         case ans of
-          #77: if rx<40 then inc(rx);
-          #75: if rx>1 then dec(rx);
-          #83: for j:=rx to 39 do tempstr[j]:=tempstr[j+1];
-         end;
-       end;
-  end;
-  printxy(51,96,tempstr);
- until (ans=#27) or (ans=#13);
- if ans=#13 then
-  begin
-   i:=40;
-   while tempstr[i]=' ' do dec(i);
-   tempstr[0]:=chr(i);
-   vgastr:=tempstr;
-   palstr:=tempstr;
-   getnewfilename:=true;
-  end
- else
-  begin
-   getnewfilename:=false;
-   mymove2(t^,screen,16000);
-   if palmodeon then redrawpalmode;
-  end;
- dispose(t);
- set256colors(colors);
-end;
-
-procedure readpalette;
-var palfile: file of paltype;
-begin
- assign(palfile,palstr+'.PAL');
- reset(palfile);
- if ioresult<>0 then
-  begin
-   palstr:='DATA\CHAR';
-   assign(palfile,palstr+'.PAL');
-   reset(palfile);
-   if ioresult<>0 then errorhandler(palstr+'.PAL',1);
-  end;
- read(palfile,colors);
- if ioresult<>0 then errorhandler(palstr+'.PAL, reading',5);
- close(palfile);
- colors[255,1]:=24;
- colors[255,2]:=24;
- colors[255,3]:=24;
- set256colors(colors);
-end;
-
-procedure load(ask: boolean);
-var vgafile: file of portraittype;
-    p: ^portraittype;
-begin
- if (ask) and (not getnewfilename) then exit;
- readpalette;
- assign(vgafile,vgastr+'.vga');
- reset(vgafile);
- if ioresult<>0 then
-  begin
-   fillchar(screen,64000,0);
-   if palmodeon then
-    begin
-     for i:=0 to maxpaly do
-      mymove2(screen[i+paly],underpal^[i],80);
-     redrawpalmode;
-    end;
-   exit;
-  end;
- new(p);
- read(vgafile,p^);
- if ioresult<>0 then errorhandler(vgastr+'.VGA reading',5);
- close(vgafile);
- fillchar(screen,64000,0);
- for i:=0 to 69 do
-  move(p^[i],screen[i],70);
- dispose(p);
- last:=screen[cury,curx];
- under:=screen[cury,curx];
- if palmodeon then
-  begin
-   for i:=0 to maxpaly do
-    mymove2(screen[i+paly],underpal^[i],80);
-   redrawpalmode;
-  end;
-end;
-
-procedure loadclipboard;
-var vgafile: file of screentype;
-begin
- new(clipboard);
- assign(vgafile,pathstr+'clip.vga');
- reset(vgafile);
- if ioresult<>0 then
-  begin
-   fillchar(clipboard^,64000,0);
-   clipx:=0;
-   clipy:=0;
-   exit;
-  end;
- read(vgafile,clipboard^);
- if ioresult<>0 then errorhandler('Loading ClipBoard failure.',5);
- close(vgafile);
- rx:=0;
- i:=199;
- while (rx=0) and (i>0) do
-  begin
-   for j:=0 to 319 do
-    if clipboard^[i,j]>0 then rx:=1;
-   if rx=0 then dec(i);
-  end;
- clipy:=i;
- rx:=0;
- j:=319;
- while (rx=0) and (i>0) do
-  begin
-   for i:=0 to clipy do
-    if clipboard^[i,j]>0 then rx:=1;
-   if rx=0 then dec(j);
-  end;
- clipx:=j;
-end;
-
-procedure getpath;
-var t1,t2,s: string[79];
-begin
- s:=fexpand(paramstr(0));
- fsplit(s,pathstr,t1,t2);
- getdir(0,curpath);
- if ioresult<>0 then errorhandler('Cannot get current directory.',1);
-end;
-
-procedure savetemp;
-var vgafile: file of screentype;
-    palfile: file of paltype;
-begin
- assign(vgafile,pathstr+'tmp.vga');
- rewrite(vgafile);
- if ioresult<>0 then errorhandler('tmp.vga',1);
- write(vgafile,screen);
- if ioresult<>0 then errorhandler('tmp.vga',5);
- close(vgafile);
- assign(palfile,pathstr+'tmp.pal');
- rewrite(palfile);
- if ioresult<>0 then errorhandler('tmp.pal',1);
- write(palfile,colors);
- if ioresult<>0 then errorhandler('tmp.pal',5);
- close(palfile);
- if ioresult<>0 then errorhandler('tmp.pal',5);
-end;
-
-procedure loadtemp;
-var vgafile: file of screentype;
-    palfile: file of paltype;
-begin
- assign(palfile,pathstr+'tmp.pal');
- reset(palfile);
- if ioresult<>0 then errorhandler('tmp.pal',1);
- read(palfile,colors);
- if ioresult<>0 then errorhandler('tmp.pal',5);
- close(palfile);
- erase(palfile);
- if ioresult<>0 then errorhandler('tmp.pal',5);
- set256colors(colors);
- assign(vgafile,pathstr+'tmp.vga');
- reset(vgafile);
- if ioresult<>0 then errorhandler('tmp.vga',1);
- read(vgafile,screen);
- if ioresult<>0 then errorhandler('tmp.vga',5);
- close(vgafile);
- erase(vgafile);
- if ioresult<>0 then errorhandler('tmp.vga',5);
-end;
-
-procedure dosshell;
-var s: string[79];
-begin
- savetemp;
- textmode(co80);
- clrscr;
- writeln(cr,cr);
- drawtitlemessage;
- textcolor(8);
- writeln(cr,'To return to SE type "EXIT".');
- textcolor(15);
- swapvectors;
- s:=getenv('COMSPEC');
- if s='' then s:='c:\command.com';
- exec(s,'/K'+pathstr+'PROMPT.BAT');
- if doserror<>0 then errorhandler('Cannot run dosshell.',7);
- swapvectors;
- chdir(curpath);
- if ioresult<>0 then errorhandler('Cannot change directory.',7);
- setgraphmode(0);
- loadtemp;
-end;
-
-procedure helpscreen;
-var str1: string[5];
-begin
- tcolor:=255;
- new(t);
- mymove2(screen,t^,16000);
- for i:=14 to 186 do fillchar(screen[i,7],307,0);
- setcolor(255);
- rectangle(8,15,312,185);
- rectangle(10,17,310,183);
- str(version:0:3,str1);
- printxy(11,19,'SCREEN EDIT (V'+str1+') COMMANDS:');
- printxy(18,30,  'ALT-A  FADE\BRIGHTEN AREA');
- printxy(18,40,  'ALT-B  BAR/PATTERN FILL');
- printxy(18,50,  'ALT-C  CIRCLE/ELLIPSE');
- printxy(18,60,  'ALT-D  DOS SHELL');
- printxy(18,70,  'ALT-F  90'' ROTATE');
- printxy(18,80,  'ALT-G  GRAB FROM CLIPBOARD');
- printxy(18,90,  'ALT-H  HORIZONTAL FLIP');
- printxy(18,100, 'ALT-I  INSERT TO CLIPBOARD');
- printxy(18,110, 'ALT-L  LOAD SCREEN AND PALETTE');
- printxy(18,120, 'ALT-M  MOVE/COPY BLOCK');
- printxy(18,130, 'ALT-N  SHRINK/GROW BLOCK');
- printxy(18,140, 'ALT-O  OPEN CLIPBOARD');
- printxy(18,150, 'ALT-P  EDIT PALETTE');
- printxy(18,160, 'ALT-R  RECTANGLE');
- printxy(18,170, 'ALT-S  SAVE SCREEN AND PALETTE');
- printxy(183,30, 'ALT-T  LINE');
- printxy(183,40, 'ALT-V  VERTICAL FLIP');
- printxy(183,50, 'ALT-W  WRITE TEXT LINE');
- printxy(183,60, 'ALT-X  QUIT');
- printxy(183,75, 'F1  COORDINATE TOGGLE');
- printxy(183,85, 'F2  PALETTE TOGGLE');
- printxy(183,95, 'F7  FILL SCREEN');
- printxy(183,105,'F8  HORIZONTAL LINE');
- printxy(183,115,'F9  VERTICAL LINE');
- printxy(183,130,'+;  ADD 1 COLOR VALUE');
- printxy(183,140,'-.  SUB 1 COLOR VALUE');
- printxy(183,150,'Z   GET UNDER COLOR');
- printxy(183,160,'SP  USE LAST COLOR');
- printxy(183,170,'ESC HELP SCREEN');
- readkey;
- while fastkeypressed do readkey;
- mymove2(t^,screen,16000);
- dispose(t);
-end;
-
-procedure entertext;
-var s: string[30];
-begin
- new(t);
- mymove2(screen,t^,16000);
- fillchar(s[1],30,' ');
- s[0]:=chr(30);
- bkcolor:=255;
- tcolor:=last;
- rx:=1;
- repeat
-  printxy(curx-5,cury-1,s);
-  ans:=upcase(readkey);
-  mymove2(t^,screen,16000);
-  case ans of
-   #8: if rx>1 then
-        begin
-         s[rx]:=' ';
-         dec(rx);
-         s[rx]:=' ';
-        end
-       else s[rx]:=' ';
-   #27: begin
-         dispose(t);
-         bkcolor:=0;
-         tcolor:=255;
-         exit;
-        end;
-   else
-    begin
-     s[rx]:=ans;
-     inc(rx);
-     if rx=31 then rx:=30;
-    end;
-  end;
- until ans=#13;
- dispose(t);
- printxy(curx-5,cury-1,s);
- bkcolor:=0;
- tcolor:=255;
-end;
-
-procedure viewclipboard;
-begin
- if (clipx=0) and (clipy=0) then exit;
- new(t);
- mymove2(screen,t^,16000);
- for i:=0 to clipy do
-  move(clipboard^[i],screen[i],clipx+1);
- readkey;
- while fastkeypressed do readkey;
- mymove2(t^,screen,16000);
- dispose(t);
-end;
-
-procedure checkexit;
-var vgafile: file of screentype;
-    palfile: file of paltype;
-    srcpal,tarpal: ^paltype;
-begin
- assign(vgafile,vgastr+'.vga');
- reset(vgafile);
- if ioresult<>0 then
-  begin
-   done:=true;
-   exit;
-  end;
- new(t);
- read(vgafile,t^);
- if ioresult<>0 then errorhandler(vgastr+'.vga reading.',5);
- close(vgafile);
- if palmodeon then
-  for i:=0 to maxpaly do
-   mymove2(underpal^[i],screen[i+paly],80);
- j:=0;
- asm
-  push ds
-  push es
-  les di, [t]
-  mov ax, $A000
-  mov ds, ax
-  xor si, si
-  mov cx, 32000
-  cld
-  repe cmpsw
-  pop es
-  pop ds
-  je @@done
-  mov [j], 1
- @@done:
- end;
- if j=0 then
-  begin
-   new(srcpal);
-   new(tarpal);
-   mymove2(colors,srcpal^,192);
-   assign(palfile,palstr+'.pal');
-   reset(palfile);
-   if ioresult<>0 then
-    begin
-     done:=true;
-     dispose(t);
-     exit;
-    end;
-   read(palfile,tarpal^);
-   if ioresult<>0 then errorhandler(palstr+'.pal reading.',5);
-   close(palfile);
-   j:=0;
-   asm
-    push ds
-    push es
-    les di, [srcpal]
-    lds si, [tarpal]
-    mov cx, 765
-    cld
-    repe cmpsb
-    pop es
-    pop ds
-    je @@done
-    mov [j], 1
-   @@done:
-   end;
-   dispose(srcpal);
-   dispose(tarpal);
-   if j=0 then
-    begin
-     done:=true;
-     dispose(t);
-     exit;
-    end;
-  end;
- mymove2(screen,t^,16000);
- for i:=90 to 109 do
-  fillchar(screen[i,65],180,0);
- rectangle(66,91,243,108);
- rectangle(68,93,241,106);
- printxy(66,96,'FILE NOT SAVED. EXIT ANYWAY? (Y/N)');
- ans:=readkey;
- if upcase(ans)='Y' then done:=true
-  else
-   begin
-    while fastkeypressed do readkey;
-    mymove2(t^,screen,16000);
-    if palmodeon then redrawpalmode;
-   end;
- dispose(t);
-end;
-
-procedure processkey;
-begin
- ans:=readkey;
- change:=last;
- case upcase(ans) of
-  ' ': under:=last;
-  #0: begin
-       ans:=readkey;
-       screen[cury,curx]:=under;
-       case ans of
-        #72: if cury<1 then cury:=199 else dec(cury);
-        #80: if cury>198 then cury:=0 else inc(cury);
-        #75: if curx<1 then curx:=319 else dec(curx);
-        #77: if curx>318 then curx:=0 else inc(curx);
-        #71: begin
-              if curx<0 then curx:=0;
-              curx:=(curx div 10) - 1;
-              if curx<0 then curx:=31;
-              curx:=(curx*10) mod 320;
-             end;
-        #79: begin
-              if curx>319 then curx:=319;
-              curx:=(curx div 10) + 1;
-              curx:=(curx*10) mod 320;
-             end;
-        #73: begin
-              if cury<0 then cury:=0;
-              cury:=(cury div 10) - 1;
-              if cury<0 then cury:=19;
-              cury:=(cury*10) mod 200;
-             end;
-        #81: begin
-              if cury>199 then cury:=199;
-              cury:=(cury div 10) + 1;
-              cury:=(cury*10) mod 200;
-             end;
-        #59: if coordon then
-              begin
-               coordon:=false;
-               if palmodeon then printxy(257,paly+cordofs,'       ');
-              end
-              else coordon:=true;
-        #60: if palmodeon then
-              begin
-               palmodeon:=false;
-               for i:=0 to maxpaly do
-                mymove2(underpal^[i],screen[i+paly],80);
-               end
-              else
-               begin
-                palmodeon:=true;
-                if cury>140 then paly:=0 else paly:=maxyonpal;
-                for i:=0 to maxpaly do
-                 mymove2(screen[i+paly],underpal^[i],80);
-                redrawpalmode;
-               end;
-        #65: fillchar(screen,64000,last);
-        #67: fillchar(screen[cury,curx],320-curx,last);
-        #68: for j:=cury to 199 do screen[j,curx]:=last;
-        #31: save;
-        #38: load(true);
-        #25: paledit;
-        #46: doacircle;
-        #20: generaloption(0);   { draw line           }
-        #48: generaloption(1);   { fill bar            }
-        #19: generaloption(2);   { rectangle           }
-        #47: generaloption(3);   { verticle flip       }
-        #35: generaloption(4);   { horizontal flip     }
-        #50: generaloption(5);   { move                }
-        #30: generaloption(6);   { brighten/fade area  }
-        #33: generaloption(7);   { rotate block        }
-        #49: generaloption(8);   { partition block     }
-        #23: generaloption(9);   { insert to clipboard }
-        #34: generaloption(10);  { grab from clipboard }
-        #32: dosshell;
-        #17: entertext;
-        #24: viewclipboard;
-        #16,#45: checkexit;
-       end;
-       under:=screen[cury,curx];
-      end;
-  '+',',': begin inc(under); last:=under; end;
-  '-','.': begin dec(under); last:=under; end;
-  '1': last:=0;
-  '2': last:=15;
-  '3': last:=31;
-  '4': last:=47;
-  '5': last:=63;
-  '6': last:=79;
-  '7': last:=95;
-  '8': last:=111;
-  '9': last:=127;
-  'Q': last:=143;
-  'W': last:=159;
-  'E': last:=175;
-  'R': last:=191;
-  'T': last:=207;
-  'Y': last:=223;
-  'U': last:=239;
-  'I': last:=255;
-  'Z': last:=under;
-  #27: helpscreen;
- end;
- if palmodeon then
-  begin
-   if change<>last then
-    begin
-     for i:=6 to 17 do
-      fillchar(screen[i+paly,300],16,last);
-     screen[paly+tick2,change+2]:=0;
-     screen[paly+tick2,last+2]:=255;
-     screen[paly+tick1,change+2]:=0;
-     screen[paly+tick1,last+2]:=255;
-     screen[paly+tick2+1,change+2]:=0;
-     screen[paly+tick2+1,last+2]:=255;
-     screen[paly+tick1+1,change+2]:=0;
-     screen[paly+tick1+1,last+2]:=255;
-    end;
-   if (cury<60) and (paly=0) then
-    begin
-     for i:=0 to maxpaly do
-      mymove2(underpal^[i],screen[i+paly],80);
-     paly:=maxyonpal;
-     for i:=0 to maxpaly do
-      mymove2(screen[i+paly],underpal^[i],80);
-     redrawpalmode;
-    end
-   else if (cury>140) and (paly=maxyonpal) then
-    begin
-     for i:=0 to maxpaly do
-      mymove2(underpal^[i],screen[i+paly],80);
-     paly:=0;
-     for i:=0 to maxpaly do
-      mymove2(screen[i+paly],underpal^[i],80);
-     redrawpalmode;
-    end;
-   if coordon then
-    begin
-     str(curx:3,str1);
-     str(cury:3,str2);
-     printxy(257,paly+cordofs,str1+','+str2);
-    end;
-  end;
-end;
-
-procedure checkmouse;
-begin
- change:=last;
- asm
-  mov ax, 5
-  mov bx, 0
-   int 33h
-  test bx, 1
-  jz @@continue
-  mov al, last
-  mov under, al
-@@continue:
-  mov ax, 0Bh
-   int 33h
-  mov mdx, cx
-  mov mdy, dx
- end;
- if (mdx=0) and (mdy=0) then exit;
- mdx:=mdx div 4;
- mdy:=mdy div 4;
- screen[cury,curx]:=under;
- cury:=cury+mdy;
- if cury>199 then cury:=199
-  else if cury<0 then cury:=0;
- curx:=curx+mdx;
- if curx>319 then curx:=319
-  else if curx<0 then curx:=0;
- under:=screen[cury,curx];
- if palmodeon then
-  begin
-   if change<>last then
-    begin
-     for i:=6 to 17 do
-      fillchar(screen[i+paly,300],16,last);
-     screen[paly+tick2,change+2]:=0;
-     screen[paly+tick2,last+2]:=255;
-     screen[paly+tick1,change+2]:=0;
-     screen[paly+tick1,last+2]:=255;
-     screen[paly+tick2+1,change+2]:=0;
-     screen[paly+tick2+1,last+2]:=255;
-     screen[paly+tick1+1,change+2]:=0;
-     screen[paly+tick1+1,last+2]:=255;
-    end;
-   if coordon then
-    begin
-     str(curx:3,str1);
-     str(cury:3,str2);
-     printxy(257,paly+cordofs,str1+','+str2);
-    end;
-   if (cury<60) and (paly=0) then
-    begin
-     for i:=0 to maxpaly do
-      mymove2(underpal^[i],screen[i+paly],80);
-     paly:=maxyonpal;
-     for i:=0 to maxpaly do
-      mymove2(screen[i+paly],underpal^[i],80);
-     redrawpalmode;
-    end
-   else if (cury>140) and (paly=maxyonpal) then
-    begin
-     for i:=0 to maxpaly do
-      mymove2(underpal^[i],screen[i+paly],80);
-     paly:=0;
-     for i:=0 to maxpaly do
-      mymove2(screen[i+paly],underpal^[i],80);
-     redrawpalmode;
-    end;
-  end;
-end;
-
-procedure mainloop;
-begin
- repeat
-  inc(screen[cury,curx],2);
-  if mouseinstalled then checkmouse;
-  if fastkeypressed then processkey;
- until done;
-end;
-
-procedure paramerror;
-begin
- textcolor(12);
- writeln(cr,'Invalid parameter.  You must enter the command line in');
- writeln(' this format: ');
- writeln(cr,'  SE filename [filename]',cr);
- writeln(' Filename must not have a filename extention (*.vga or *.pal).');
- writeln(' The first filename is the screen file, the second, palette.');
- writeln(' Palette file is optional.');
- textcolor(15);
- halt(255);
-end;
-
-procedure checkformouse; assembler;
-asm
- mov ax, 0
-  int 33h
- cmp ax, 0
- je @@error
- mov mouseinstalled, 1
-@@error:
-end;
-
-procedure initialize;
-begin
- tcolor:=255;
- bkcolor:=0;
- done:=false;
- palchange:=false;
- palmodeon:=true;
- coordon:=true;
- clipboardchange:=false;
- r:=10;
- if (paramcount>2) or (paramcount=0) then paramerror;
- vgastr:=paramstr(1);
- for i:=1 to length(vgastr) do vgastr[i]:=upcase(vgastr[i]);
- if (paramcount=2) then
-  begin
-   palstr:=paramstr(2);
-   for i:=1 to length(vgastr) do palstr[i]:=upcase(palstr[i]);
-  end
- else palstr:=vgastr;
- getpath;
- new(underpal);
- loadclipboard;
- curx:=160;
- cury:=100;
- paly:=maxyonpal;
- readygraph;
- load(false);
- printxy(257,paly+cordofs,'160,100');
- mouseinstalled:=false;
- checkformouse;
-end;
-
-begin
- initialize;
- mainloop;
- closegraph;
- dispose(underpal);
- saveclipboard;
- dispose(clipboard);
- drawtitlemessage;
-end.
\ No newline at end of file
diff --git a/makedata/ship1a.dta b/makedata/ship1a.dta
deleted file mode 100644
index 94258af..0000000
Binary files a/makedata/ship1a.dta and /dev/null differ
diff --git a/makedata/ship1b.dta b/makedata/ship1b.dta
deleted file mode 100644
index 21ab151..0000000
Binary files a/makedata/ship1b.dta and /dev/null differ
diff --git a/makedata/ship1c.dta b/makedata/ship1c.dta
deleted file mode 100644
index 122cec4..0000000
Binary files a/makedata/ship1c.dta and /dev/null differ
diff --git a/makedata/ship2a.dta b/makedata/ship2a.dta
deleted file mode 100644
index ccf08a1..0000000
Binary files a/makedata/ship2a.dta and /dev/null differ
diff --git a/makedata/ship2b.dta b/makedata/ship2b.dta
deleted file mode 100644
index 6d5c2dc..0000000
Binary files a/makedata/ship2b.dta and /dev/null differ
diff --git a/makedata/ship2c.dta b/makedata/ship2c.dta
deleted file mode 100644
index 545c5e8..0000000
Binary files a/makedata/ship2c.dta and /dev/null differ
diff --git a/makedata/ship3a.dta b/makedata/ship3a.dta
deleted file mode 100644
index 3d94575..0000000
Binary files a/makedata/ship3a.dta and /dev/null differ
diff --git a/makedata/ship3b.dta b/makedata/ship3b.dta
deleted file mode 100644
index a2664c5..0000000
Binary files a/makedata/ship3b.dta and /dev/null differ
diff --git a/makedata/ship3c.dta b/makedata/ship3c.dta
deleted file mode 100644
index f98fe50..0000000
Binary files a/makedata/ship3c.dta and /dev/null differ
diff --git a/makedata/shipicon.cpr b/makedata/shipicon.cpr
deleted file mode 100644
index c52f08a..0000000
Binary files a/makedata/shipicon.cpr and /dev/null differ
diff --git a/makedata/shipicon.pal b/makedata/shipicon.pal
deleted file mode 100644
index bf26215..0000000
Binary files a/makedata/shipicon.pal and /dev/null differ
diff --git a/makedata/shipmake.pas b/makedata/shipmake.pas
index 13d10ef..b3b48a0 100644
--- a/makedata/shipmake.pas
+++ b/makedata/shipmake.pas
@@ -1,4 +1,20 @@
 program getshipdata;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 type
  alienshiptype=
diff --git a/makedata/shippart.cpr b/makedata/shippart.cpr
deleted file mode 100644
index 58c4be5..0000000
Binary files a/makedata/shippart.cpr and /dev/null differ
diff --git a/makedata/shp2make.pas b/makedata/shp2make.pas
deleted file mode 100644
index 397a9cb..0000000
--- a/makedata/shp2make.pas
+++ /dev/null
@@ -1,32 +0,0 @@
-program huh;
-
-uses data;
-
-var
- i,j: integer;
-
-procedure saveship(index,x1,y1: integer);
-var shipfile: file of shipdistype;
-    temp: ^shipdistype;
-    i,j: integer;
-begin
- new(temp);
- for j:=x1 to x1+57 do
-  for i:=0 to 74 do
-   temp^[j-x1,i]:=screen[y1+i,j];
- assign(shipfile,'data\shippix.dta');
- reset(shipfile);
- if ioresult<>0 then errorhandler('data\shippix.dta',1);
- seek(shipfile,index);
- if ioresult<>0 then errorhandler('data\shippix.dta',5);
- write(shipfile,temp^);
- if ioresult<>0 then errorhandler('data\shippix.dta',5);
- close(shipfile);
- dispose(temp);
-end;
-
-begin
- loadscreen('makedata\shippart.vga');
- for j:=0 to 8 do
-  saveship(j,(j mod 5)*61+3,(j div 5)*77+3);
-end.
\ No newline at end of file
diff --git a/makedata/special.pas b/makedata/special.pas
deleted file mode 100644
index 4c61c1e..0000000
--- a/makedata/special.pas
+++ /dev/null
@@ -1,139 +0,0 @@
-unit special;
-
-{***************************
-   Security Unit for IronSeed
-
-   Channel 7
-   Destiny: Virtual
-
-
-   Copywrite DEC. 31, 1993
-
-***************************}
-
-interface
-
-procedure seccheck2;
-
-implementation
-
-uses crt, dos;
-
-const
- delaytime = 2;
-
-type
- buftype= array[0..2047] of byte;
-
-var
- status: integer;
-
-procedure errorhandler;
-begin
- writeln;
- writeln('Inrevokeable error!');
- halt;
-end;
-
-procedure erase2(s: string);
-var f: file;
-    buffer: ^buftype;
-    s1: string[50];
-    size: integer;
-begin
- s1:=fexpand(s);
- assign(f,s1);
- reset(f,1);
- if ioresult<>0 then errorhandler;
- new(buffer);
- fillchar(buffer^,2048,0);
- size:=(filesize(f) div 2048) + 2;
- repeat
-  blockwrite(f,buffer^,2048);
-  dec(size);
- until (ioresult<>0) or (size=0);
- dispose(buffer);
- close(f);
-end;
-
-procedure killit2;
-begin
- textmode(co80);
- erase2(paramstr(0));
- nosound;
- halt;
-end;
-
-procedure seccheck2;
-var m2,d2,y2,total1,total2: word;
-    f: file;
-    t: longint;
-    dt: datetime;
-    junk: word;
-begin
- if status=0 then killit2;
- getdate(y2,m2,d2,junk);
- if y2<1994 then killit2;
- total2:=(y2-1994)*365 + m2*30 + d2;
- assign(f,paramstr(0));
- getftime(f,t);
- unpacktime(t,dt);
- if dt.year<1994 then killit2;
- total1:=(dt.year-1994)*365 + dt.month*30 + dt.day;
- if total1>total2 then killit2;
- if total2-delaytime>=total1 then killit2;
-end;
-
-procedure erase1(s: string);
-var f: file;
-    buffer: ^buftype;
-    s1: string[50];
-    size: integer;
-begin
- s1:=fexpand(s);
- assign(f,s1);
- reset(f,1);
- if ioresult<>0 then errorhandler;
- new(buffer);
- fillchar(buffer^,2048,0);
- size:=(filesize(f) div 2048) + 2;
- repeat
-  blockwrite(f,buffer^,2048);
-  dec(size);
- until (ioresult<>0) or (size=0);
- dispose(buffer);
- close(f);
-end;
-
-procedure killit1;
-begin
- textmode(co80);
- erase1(paramstr(0));
- nosound;
- halt;
-end;
-
-procedure seccheck1;
-var m2,d2,y2,total1,total2: word;
-    f: file;
-    t: longint;
-    dt: datetime;
-    junk: word;
-begin
- getdate(y2,m2,d2,junk);
- if y2<1994 then killit1;
- total2:=(y2-1994)*365 + m2*30 + d2;
- assign(f,paramstr(0));
- getFtime(f,t);
- unpacktime(t,dt);
- if dt.year<1994 then killit1;
- total1:=(dt.year-1994)*365 + dt.month*30 + dt.day;
- if total1>total2 then killit2;
- if total2-delaytime>=total1 then killit1;
- status:=1;
-end;
-
-begin
- status:=0;
- seccheck1;
-end.
\ No newline at end of file
diff --git a/makedata/sysmake.pas b/makedata/sysmake.pas
index 9cde194..ff7e057 100644
--- a/makedata/sysmake.pas
+++ b/makedata/sysmake.pas
@@ -1,4 +1,20 @@
 program displaysystems;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 
 uses crt;
@@ -21,11 +37,11 @@ var
 
 procedure display;
 begin
- assign(f,'data\sysname.dta');
+ assign(f,'data/sysname.dta');
  reset(f);
- assign(f2,'data\sysset.dta');
+ assign(f2,'data/sysset.dta');
  reset(f2);
- assign(ft,'sysdata.txt');
+ assign(ft,'other/sysdata.txt');
  rewrite(ft);
  for a:=1 to 250 do
   begin
@@ -58,11 +74,9 @@ end;
 
 
 begin
- display;
- exit;
- assign(ft,'makedata\names.txt');
+ assign(ft,'makedata/names.txt');
  reset(ft);
- assign(f,'data\sysname.dta');
+ assign(f,'data/sysname.dta');
  rewrite(f);
  textmode(co80);
  for a:=1 to 250 do
@@ -76,4 +90,7 @@ begin
   end;
  close(ft);
  close(f);
+
+ display;
+ exit;
 end.
\ No newline at end of file
diff --git a/makedata/tech1.cpr b/makedata/tech1.cpr
deleted file mode 100644
index f76647b..0000000
Binary files a/makedata/tech1.cpr and /dev/null differ
diff --git a/makedata/tech2.cpr b/makedata/tech2.cpr
deleted file mode 100644
index f76647b..0000000
Binary files a/makedata/tech2.cpr and /dev/null differ
diff --git a/makedata/temp.txt b/makedata/temp.txt
deleted file mode 100644
index b6f5199..0000000
--- a/makedata/temp.txt
+++ /dev/null
@@ -1,61 +0,0 @@
-CONV BEGIN
-
--1      -1      1       1       HI HELLO GREETINGS HYA HIYA SALUTATIONS WELCOME
--1      20000   1       2       BYE GOOD-BYE GOODBYE OVER OUT 10-4 QUIT
--1      -1      1       3       HELP
--1      -1      1       5       VOID DWELLERS
--1      -1      1       6       D'PAHK WORMS
--1      -1      1       7       SENGZHAC BUGS BUGGERS
-239     -1      1       37      GUILD
-220     -1      1       38      GUILD
--1      -1      1       8       GUILD
--1      -1      1       9       PHAEDOR MOCH PUPPET
-277     -1      1       39      ERMIGEN
--1      -1      1       10      ERMIGEN
-263     -1      1       40      QUAI PA'LOI
-212     -1      1       41      QUAI PA'LOI
--1      -1      1       11      QUAI PA'LOI
-263     -1      1       42      PAI ALOI
-212     -1      1       43      PAI ALOI
--1      -1      1       12      PAI ALOI
-263     -1      1       44      Q'OOUL
-212     -1      1       45      Q'OOUL
--1      -1      1       13      Q'OOUL
--1      -1      1       14      ICON
--1      -1      1       15      TITERIAN
-239     -1      1       46      YLINTHLIXYMN YILLER
-220     -1      1       47      YLINTHLIXYMN YILLER
--1      -1      1       16      YLINTHLIXYMN YILLER
-286     -1      1       48      SCAVENGERS SCAVS
-277     -1      1       49      SCAVENGERS SCAVS
-255     -1      1       50      SCAVENGERS SCAVS
-223     -1      1       51      SCAVENGERS SCAVS
-208     -1      1       52      SCAVENGERS SCAVS
--1      -1      1       17      SCAVENGERS SCAVS
--1      -1      1       18      AARD
-254     -1      1       53      MALZATOIR
--1      -1      1       19      MALZATOIR
--1      -1      1       20      **** NAMELESS
--1      -1      1       21      MURIEL
--1      -1      1       22      DERRAAK
--1      -1      1       23      TROJAN GATE GATES
--1      -1      1       24      MONKS MONK
--1      -1      1       25      HOMEWORLD HOME WORLD
--1      -1      1       26      SELL BUY TRADE TRADERS
--1      -1      1       27      HALLIFAX MANUEVER
--1      -1      1       28      NOVA
--1      -1      1       29      SHUNT
--1      -1      1       30      PHASE
--1      -1      1       31      GOD'S EYE
--1      -1      1       32      IRONSEED
--1      -1      1       33      THERMOPLAST
-277     -1      1       54      CARGAN
--1      -1      1       34      CARGAN
--1      -1      1       35      MOBEUS
--1      -1      1       36      KENDAR
-
--500
-
-
-
--500
\ No newline at end of file
diff --git a/makedata/test.com b/makedata/test.com
deleted file mode 100644
index e2d9a7c..0000000
Binary files a/makedata/test.com and /dev/null differ
diff --git a/makedata/test.cpr b/makedata/test.cpr
deleted file mode 100644
index d6e99ee..0000000
Binary files a/makedata/test.cpr and /dev/null differ
diff --git a/makedata/test.dta b/makedata/test.dta
deleted file mode 100644
index 4474fe5..0000000
Binary files a/makedata/test.dta and /dev/null differ
diff --git a/makedata/test.out b/makedata/test.out
deleted file mode 100644
index e956c50..0000000
--- a/makedata/test.out
+++ /dev/null
@@ -1,2 +0,0 @@
-
-HELLO WORLD...
diff --git a/makedata/test.pal b/makedata/test.pal
deleted file mode 100644
index 8b17520..0000000
Binary files a/makedata/test.pal and /dev/null differ
diff --git a/makedata/test.pas b/makedata/test.pas
deleted file mode 100644
index d192d6e..0000000
--- a/makedata/test.pas
+++ /dev/null
@@ -1,506 +0,0 @@
-program test;
-
-uses data, crt, graph;
-
-var
- ans: char;
- j,i: integer;
- str1, str2: string;
-
-{$L mover2}
-{$L vga256}
-procedure vgadriver; external;
-procedure mymove2(var src,tar; count: integer); external;
-
-
-{***************************************************************************}
-
-procedure scale(startx,starty,sizex,sizey,newx,newy: integer; var s,t);
-var sety, py, pdy, px, pdx, dcx, dcy: integer;
-begin
- asm
-  push ds
-  push es
-  les si, [s]         { es: si is our source location }
-  lds di, [t]         { ds: di is our destination }
-  imul di, [starty], 320
-  mov [sety], di
-  add di, [startx]
-
-  mov ax, [sizex]
-  xor dx, dx
-  mov cx, [newx]
-  div cx
-  mov [px], ax
-  mov [pdx], dx       { set up py and pdy }
-
-  mov ax, [sizey]
-  xor dx, dx
-  mov cx, [newy]
-  div cx
-  mov [py], ax
-  mov [pdy], dx       { set up py and pdy }
-
-  xor cx, cx
-  mov [dcx], cx
-  mov [dcy], cx
-  mov dx, [newy]
-
- @@iloop:
-  add cx, [py]
-
-  mov ax, [pdy]
-  add [dcy], ax
-  mov ax, [dcy]
-
-  cmp ax, [newy]
-  jl @@nodcychange
-  inc cx
-  sub ax, [newy]
-  mov [dcy], ax
-
- @@nodcychange:
-
-  imul si, cx, 320
-
-  mov bx, [newx]
-
- @@jloop:
-  add si, [px]
-
-  mov ax, [pdx]
-  add [dcx], ax
-  mov ax, [dcx]
-  cmp ax, [newx]
-  jl @@nodcxchange
-
-  inc si
-  sub ax, [newx]
-  mov [dcx], ax
-
- @@nodcxchange:
-
-  mov al, [es: si]
-  mov [ds: di], al     { finally draw it! }
-
-  inc di
-  dec bx
-  jnz @@jloop
-
-  add [sety], 320
-  mov di, [sety]
-  add di, [startx]
-
-  dec dx
-  jnz @@iloop
-
-  pop es
-  pop ds
- end;
-end;
-
-{***************************************************************************}
-
-procedure loopscale(startx,starty,sizex,sizey,newx,newy: integer; var s,t);
-var sety, py, pdy, px, pdx, dcx, dcy: integer;
-begin
- asm
-  push ds
-  push es
-  les si, [s]         { es: si is our source location }
-  lds di, [t]
-  imul di, [starty], 320
-  mov [sety], di
-  add di, [startx]
-
-  mov ax, [sizex]
-  xor dx, dx
-  mov cx, [newx]
-  div cx
-  mov [px], ax
-  mov [pdx], dx       { set up py and pdy }
-
-  mov ax, [sizey]
-  xor dx, dx
-  mov cx, [newy]
-  div cx
-  mov [py], ax
-  mov [pdy], dx       { set up py and pdy }
-
-  xor cx, cx
-  mov [dcx], cx
-  mov [dcy], cx
-  mov dx, [sizey]
-
- @@iloop:
-  add cx, [py]
-
-  mov ax, [pdy]
-  add [dcy], ax
-  mov ax, [newy]
-  cmp ax, [dcy]
-  jg @@nodcychange
-
-  inc cx
-  sub [dcy], ax
-
- @@nodcychange:
-
-  cmp cx, [sizey]
-  jb @@noloopy
-  xor cx, cx
-
- @@noloopy:
-
-  imul si, cx, 320
-
-  mov bx, [sizex]
-
- @@jloop:
-  add si, [px]
-
-  mov ax, [pdx]
-  add [dcx], ax
-  mov ax, [newx]
-  cmp ax, [dcx]
-  jg @@nodcxchange
-
-  inc si
-  sub [dcx], ax
-
- @@nodcxchange:
-
-  mov al, [es: si]
-  mov [ds: di], al     { finally draw it! }
-
-  inc di
-  dec bx
-  jnz @@jloop
-
-  add [sety], 320
-  mov di, [sety]
-  add di, [startx]
-
-  dec dx
-  jnz @@iloop
-
-  pop es
-  pop ds
- end;
-end;
-
-{***************************************************************************}
-
-procedure rotateloopscale(startx,starty,sizex,sizey,newx,newy,a: integer; var s,t);
-var sety, py, pdy, px, pdx, dcx, dcy: integer;
-
-    xb, yb: integer;
-
-    x1,y1: integer;
-
-    basey: integer;
-
-    rotx,roty: integer;
-
-begin
-
- rotx:=round(cos(a/100)*1000);
- roty:=round(sin(a/100)*1000);
-
- asm
-  push ds
-  push es
-  les si, [s]         { es: si is our source location }
-  lds di, [t]
-  imul di, [starty], 320
-  mov [sety], di
-  add di, [startx]
-
-  mov ax, [sizex]
-  xor dx, dx
-  mov cx, [newx]
-  div cx
-  mov [px], ax
-  mov [pdx], dx       { set up py and pdy }
-
-  mov ax, [sizey]
-  xor dx, dx
-  mov cx, [newy]
-  div cx
-  mov [py], ax
-  mov [pdy], dx       { set up py and pdy }
-
-  xor cx, cx
-  mov [dcx], cx
-  mov [dcy], cx
-  mov dx, [sizey]
-
- @@iloop:
-  add cx, [py]
-
-  mov ax, [pdy]
-  add [dcy], ax
-  mov ax, [newy]
-  cmp ax, [dcy]
-  jg @@nodcychange
-
-  inc cx
-  sub [dcy], ax
-
- @@nodcychange:
-
-  cmp cx, [sizey]
-  jb @@noloopy
-  xor cx, cx
-
- @@noloopy:
-
-  imul si, cx, 320
-
-  mov [basey], si
-
-  mov bx, [sizex]
-
- @@jloop:
-  add si, [px]
-
-  mov ax, [pdx]
-  add [dcx], ax
-  mov ax, [newx]
-  cmp ax, [dcx]
-  jg @@nodcxchange
-
-  inc si
-  sub [dcx], ax
-
- @@nodcxchange:
-
-
-
-
-  {
-
-  x2:=round((si-basey)*rotx-(cx)*roty);
-  y2:=round((cx)*rotx+(si-basey)*roty);
-
-  }
-
-
-  mov al, [es: si]
-  mov [ds: di], al     { finally draw it! }
-
-  inc di
-  dec bx
-  jnz @@jloop
-
-  add [sety], 320
-  mov di, [sety]
-  add di, [startx]
-
-  dec dx
-  jnz @@iloop
-
-  pop es
-  pop ds
- end;
-end;
-
-
-procedure scale2(startx,starty,sizex,sizey,newx,newy: integer; var t);
-var x, y, py, pdy, px, pdx, ry, rx, dx, dy: integer;
-begin
- py:=sizey div newy;
- pdy:=sizey mod newy;
- px:=sizex div newx;
- pdx:=sizex mod newx;
- ry:=starty+sizey;
- rx:=startx+sizex;
- dy:=0;
- dx:=0;
- x:=0;
- y:=0;
- for i:=starty to ry do
-  begin
-   y:=y+py;
-   dy:=dy+pdy;
-   if dy>= newy then
-    begin
-     inc(y);
-     dy:=dy-newy;
-    end;
-   x:=0;
-   for j:=startx to rx do
-    begin
-     x:=x+px;
-     dx:=dx+pdx;
-     if dx >= newx then
-      begin
-       inc(x);
-       dx:=dx-newx;
-      end;
-     if (x>sizex) or (y>sizey) then screen[i,j]:=0
-      else
-       begin
-        asm
-         push es
-         push ds
-         les si, [t]
-         imul di, [i], 320
-         add di, [j]
-         imul si, [y], 320
-         add si, [x]
-         mov ax, $A000
-         mov ds, ax
-         mov al, [es: si]
-         mov [ds: di], al
-         pop ds
-         pop es
-        end;
-       end;
-    end;
- end;
-end;
-
-procedure rotatescale2(startx,starty,sizex,sizey,newx,newy,a: integer; var t);
-var x, y, py, pdy, px, pdx, ry, rx, dx, dy: integer;
-    rotx,roty: real;
-    x2,y2: integer;
-begin
-
- rotx:=cos(a/100);
- roty:=sin(a/100);
-
- py:=sizey div newy;
- pdy:=sizey mod newy;
- px:=sizex div newx;
- pdx:=sizex mod newx;
- ry:=starty+100;
- rx:=startx+160;
- dy:=0;
- dx:=0;
- x:=0;
- y:=0;
- for i:=starty to ry do
-  begin
-   y:=y+py;
-   dy:=dy+pdy;
-   if dy>= newy then
-    begin
-     inc(y);
-     dy:=dy-newy;
-    end;
-   x:=0;
-   for j:=startx to rx do
-    begin
-     x:=x+px;
-     dx:=dx+pdx;
-     if dx >= newx then
-      begin
-       inc(x);
-       dx:=dx-newx;
-      end;
-      x2:=round(x*rotx-y*roty);
-      y2:=round(y*rotx+x*roty);
-      asm
-       push es
-       push ds
-       les si, [t]
-       imul di, [i], 320
-       add di, [j]
-       imul si, [y2], 320
-       add si, [x2]
-       mov ax, $A000
-       mov ds, ax
-       mov al, [es: si]
-       mov [ds: di], al
-       pop ds
-       pop es
-      end;
-    end;
- end;
-end;
-
-procedure shrinkalienscreen;
-var t: ^screentype;
-    partx,party,b: real;
-    a,i2,startx,max,starty: integer;
-    temppal: paltype;
-    t2: ^screentype;
-begin
- new(t);
- new(t2);
- mymove2(screen,t^,16000);
- for i:=0 to 199 do
-  mymove2(screen[199-i],t2^[i],80);
-
-
-{ for i:=0 to 199 do
-  begin
-   fillchar(t2^[i],10,0);
-   move(screen[i,160],t2^[i,10],170);
-   fillchar(t^[i,160],160,0);
-  end;
- }
-{ for i:=22 to 199 do
-  mymove2(screen[i,13],t^[i-22],306);}
-
- max:=20;
- repeat
-{  for a:=0 to 314 do
-   rotatescale2(0,0,319,199,80,50,a*4,t^);}
-
-
-  for a:=4 to max do
-   begin
-    partx:=320/max*a;
-    party:=200/max*a;
-    scale(0,0,319,199,round(partx),round(party),t^,screen);
-   end;
-  for a:=max downto 4 do
-   begin
-    partx:=320/max*a;
-    party:=200/max*a;
-    scale(0,0,320,199,round(partx),round(party),t^,screen);
-   end;
-
-
-{  for a:=1 to 39 do
-   begin
-    scale(a*2,a*2,170,200,170-a*4,199-a*4,t^);
-    scale((39-a)*2+160,(39-a)*2,170,200,160-(39-a)*4,199-(39-a)*4,t2^);
-   end;
-  for a:=38 downto 0 do
-   begin
-    scale(a*2,a*2,170,200,170-a*4,199-a*4,t^);
-    scale((39-a)*2+160,(39-a)*2,170,200,160-(39-a)*4,199-(39-a)*4,t2^);
-   end;
- }
- until fastkeypressed;
-
-
-{ max:=50;
-  for a:=0 to max do
-   begin
-    partx:=306-234/max*a;        { we want 72 pels in max moves from 306
-    party:=177-142/max*a;        { we want 35 pels in max moves from 177
-    starty:=176-round(party)+42;
-    startx:=305-round(partx)+43;
-    scale(startx,starty,306,177,round(partx),round(party),t^);
-   end;
- }
-{ for i:=142 to 176 do
-  mymove2(screen[i,234],t^[i,234],18);
- loadscreen('data\alien.vga');
- for i:=142 to 176 do
-  mymove2(t^[i,234],screen[i,234],18);}
- dispose(t);
- dispose(t2);
- delay(500);
-end;
-
-begin
- loadpal('data\intro5.pal');
- set256colors(colors);
- loadscreen('data\intro5.vga');
- shrinkalienscreen;
-end.
diff --git a/makedata/test.txt b/makedata/test.txt
deleted file mode 100644
index 4737fc2..0000000
--- a/makedata/test.txt
+++ /dev/null
@@ -1 +0,0 @@
-
\ No newline at end of file
diff --git a/makedata/test2.cpr b/makedata/test2.cpr
deleted file mode 100644
index f26bad2..0000000
Binary files a/makedata/test2.cpr and /dev/null differ
diff --git a/makedata/test2.pal b/makedata/test2.pal
deleted file mode 100644
index 483593f..0000000
Binary files a/makedata/test2.pal and /dev/null differ
diff --git a/makedata/test2.pas b/makedata/test2.pas
deleted file mode 100644
index a59b813..0000000
--- a/makedata/test2.pas
+++ /dev/null
@@ -1,11 +0,0 @@
-program test2;
-
-
-uses crt;
-
-var
- i,j: array[0..100] of byte;
-
-begin
- move(i,j,101);
-end.
\ No newline at end of file
diff --git a/makedata/testchar.pas b/makedata/testchar.pas
deleted file mode 100644
index d2b68d7..0000000
--- a/makedata/testchar.pas
+++ /dev/null
@@ -1,23 +0,0 @@
-program testplan;
-
-
-uses crt,data;
-
-var
- planfile: file of planettype;
- planets: array[1..1000] of planettype;
- j: integer;
-
-begin
- textmode(co80);
- assign(planfile,'save2\planets.dta');
- reset(planfile);
- for j:=1 to 1000 do read(planfile,planets[j]);
- close(planfile);
- for j:=1 to 1000 do
-  begin
-   if planets[j].mode=0 then
-    readkey;
-   writeln(j,' ',planets[j].mode);
-  end;
-end.
\ No newline at end of file
diff --git a/makedata/testdot.pas b/makedata/testdot.pas
deleted file mode 100644
index d24e2b7..0000000
--- a/makedata/testdot.pas
+++ /dev/null
@@ -1,39 +0,0 @@
-program testpixel;
-
-uses crt;
-
-{$L video}
-procedure initvga; external;
-procedure setpix(x,y: integer; pcolor: byte); external;
-function  getpix(x,y: integer ): byte; external;
-
-var
- under,dx,dy,x,y,countx,county: integer;
-
-
-procedure movedot;
-begin
- dx:=25;
- dy:=-4;
- x:=10;
- y:=15;
- under:=getpix(x,y);
- setpix(x,y,31);
- countx:=dx;
- county:=abs(dy);
- repeat
-  dec(dx);
-  inc(dy);
-{  setpix(x,y,under);}
-  x:=x+dx;
-  y:=y+dy;
-  setpix(x,y,31);
-  delay(80*3);
- until (dy=24);
-end;
-
-begin
- initvga;
- movedot;
- readkey;
-end.
diff --git a/makedata/testdraw.pas b/makedata/testdraw.pas
deleted file mode 100644
index 5e27734..0000000
--- a/makedata/testdraw.pas
+++ /dev/null
@@ -1,1589 +0,0 @@
-program testshipdraw;
-uses crt, data, graph, dos;
-
-type
- portraittype= array[0..69,0..69] of byte;
- scrtype=array[40..132,94..226] of byte;
- holotype= array[35..63,84..120] of byte;
-var
- a,b,c,i,j: integer;
- vgafile: file of screentype;
- palfile: file of paltype;
-
-procedure savescreen(s: string);
-begin
- assign(vgafile,s);
- rewrite(vgafile);
- write(vgafile,screen);
- close(vgafile);
-end;
-
-procedure savepal(s: string);
-begin
- assign(palfile,s);
- rewrite(palfile);
- write(palfile,colors);
- close(palfile);
-end;
-
-procedure plate(x1,y1,x2,y2:integer);
-var a,c: integer;
-begin
- a:=5; c:=8;
- for j:=x1 to x2 do
-   for i:=y1 to y2 do
-    begin
-     dec(a);
-     if a<5 then
-      begin
-       a:=random(5)*70;
-       c:=c-1;
-       if c<4 then c:=4+random(4)
-        else if c>12 then c:=12-random(4)
-        else c:=c+random(3);
-      end;
-     if screen[i,j]=31 then screen[i,j]:=c;
-    end;
-end;
-
-procedure ship;
-begin
- fillchar(screen,64000,31);
- for a:=1 to 200 do
-  begin
-   setfillstyle(1,random(12)+4);
-   j:=random(320);
-   i:=random(200);
-   bar(j,i,j+random(40),i+random(40));
-  end;
- plate(0,0,319,199);
- readkey;
-end;
-
-procedure stars;
-var vgafile: file of screentype;
-begin
- fillchar(screen,64000,0);
- for a:=1 to 75 do
-  begin
-   j:=random(320);
-   i:=random(200);
-   c:=random(10)+10;
-   screen[i,j]:=c;
-   if random(2)=0 then
-   for b:=1 to random(4) do
-    begin
-     screen[i+b,j]:=c div (b+1);
-     screen[i-b,j]:=c div (b+1);
-     screen[i,j+b]:=c div (b+1);
-     screen[i,j-b]:=c div (b+1);
-    end;
- end;
- readkey;
- assign(vgafile,'data\cloud.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);
-end;
-
-procedure makehighspeed;
-var f: file of screentype;
-    str1: string[1];
-    a,b,total,count,x: integer;
-    f2: file of paltype;
-begin
- setcolor(10);
- setaspectratio(3,5);
- for j:=0 to 3 do
-  begin
-   str(j,str1);
-   assign(f,'data\highspd'+str1+'.vga');
-   reset(f);
-   for i:=0 to 63 do
-    begin
-     colors[i,1]:=i;
-     colors[i,2]:=round(i/1.2);
-     colors[i,3]:=round(i/1.2);
-    end;
-   for i:=64 to 127 do
-    for a:=0 to 3 do colors[i,a]:=i-64;
-   set256colors(colors);
-   fillchar(screen,64000,0);
-   for i:=0 to 230 do
-    begin
-     setcolor(round(i/230*64));
-     circle(160,100,i);
-    end;
-   setcolor(12);
-   b:=1;
-   for i:=0 to 11 do
-    begin
-     b:=b*2;
-     circle(160,100,b+round(b/4*j));
-    end;
-   for x:=0 to 319 do
-    for i:=0 to 199 do
-     if screen[i,x]=0 then
-      begin
-       total:=0;
-       count:=0;
-       for a:=-1 to 1 do
-        for b:=-1 to 1 do
-         if screen[i+b,x+a]<>0 then
-          begin
-           inc(count);
-           inc(total,screen[i+b,x+a]);
-          end;
-       screen[i,x]:=round(total/count);
-      end;
-   for i:=110 to 199 do
-    begin
-     a:=1-j;
-     setcolor(round((i-110)/99*40)+66+a);
-     line(61+i,i,259-i,i);
-     line(61+i,199-i,259-i,199-i);
-    end;
-   setcolor(80);
-   readkey;
-   write(f,screen);
-   close(f);
-  end;
- assign(f2,'data\highspd.pal');
- reset(f2);
- write(f2,colors);
- close(f2);
-end;
-
-procedure redocargo;
-var i: integer;
-    vgafile: file of screentype;
-begin
- loadscreen('data\cargo.vga',@screen);
- loadpal('data\main.pal');
-{ for i:=0 to 19 do
-  for j:=160 downto 0 do
-    screen[i,319-j]:=screen[i,j];
- for i:=131 to 199 do
-  for j:=0 to 160 do
-   if ((screen[i,319-j]<32) and (screen[i,319-j]<>0))
-      or ((screen[i,319-j]>111) and (screen[i,319-j]<128))
-
-    then screen[i,j]:=screen[i,319-j];
-}
-
- for i:=0 to 19 do
-  for j:=1 to 160 do
-   screen[i,320-j]:=screen[i,j];
-
- assign(vgafile,'data\cargo.vga');
- reset(vgafile);
-{ write(vgafile,screen);}
- close(vgafile);
- readkey;
-end;
-
-procedure newintro;
-var a: integer;
-    c,d,e: real;
-    f,g,h: real;
-    ans: char;
-    vgafile: file of screentype;
-    f2: file of paltype;
-begin
- loadscreen('makedata\intro.vga',@screen);
- loadpal('data\main.pal');
- colors[15]:=colors[31];
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   if (screen[i,j]>0) then screen[i,j]:=128+(screen[i,j] mod 32);
- for i:=0 to 157 do
-  begin
-   a:=128-round(i/157*63);
-   for j:=0 to 319 do if screen[i,j]=0 then screen[i,j]:=a;
-  end;
- c:=1.95;
- d:=1.0;
- e:=0.9;
- f:=0.8;
- g:=0.0;
- h:=0.35;
- repeat
-  ans:=readkey;
-  case upcase(ans) of
-   'Q': c:=c+0.05;
-   'W': d:=d+0.05;
-   'E': e:=e+0.05;
-   'A': c:=c-0.05;
-   'S': d:=d-0.05;
-   'D': e:=e-0.05;
-   'I': f:=f+0.05;
-   'O': g:=g+0.05;
-   'P': h:=h+0.05;
-   'K': f:=f-0.05;
-   'L': g:=g-0.05;
-   ';': h:=h-0.05;
-  end;
-  for j:=64 to 127 do
-  begin
-   colors[j,1]:=round((j-64)*f);
-   colors[j,2]:=round((j-64)*g);
-   colors[j,3]:=round((j-64)*h);
-  end;
-  for j:=128 to 159 do
-  begin
-   colors[j,1]:=round((j-128)*c);
-   colors[j,2]:=round((j-128)*d);
-   colors[j,3]:=round((j-128)*e);
-  end;
-  set256colors(colors);         {1.7,0.6,1.6}   {2.4,1.2,1.6}
- until ans=#27;
-{ assign(vgafile,'data\intro.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);
- assign(f2,'data\intro.pal');
- reset(f2);
- write(f2,colors);
- close(f2);
-} closegraph;
- writeln(c,'/',d,'/',e);
- writeln(f,'/',g,'/',h);
-  {awesome!!!!!  2.0,0.8,1.25, 0.6,0,0.3}
-  {              1.85,1.1,1.15 0.8,0,0.3}
-end;
-
-procedure newpalette;
-var palfile: file of paltype;
-begin
- loadpal('data\main.pal');
- for j:=192 to 255 do
-  for i:=1 to 3 do colors[j,i]:=j-192;
- assign(palfile,'data\bw.pal');
- reset(palfile);
- write(palfile,colors);
- close(palfile);
-end;
-
-procedure newresearch;
-var
- ans: char;
- vgafile: file of screentype;
- palfile: file of paltype;
-begin
- loadscreen('data\research.vga',@screen);
- loadpal('data\main.pal');
- for i:=0 to 160 do
-  for j:=0 to 319 do
-   if screen[i,j]=0 then screen[i,j]:=random(2)+250;
- for i:=132 to 148 do
-  fillchar(screen[i,123],75,0);
- for j:=1 to 3 do
-  for i:=0 to 16 do
-   fillchar(screen[j*40-28+i,123],75,0);
- for i:=52 to 68 do
-  fillchar(screen[i,223],85,0);
- for i:=22 to 118 do
-  fillchar(screen[i,13],95,0);
- colors[250,1]:=10;
- colors[250,2]:=9;
- colors[250,3]:=0;
- colors[251,1]:=6;
- colors[251,2]:=10;
- colors[251,3]:=13;
- repeat
-  ans:=readkey;
-  case upcase(ans) of
-   'Q': inc(colors[250,1]);
-   'W': inc(colors[250,2]);
-   'E': inc(colors[250,3]);
-   'A': dec(colors[250,1]);
-   'S': dec(colors[250,2]);
-   'D': dec(colors[250,3]);
-   'I': inc(colors[251,1]);
-   'O': inc(colors[251,2]);
-   'P': inc(colors[251,3]);
-   'K': dec(colors[251,1]);
-   'L': dec(colors[251,2]);
-   ';': dec(colors[251,3]);
-  end;
-  set256colors(colors);
- until ans=#27;
- assign(vgafile,'data\research.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);
- assign(palfile,'data\research.pal');
- reset(palfile);
- write(palfile,colors);
- close(palfile);
-end;
-
-procedure newchar;
-var vgafile: file of screentype;
-    palfile: file of paltype;
-    i2: integer;
-begin
- loadscreen('data\char.vga',@screen);
- loadpal('data\char.pal');
-{ for a:=18 downto 1 do
-  begin
-   for i:=a to 199 do
-    move(screen[i+1],screen[i],100);
-  end;
- for i:=0 to 199 do
-  move(screen[i,12],screen[i],88);
- for i:=0 to 199 do
-  fillchar(screen[i,88],12,0);
- for i:=119 to 199 do
-  fillchar(screen[i],268,0);
- for a:=24 downto 1 do
-  for i:=a to 119 do
-   move(screen[i+1,88],screen[i,88],231);
-}
- for i:=0 to 31 do colors[i]:=colors[128+i];
-
-
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   case screen[i,j] of
-    128..159: screen[i,j]:=screen[i,j]-128;
-   end;
-
- repeat
-  dec(i2);
-  if i2<1 then i2:=31;
-  i:=i2;
-  for j:=0 to 31 do
-   begin
-    inc(i);
-    if i>31 then i:=0;
-    colors[j+128]:=colors[i*2+128];
-   end;
-  set256colors(colors);
-  delay(200);
- until fastkeypressed;
-
- assign(vgafile,'data\char.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);
- assign(palfile,'data\char.pal');
- reset(palfile);
- write(palfile,colors);
- close(palfile);
-end;
-
-procedure newcharani;
-var temp: ^screentype;
-    vgafile: file of screentype;
-    palfile: file of paltype;
-    c: integer;
-begin
- new(temp);
- loadpal('data\char.pal');
- set256colors(colors);
- loadscreen('data\char.vga',@screen);
- move(screen,temp^,64000);
- loadscreen('data\char.vga',@screen);
- fillchar(screen,64000,0);
- c:=0;
- for b:=0 to 4 do
-  for a:=0 to 5 do
-   begin
-    inc(c);
-    for i:=19+c downto c do
-     move(temp^[i+80,32],temp^[i+81,32],25);
-
-    for i:=0 to 34 do
-     move(temp^[i+81,22],screen[b*35+i,a*50],49);
-   end;
- readkey;
- assign(vgafile,'data\charani.vga');
- reset(vgafile);
-{ write(vgafile,screen);}
- close(vgafile);
- dispose(temp);
-end;
-
-procedure newimages;
-var datafile: file of portraittype;
-    s: string[2];
-    portrait: ^portraittype;
-    n: integer;
-begin
- new(portrait);
- loadpal('data\char.pal');
- set256colors(colors);
- for n:=1 to 4 do
-  begin
-   str(n:2,s);
-   if n<10 then s[1]:='0';
-   assign(datafile,'data\image'+s+'.vga');
-   if ioresult<>0 then errorhandler('portrait',1);
-   reset(datafile);
-   if ioresult<>0 then errorhandler('portrait',5);
-   read(datafile,portrait^);
-   for j:=0 to 69 do
-    for i:=0 to 69 do
-     begin
-      if (portrait^[i,j]>128)
-       and (portrait^[i,j]<160) then dec(portrait^[i,j],128);
-      screen[i+7,j+13]:=portrait^[i,j];
-     end;
-   readkey;
-   reset(datafile);
-{   write(datafile,portrait^);}
-   close(datafile);
-  end;
- dispose(portrait);
-end;
-
-procedure newscan;
-var vgafile: file of screentype;
-begin
- loadscreen('data\scan.vga',@screen);
- set256colors(colors);
- setcolor(31);
- circle(250,150,36);
- circle(250,150,18);
- readkey;
- assign(vgafile,'data\scan.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);
-end;
-
-procedure cliff;
-begin
-
-
- for j:=32 to 47 do
-  begin
-   colors[j,1]:=j-30;
-   colors[j,2]:=j-30;
-   colors[j,3]:=j-30;
-  end;
- for j:=48 to 63 do
-  begin
-   colors[j,1]:=round((64-j)*1.9);
-   colors[j,2]:=round((64-j)*0.9);
-   colors[j,3]:=0;
-  end;
- for j:=64 to 95 do
-  begin
-   colors[j,1]:=round((j-55)*1.9);
-   colors[j,2]:=round((j-55)*0.9);
-   colors[j,3]:=0;
-  end;
-
-
- set256colors(colors);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   screen[i,j]:=random(16)+32+round((199-i)/4);
-
- readkey;
-end;
-
-procedure newpal1;
-var temp: ^screentype;
-    colors2: paltype;
-    c: integer;
-    vgafile: file of screentype;
-    palfile: file of paltype;
-begin
- new(temp);
- loadpal('data\land2.pal');
- colors2:=colors;
- loadpal('data\land1.pal');
- loadscreen('data\land2.vga',@screen);
- move(screen,temp^,64000);
- loadscreen('data\land1.vga',@screen);
- for j:=0 to 63 do for i:=1 to 3 do colors[j,i]:=j;
- set256colors(colors);
- x:=20;
- for i:=0 to 199 do
-  begin
-   if i mod 32=0 then dec(x);
-   for j:=0 to 319 do
-    begin
-     c:=round(colors2[temp^[i,j],1]*0.30+colors2[temp^[i,j],2]*0.59+colors2[temp^[i,j],3]*0.11);
-     screen[100+round(i/10),143+round(j/16)+x]:=c;
-    end;
-  end;
- readkey;
- assign(vgafile,'data\land1.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);
- assign(palfile,'data\land1.pal');
- reset(palfile);
- write(palfile,colors);
- close(palfile);
- dispose(temp);
-end;
-
-procedure newpal2;
-var palfile: file of paltype;
-begin
- loadpal('data\land2.pal');
- for j:=0 to 63 do
-  for i:=1 to 3 do colors[j,i]:=j;
- for j:=64 to 127 do
-  begin
-   colors[j,1]:=j-64;
-   colors[j,2]:=0;
-   colors[j,3]:=0;
-  end;
- readkey;
- assign(palfile,'data\land2.pal');
- reset(palfile);
- write(palfile,colors);
- close(palfile);
-end;
-
-procedure newplanicons;
-var vgafile: file of screentype;
-begin
- loadscreen('data\planicon.vga',@screen);
- for a:=8 to 11 do
-  for i:=10 to 29 do
-   move(screen[i,140],screen[i,a*20],20);
-
- readkey;
- assign(vgafile,'data\planicon.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);
-end;
-
-
-procedure newresearch2;
-var vgafile: file of screentype;
-begin
- loadscreen('data\research.vga',@screen);
- for i:=165 to 199 do
-  for j:=152 to 318 do
-    if screen[i,j]=0 then screen[i,j]:=random(2)+250;
-
- colors[250,1]:=10;
- colors[250,2]:=9;
- colors[250,3]:=0;
- colors[251,1]:=6;
- colors[251,2]:=10;
- colors[251,3]:=13;
- set256colors(colors);
-
- readkey;
-
- assign(vgafile,'data\research.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);
-end;
-
-procedure newcombat;
-var vgafile: file of screentype;
-begin
- loadscreen('data\tactic.vga',@screen);
-
- setcolor(47);
-
- circle(265,102,45);
-
- setaspectratio(1,4);
-
- circle(105,102,102);
-
- readkey;
- assign(vgafile,'data\tactic.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);
-
-end;
-
-procedure newcombat2;
-var j: longint;
-   ans: char;
-   temp: ^screentype;
-   total: integer;
-begin
-
- loadscreen('data\tactic.vga',@screen);
-
-  for i:=37 downto 31 do
-   move(screen[i-1],screen[i],80);
-  fillchar(screen[30],80,0);
-
-  for i:=37 downto 15 do
-   move(screen[i-1,80],screen[i,80],120);
-
-
- readkey;
-
-{ assign(vgafile,'data\tactic.vga');
- reset(vgafile);
- write(vgafile,screen);
- close(vgafile);
-}
-
-end;
-
-procedure makebitmap;
-begin
- set256colors(colors);
- loadscreen('makedata\bitmap.vga',@screen);
-{ for i:=0 to 99 do
-  fillchar(screen[i],100,32);
- setcolor(123);   }
-
-
- setfillstyle(1,0);
- arc(50,50,200,340,30);
- screen[50,50]:=0;
-
- readkey;
- assign(vgafile,'makedata\bitmap.vga');
- rewrite(vgafile);
- write(vgafile,screen);
- close(vgafile);
-end;
-
-{$L mover}
-{$f+}
-procedure mymove(var src,tar; count: word); external;
-{$f-}
-
-procedure testmoves;
-var temp,temp2: ^screentype;
-begin
- loadscreen('data\main.vga',@screen);
- new(temp);
- new(temp2);
- mymove(screen,temp^,16000);
- fillchar(temp2^,64000,0);
- for j:=1 to 500 do
-  begin
-   mymove(temp2^,screen,12800);
-   mymove(temp^,screen,12800);
-  end;
-{ for j:=1 to 500 do
-  begin
-   for i:=40 to 132 do
-    move(temp2^[i,94],screen[i,94],132);
-   for i:=40 to 132 do
-    move(temp^[i,94],screen[i,94],132);
-  end;
-} dispose(temp2);
- dispose(temp);
-end;
-
-procedure newchar2;
-var temp: ^screentype;
-begin
- new(temp);
- loadpal('data\char.pal');
- set256colors(colors);
- loadscreen('data\sector.vga',@screen);
- temp^:=screen;
- loadscreen('data\char2.vga',@screen);
- for j:=60 to 110 do
-  for i:=80 to 110 do
-   begin
-    a:=temp^[i,j];
-    if a<31 then
-     begin
-      a:=a*4;
-      if a>31 then a:=175+a;
-     end;
-    screen[i-45,j+125]:=a;
-   end;
- readkey;
- dispose(temp);
- savescreen('data\char2.vga');
-end;
-
-
-procedure newmain2;
-begin
- colors[255,1]:=63;
- colors[255,2]:=0;
- colors[255,3]:=63;
- set256colors(colors);
- loadscreen('data\main.vga',@screen);
- for a:=0 to 99 do
-   for j:=292 downto 186+a do
-    for i:=1 to 4 do
-     for b:=0 to 10 do
-      screen[i*20+15+b,j]:=screen[i*20+15+b,j-1];
- readkey;
- savescreen('data\main2.vga');
-end;
-
-procedure newchar2_4;
-begin
- loadscreen('data\char2.vga',@screen);
- loadpal('data\char2.pal');
- set256colors(colors);
- for a:=1 to 6 do
-  for i:=180 to 195 do
-   mymove(screen[i,10],screen[i,a*17+10],4);
- readkey;
- savescreen('data\char2.vga');
-end;
-
-procedure newbreach1_1;
-begin
- loadscreen('data\breach1.vga',@screen);
- set256colors(colors);
- for i:=80 to 199 do
-  for j:=0 to 160 do
-   screen[i,320-j]:=screen[i,j];
- readkey;
- savescreen('data\breach1.vga');
-end;
-
-procedure newbreach2_1;
-begin
- loadscreen('data\breach2.vga',@screen);
- set256colors(colors);
- for i:=0 to 100 do
-  for j:=1 to 160 do
-   screen[i,320-j]:=screen[i,j];
- for i:=199 downto 101 do
-  for j:=0 to 319 do
-   screen[i,j]:=screen[200-i,j];
- readkey;
- savescreen('data\breach2.vga');
-end;
-
-procedure newbreach2_2;
-begin
- loadscreen('data\breach2.vga',@screen);
- set256colors(colors);
- for i:=0 to 90 do
-  for j:=1 to 160 do
-   screen[i,319-j]:=screen[i,j];
- for i:=110 to 199 do
-  for j:=1 to 160 do
-   screen[i,319-j]:=screen[i,j];
- readkey;
- savescreen('data\breach2.vga');
-end;
-
-procedure newresearch3;
-begin
- loadscreen('data\research.vga',@screen);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   if screen[i,j]>249 then screen[i,j]:=0;
- readkey;
-end;
-
-procedure newtactic;
-var temp: ^screentype;
-begin
- new(Temp);
- loadscreen('data\war.vga',@screen);
- for i:=0 to 199 do
-  move(screen[i],temp^[199-i],320);
- move(temp^,screen,64000);
- readkey;
- savescreen('data\war.vga');
- dispose(temp);
-end;
-
-procedure newtech2_1;
-begin
- loadscreen('data\tech2.vga',@screen);
- for i:=0 to 17 do
-  move(screen[i+105,134],screen[i+40,134],186);
- for i:=0 to 17 do
-  move(Screen[i+138,134],screen[i+78,134],186);
- readkey;
- savescreen('data\tech2.vga');
-end;
-
-procedure putpixxy(x,y,n: integer);
-var t: portraittype;
-    f: file of portraittype;
-    part: real;
-    str1: string[2];
-begin
- str(n:2,str1);
- if n<10 then str1[1]:='0';
- assign(f,'data\image'+str1+'.vga');
- reset(f);
- read(f,t);
- part:=28/69;
- for i:=0 to 69 do
-  for j:=0 to 69 do
-   screen[round(y+i*part),round(x+j*part)]:=t[i,j] mod 64;
- close(f);
-end;
-
-
-procedure newbreach2_3;
-begin
- loadscreen('data\breach2.vga',@screen);
- loadpal('data\breach2.pal');
- set256colors(colors);
-
-{ for i:=0 to 199 do
-  for j:=0 to 319 do
-   if screen[i,j]<31 then screen[i,j]:=64+screen[i,j]
-    else screen[i,j]:=screen[i,j] mod 16 + 96;
- for i:=0 to 95 do
-  for j:=319 downto 160 do
-   screen[i,319-j]:=screen[i,j];}
-
- putpixxy(25,21,1);
- putpixxy(25,51,2);
- putpixxy(55,21,3);
- putpixxy(55,51,4);
- putpixxy(85,21,5);
- putpixxy(85,51,6);
- putpixxy(115,21,7);
- putpixxy(115,51,8);
-
- putpixxy(173,21,9);
- putpixxy(173,51,10);
- putpixxy(203,21,11);
- putpixxy(203,51,12);
- putpixxy(233,21,13);
- putpixxy(233,51,14);
- putpixxy(263,21,15);
- putpixxy(263,51,16);
- readkey;
-end;
-
-procedure newmain;
-var holo: ^holotype;
-begin
- loadscreen('data\char2.vga',@screen);
- new(holo);
- for i:=35 to 63 do
-  mymove(screen[i,84],holo^[i,84],9);
- loadscreen('data\main.vga',@screen);
- for i:=35 to 63 do
-  mymove(holo^[i,84],screen[i+117,136+84],9);
- for i:=35+117 to 63+117 do
-  for j:=136+84 to 136+120 do
-   screen[i,j]:=(screen[i,j] mod 64) div 2;
-
- dispose(holo);
- readkey;
- savescreen('data\main.vga');
-end;
-
-procedure testportrait;
-var t: ^portraittype;
-    f: file of portraittype;
-begin
- loadpal('data\char2.pal');
- set256colors(colors);
- new(t);
- assign(f,'data\image15.vga');
- reset(f);
- read(f,t^);
- close(f);
- repeat
-{  for i:=0 to 69 do
-   move(t^[i],screen[i],70);}
-  for i:=0 to 34 do
-   begin
-    move(t^[i*2],screen[i*2],70);
-    fillchar(screen[i*2+1],70,0);
-   end;
-  delay(1);
-  for i:=0 to 34 do
-   begin
-    move(t^[i*2+1],screen[i*2+1],70);
-    fillchar(screen[i*2],70,0);
-   end;
-  delay(2);
- until fastkeypressed;
- dispose(t);
-end;
-
-procedure newtech2;
-var t: ^screentype;
-begin
- new(t);
- loadscreen('data\tech2.vga',@screen);
- mymove(screen,t^,16000);
- loadscreen('data\tech1.vga',@screen);
- for i:=33 to 102 do
-  move(t^[i,122],screen[i,122],198);
- for i:=105 to 155 do
-  move(t^[i,122],screen[i,122],198);
- readkey;
- dispose(t);
- savescreen('data\tech2.vga');
-end;
-
-procedure newcom;
-begin
- loadscreen('data\com.vga',@screen);
- set256colors(colors);
- for a:=0 to 3 do
-  for i:=198 downto 180 do
-   move(screen[i-1],screen[i],319);
- readkey;
-end;
-
-procedure newalien;
-begin
- loadpal('data\alien.pal');
- set256colors(colors);
- loadscreen('data\alien.vga',@screen);
- for i:=0 to 199 do
-  for j:=0 to 159 do
-   screen[i,320-j]:=screen[i,j];
- for j:=90 to 230 do
-  for i:=100 to 199 do
-   screen[199-i,j]:=screen[i,j];
- readkey;
-{ savescreen('data\alien.vga');}
-end;
-
-procedure newstarfield;
-begin
- set256colors(colors);
- loadscreen('data\test.vga',@screen);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   if screen[i,j]>0 then screen[i,j]:=31-(screen[i,j] div 8);
- readkey;
- savescreen('data\starfeld.vga');
-end;
-
-procedure newworld;
-var temp: ^screentype;
-    temppal: paltype;
-begin
- new(temp);
- loadpal('data\cloud2.pal');
- temppal:=colors;
- loadpal('data\world.pal');
- for i:=1 to 55 do
-  colors[i]:=temppal[i+200];
- set256colors(colors);
- loadscreen('data\world.vga',@screen);
- for i:=0 to 189 do
-  mymove(screen[i+9],screen[i],320);
- readkey;
-{ savescreen('data\world.vga');
- savepal('data\world.pal');}
- dispose(temp);
-end;
-
-procedure newlensflare;
-var temppal: paltype;
-begin
- loadpal('data\main.pal');
- temppal:=colors;
- loadpal('data\test.pal');
- for j:=0 to 104 do
-  colors[j]:=temppal[j];
- set256colors(colors);
- loadscreen('data\test.vga',@screen);
- readkey;
- savepal('data\battle1.pal');
- savescreen('data\battle1.vga');
-end;
-
-procedure newcloud2;
-begin
- loadpal('data\world.pal');
- loadscreen('data\cloud2.vga',@screen);
- set256colors(colors);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   screen[i,j]:=screen[i,j]-200;
- readkey;
- savescreen('data\cloud2.vga');
-end;
-
-procedure newintrostuff;
-var t: ^screentype;
-    a,seed,j,index,max: word;
-    temppal: paltype;
-    vgafile: file of screentype;
-begin
- new(t);
- fillchar(colors,768,0);
- set256colors(colors);
- assign(vgafile,'data\channel7.vga');
- reset(vgafile);
- if ioresult<>0 then errorhandler('channel7.vga',1);
- read(vgafile,t^);
- if ioresult<>0 then errorhandler('channel7.vga',5);
- close(vgafile);
- loadpal('data\main.pal');
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   screen[i,j]:=random(16)+200+(i mod 2)*16;
- tslice:=60;
- max:=38000;
- index:=0;
- j:=0;
- seed:=159;
- repeat
-  for i:=200 to 215 do
-   colors[i]:=colors[random(16)];
-  for i:=216 to 231 do
-   colors[i]:=colors[0];
-  set256colors(colors);
-  for i:=1 to 70+(60-tslice) do
-   begin
-    inc(index);
-    j:=j+seed;
-    if j>max then j:=j-max;
-    y:=(j div 300)+30;
-    x:=j mod 300+20;
-    if t^[y,x]>0 then screen[y,x]:=t^[y,x];
-   end;
-  for i:=216 to 231 do
-   colors[i]:=colors[random(16)];
-  for i:=200 to 215 do
-   colors[i]:=colors[0];
-  set256colors(colors);
-  delay(tslice div 3);
- until index>max;
- a:=31;
- mymove(colors,temppal,192);
- index:=0;
- repeat
-  inc(index);
-  if a>0 then
-   for j:=0 to 199 do
-    for i:=1 to 3 do
-     colors[j,i]:=round(a*temppal[j,i]/32);
-  for i:=200 to 215 do
-   colors[i]:=colors[random(16)];
-  for i:=216 to 231 do
-   colors[i]:=colors[0];
-  set256colors(colors);
-  delay(tslice);
-  for i:=216 to 231 do
-   colors[i]:=colors[random(16)];
-  for i:=200 to 215 do
-   colors[i]:=colors[0];
-  set256colors(colors);
-  delay(tslice div 2);
-  if index mod 4=0 then dec(a);
- until (fastkeypressed) or (a=0);
- dispose(t);
-end;
-
-procedure tryinvertpal;
-begin
- loadpal('data\world.pal');
- for i:=32 to 255 do
-  begin
- {  colors[i,1]:=round((63-colors[i,1])*0.45);
-  colors[i,2]:=round((63-colors[i,2])*0.55); }
-   colors[i,3]:=round((63-colors[i,3])*0.85);
-  end;
- set256colors(colors);
- loadscreen('data\world.vga',@screen);
- readkey;
-end;
-
-procedure tryconvertpal;
-var t: colortype;
-    min,c,a,b,index: integer;
-    indexpal: array[0..255] of byte;
-    indexpal2: array[0..255] of byte;
-begin
- loadpal('data\world2.pal');
- for j:=0 to 255 do
-  for i:=0 to 199 do
-   screen[i,j]:=j;
- for j:=0 to 255 do
-  indexpal[j]:=j;
- for j:=32 to 255 do
-  begin
-   min:=colors[j,1]+colors[j,2]+colors[j,3];
-   index:=j;
-   for i:=j+1 to 255 do
-    begin
-     c:=colors[i,1]+colors[i,2]+colors[i,3];
-     if c<min then
-      begin
-       index:=i;
-       min:=c;
-      end
-    end;
-   if index<>j then
-    begin
-     c:=indexpal[index];
-     indexpal[index]:=indexpal[j];
-     indexpal[j]:=c;
-     t:=colors[index];
-     colors[index]:=colors[j];
-     colors[j]:=t;
-     set256colors(colors);
-     delay(200);
-    end;
-  end;
- readkey;
- loadscreen('data\world2.vga',@screen);
- for j:=0 to 255 do
-  for i:=0 to 255 do
-   if indexpal[i]=j then indexpal2[j]:=i;
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   screen[i,j]:=indexpal2[screen[i,j]];
- readkey;
-end;
-
-procedure grayscale;
-var a,c: integer;
-begin
- loadscreen('data\world.vga',@screen);
- loadpal('data\world.pal');
- set256colors(colors);
- for i:=0 to 63 do
-  for j:=1 to 3 do colors[i,j]:=i;
- set256colors(colors);
- for j:=0 to 255 do
-  for i:=190 to 199 do
-   screen[i,j]:=j;
- for i:=0 to 189 do
-  for j:=0 to 319 do
-   begin
-    c:=screen[i,j];
-    a:=round(colors[c,1]*0.29+colors[c,2]*0.60+colors[c,3]*0.11);
-    screen[i,j]:=a;
-   end;
- readkey;
-end;
-
-procedure newsweep;
-begin
- loadpal('data\scan.pal');
- set256colors(colors);
- loadscreen('data\scan.vga',@screen);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   begin
-    c:=144+round(55*(199-i+319-j)/520);
-    if screen[i,j]=0 then screen[i,j]:=c;
-   end;
- readkey;
-end;
-
-procedure sector;
-begin
- loadpal('data\sector.pal');
- set256colors(colors);
- loadscreen('data\sector.vga',@screen);
- for i:=0 to 30 do
-  for j:=0 to 319 do
-   begin
-    c:=160+round(50*(199-i+319-j)/520);
-    if screen[i,j]=0 then screen[i,j]:=c;
-   end;
- for i:=0 to 199 do
-  for j:=310 to 319 do
-   begin
-    c:=160+round(50*(199-i+319-j)/520);
-    if screen[i,j]=0 then screen[i,j]:=c;
-   end;
- for i:=157 to 199 do
-  for j:=0 to 319 do
-   begin
-    c:=160+round(50*(199-i+319-j)/520);
-    if screen[i,j]=0 then screen[i,j]:=c;
-   end;
- readkey;
-end;
-
-procedure psyche2;
-begin
- loadpal('data\psyche.pal');
- set256colors(colors);
- loadscreen('data\psyche.vga',@screen);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   if screen[i,j] div 32=1 then screen[i,j]:=screen[i,j]+128 else
-   if screen[i,j] div 32=5 then screen[i,j]:=screen[i,j]-128;
- readkey;
-end;
-
-procedure psyche3;
-begin
- loadpal('data\psyche.pal');
- set256colors(colors);
- loadscreen('data\psyche.vga',@screen);
- for i:=50 to 120 do
-  for j:=35 to 90 do
-   if screen[i,j] div 32=2 then screen[i,j]:=screen[i,j]+32;
- readkey;
- savescreen('data\psyche.vga');
-end;
-
-procedure war;
-begin
- loadpal('data\war.pal');
- set256colors(colors);
- loadscreen('data\war.vga',@screen);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   begin
-    c:=160+round(55*(199-i+319-j)/520);
-    if screen[i,j]=0 then screen[i,j]:=c;
-   end;
- readkey;
-end;
-
-procedure newship;
-begin
- loadscreen('data\lilship.vga',@screen);
- loadpal('data\lilship.pal');
- set256colors(colors);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   if screen[i,j]>112 then screen[i,j]:=0;
- readkey;
-end;
-
-procedure newworld2;
-var t: ^screentype;
-begin
- new(t);
- loadscreen('data\cloud.vga',@screen);
- mymove(screen,t^,16000);
- loadpal('data\world2.pal');
- loadscreen('data\world2.vga',@screen);
- set256colors(colors);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   if (screen[i,j]=0) and (t^[i+40,j]>0) then
-    screen[i,j]:=t^[i,j]+64;
- readkey;
- dispose(t);
-end;
-
-procedure newalien2;
-var t: ^screentype;
-begin
- new(t);
- loadpal('data\alien.pal');
- set256colors(colors);
- loadscreen('data\cloud.vga',@screen);
- mymove(screen,t^,16000);
- loadscreen('data\alien.vga',@screen);
- for i:=31 to 138 do
-  for j:=3 to 318 do
-   if screen[i,j]=0 then screen[i,j]:=t^[i,j];
- readkey;
-end;
-
-procedure war2;
-begin
- loadpal('data\war.pal');
- set256colors(colors);
- loadscreen('data\war.vga',@screen);
- for i:=55 to 135 do
-  for j:=0 to 60 do
-   begin
-    c:=round(23*(199-i+319-j)/520)-12;
-    if screen[i,j]=0 then screen[i,j]:=c;
-   end;
- readkey;
-end;
-
-procedure newback;
-var t: ^screentype;
-begin
- loadscreen('makedata\land0001.vga',@screen);
- loadpal('makedata\land0001.pal');
- set256colors(colors);
- readkey;
- for i:=255 downto 64 do
-  colors[i]:=colors[i-64];
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   screen[i,j]:=screen[i,j]+64;
- set256colors(colors);
- readkey;
-end;
-
-procedure newwar2;
-begin
- loadpal('data\war.pal');
- set256colors(colors);
- loadscreen('data\war.vga',@screen);
- setaspectratio(1,3);
- setcolor(47);
- circle(160,70,80);
- screen[70,160]:=47;
- readkey;
-end;
-
-procedure logo2;
-begin
- loadscreen('data\intro2.vga',@screen);
- loadpal('logo2.pal');
- set256colors(colors);
- for j:=0 to 319 do
-  for i:=0 to 199 do
-   if screen[i,j] div 32=4 then screen[i,j]:=screen[i,j]+96
-    else screen[i,j]:=0;
- readkey;
-end;
-
-procedure logo3;
-begin
- randomize;
- loadpal('demo.pal');
- x:=100;
- y:=100;
- for i:=1 to 60 do
-  for j:=60-i to 60 do
-   screen[i+y,x+j-round((60-i)/2)]:=223;
- readkey;
-end;
-
-procedure logo4;
-begin
- loadpal('logo2.pal');
- loadscreen('demo2.vga',@screen);
- set256colors(colors);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   begin
-    if screen[i,j]=0 then screen[i,j]:=0
-     else screen[i,j]:=round(j/320*54)+74;
-
-   end;
- readkey;
-end;
-
-procedure scrolly;
-begin
- loadpal('logo.pal');
- set256colors(colors);
- for i:=0 to 40 do
-  fillchar(screen[i+10,10],40,200-i);
- readkey;
-end;
-
-procedure introchange;
-begin
- loadscreen('data\intro5.vga',@screen);
- loadpal('data\intro5.pal');
- set256colors(colors);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   if screen[i,j] div 32=4 then screen[i,j]:=screen[i,j]-64
-    else screen[i,j]:=0;
- readkey;
-end;
-
-procedure filllogo;
-begin
- setgraphbufsize(16000);
- loadpal('water.pal');
- set256colors(colors);
- loadscreen('water.vga',@screen);
- a:=0;
- for i:=0 to 199 do
-  begin
-   a:=0;
-   b:=0;
-   for j:=0 to 319 do
-    begin
-     if (screen[i,j]>0) and (a<>1) then
-      begin
-       a:=1;
-       if b=0 then b:=1 else b:=0;
-      end
-     else if (a=1) and (screen[i,j]=0) then a:=2;
-     if b=1 then screen[i,j]:=205;
-    end;
-  end;
- readkey;
-end;
-
-procedure filllogo2;
-begin
- loadpal('water.pal');
- set256colors(colors);
- loadscreen('water.vga',@screen);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   if screen[i,j]>0 then screen[i,j]:=screen[i,j]-48+round(i/199*40);
- readkey;
-end;
-
-procedure newlogo3;
-begin
- loadpal('ocean.pal');
- set256colors(colors);
- loadscreen('ocean.vga',@screen);
- for i:=10 to 100 do
-  for j:=0 to 319 do
-   if screen[i,j]<223 then screen[i,j]:=random(20)+183;
- readkey;
-end;
-
-procedure newsaver;
-begin
- loadscreen('data\saver.vga',@screen);
- loadpal('data\saver.pal');
- set256colors(colors);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   if screen[i,j]>0 then screen[i,j]:=(screen[i,j] mod 32)*2;
- readkey;
-end;
-
-procedure newlog;
-begin
- loadpal('data\log.pal');
- set256colors(colors);
- loadscreen('data\log.vga',@screen);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   if (screen[i,j]>127) and (screen[i,j]<255) then screen[i,j]:=0;
-
- readkey;
-
-end;
-
-procedure newdragon;
-begin
- loadscreen('data\test.vga',@screen);
- loadpal('data\test.pal');
- set256colors(colors);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   screen[i,j]:=screen[i,j] div 4;
- readkey;
-end;
-
-procedure newpic;
-begin
- loadscreen('data\test.vga',@screen);
- loadpal('data\test.pal');
- set256colors(colors);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   screen[i,j]:=screen[i,j] div 4;
- readkey;
- savescreen('makedata\jeremy.vga');
-end;
-
-procedure loadshipdisplay2(index,x1,y1: integer);
-var shipfile: file of shipdistype;
-    temp: ^shipdistype;
-    i,j: integer;
-begin
- new(temp);
- assign(shipfile,'data\shippix.dta');
- reset(shipfile);
- if ioresult<>0 then errorhandler('data\shippix.dta',1);
- seek(shipfile,index);
- if ioresult<>0 then errorhandler('data\shippix.dta',5);
- read(shipfile,temp^);
- if ioresult<>0 then errorhandler('data\shippix.dta',5);
- close(shipfile);
- for j:=x1 to x1+57 do
-  for i:=0 to 74 do
-   screen[y1+i,j]:=temp^[j-x1,i];
- dispose(temp);
-end;
-
-procedure showships;
-begin
- fillchar(screen,64000,4);
- for j:=0 to 8 do
-  loadshipdisplay2(j,(j mod 5)*61+3,(j div 5)*77+3);
- readkey;
- savescreen('makedata\shippart.vga');
-end;
-
-procedure convertscreens;
-var ft: searchrec;
-    name,path,dir,ext: string[40];
-    f: file;
-    i: word;
-begin
- findfirst('data\*.vga',$3f,ft);
- while doserror=0 do
-  begin
-   assign(f,'data\'+ft.name);
-   reset(f,1);
-   i:=filesize(f);
-   if i=64000 then
-    begin
-     loadscreen('data\'+ft.name,@screen);
-     compressfile('data\'+ft.name,@screen);
-    end;
-   close(f);
-   findnext(ft);
-  end;
-end;
-
-procedure convertscr2;
-begin
- loadscreen('scav1.vga',@screen);
- set256colors(colors);
- for i:=0 to 199 do
-  for j:=0 to 319 do
-   screen[i,j]:=(screen[i,j] div 8)+191;
- savescreen('scavenger.vga');
- for i:=0 to 31 do
-  for j:=1 to 3 do
-   colors[i+191,j]:=i*2;
- set256colors(colors);
- savepal('scavenger.pal');
- readkey;
-end;
-
-procedure showportrait(n,x,y: integer);
-var datafile: file of portraittype;
-    s: string[2];
-    portrait: ^portraittype;
-begin
- new(portrait);
- str(n:2,s);
- if n<10 then s[1]:='0';
- assign(datafile,'data\image'+s+'.vga');
- if ioresult<>0 then errorhandler('portrait',1);
- reset(datafile);
- if ioresult<>0 then errorhandler('portrait',5);
- read(datafile,portrait^);
- close(datafile);
- for i:=0 to 69 do
-  move(portrait^[i],screen[i+y,x],70);
- dispose(portrait);
-end;
-
-procedure test;
-begin
- showportrait(20,0,0);
- showportrait(20,100,0);
- loadpal('makedata\test2.pal');
- set256colors(colors);
- for j:=0 to 69 do
-  for i:=0 to 69 do
-   begin
-    a:=screen[i,j];
-    if a<32 then screen[i,j]:=(a div 2)+32
-    else screen[i,j]:=(((a mod 32)+32) div 2) + 32;
-   end;
-
-
- readkey;
-end;
-
-begin
- randomize;
- convertscr2;
-end.
\ No newline at end of file
diff --git a/makedata/testems.pas b/makedata/testems.pas
deleted file mode 100644
index a645ee7..0000000
--- a/makedata/testems.pas
+++ /dev/null
@@ -1,398 +0,0 @@
-{**********************************************************************}
-{*                              E M M P                               *}
-{*--------------------------------------------------------------------*}
-{*    Description    : Implement certain function to demonstrate      *}
-{*                     access to EMS memory using EMM.                *}
-{*--------------------------------------------------------------------*}
-{*    Author         : MICHAEL TISCHER                                *}
-{*    Developed on   : 08/30/1988                                     *}
-{*    Last update on : 02/19/1992                                     *}
-{*--------------------------------------------------------------------*}
-{*    Changes       : 02/19/92 : MK_FP replaced through PTR           *}
-{**********************************************************************}
-                                                                        
-program EMMP;
-                                                                        
-Uses Dos, CRT;                                { Add DOS and CRT units }
-                                                                       
-type  ByteBuf = array[0..1000] of byte;   { One memory range as bytes }
-      CharBuf = array[0..1000] of char;    { one memory range as Char }
-      BytePtr = ^ByteBuf;                     { Pointer to byte range }
-      CharPtr = ^CharBuf;                { Pointer to character range }
-
-const EMS_INT   = $67;                 { Interrupt # for access to EMM }
-      EMS_ERR   = -1;                           { Error if this occurs }
-      W_EMS_ERR = $FFFF;                     { error code in WORD form }
-      EmmName   : array[0..7] of char = 'EMMXXXX0';      { Name of EMM }
-
-var   EmmEC,                           { Allocation of EMM error codes }
-      i        : byte;                                  { loop counter }
-      Handle,                        { handle for access to EMS memory }
-      EmmVer   : integer;                      { Version number of EMM }
-      NumPage,                               { Number of the EMS pages }
-      PageSeg  : word;                 { Segment address of page frame }
-      KeyPress    : char;
-                                                                        
-{**********************************************************************}
-{* EmsInst : Determine the existance of EMS and corresponding EMM     *}
-{* Input   : none                                                     *}
-{* Output  : TRUE,when EMS memory is available, else FALSE            *}
-{**********************************************************************}
-                                                                        
-function EmsInst : boolean;
-                                                                        
-type EmmName  = array [1..8] of char;   { Name the EMM in driver header }
-     EmmNaPtr = ^EmmName;           { Pointer to name in driver header  }
-
-const Name : EmmName = 'EMMXXXX0';                 { Name of EMS driver }
-
-var Regs  : Registers;          { Processor register for interrupt call }
-
-begin
-  Regs.ax := $35 shl 8 + EMS_INT;          { over interrupt vector 67H }
-  msdos( Regs );                                 {Get DOS function 35H }
-
-  EmsInst := (EmmNaPtr(Ptr(Regs.ES,10))^ = Name); {Driver name compare }
-end;
-                                                                        
-{**********************************************************************}
-{* EmsNumPage: Determine the total of EMS pages.                      *}
-{* Input   : none                                                     *}
-{* Output  : EMS_ERR if error occurs, otherwise number of EMS pages.  *}
-{**********************************************************************}
-                                                                        
-function EmsNumPage : integer;
-                                                  
-var Regs : Registers;      { Processor register for the interrupt call }
-                                                                        
-begin
-  Regs.ah := $42;                { Fnt.nr.: Determine number of pages }
-  Intr(EMS_INT, Regs);                                     { call EMM }
-  if (Regs.ah <>0 ) then                        { did an error occur? }
-    begin                                                       { Yes }
-      EmmEC := Regs.ah;                              { get error code }
-      EmsNumPage := EMS_ERR;                          { display error }
-    end
-  else                                                     { no error }
-    EmsNumPage := Regs.dx;             { Return total number of pages }
-end;
-                                                                        
-{**********************************************************************}
-{* EmsFreePage: Determines the number of free EMS pages.              *}
-{* Input   : none                                                     *}
-{* Output  : EMS_ERR if error occurs, otherwise the number of un-     *}
-{*           used EMS pages.                                          *}
-{**********************************************************************}
-                                                                        
-function EmsFreePage : integer;
-                                                                        
-var Regs : Registers;     { Processor register for the interrupt call }
-
-begin
-  Regs.ah := $42;                   { Fnt.nr.: Determine no. of pages }
-  Intr(EMS_INT, Regs);                                     { call EMM }
-  if (Regs.ah <>0 ) then                        { did an error occur? }
-    begin                                                       { Yes }
-      EmmEC := Regs.ah;                              { get error code }
-      EmsFreePage := EMS_ERR;                         { display error }
-    end
-  else                                                     { no error }
-    EmsFreePage := Regs.bx;             { Return number of free pages }
-end;
-                                                                        
-{**********************************************************************}
-{* EmsFrameSeg: Determines the segment address of the page frame.     *}
-{* Input   : none                                                     *}
-{* Output  : EMS_ERR if error occurs, else the segment address.       *}
-{**********************************************************************}
-                                                                        
-function EmsFrameSeg : word;
-                                                                        
-var Regs : Registers;      { Processor register for the interrupt call }
-                                                                        
-begin
-  Regs.ah := $41;               { Fnt.nr.: get Segment adr. page frame }
-  Intr(EMS_INT, Regs);                                      { call EMM }
-  if (Regs.ah <>0 ) then                         { did an error occur? }
-    begin                                                        { Yes }
-      EmmEC := Regs.ah;                               { get error code }
-      EmsFrameSeg := W_EMS_ERR;                        { display error }
-    end
-  else                                                      { no error }
-    EmsFrameSeg := Regs.bx;     { return segment address of page frame }
-end;
-                                                                        
-{**********************************************************************}
-{* EmsAlloc: Allocate the specified number of pages and returns a     *}
-{*           handle for access to these pages.                        *}
-{* Input   : PAGES: the number of allocated pages.                   * }
-{* Output  : EMS_ERR returns the error, else the handle.              *}
-{**********************************************************************}
-                                                                        
-function EmsAlloc( Pages : integer ) : integer;
-                                                                        
-var Regs : Registers;      { Processor register for the interrupt call }
-                                                                        
-begin
-  Regs.ah := $43;                           { Fnt.nr.: Pages allocated }
-  Regs.bx := Pages;                     { set number of allocate pages }
-  Intr(EMS_INT, Regs);                                      { call EMM }
-  if (Regs.ah <>0 ) then                         { did an error occur? }
-    begin                                                        { Yes }
-      EmmEC := Regs.ah;                               { get error code }
-      EmsAlloc := EMS_ERR;                             { display error }
-    end
-  else                                                      { no error }
-    EmsAlloc := Regs.dx;                             { Handle returned }
-end;
-                                                                        
-{**********************************************************************}
-{* EmsMap  : Creates an allocated logical page from a physical page   *}
-{*           in the page frame.                                       *}
-{* Input   : HANDLE: Handle recieved from EmsAlloc.                   *}
-{*           LOGP  : Logical page about to be created                 *}
-{*           PHYSP : The physical page in the page frame.             *}
-{* Output  : FALSE if error ,else TRUE.                               *}
-{**********************************************************************}
-                                                                        
-function EmsMap(Handle, LogP : integer; PhysP : byte) : boolean;
-                                                                        
-var Regs : Registers;      { Processor register for the interrupt call }
-                                                                        
-begin
-  Regs.ah := $44;                               { Fnt.nr.: set mapping }
-  Regs.al := PhysP;                                { set physical page }
-  Regs.bx := LogP;                                  { set logical page }
-  Regs.dx := Handle;                                  { set EMS handle }
-  Intr(EMS_INT, Regs);                                      { call EMM }
-  EmmEC := Regs.ah;                                   { get error code }
-  EmsMap := (Regs.ah = 0)               { TRUE returned, when no error }
-end;
-                                                                        
-{**********************************************************************}
-{* EmsFree : Frees memory when given with an allocated handle.        *}
-{* Input   : HANDLE: Handle received by EmsAlloc.                     *}
-{* Output  : FALSE on error, else TRUE.                               *}
-{**********************************************************************}
-                                                                        
-function EmsFree(Handle : integer) : boolean;
-                                                                        
-var Regs : Registers;      { Processor register for the interrupt call }
-                                                                        
-begin
-  Regs.ah := $45;                             { Fnt.nr.: Release pages }
-  Regs.dx := handle;                                  { set EMS handle }
-  Intr(EMS_INT, Regs);                                      { call EMM }
-  EmmEC := Regs.ah;                                   { get error code }
-  EmsFree := (Regs.ah = 0)              { TRUE returned, when no error }
-end;
-                                                                        
-{**********************************************************************}
-{* EmsVersion: Determines the version number of EMM.                  *}
-{* Input   : none                                                     *}
-{* Output  : EMS_ERR on error, otherwise the version number.          *}
-{*           ( 11 for 1.1, 40 for 4.0 etc.)                           *}
-{**********************************************************************}
-                                                                        
-function EmsVersion : integer;
-                                                                        
-var Regs : Registers;      { Processor register for the interrupt call }
-                                                                        
-begin
-  Regs.ah := $46;                     { Fnt.nr.: Determine EMM version }
-  Intr(EMS_INT, Regs);                                      { call EMM }
-  if (Regs.ah <>0 ) then                         { did an error occur? }
-    begin                                                        { Yes }
-      EmmEC := Regs.ah;                               { get error code }
-      EmsVersion := EMS_ERR;                           { display error }
-    end
-  else            { no error, computer version number from BCD number }
-   EmsVersion := (Regs.al and 15) + (Regs.al shr 4) * 10;
-end;
-                                                                        
-{**********************************************************************}
-{* EmsSaveMap: Saves display between logical and physical pages of the*}
-{*             given handle.                                          *}
-{* Input   : HANDLE: Handle assigned by EmsAlloc.                     *}
-{* Output  : FALSE on error, else TRUE.                               *}
-{**********************************************************************}
-                                                                        
-function EmsSaveMap( Handle : integer ) : boolean;
-                                                                        
-var Regs : Registers;      { Processor register for the interrupt call }
-                                                                        
-begin
-  Regs.ah := $47;                              { Fnt.nr.: Save mapping }
-  Regs.dx := handle;                                  { set EMS handle }
-  Intr(EMS_INT, Regs);                                      { call EMM }
-  EmmEC := Regs.ah;                                   { get error code }
-  EmsSaveMap := (Regs.ah = 0)           { TRUE returned, when no error }
-end;
-                                                                        
-{**********************************************************************}
-{* EmsRestoreMap: Returns display between logical and physical pages, *}
-{*                from the page saved by EmsSaveMap                   *}
-{* Input   : HANDLE: Handle assigned by EmsAlloc                      *}
-{* Output  : FALSE if an error occurs, otherwise TRUE                 *}
-{**********************************************************************}
-                                                                       
-function EmsRestoreMap( Handle : integer ) : boolean;
-                                                                        
-var Regs : Registers;      { Processor register for the interrupt call }
-                                                                        
-begin
-  Regs.ah := $48;                           { Fnt.nr.: Restore mapping }
-  Regs.dx := handle;                                  { set EMS handle }
-  Intr(EMS_INT, Regs);                                      { call EMM }
-  EmmEC := Regs.ah;                                  { mark error code }
-  EmsRestoreMap := (Regs.ah = 0)         { TRUE returned when no error }
-end;
-                                                                        
-{**********************************************************************}
-{* PrintErr: Displays an error message and ends the program           *}
-{* Input   : none                                                     *}
-{* Output  : none                                                     *}
-{* Info    : This function is called only if an error occurs during a *}
-{*           function call within this module                         *}
-{**********************************************************************}
-
-procedure PrintErr;
-
-begin
-  writeln('ATTENTION! Error during EMS memory access');
-  write('     ... ');
-  if ((EmmEC<$80) or (EmmEc>$8E) or (EmmEc=$82)) then
-    writeln('Unidentifiable error')
-  else
-    case EmmEC of
-      $80 : writeln('EMS driver error (EMM trouble)');
-      $81 : writeln('EMS hardware error');
-      $83 : writeln('Illegal EMM handle');
-      $84 : writeln('Called EMS function does not exist');
-      $85 : writeln('No more free EMS handles available');
-      $86 : writeln('Error while saving or restoring mapping ');
-      $87 : writeln('More pages requested than are actually ',
-                    'available');
-      $88 : writeln('More pages requested than are free');
-      $89 : writeln('No pages requested');
-      $8A : writeln('Logical page does not belong to handle');
-      $8B : writeln('Illegal physical page number');
-      $8C : writeln('Mapping memory range is full');
-      $8D : writeln('Map save has already been done');
-      $8E : writeln('Mapping must be saved before it can',
-                    'be restored');
-    end;
-  Halt;                                                  { Program end }
-end;
-
-{**********************************************************************}
-{* VrAdr: Returns a pointer to video RAM                              *}
-{* Input   : none                                                     *}
-{* Output  : Pointer to video RAM                                     *}
-{**********************************************************************}
-                                                                       
-function VrAdr : BytePtr;
-                                                                        
-var Regs : Registers;      { Processor register for the interrupt call }
-                                                                        
-begin
-  Regs.ah := $0f;                      { Fnt.nr.: Determine video mode }
-  Intr($10, Regs);                         { call BIOS video interrupt }
-  if (Regs.al = 7) then                       { monochrome video card? }
-    VrAdr := ptr($B000, 0)               { Yes, Video-RAM at B000:0000 }
-  else                                      { Color-, EGA- or VGA-card }
-    VrAdr := ptr($B800, 0);                   { Video-RAM at B800:0000 }
-end;
-                                                                        
-{**********************************************************************}
-{* PageAdr : Returns address of a physical page in page frame         *}
-{* Input   : PAGE: Physical page number (0-3)                         *}
-{* Output  : Pointer to the physical page                             *}
-{**********************************************************************}
-                                                                       
-function PageAdr( Page : integer ) : BytePtr;
-                                                                        
-begin
-  PageAdr := Ptr( EmsFrameSeg + (Page shl 10), 0 );
-end;
-                                                                        
-{**********************************************************************}
-{**                           MAIN PRORAM                            **}
-{**********************************************************************}
-                                                                        
-begin
-  ClrScr;                                               { clear screen }
-  writeln('EMMP  -  (c) 1988, 92 by MICHAEL TISCHER',#13#10);
-  if EmsInst then                           { is EMS memory installed? }
-    begin                                                        { Yes }
-      {*--Display information about the EMS memory   -----------------*}
-                                                                        
-      EmmVer := EmsVersion;             { Determine EMM version number }
-      if EmmVer = EMS_ERR then                   { did an error occur? }
-        PrintErr;         { Yes, display error message and end program }
-      writeln('EMM-Version number           : ',EmmVer div 10, '.',
-              EmmVer mod 10);
-                                                                        
-      NumPage := EmsNumPage;             { Determine total no.  pages }
-      if NumPage = EMS_ERR then                 { did an error occur? }
-        PrintErr;        { Yes, display error message and end program }
-      writeln('Number of EMS pages          : ', NumPage, ' (',
-               NumPage shl 4, ' KByte)');
-                                                                        
-      NumPage := EmsFreePage;         { Determine number of free pages}
-      if NumPage = EMS_ERR then                 { did an error occur? }
-        PrintErr;        { Yes, display error message and end program }
-      writeln('... free                     : ', NumPage, ' (',
-               NumPage shl 4, ' KByte)');
-                                                                        
-      PageSeg := EmsFrameSeg;        { Segment addresse of page frame }
-      if PageSeg = W_EMS_ERR then               { did an error occur? }
-        PrintErr;        { Yes, display error message and end program }
-      writeln('Segment address of page frame: ', PAgeSeg);
-                                                                        
-      writeln;
-      writeln('Now a page from EMS memory can be allocated,   and the');
-      writeln('screen contents can be copied from video RAM into this');
-      writeln('page.');
-      writeln('                                ... Please press a key');
-      Keypress := ReadKey;                       { Wait for a keypress }
-      
-      {*-- Page is allocated, and the data is passed to the first-----*}
-      {*-- logical page in the page frame                        -----*}
-                                                                     
-      Handle := EmsAlloc( 2 );                     { Allocate one page }
-      if Handle = EMS_ERR then                   { did an error occur? }
-        PrintErr;         { Yes, display error message and end program }
-      if not(EmsMap(Handle, 0, 0)) then                  { Set mapping }
-        PrintErr;               { Error: display error and end program }
-      if not(emsmap(handle, 1, 1)) then
-        printerr;
-
-      {*-- Copy 4000 Bytes from Video-RAM to EMS memory----------- -*}
-                                                                        
-      Move(VrAdr^, PageAdr(0)^, 4000);
-
-      ClrScr;                                           { Clear screen }
-      while KeyPressed do                       { Read keyboard buffer }
-        Keypress := ReadKey;
-      writeln('Old screen contents are cleared.  However, the  data ');
-      writeln('from the screen is in EMS, and can be re-copied onto ');
-      writeln('the screen.                                          ');
-      writeln('                               ... Please press a key');
-      Keypress := ReadKey;                       { Wait for a keypress }
-
-      {*-- Copy contents of video RAM from EMS memory and release   --*}
-      {*-- the allocated EMS memory                                 --*}
-       
-      Move(PageAdr(0)^, VrAdr^, 4000);           { Copy over Video RAM }
-      if not(emssavemap(handle)) then printerr;
-      fillchar(pageadr(0)^,32000,0);
-      if not(emsrestoremap(handle)) then printerr;
-      if not(EmsFree(Handle)) then                    { Release memory }
-        PrintErr;    { Error: display message and end program }
-      GotoXY(1, 15);
-      writeln('END')
-    end
- else                                   { the EMS driver not available }
-   writeln('No EMS memory installed');
-end.
diff --git a/makedata/testfont.pas b/makedata/testfont.pas
deleted file mode 100644
index a43968d..0000000
--- a/makedata/testfont.pas
+++ /dev/null
@@ -1,52 +0,0 @@
-program testfont;
-uses crt, graph, data;
-
-var
- i,j: integer;
-
-procedure printxy(x1,y1: integer; s: string);
-var letter,a,index,t,i,j: integer;
-begin
- t:=tcolor;
- for j:=1 to length(s) do
-  begin
-   tcolor:=t;
-   letter:=ord(s[j]);
-   index:=1;
-   for i:=1 to 6 do
-    begin
-     for a:=4 to 7 do
-      if testbit(font[letter,index],a) then screen[y1+i,x1+j*5+7-a]:=tcolor
-       else if bkcolor<255 then screen[y1+i,x1+j*5+7-a]:=bkcolor;
-{     dec(tcolor,2);}
-     inc(i);
-     for a:=0 to 3 do
-      if testbit(font[letter,index],a) then screen[y1+i,x1+j*5+3-a]:=tcolor
-       else if bkcolor<255 then screen[y1+i,x1+j*5+3-a]:=bkcolor;
-     inc(index);
-{     dec(tcolor,2); }
-    end;
-    if bkcolor<255 then for i:=1 to 6 do screen[y1+i,x1+j*5+4]:=bkcolor;
-  end;
- tcolor:=t;
-end;
-
-procedure savescreen(s: string);
-var vgafile: file of screentype;
-begin
- assign(vgafile,s);
- rewrite(vgafile);
- write(vgafile,screen);
- close(vgafile);
-end;
-
-begin
- set256colors(colors);
- tcolor:=31;
- bkcolor:=4;
- for j:=1 to 55 do
-  printxy(j*5-9,-1,chr(j));
- savescreen('makedata\font.vga');
- readkey;
- closegraph;
-end.
\ No newline at end of file
diff --git a/makedata/testintr.pas b/makedata/testintr.pas
deleted file mode 100644
index 0dc07e5..0000000
--- a/makedata/testintr.pas
+++ /dev/null
@@ -1,76 +0,0 @@
-program testintro;
-
-uses crt, graph;
-
-type
- paltype= array[0..255,1..3] of byte;
- screentype= array[0..199,0..319] of byte;
-var
- colors: paltype;
- i,j,a: integer;
-
-{$L v3220pa}
-
-procedure init320200; external;
-procedure setpix( x, y : integer; pcolor : byte ); external;
-function  getpix( x, y: integer ) : byte ; external;
-procedure setpage( page : byte ); external;
-procedure showpage( page : byte ); external;
-
-procedure set256Colors(pal: paltype); assembler;
-asm
- mov ax, 1012h
- mov bx, 0
- mov cx, 256
- les dx, Pal
-  int 10h
-end;
-
-procedure loadpal(s: string);
-var palfile: file of paltype;
-begin
- assign(palfile,s);
- reset(palfile);
- read(palfile,colors);
- close(palfile);
-end;
-
-
-procedure loadscreens;
-var vgafile: file of screentype;
-    t: ^screentype;
-begin
- new(t);
- for a:=1 to 4 do
-  begin
-   assign(vgafile,'data\blast0'+chr(a+48)+'.vga');
-   reset(vgafile);
-   read(vgafile,t^);
-   setpage(a-1);
-   for i:=0 to 199 do
-    for j:=0 to 319 do
-     setpix(j,i,t^[i,j]);
-   close(vgafile);
-  end;
- dispose(t);
-end;
-
-procedure cycle;
-begin
- i:=0;
- repeat
-  showpage(i);
-  inc(i);
-  if i=4 then i:=0;
-  delay(30);
- until keypressed;
-end;
-
-begin
- init320200;
- loadpal('data\blast01.pal');
- set256colors(colors);
- loadscreens;
- cycle;
- closegraph;
-end.
\ No newline at end of file
diff --git a/makedata/testkbd.pas b/makedata/testkbd.pas
deleted file mode 100644
index d830bb1..0000000
--- a/makedata/testkbd.pas
+++ /dev/null
@@ -1,10 +0,0 @@
-program testkbd;
-
-uses crt;
-
-begin
- repeat
-  writeln(port[$60]);
-  delay(200);
- until port[$60]=187;
-end.
\ No newline at end of file
diff --git a/makedata/testkeys.pas b/makedata/testkeys.pas
deleted file mode 100644
index d900ec0..0000000
--- a/makedata/testkeys.pas
+++ /dev/null
@@ -1,14 +0,0 @@
-program testkeys;
-uses crt;
-
-var
- ans: char;
-
-begin
- repeat
-  if keypressed then
-   begin
-    write(readkey);
-   end;
- until ans=#27;
-end.
\ No newline at end of file
diff --git a/makedata/testland.pas b/makedata/testland.pas
deleted file mode 100644
index ac4d258..0000000
--- a/makedata/testland.pas
+++ /dev/null
@@ -1,154 +0,0 @@
-program landformdisplay;
-{$M 64000,0,128000}
-uses crt,graph,data;
-
-
-var
- landform: ^landtype;
- i,j,i2,j2,water,a,b: integer;
- part: real;
- y2,t1,t2,x1,y1: integer;
- ans: char;
- screen2: ^screentype;
-
-{$F+}
-
-procedure createplanet(xc,yc: integer);
-var x1,y1: integer;
-    a: longint;
-begin
- x1:=xc;
- y1:=yc;
- for a:=1 to 40000 do
-  begin
-   x1:=x1-1+random(3);
-   y1:=y1-1+random(3);
-   if x1>240 then x1:=1 else if x1<1 then x1:=239;
-   if y1>120 then y1:=1 else if y1<1 then y1:=119;
-   if landform^[x1,y1]<245 then landform^[x1,y1]:=landform^[x1,y1]+5;
-  end;
-end;
-
-procedure readyplanet;
-begin
- water:=30;
- for i:=1 to 240 do
-   for j:=1 to 120 do
-     landform^[i,j]:=water-2;
- createplanet(200,90);
- createplanet(30,30);
- createplanet(120,60);
- for i:=10 to 100 do
-  for j:=0 to 120 do screen2^[i,j]:=0;
-end;
-
-procedure erase(x,y: integer);
-begin
- for i:=0 to 100 do
-  for j:=0 to 120 do
-   screen2^[i,j]:=0;
-{ part:=8/(255-water);
- for j:=x to x+60 do
-  for i:=y to y+60 do
-  begin
-   if j>240 then j2:=j-239 else j2:=j;
-   if i>120 then i2:=i-119 else i2:=i;
-   if landform^[j2,i2]<water then
-     begin
-      x1:=20+(j-x);
-      y1:=(i-y)+40;
-      screen[y1,x1]:=0
-     end
-   else
-    begin
-     y2:=round(part*landform^[j2,i2]);
-     x1:=20+(j-x);
-     y1:=(i-y)+40;
-     setcolor(0);
-     line(x1,y1,x1,y1-4*y2);
-    end;
-  end;}
-end;
-
-procedure display(x,y: integer);
-begin
- part:=32/(255-water);
- for j:=x to x+120 do
-  for i:=y to y+120 do
-  begin
-   if j>240 then j2:=j-240 else j2:=j;
-   if i>120 then i2:=i-120 else i2:=i;
-   if landform^[j2,i2]<water then
-     begin
-      x1:=20+(j-x);
-      y1:=(i-y)+40;
-      screen2^[y1,x1]:=40
-     end
-   else
-    begin
-     a:=round(landform^[j2,i2]*part);
-     if a<7 then a:=43+a
-     else if a=7 then a:=128;
-     if a<8 then y2:=2
-     else y2:=round(part*landform^[j2,i2]/4);
-     x1:=20+(j-x);
-     y1:=(i-y)+40;
-
-     for b:=y1 downto y1-2*y2 do
-      screen2^[b,x1]:=a;
-{     screen2[y1-y2,x1]:=31;}
-    end;
-  end;
-  i:=y+120;
-  for j:=x to x+30 do
-  begin
-   if j>240 then j2:=j-240 else j2:=j;
-   if i>120 then i2:=i-120 else i2:=i;
-   if landform^[j2,i2]<water then
-     begin
-      x1:=20+(j-x);
-      y1:=(i-y)+40;
-      screen2^[y1,x1]:=6
-     end
-   else
-    begin
-     a:=round(landform^[j2,i2]*part);
-     if a<8 then y2:=2
-     else y2:=round(part*landform^[j2,i2]/4);
-     if a<7 then a:=43+a
-     else if a=7 then a:=128
-     else a:=6;
-     x1:=20+(j-x);
-     y1:=(i-y)+40;
-
-     for b:=y1 downto y1-2*y2 do
-      screen2^[b,x1]:=a;
-{     screen2[y1-y2,x1]:=31;}
-    end;
-  end;
-
- move(screen2^,screen,64000);
-end;
-
-begin
- new(landform);
- new(screen2);
- readyplanet;
- ans:=' ';
- t1:=1;
- t2:=1;
- repeat
-  case ans of
-   '6':if t1<240 then inc(t1,5) else t1:=t1-239;
-   '2':if t2<120 then inc(t2,5) else t2:=t2-120;
-   '4':if t1>1 then dec(t1,5) else t1:=t1+240;
-   '8':if t2>1 then dec(t2,5) else t2:=t2+120;
-  end;
-  display(t1,t2);
-  if keypressed then ans:=readkey;
-  erase(t1,t2);
- until ans=#59;
- dispose(landform);
- dispose(screen2);
-end.
-
diff --git a/makedata/testline.pas b/makedata/testline.pas
deleted file mode 100644
index 75e2d5d..0000000
--- a/makedata/testline.pas
+++ /dev/null
@@ -1,545 +0,0 @@
-program TestLines;
-
-uses crt;
-
-type
- screentype= array[0..199,0..319] of byte;
- paltype= array[0..255,1..3] of byte;
-
-var
- screen: screentype absolute $A000:0000;
- colors: paltype;
-
- x1,y1,x2,y2,j: integer;
-
-procedure errorhandler(s: string; errtype: integer);
-begin                              { handles errors and outputs a message}
- textmode(co80);
- writeln;
- case errtype of
-  1: writeln('File Error: ',s);
-  2: writeln('Mouse Error: ',s);
-  3: writeln('Sound Error: ',s);
-  4: writeln('EMS Error: ',s);
-  5: writeln('Fatal File Error: ',s);
-  6: writeln('Program Error: ',s);
- end;
- halt(4);
-end;
-
-procedure setvidmode(mode: byte);  { sets different video modes }
-begin
- asm
-  mov ah, 00
-  mov al, [mode]
-   int 10h
- end;
-end;
-
-procedure loadscreen(s: string);   { load up the screen }
-var vgafile: file of screentype;
-begin
- assign(vgafile,s);
- reset(vgafile);
- if ioresult<>0 then errorhandler(s,1);
- read(vgafile,screen);
- if ioresult<>0 then errorhandler(s,5);
- close(vgafile);
-end;
-
-procedure loadpal(s: string);      { load up the palette but don't set }
-var palfile: file of paltype;
-begin
- assign(palfile,s);
- reset(palfile);
- if ioresult<>0 then errorhandler(s,1);
- read(palfile,colors);
- if ioresult<>0 then errorhandler(s,5);
- close(palfile);
-end;
-
-procedure setrgb256(palnum,r,g,b: byte); assembler;
-asm                                { this is an extra, sets 1 color }
- xor bh, bh
- mov bl, palnum
- mov ax, 1010h
- mov dh, r
- mov ch, g
- mov cl, b
-  int 10h
-end;
-
-procedure getrgb256(palnum: byte; var r,g,b); assembler;
-asm                                { this is an extra, gets 1 color }
- xor bh, bh
- mov bl, palnum
- mov ax, 1015h
-  int 10h
- les di, r
- mov es:[di], dh
- les di, g
- mov es:[di], ch
- les di, b
- mov es:[di], cl
-end;
-
-procedure set256Colors(pal: paltype); assembler;
-asm                                { sets all colors }
- mov ax, 1012h
- mov bx, 0
- mov cx, 256
- les dx, Pal
-  int 10h
-end;
-
-procedure fading;                  { nice clean fade function }
-var a,i,j: integer;
-    temppal: paltype;
-begin
- move(colors,temppal,768);
- for a:=31 downto 1 do
-  begin
-   for j:=0 to 255 do
-    for i:=1 to 3 do
-     temppal[j,i]:=round(a*colors[j,i]/32);
-   set256colors(temppal);
-   delay(40);
-  end;
- fillchar(temppal,768,0);
- set256colors(temppal);
-end;
-
-procedure fadein;                  { nice fade in function }
-var a,i,j: integer;
-    temppal: paltype;
-begin
- fillchar(temppal,768,0);
- for a:=0 to 15 do
-  begin
-   for j:=0 to 15 do
-    for i:=a to 15 do
-     temppal[j*16+i]:=colors[j*16+a];
-   set256colors(temppal);
-   delay(40);
-  end;
- set256colors(colors);
-end;
-
-procedure line(x1,y1,x2,y2,c: integer);
-var dx,dy,incre,incrne,d,x,y: integer;
-begin
- if x1>x2 then
-  begin
-   x:=x1;
-   x1:=x2;
-   x2:=x;
-   y:=y1;
-   y1:=y2;
-   y2:=y;
-  end;
- dx:=x2-x1;
- dy:=y2-y1;
- if (abs(dy)<dx) and (dy<0) then
-  begin
-   if y1<y2 then
-    begin
-     y:=y1;
-     y1:=y2;
-     y2:=y;
-    end;
-   dy:=y1-y2;
-   d:=dy*2-dx;
-   incre:=dy*2;
-   incrne:=(dy-dx)*2;
-   x:=x1;
-   y:=y1;
-   screen[y,x]:=c;
-   while x<x2 do
-    begin
-     if d<=0 then
-      begin
-       inc(d,incre);
-       inc(x);
-      end
-     else
-      begin
-       inc(d,incrne);
-       inc(x);
-       dec(y);
-      end;
-     screen[y,x]:=c;
-    end;
-  end
- else if (dy<0) then
-  begin
-   if y1<y2 then
-    begin
-     y:=y1;
-     y1:=y2;
-     y2:=y;
-    end;
-   dy:=y1-y2;
-   d:=dx*2-dy;
-   incre:=dx*2;
-   incrne:=(dx-dy)*2;
-   x:=y1;
-   y:=x1;
-   screen[x,y]:=c;
-   while x>y2 do
-    begin
-     if d<=0 then
-      begin
-       inc(d,incre);
-       dec(x);
-      end
-     else
-      begin
-       inc(d,incrne);
-       dec(x);
-       inc(y);
-      end;
-     screen[x,y]:=c;
-    end;
-  end
- else if dy>dx then
-  begin
-   if y1>y2 then
-    begin
-     y:=y1;
-     y1:=y2;
-     y2:=y;
-    end;
-   dy:=y2-y1;
-   d:=dx*2-dy;
-   incre:=dx*2;
-   incrne:=(dx-dy)*2;
-   x:=y1;
-   y:=x1;
-   screen[x,y]:=c;
-   while x<y2 do
-    begin
-     if d<=0 then
-      begin
-       inc(d,incre);
-       inc(x);
-      end
-     else
-      begin
-       inc(d,incrne);
-       inc(x);
-       inc(y);
-      end;
-     screen[x,y]:=c;
-    end;
-  end
- else
-  begin
-   if y1>y2 then
-    begin
-     y:=y1;
-     y1:=y2;
-     y2:=y;
-    end;
-   dy:=y2-y1;
-   d:=dy*2-dx;
-   incre:=dy*2;
-   incrne:=(dy-dx)*2;
-   x:=x1;
-   y:=y1;
-   screen[y,x]:=c;
-   while x<x2 do
-    begin
-     if d<=0 then
-      begin
-       inc(d,incre);
-       inc(x);
-      end
-     else
-      begin
-       inc(d,incrne);
-       inc(x);
-       inc(y);
-      end;
-     screen[y,x]:=c;
-    end;
-  end;
-end;
-
-procedure line2(x1,y1,x2,y2,c: integer);
-var dx,dy,incre,incrne,d,x,y: integer;
-begin
- if x1>x2 then
-  begin
-   x:=x1;
-   x1:=x2;
-   x2:=x;
-   y:=y1;
-   y1:=y2;
-   y2:=y;
-  end;
- dx:=x2-x1;
- dy:=y2-y1;
- if (abs(dy)<dx) and (dy<0) then
-  begin
-   if y1<y2 then
-    begin
-     y:=y1;
-     y1:=y2;
-     y2:=y;
-    end;
-   dy:=y1-y2;
-   d:=dy*2-dx;
-   incre:=dy*2;
-   incrne:=(dy-dx)*2;
-   x:=x1;
-   y:=y1;
-   screen[y,x]:=c;
-   while x<x2 do
-    begin
-     if d<=0 then
-      begin
-       inc(d,incre);
-       inc(x);
-      end
-     else
-      begin
-       inc(d,incrne);
-       inc(x);
-       dec(y);
-      end;
-     screen[y,x]:=c;
-    end;
-  end
- else if (dy<0) then
-  begin
-   if y1<y2 then
-    begin
-     y:=y1;
-     y1:=y2;
-     y2:=y;
-    end;
-   dy:=y1-y2;
-   d:=dx*2-dy;
-   incre:=dx*2;
-   incrne:=(dx-dy)*2;
-   x:=y1;
-   y:=x1;
-   screen[x,y]:=c;
-   while x>y2 do
-    begin
-     if d<=0 then
-      begin
-       inc(d,incre);
-       dec(x);
-      end
-     else
-      begin
-       inc(d,incrne);
-       dec(x);
-       inc(y);
-      end;
-     screen[x,y]:=c;
-    end;
-  end
- else if dy>dx then
-  begin
-   if y1>y2 then
-    begin
-     y:=y1;
-     y1:=y2;
-     y2:=y;
-    end;
-   dy:=y2-y1;
-   d:=dx*2-dy;
-   incre:=dx*2;
-   incrne:=(dx-dy)*2;
-   x:=y1;
-   y:=x1;
-   screen[x,y]:=c;
-   while x<y2 do
-    begin
-     if d<=0 then
-      begin
-       inc(d,incre);
-       inc(x);
-      end
-     else
-      begin
-       inc(d,incrne);
-       inc(x);
-       inc(y);
-      end;
-     screen[x,y]:=c;
-    end;
-  end
- else
-  begin
-   if y1>y2 then
-    begin
-     y:=y1;
-     y1:=y2;
-     y2:=y;
-    end;
-   dy:=y2-y1;
-   d:=dy*2-dx;
-   incre:=dy*2;
-   incrne:=(dy-dx)*2;
-   x:=x1;
-   y:=y1;
-   screen[y,x]:=c;
-   while x<x2 do
-    begin
-     if d<=0 then
-      begin
-       inc(d,incre);
-       inc(x);
-      end
-     else
-      begin
-       inc(d,incrne);
-       inc(x);
-       inc(y);
-      end;
-     screen[y,x]:=c;
-    end;
-  end;
-end;
-
-procedure circlepoints(x1,y1,x,y: integer; c: byte);
-begin
-asm
- push es
- mov ax, $A000
- mov es, ax
- mov bx, [x1]
- mov cx, [y1]
- mov dl, [c]
-
- mov ax, cx
- add ax, [x]
- imul di, ax, 320
- add di, bx
- add di, [y]
- mov [es:di], dl
-
- mov ax, cx
- add ax, [x]
- imul di, ax, 320
- add di, bx
- sub di, [y]
- mov [es:di], dl
-
- mov ax, cx
- sub ax, [x]
- imul di, ax, 320
- add di, bx
- add di, [y]
- mov [es:di], dl
-
- mov ax, cx
- sub ax, [x]
- imul di, ax, 320
- add di, bx
- sub di, [y]
- mov [es:di], dl
-
- mov ax, cx
- add ax, [y]
- imul di, ax, 320
- add di, bx
- add di, [x]
- mov [es:di], dl
-
- mov ax, cx
- add ax, [y]
- imul di, ax, 320
- add di, bx
- sub di, [x]
- mov [es:di], dl
-
- mov ax, cx
- sub ax, [y]
- imul di, ax, 320
- add di, bx
- add di, [x]
- mov [es:di], dl
-
- mov ax, cx
- sub ax, [y]
- imul di, ax, 320
- add di, bx
- sub di, [x]
- mov [es:di], dl
-
- pop es
-end;
-end;
-
-procedure circle(x1,y1,r,c: integer);
-var x,y,d,de,dse: integer;
-label loop;
-begin
-asm
- mov [x], 0
- mov ax, [r]
- mov [y], ax
- mov bx, 1
- sub bx, ax
- mov [d], bx
- mov [de], 3
- shl ax, 1
- mov [dse], 5
- sub [dse], ax
-end;
- circlepoints(x1,y1,x,y,c);
-asm
-loop:
- cmp [d], 0
- jge @@se
-@@e:
- mov ax, [de]
- add [d], ax
- add [dse], 2
- jmp @@done
-@@se:
- mov ax, [dse]
- add [d], ax
- add [dse], 4
- dec [y]
-@@done:
- inc [x]
- add [de], 2
-end;
- circlepoints(x1,y1,x,y,c);
-asm
- mov ax, [y]
- cmp ax, [x]
- jg loop
-end;
-end;
-
-begin
- setvidmode($13);                  { set the vga video mode }
- loadpal('data\main.pal');
- set256colors(colors);             { set cleared palette }
- randomize;
-
- for j:=50 to 50 do
-  begin
-   circle(160,100,j,31);
-   delay(100);
-  end;
-{ for j:=0 to 500 do
-  begin
-   x1:=random(320);
-   y1:=random(200);
-   x2:=random(320);
-   y2:=random(200);
-   line(x1,y1,x2,y2,63);
-   screen[y1,x1]:=47;
-   screen[y2,x2]:=95;
-  end; }
- readkey;
-
- textmode(co80);                   { reset video to text mode }
-end.
\ No newline at end of file
diff --git a/makedata/testmice.pas b/makedata/testmice.pas
deleted file mode 100644
index 153571c..0000000
--- a/makedata/testmice.pas
+++ /dev/null
@@ -1,20 +0,0 @@
-program mousetest;
-
-uses crt, data, gmouse;
-
-begin
- set256colors(colors);
- fillchar(screen,64000,95);
- mouseshow;
- repeat
-  mousehide;
-  for i:=75 to 125 do
-   fillchar(screen[i,100],120,47);
-  mouseshow;
-  mousehide;
-  for i:=75 to 125 do
-   fillchar(screen[i,100],120,95);
-  mouseshow;
- until keypressed;
- mousehide;
-end.
\ No newline at end of file
diff --git a/makedata/testmove.pas b/makedata/testmove.pas
deleted file mode 100644
index 53be704..0000000
--- a/makedata/testmove.pas
+++ /dev/null
@@ -1,11 +0,0 @@
-program testmove;
-
-
-var
- t,s: array[0..1023] of byte;
-
-
-begin
- fillchar(s,1024,0);
- move(s,t,1024);
-end.
\ No newline at end of file
diff --git a/makedata/testout.pas b/makedata/testout.pas
deleted file mode 100644
index 7c8ec25..0000000
--- a/makedata/testout.pas
+++ /dev/null
@@ -1,6 +0,0 @@
-program helloworld;
-
-
-begin
- write(#13#10'Hello World...'#10#13);
-end.
\ No newline at end of file
diff --git a/makedata/testplay.pas b/makedata/testplay.pas
deleted file mode 100644
index 6c779dc..0000000
--- a/makedata/testplay.pas
+++ /dev/null
@@ -1,137 +0,0 @@
-program testsongplaying;
-
-{$M 6000,200000,200000}
-
-
-{$I dsmi.inc}, crt,modplay,data;
-
-var j,i,t,vol,orgvol: integer;
-    track: integer;
-    hsample: pointer;
-    sample: ^byte;
-    pos: longint;
-    textscreen: array[0..23,0..79] of integer absolute $B800:0000;
-    voltable: array[0..31] of integer;
-    ans: char;
-
-procedure drawtracks;
-begin
- for track:=0 to module^.channelcount+3 do
-  begin
-   orgvol:=cdigetvolume(track);
-   if orgvol=0 then
-    for j:=0 to 20 do textscreen[track,j]:=$082A
-   else
-    begin
-     pos:=cdigetposition(track);
-     hsample:=mcpGetsample(track);
-     sample:=hsample;
-     vol:=0;
-     inc(sample,pos);
-     for t:=0 to 79 do
-      begin
-       vol:=vol+abs(sample^);
-       inc(sample);
-      end;
-     vol:=round(vol*orgvol/2000);
-     if vol>0 then
-      begin
-       for j:=0 to vol do textscreen[track,j]:=$0F2A;
-       if vol<20 then
-        for j:=vol+1 to 20 do textscreen[track,j]:=$082A;
-      end;
-    end;
-  end;
-end;
-
-procedure errorhandler(s: string);
-begin
- textmode(co80);
- writeln;
- writeln(s);
- halt;
-end;
-
-{procedure soundeffect(n:integer; s: string);
-var f: file;
-    size: integer;
-    si: tsampleinfo;
-begin
- assign(f,s);
- reset(f,1);
- if ioresult<>0 then errorhandler('NO FILE!!!');
- size:=filesize(f);
- getmem(si.sample,size);
- blockread(f,si.sample^,size);
- if ioresult<>0 then errorhandler('WRONG SIZE!!!');
- close(f);
-
- with si do
-  begin
-   length:=size;
-   loopstart:=0;
-   loopend:=0;
-   mode:=0;
-   sampleid:=0;
-  end;
-
- mcpconvertsample(si.sample,size);
- for j:=0 to 3 do
-  begin
-   if mcpsetsample(module^.channelcount+j,@si)<>0 then errorhandler('HUH? Sample.');
-   if mcpplaysample(module^.channelcount+j,11900+j*10,64)<>0 then errorhandler('HUH? Playing.');
-  end;
- freemem(si.sample,size);
-end;
-}
-
-
-begin
- textmode(co80);
-
-{ if initdsmi(22000,4096,MCP_QUALITY,@sc)<>0 then exit;
- module:=amploadmod('sound\combat.mod',LM_IML);
- if sc.id<>ID_GUS then mcpStartVoice else gusStartVoice;
- mcpclearbuffer;
- for i:=0 to 32 do voltable[i]:=2*i+1;
- cdiSetupChannels(0,module^.channelCount+4,@voltable);
- for j:=0 to module^.channelcount-1 do
-  mcpSetVolume(j,64);
- for j:=0 to 3 do
-  begin
-   mcpsetvolume(module^.channelcount+j,64);
-   cdisetpan(module^.channelcount+j,Pan_Surround);
-  end;
- mcpclearbuffer;
- ampplaymodule(module,PM_Loop);
- clrscr;}
-
- ship.options[3]:=1;
- ship.options[9]:=64;
- ans:=' ';
- playmod(true,'\ironseed\sound\combat.mod');
-{ cdisetpan(0,pan_middle);
- cdisetpan(1,pan_middle);}
- repeat
-  drawtracks;
-  if fastkeypressed then
-   begin
-    ans:=readkey;
-    case upcase(ans) of
-     'A': soundeffect('gun1.sam',0);
-     'B': soundeffect('laser1.sam',7000);
-     'C': soundeffect('laser2.sam',7000);
-     'D': soundeffect('laser3.sam',7000);
-     'E': soundeffect('laser4.sam',7000);
-     'F': soundeffect('laser5.sam',7000);
-     'G': soundeffect('laser6.sam',7000);
-     'H': soundeffect('laser7.sam',7000);
-     'I': soundeffect('explode2.sam',7000);
-    end;
-   end;
- until (ans=#27) or (ans=#13);
-
- ampstopmodule;
-{ ampfreemodule(module); }
-end.
-
diff --git a/makedata/testsb.pas b/makedata/testsb.pas
deleted file mode 100644
index d2329b9..0000000
--- a/makedata/testsb.pas
+++ /dev/null
@@ -1,125 +0,0 @@
-
-program testsb;
-
-{$M 64000,0,160000}
-
-uses voctool,crt;
-type
-  buffertype= array[0..64000] of byte;
-
-var
- vocfile: file of byte;
- buffer1,buffer2: ^buffertype;
- i,j,vseg,vofs: word;
- length: word;
-
-procedure readsongin;
-begin
- for j:=0 to 5 do read(vocfile,buffer1^[j]);
- writeln('Block type:',buffer1^[0]);
- if buffer1^[0]=0 then exit;
- length:=buffer1^[1]+buffer1^[2]*256;
- writeln('Block length:',length);
- writeln('Sample rate:',buffer1^[4]);
- buffer1^[4]:=80;
- writeln('Pack Byte:',buffer1^[5]);
- for j:=1 to length-2 do read(vocfile,buffer1^[j+5]);
- buffer1^[length+4]:=0;
- VSeg := Seg(Buffer1^);
- VOfs := Ofs(Buffer1^);
- ASM
-  MOV       BX,6
-  MOV       ES,VSeg
-  MOV       DI,VOfs
- end;
-
- repeat
- until voc.statusword=0;
- writeln('------------------------------------');
- for j:=0 to 5 do read(vocfile,buffer2^[j]);
- writeln('Block type:',buffer2^[0]);
- if buffer2^[0]=0 then exit;
- length:=buffer2^[1]+buffer2^[2]*256;
- writeln('Block length:',length);
- writeln('Sample rate:',buffer2^[4]);
- buffer2^[4]:=80;
- writeln('Pack Byte:',buffer2^[5]);
- for j:=1 to length-2 do read(vocfile,buffer2^[j+5]);
- buffer2^[length+4]:=0;
- VSeg := Seg(Buffer2^);
- VOfs := Ofs(Buffer2^);
- ASM
-  MOV       BX,6
-  MOV       ES,VSeg
-  MOV       DI,VOfs
- @@loopit:
-  cmp voc.statusword, 0
-  jne @@loopit
-  CALL      VOC.PtrToDriver
- END;
- repeat
- until voc.statusword=0;
- writeln('------------------------------------');
-end;
-
-begin
- textmode(co80);
- new(buffer1);
- new(buffer2);
- assign(vocfile,'c:\apps\sbpro\vedit2\song.voc');
- reset(vocfile);
- clrscr;
- for j:=0 to 25 do
-  begin
-   read(vocfile,buffer1^[j]);
-   write(chr(buffer1^[j]));
-  end;
- writeln;
- writeln('------------------------------------');
- for j:=0 to 5 do read(vocfile,buffer2^[j]);
- writeln('Block type:',buffer2^[0]);
- length:=buffer2^[1]+buffer2^[2]*256;
- writeln('Block length:',length);
- writeln('Sample rate:',buffer2^[4]);
- writeln('Pack Byte:',buffer2^[5]);
- for j:=1 to length-2 do read(vocfile,buffer2^[j+5]);
- buffer2^[length+4]:=0;
- buffer2^[length+5]:=0;
- buffer2^[4]:=140;
- VOC.SetSpeaker(TRUE);
- VSeg := Seg(Buffer2^);
- VOfs := Ofs(Buffer2^);
- ASM
-  MOV       BX,6
-  MOV       ES,VSeg
-  MOV       DI,VOfs
-  CALL      VOC.PtrToDriver
- END;
- writeln('------------------------------------');
-{ for j:=length+3 downto 6 do buffer1^[length+9-j]:=buffer2^[j];
- for j:=0 to 5 do buffer1^[j]:=buffer2^[j];
- buffer1^[length+4]:=0;
- buffer1^[length+5]:=0;
- writeln('Block type:',buffer1^[0]);
- writeln('Block length:',length);
- writeln('Sample rate:',buffer1^[4]);
- writeln('Pack Byte:',buffer1^[5]);
- repeat
- until vocstatusword=0;
- VSeg := Seg(Buffer1^);
- VOfs := Ofs(Buffer1^);
- ASM
-  MOV       BX,6
-  MOV       ES,VSeg
-  MOV       DI,VOfs
-  CALL      VOCPtrToDriver
- END;
- writeln('------------------------------------');
-} repeat
-  readsongin;
- until (buffer1^[0]=0) or (buffer2^[0]=0);
- close(vocfile);
- readkey;
- dispose(buffer1);
- dispose(buffer2);
-end.
diff --git a/makedata/testsb2.pas b/makedata/testsb2.pas
deleted file mode 100644
index 604dc22..0000000
--- a/makedata/testsb2.pas
+++ /dev/null
@@ -1,20 +0,0 @@
-program testsound;
-{$M 16000,0,25000}
-uses crt,voctool,data;
-
-var
- speed: ^byte;
- i,j: integer;
-
-begin
- runvoice('sound\engine2.voc');
- speed:=song;
- inc(speed,30);
- for j:=1 to 16 do
-  begin
-   repeat until vocstatusword=0;
-   if speed^<160 then inc(speed^,12);
-   vocoutput(song);
-  end;
- vocstop;
-end.
diff --git a/makedata/testtime.pas b/makedata/testtime.pas
deleted file mode 100644
index 6098413..0000000
--- a/makedata/testtime.pas
+++ /dev/null
@@ -1,17 +0,0 @@
-program testtime;
-
-uses graftool;
-
-var
- buf1,buf2: array[0..29999] of byte;
- j: word;
-
-begin
- for j:=1 to 1005 do
-  begin
-   fillchar(buf1,30000,5);
-   fillchar(buf2,30000,10);
-   move(buf1,buf2,30000);
-   move(buf1,buf2,30000);
-  end;
-end.
\ No newline at end of file
diff --git a/makedata/testtxt.pas b/makedata/testtxt.pas
deleted file mode 100644
index b05f5c4..0000000
--- a/makedata/testtxt.pas
+++ /dev/null
@@ -1,22 +0,0 @@
-program testtext;
-
-uses crt;
-
-type
- texttype=array[0..24,0..79] of integer;
-var
- textscreen: texttype absolute $B800:0000;
-
-procedure loadtext(s: string);
-var f: file of texttype;
-begin
- assign(f,s);
- reset(f);
- read(f,textscreen);
- close(f);
-end;
-
-begin
- loadtext('makedata\test.txt');
- readkey;
-end.
\ No newline at end of file
diff --git a/makedata/testvid.pas b/makedata/testvid.pas
deleted file mode 100644
index 8a86978..0000000
--- a/makedata/testvid.pas
+++ /dev/null
@@ -1,309 +0,0 @@
-program testvideo;
-
-uses crt,graph,data;
-
-const
-
- crtaddr = $3D4;
- crtstat = $3DA;
- crtattr = $3C0;
-type
- colortype=array[1..3] of byte;
- paltype=array[0..255] of colortype;
- screentype= array[0..199,0..319] of byte;
-
-var
- a,b,i,j,total,max: word;
- temp: ^screentype;
- seed,tslice: integer;
- vgafile: file of screentype;
- palfile: file of paltype;
- colors: paltype;
- screen: screentype absolute $A000:0000;
- offs: word;
-
-{$L v3220pa}
-
-procedure init320200; external;
-procedure setpix(x,y: integer; pcolor: byte); external;
-function getpix(x,y: integer): byte; external;
-procedure setpage(page: byte); external;
-procedure showpage(page: byte); external;
-
-procedure set256Colors(pal: paltype); assembler;
-asm
- mov ax, 1012h
- mov bx, 0
- mov cx, 256
- les dx, Pal
-  int 10h
-end;
-
-procedure init;
-begin
- for j:=208 to 240 do colors[j]:=colors[j-208];
- set256colors(colors);
- for j:=0 to 318 do
-  for i:=0 to 199 do
-   screen[i,j]:=random(32)+196;
-end;
-
-procedure snowing3;
-var index: integer;
-    temp: colortype;
-begin
- for j:=1 to 10000 do
-  begin
-   i:=192+random(31);
-   setcolor(i);
-   setfillstyle(1,i);
-   pieslice(random(320),random(200),0,360,random(2)+1);
-  end;
- for j:=192 to 223 do
-  begin
-   colors[j,3]:=j-208;
-   colors[j,1]:=0;
-   colors[j,2]:=0;
-  end;
- for j:=224 to 255 do colors[j]:=colors[j-32];
- set256colors(colors);
-  repeat
-   inc(index);
-   if index<32 then inc(index) else index:=0;
-    temp:=colors[192];
-    for i:=192 to 222 do
-     colors[i]:=colors[i+1];
-    colors[223]:=temp;
-    set256colors(colors);
-  delay(tslice*5);
- until keypressed;
-end;
-
-procedure snowing2;
-begin
- total:=64000;
- seed:=16;
- for j:=192 to 223 do
-  begin
-   colors[j,3]:=j-208;
-   colors[j,1]:=j-208;
-   colors[j,2]:=j-208;
-  end;
- for j:=223 to 255 do colors[j]:=colors[j-32];
- for j:=0 to 32 do
-  begin
-   colors[j,1]:=j*2;
-   colors[j,2]:=j*2;
-   colors[j,3]:=j*2;
-  end;
- repeat
-  for i:=192 to 223 do
-   colors[i]:=colors[223+random(32)];
-  set256colors(colors);
-  if total mod 4000=0 then
-   begin
-    dec(seed);
-    for j:=0 to 319 do
-     for i:=0 to 199 do
-      if (temp^[i,j] mod 16=seed)
-       and (temp^[i,j]>0)
-       then screen[i,j]:=temp^[i,j];
-   end;
- until seed=0;
- repeat
-    for i:=192 to 223 do
-     colors[i]:=colors[223+random(32)];
-    set256colors(colors);
-  delay(tslice*3);
- until keypressed;
-end;
-
-procedure snowing;
-begin
- 
-  total:=0;
-  max:=64000;
-  j:=0;
-  seed:=17;
- repeat
-   inc(total);
-   j:=j+seed;
-   if j>max then j:=j-max;
-   a:=j div 319;
-   b:=j mod 319;
-   if total<max then screen[a,b]:=temp^[a,b];
-  if total mod 100=0 then
-   begin
-    for i:=208 to 240 do
-     colors[i]:=colors[random(32)];
-    set256colors(colors);
-   end;
- until total>=max;
- max:=64000;
- total:=0;
- j:=0;
- repeat
-  inc(total);
-  j:=j+seed;
-  if j>max then j:=j-max;
-  screen[j div 319,j mod 319]:=random(32)+208;
-  if total mod 100=0 then
-   begin
-    for i:=208 to 240 do
-     colors[i]:=colors[random(32)];
-    set256colors(colors);
-   end;
-  until total>max;
-end;
-
-procedure shiftit;
-begin
- offs:=140;
- asm
-  mov dx, crtstat
- @@wait48:
-  in ax, dx
-  test ax, 8
-  jz @@wait48
- @@wait40:
-  in ax, dx
-  test ax, 8
-  jnz @@wait40
-  mov dx, crtaddr
-  mov cx, offs
-  cli
-  mov ah, ch
-  mov al, 0Ch
-  out dx, ax
-  mov ah, cl
-  mov al, 0Dh
-  out dx, ax
-  sti
-  mov dx, crtstat
- @@wait48b:
-  in ax, dx
-  test ax, 08h
-  jz @@wait48b
-  mov dx, crtaddr
-  cli
-  mov ah, 0
-  mov al, 08h
-  out dx, ax
-  mov dx, crtattr
-  mov al, 33h
-  out dx, al
-  mov al, 0
-  out dx, al
-  sti
- end;
-end;
-
-procedure scrollit2(x: byte);
-begin
- asm
-  mov ax, 1000h
-  mov bh, 33h
-  mov bl, x
-   int 10h
- end;
-end;
-
-procedure scrollit(x,y: byte);
-var offs: word;
-begin
-{  if y>0 then offs:=offs+80*y else offs:=0;}
-  offs:=j mod 5;
-   asm
-    mov dx, crtstat
-   @@wait48:
-    in ax, dx
-    test ax, 8
-    jz @@wait48
-   @@wait40:
-    in ax, dx
-    test ax, 8
-    jnz @@wait40
-    mov dx, crtaddr
-    mov cx, offs
-    cli
-    mov ah, ch
-    mov al, 0Ch
-    out dx, ax
-    mov ah, cl
-    mov al, 0Dh
-    out dx, ax
-    sti
-{    mov dx, crtstat
-   @@wait48b:
-    in ax, dx
-    test ax, 08h
-    jz @@wait48b
-    mov dx, crtaddr
-    cli
-    mov ah, y
-    mov al, 08h
-    out dx, ax
-    mov dx, crtattr
-    mov al, 33h
-    out dx, al
-    mov al, x
-    out dx, al
-    sti
-}   end;
-end;
-
-procedure loadscreen2(s: string);
-begin
- assign(vgafile,s);
- reset(vgafile);
- read(vgafile,temp^);
- close(vgafile);
- for j:=0 to 319 do
-  for i:=0 to 199 do
-   setpix(j,i,temp^[i,j]);
-end;
-
-procedure loadpal2(s: string);
-begin
- assign(palfile,s);
- reset(palfile);
- read(palfile,colors);
- close(palfile);
- set256colors(colors);
-end;
-
-procedure test1;
-begin
- randomize;
- tslice:=120;
- init320200;
- loadpal2('data\mars.pal');
- new(temp);
- setpage(0);
- showpage(0);
- loadscreen2('data\cloud.vga');
- setpage(1);
- loadscreen('data\mars.vga');
- setpage(2);
- loadscreen2('data\cloud.vga');
- for j:=1 to 100 do
-  begin
-   scrollit2(4);
-   readkey;
-  end;
- dispose(temp);
- closegraph;
-end;
-
-begin
- loadpal('data\mars.pal');
- loadscreen('data\mars.vga');
- set256colors(colors);
- readkey;
- offs:=0;
- for j:=1 to 200 do
-  begin
-   scrollit(0,2);
-  end;
- closegraph;
-end.
\ No newline at end of file
diff --git a/makedata/unused.pas b/makedata/unused.pas
deleted file mode 100644
index c2f5de8..0000000
--- a/makedata/unused.pas
+++ /dev/null
@@ -1,2797 +0,0 @@
-procedure loadshipdisplay(x,y: char);
-var shipfile: file of shipdistype;
-    temp: shipdistype;
-    x1: integer;
-begin
- assign(shipfile,'data\ship'+x+y+'.dta');
- reset(shipfile);
- if ioresult<>0 then errorhandler('data\ship'+x+y+'.dta');
- read(shipfile,temp);
- close(shipfile);
- case y of
-  'A':x1:=60;
-  'B':x1:=118;
-  'C':x1:=176;
- end;
- for j:=0 to 57 do
-  for i:=0 to 74 do
-   if (temp[j,i]=0) or (temp[j,i]=38) then temp[j,i]:=4;
- for j:=x1 to x1+57 do
- begin
-  for i:=37 to 112 do
-   begin
-    screen[10+i div 2,j div 2]:=temp[j-x1,i-37];
-    inc(i);
-   end;
-  inc(j);
- end;
-end;
-
-procedure displayship;
-var str1: string;
-begin
- erasestars;
- tcolor:=47;
- j:=20;
- if ship.name[20]=' ' then
- repeat
-  dec(j);
- until ship.name[j]<>' ';
- str1:=ship.name;
- str1[0]:=chr(j);
- printxy(73-j*3,10,'"'+str1+'"');
- setcolor(43);
- setfillstyle(1,4);
- bar(20,20,135,73);
- setlinestyle(0,0,3);
- rectangle(20,20,135,73);
- setcolor(47);
- setlinestyle(0,0,0);
- rectangle(20,20,135,73);
- case ship.shiptype[1] of
-  'A':loadshipdisplay('1','A');
-  'B':loadshipdisplay('2','A');
-  'C':loadshipdisplay('3','A');
- end;
- case ship.shiptype[2] of
-  '1':loadshipdisplay('1','B');
-  '2':loadshipdisplay('2','B');
-  '3':loadshipdisplay('3','B');
- end;
- case ship.shiptype[3] of
-  'X':loadshipdisplay('1','C');
-  'Y':loadshipdisplay('2','C');
-  'Z':loadshipdisplay('3','C');
- end;
- bkcolor:=4;
- printxy(10,80,'CREW:');
- for j:=1 to 7 do
-  begin
-   case j of
-    1: str1:='CPT';
-    2: str1:='PSY';
-    3: str1:='ENG';
-    4: str1:='SCI';
-    5: str1:='SEC';
-    6: str1:='NAV';
-    7: str1:='MED';
-   end;
-   tcolor:=14;
-   printxy(24,81+j*7,str1);
-   tcolor:=31;
-   printxy(45,81+j*7,crew[j].name);
-   case crew[j].status of
-    0:bkcolor:=63;
-   end;
-   printxy(15,81+j*7,' ');
-   bkcolor:=4;
-  end;
- drawstars(0,0);
- bkcolor:=0;
-end;
-
-procedure rotatecube(src,tar: byte);
-label skip1,skip2,skip3;
-begin  {215,145}
- if tar+src=5 then
-  begin
-   if (tar=2) or (tar=3) then rotatecube(src,tar-2)
-   else if (tar>0) then rotatecube(src,tar-1)
-   else rotatecube(src,tar+1);
-  end;
- getcube(src,tar);
- setfillstyle(0,0);
- mouse.hide;
- getback;
- vocstop;
- vocoutput(cubesound);
- for t:=1 to 31 do
-  begin
-  for i:=215 to 231 do
-   begin
-    q:=round(sin(t/20)*45);
-    m:=round(51*(sqrt(2)-1)*0.5*sin(t/10));
-    part:=45/q;
-    for j:=133 to 145-m do screen[j,i]:=back1[i-215,j-133];
-    for j:=0 to q-1 do
-     begin
-      index:=round(j*part);
-      if index<46 then screen[j+145-m,i]:=cubetar^[index,i-215];
-     end;
-    if (45+2*m-q)=0 then goto skip1;
-    part:=45/(45+2*m-q);
-    for j:=145-m+q to 188+m do
-     begin
-      index:=round((j-145+m-q)*part);
-      if index<46 then screen[j,i]:=cubesrc^[index,i-215];
-     end;
-skip1:
-    for j:=190+m to 199 do screen[j,i]:=back2[i-215,j-190];
-   end;
-  for i:=232 to 249 do
-   begin
-    for j:=133 to 145-m do screen[j,i]:=back1[i-215,j-133];
-    q:=round(sin((31-t)/20)*45);
-    if q=0 then goto skip2;
-    part:=45/q;
-    for j:=0 to q-1 do
-     begin
-      index:=round(j*part);
-      if index<46 then screen[j+145-m,i]:=cubesrc^[index,i-215];
-     end;
-    if (45+2*m-q)=0 then goto skip2;
-    part:=45/(45+2*m-q);
-    for j:=145-m+q to 188+m do
-     begin
-      index:=round((j-145+m-q)* part);
-      if index<46 then screen[j,i]:=cubetar^[index,i-215];
-     end;
-skip2:
-    for j:=190+m to 199 do screen[j,i]:=back2[i-215,j-190];
-   end;
-  for i:=250 to 265 do
-   begin
-    q:=round(sin(t/20)*45);
-    part:=45/q;
-    for j:=133 to 145-m do screen[j,i]:=back1[i-215,j-133];
-    for j:=0 to q-1 do
-     begin
-      index:=round(j*part);
-      if index<46 then screen[j+145-m,i]:=cubetar^[index,i-215];
-     end;
-    if (45+2*m-q)=0 then goto skip3;
-    part:=45/(45+2*m-q);
-    for j:=145-m+q to 188+m do
-     begin
-      index:=round((j-145+m-q)* part);
-      if index<46 then screen[j,i]:=cubesrc^[index,i-215];
-     end;
-skip3:
-    for j:=190+m to 199 do screen[j,i]:=back2[i-215,j-190];
-   end;
-  end;
- for j:=0 to 50 do
-  for i:=0 to 44 do
-   screen[i+145,j+215]:=cubetar^[i,j];
- mouse.show;
- cube:=tar;
-end;
-
-procedure fading(n: integer);
-var a: integer;
-begin
- temppal:=colors;
- for a:=0 to n do
-  begin
-   for j:=0 to 255 do
-    for i:=0 to 2 do
-      temppal[j,i]:=temppal[j,i] - (temppal[j,i] div 4);
-   set256colors(temppal);
-   if a<n then delay(tslice*3);
-  end;
-  for j:=0 to 255 do for i:=0 to 2 do temppal[j,i]:=0;
-  set256colors(temppal);
-  delay(tslice*5);
-end;
-
-procedure fadein(n: integer);
-var a: integer;
-begin
- for j:=0 to 255 do for i:=0 to 2 do temppal[j,i]:=0;
- for a:=0 to n do
-  begin
-   for j:=0 to 255 do
-    for i:=0 to 2 do
-     temppal[j,i]:=temppal[j,i] + ((colors[j,i]-temppal[j,i]) div 4);
-   set256colors(temppal);
-   delay(tslice*3);
-  end;
- set256colors(colors);
- delay(tslice*5);
-end;
-
-procedure erasestars;
-begin
- for j:=0 to 100 do
-  if stars[j,4]=0 then screen[stars[j,2],stars[j,1]]:=2;
-end;
-
-procedure drawstars(x1,y1: integer);
-var x,y: integer;
-begin
- for j:=0 to 100 do
-  begin
-   x:=stars[j,1]+x1;
-   y:=stars[j,2]+y1;
-   if y>140 then y:=y-140
-    else if y<0 then y:=y+140;
-   if x>300 then x:=x-300
-    else if x<0 then x:=x+310;
-   stars[j,1]:=x;
-   stars[j,2]:=y;
-   if screen[y,x]=2 then stars[j,4]:=0
-    else stars[j,4]:=1;
-   if stars[j,4]=0 then screen[y,x]:=stars[j,3];
-  end;
-end;
-
-procedure fading2;
-var a: integer;
-begin
- temppal:=colors;
- for a:=25 downto 1 do
-  begin
-   for j:=0 to 255 do
-    for i:=1 to 3 do
-     temppal[j,i]:=round(a*temppal[j,i]/25);
-   set256colors(temppal);
-   delay(tslice*2);
-  end;
- for j:=0 to 255 do for i:=1 to 3 do temppal[j,i]:=0;
- set256colors(temppal);
- delay(tslice);
-end;
-
-procedure fadein2;
-var a: integer;
-begin
- for j:=0 to 255 do for i:=1 to 3 do temppal[j,i]:=0;
- for a:=1 to 25 do
-  begin
-   for j:=0 to 255 do
-    for i:=1 to 3 do
-     temppal[j,i]:=round(a*colors[j,i]/25);
-   set256colors(temppal);
-   delay(tslice*2);
-  end;
- set256colors(colors);
- delay(tslice);
-end;
-
- asm
-  push ds
-  push es
-  mov ax, seg screen
-  mov es, ax
-  mov di, offset screen
-  mov [tar1], es
-  mov [tar2], di
-
-  mov ax, [tempseg]
-  mov ds, ax
-  mov si, [tempofs]
-  mov [src1], es
-  mov [src2], si
-
-  mov [a], 199
-  mov bl, 160
- @@loopa:
-  mov ax, [a]
-  mov [i], ax
- @@loopi:
-  mov ax, [i]
-  mul bl
-  shl ax, 1
-  mov di, [tar2]
-  add di, ax
-  mov ax, [i]
-  sub ax, [a]
-  mul bl
-  shl ax, 1
-  mov si, [src2]
-  add si, ax
-  mov cx, 160
-  repe movsw
-  inc [i]
-  cmp [i], 200
-  jl @@loopi
-  dec [a]
-  cmp [a], 0
-  jg @@loopa
-  pop es
-  pop ds
- end;
-
-procedure staticin(s: string);
-var temp: ^screentype;
-    vgafile: file of screentype;
-    seed,total: word;
-begin
- new(temp);
- assign(vgafile,s);
- reset(vgafile);
- if ioresult<>0 then errorhandler(s);
- read(vgafile,temp^);
- close(vgafile);
- seed:=16;
- total:=800;
- repeat
-  dec(total);
-  for i:=192 to 223 do
-   colors[i]:=colors[223+random(32)];
-  set256colors(colors);
-  if total mod 15=0 then
-   begin
-    dec(seed);
-    for j:=0 to 319 do
-     for i:=0 to 199 do
-      if (temp^[i,j] mod 16=seed)
-       and (temp^[i,j]>0)
-       then screen[i,j]:=temp^[i,j];
-   end;
- until seed=0;
- total:=50;
- repeat
-  dec(total);
-    for i:=192 to 223 do
-     colors[i]:=colors[223+random(32)];
-    set256colors(colors);
-  delay(tslice*3);
- until total=0;
- total:=800;
- seed:=16;
- repeat
-  dec(total);
-  for i:=192 to 223 do
-   colors[i]:=colors[223+random(32)];
-  set256colors(colors);
-  if total mod 15=0 then
-   begin
-    dec(seed);
-    for j:=0 to 319 do
-     for i:=0 to 199 do
-      if (temp^[i,j] mod 16=seed)
-       then screen[i,j]:=random(32)+192;
-   end;
- until seed=0;
- dispose(temp);
-end;
-
-procedure glass(x1,y1,x2: integer);
-var i,j: integer;
-begin
- for j:=x1-6 to x2 do
-  for i:=y1 to y1+10 do screen[i,j]:=0;
- setfillstyle(1,7);
- setcolor(5);
- pieslice(x1,y1+5,90,270,6);
- for j:=x1 to x2 do
-  begin
-   index:=7;
-   for i:=y1 to y1+10 do
-    begin
-     if (i-y1)>3 then dec(index,2) else inc(index,2);
-     screen[i,j]:=index;
-   end;
-  end;
-end;
-
-
- for a:=0 to 319 do
-  begin
-   for b:=0 to 149 do
-    begin
-     x:=a+backgrx;
-     if x>319 then x:=x-319;
-     y:=b+backgry;
-     if y>199 then y:=y-199;
-     if temp^[b,a]=255 then screen[b,a]:=backgr^[y,x];
-    end;
-   if voc.statusword=0 then
-    begin
-     inc(speed^,20);
-     voc.output(vocptr);
-    end;
-  end;
- setwritemode(xorput);
- while t<471 do
-  begin
-   inc(t,2);
-   if t>471 then t:=471;
-   delay(tslice);
-   if t>470 then delay(tslice*15);
-   if voc.statusword=0 then
-    begin
-     inc(speed^,20);
-     voc.output(vocptr);
-    end;
-  end;
- for a:=40 downto 1 do
-  begin
-   setcolor(95);
-   if a>20 then
-    begin
-     moveto(160+round((a-20)*cos(t/100)),70+round((a-20)*sin(t/100)));
-     lineto(160+round((a-20)*cos(t/100+2.09)),70+round((a-20)*sin(t/100+2.09)));
-     lineto(160+round((a-20)*cos(t/100+4.18)),70+round((a-20)*sin(t/100+4.18)));
-     lineto(160+round((a-20)*cos(t/100)),70+round((a-20)*sin(t/100)));
-    end;
-   moveto(160+round(a*cos(-t/100)),70+round(40*sin(-t/100)));
-   lineto(160+round(a*cos(-t/100+2.09)),70+round(40*sin(-t/100+2.09)));
-   lineto(160+round(a*cos(-t/100+4.18)),70+round(40*sin(-t/100+4.18)));
-   lineto(160+round(a*cos(-t/100)),70+round(40*sin(-t/100)));
-   setcolor(0);
-   if a>20 then
-    begin
-     moveto(160+round((a-20)*cos(t/100)),70+round((a-20)*sin(t/100)));
-     lineto(160+round((a-20)*cos(t/100+2.09)),70+round((a-20)*sin(t/100+2.09)));
-     lineto(160+round((a-20)*cos(t/100+4.18)),70+round((a-20)*sin(t/100+4.18)));
-     lineto(160+round((a-20)*cos(t/100)),70+round((a-20)*sin(t/100)));
-    end;
-   moveto(160+round(a*cos(-t/100)),70+round(40*sin(-t/100)));
-   lineto(160+round(a*cos(-t/100+2.09)),70+round(40*sin(-t/100+2.09)));
-   lineto(160+round(a*cos(-t/100+4.18)),70+round(40*sin(-t/100+4.18)));
-   lineto(160+round(a*cos(-t/100)),70+round(40*sin(-t/100)));
-  end;
- setwritemode(0);
- for a:=0 to 70 do
-  begin
-   for i:=69 downto 1 do
-    if i>0 then move(backgr^[i-1],backgr^[i],320);
-   fillchar(backgr^[0],320,0);
-   for i:=71 to 140 do
-    if i<140 then move(backgr^[i+1],backgr^[i],320);
-   fillchar(backgr^[140],320,0);
-   for j:=0 to 319 do
-    begin
-     for i:=0 to 69 do
-      if temp^[i,j]=255 then screen[i,j]:=backgr^[i,j];
-     for i:=71 to 140 do
-      if temp^[i,j]=255 then screen[i,j]:=backgr^[i,j];
-    end;
-   setcolor(round(a*0.376));
-   line(40,70,280,70);
-   setcolor(round(a*0.188));
-   line(80,69,240,69);
-   line(80,71,240,71);
-   setcolor(round(a*0.094));
-   line(120,68,200,68);
-   line(120,72,200,72);
-   if voc.statusword=0 then
-    begin
-     if speed^<180 then inc(speed^,17);
-     voc.output(vocptr);
-    end;
-  end;
-
-
-procedure loadshipdisplay(x,y: char);
-var shipfile: file of shipdistype;
-    temp: ^shipdistype;
-    x1: integer;
-begin
- new(temp);
- assign(shipfile,'data\ship'+x+y+'.dta');
- reset(shipfile);
- if ioresult<>0 then errorhandler('data\ship'+x+y+'.dta',1);
- read(shipfile,temp^);
- close(shipfile);
- case y of
-  'A':x1:=60;
-  'B':x1:=118;
-  'C':x1:=176;
- end;
- for j:=0 to 57 do
-  for i:=0 to 74 do
-   if (temp^[j,i]=0) or (temp^[j,i]=38) then temp^[j,i]:=4;
- for j:=x1 to x1+57 do
- begin
-  for i:=0 to 74 do
-   begin
-    if temp^[j-x1,i]<>4 then screen[61+i div 4,186+j div 4]:=temp^[j-x1,i];
-    i:=i+2;
-    if i>74 then i:=74
-   end;
-  j:=j+3;
-  if j>x1+57 then j:=x1+57;
- end;
- dispose(temp);
-end;
-
-procedure displayship;
-var str1: string;
-begin
- case ship.shiptype[1] of
-  'A':loadshipdisplay('1','A');
-  'B':loadshipdisplay('2','A');
-  'C':loadshipdisplay('3','A');
- end;
- case ship.shiptype[2] of
-  '1':loadshipdisplay('1','B');
-  '2':loadshipdisplay('2','B');
-  '3':loadshipdisplay('3','B');
- end;
- case ship.shiptype[3] of
-  'X':loadshipdisplay('1','C');
-  'Y':loadshipdisplay('2','C');
-  'Z':loadshipdisplay('3','C');
- end;
-end;
-
-procedure displayshortscan;
-begin
- setwritemode(xorput);
- setcolor(120);
- mouse.hide;
- rectangle(198-scanindex,58-scanindex,246+scanindex,82+scanindex);
- inc(scanindex);
- if scanindex<31 then inc(scanindex) else scanindex:=0;
- if scanindex=0 then playvoice(19);
- rectangle(198-scanindex,58-scanindex,246+scanindex,82+scanindex);
- rectangle(198-scanindex2,58-scanindex2,246+scanindex2,82+scanindex2);
- inc(scanindex2);
- if scanindex2<31 then inc(scanindex2) else scanindex2:=0;
- if scanindex2=0 then playvoice(19);
- rectangle(198-scanindex2,58-scanindex2,246+scanindex2,82+scanindex2);
- mouse.show;
- setwritemode(copyput);
-end;
-
-procedure readyshortscan;
- viewmode:=2;
- tcolor:=63;
- println;
- print('INITIALIZING SHORT RANGE SCAN');
- bkcolor:=0;
- mouse.hide;
- setcolor(44);
- setlinestyle(0,0,3);
- rectangle(165,25,279,115);
- setcolor(47);
- setlinestyle(0,0,0);
- rectangle(165,25,279,115);
- rotatemapin(167,27,277,113);
- for j:=1 to 13 do
-  for i:=27 to 113 do
-   screen[i,166+j*8]:=33;
- for i:=1 to 10 do
-  fillchar(screen[26+i*8,167],110,33);
- displayship;
- setwritemode(xorput);
- setcolor(120);
- rectangle(198-scanindex,58-scanindex,246+scanindex,82+scanindex);
- rectangle(198-scanindex2,58-scanindex2,246+scanindex2,82+scanindex2);
- playvoice(19);
- displayshortscan;
- mouse.show;
- anychange:=true;
-end;
-
-procedure makeastoroid;
-label endcheck;
-begin
- for i:=6 to 2*r2+4 do
-   begin
-    y:=sqrt(radius-sqr(i-r2-5));
-    m:=round((r2-y)*c2);
-    part:=r2/y;
-    alt:=0;
-    ofsy:=i+offset;
-    for j:=1 to 2*r2+10 do
-     begin
-      index:=round(j*part);
-      if index>2*r2+10 then goto endcheck;
-      ofsx:=j+m+offset;
-      if (ecl>170) then alt:=(index-ecl+186) div 2
-       else if (ecl<171) and (index<ecl) then alt:=(ecl-index) div 2
-       else alt:=0;
-      if alt<0 then alt:=0;
-      if (index+c)>240 then j2:=index+c-240
-       else j2:=index+c;
-      if alt>round(landform^[j2,i]*part2) then planet^[ofsy,ofsx]:=0
-       else planet^[ofsy,ofsx]:=round(landform^[j2,i]*part2)-alt+1;
-endcheck:
-     end;
-   end;
- mouse.hide;
- for i:=1 to 120 do
-  mymove(planet^[i],screen[i+12,28],30);
- mouse.show;
-end;
-
-procedure makeastoroid;
-label endcheck;
-begin
- for i:=6 to 2*r2+4 do
-   begin
-    y:=sqrt(radius-sqr(i-r2-5));
-    m:=round((r2-y)*c2);
-    part:=r2/y;
-    alt:=0;
-    ofsy:=i+offset;
-    for j:=1 to 2*r2+10 do
-     begin
-      index:=round(j*part);
-      if index>2*r2+10 then goto endcheck;
-      ofsx:=j+m+offset;
-      if (ecl>170) then alt:=(index-ecl+186) div 2
-       else if (ecl<171) and (index<ecl) then alt:=(ecl-index) div 2
-       else alt:=0;
-      if alt<0 then alt:=0;
-      if (index+c)>240 then j2:=index+c-240
-       else j2:=index+c;
-      if alt>round(landform^[j2,i]*part2) then planet^[ofsy,ofsx]:=0
-       else planet^[ofsy,ofsx]:=round(landform^[j2,i]*part2)-alt+1;
-endcheck:
-     end;
-   end;
- mouse.hide;
- for i:=1 to 120 do
-  mymove(planet^[i],screen[i+12,28],30);
- mouse.show;
-end;
-
-procedure lowerball;
-var anifile: file of aniarraytype;
-begin
- new(ani);
- assign(anifile,'data\charani.dta');
- reset(anifile);
- if ioresult<>0 then errorhandler('charani.dta',1);
- read(anifile,ani^);
- if ioresult<>0 then errorhandler('charani.dta',5);
- close(anifile);
- for j:=0 to 30 do
-  begin
-   for i:=0 to 34 do
-    mymove(ani^[j,i],screen[i+81,22],12);
-   delay(tslice div 2);
-  end;
- dispose(ani);
-end;
-
-procedure raiseball;
-var anifile: file of aniarraytype;
-begin
- new(ani);
- assign(anifile,'data\charani.dta');
- reset(anifile);
- if ioresult<>0 then errorhandler('charani.dta',1);
- read(anifile,ani^);
- if ioresult<>0 then errorhandler('charani.dta',5);
- close(anifile);
- for j:=30 downto 0 do
-  begin
-   for i:=0 to 34 do
-    mymove(ani^[j,i],screen[i+81,22],12);
-   delay(tslice div 2);
-  end;
- dispose(ani);
-end;
-
-procedure rotatemapin(x1,y1,x2,y2: integer);
-var n: integer;
-begin
- if ship.options[6]=0 then
-  begin
-   mousehide;
-   j:=x2-x1+1;
-   for i:=y1 to y2 do
-    fillchar(screen[i,x1],j,4);
-   mouseshow;
-   exit;
-  end;
- n:=(x2-x1) div 2;
- for a:=(x2-x1) downto 1 do
-  begin
-   for i:=y1 to y2 do
-    begin
-     index:=n+1;
-     for j:=n+x1 downto x1 do
-      if j mod a=0 then
-       begin
-        dec(index);
-        screen[i,index+x1]:=4;
-       end;
-     for j:=index+x1 downto x1 do screen[i,j]:=0;
-     index:=n-1;
-     for j:=n+x1 to x2 do
-      if j mod a=0 then
-       begin
-        inc(index);
-        screen[i,index+x1]:=4;
-       end;
-     for j:=index+x1 to x2 do screen[i,j]:=0;
-    end;
-   a:=round(a*0.8);
-   if a=0 then exit;
-   delay(tslice);
-  end;
- j:=x2-x1+1;
- for i:=y1 to y2 do
-  fillchar(screen[i,x1],j,4);
-end;
-
-procedure rotatemapout(x1,y1,x2,y2: integer);
-var n: integer;
-begin
- if ship.options[6]=0 then
-  begin
-   mousehide;
-   j:=x2-x1+1;
-   for i:=y1 to y2 do
-    fillchar(screen[i,x1],j,0);
-   mouseshow;
-   exit;
-  end;
- n:=(x2-x1) div 2;
- for a:=1 to 25 do
-  begin
-   for i:=y1 to y2 do
-    begin
-     index:=n+1;
-     for j:=n+x1 downto x1 do
-      if j mod a=0 then
-       begin
-        dec(index);
-        screen[i,index+x1]:=starmapscreen^[i,j];
-       end;
-     for j:=index+x1 downto x1 do screen[i,j]:=0;
-     index:=n-1;
-     for j:=n+x1 to x2 do
-      if j mod a=0 then
-       begin
-        inc(index);
-        screen[i,index+x1]:=starmapscreen^[i,j];
-       end;
-     for j:=index+x1 to x2 do screen[i,j]:=0;
-    end;
-   if a>25 then exit;
-   a:=round(a*1.2);
-   delay(tslice);
-  end;
-end;
-
-procedure rotatescanout(x1,y1,x2,y2: integer);
-var n: integer;
-begin
- if ship.options[6]=0 then
-  begin
-   mousehide;
-   j:=x2-x1+1;
-    for i:=y1 to y2 do
-     fillchar(screen[i,x1],j,4);
-   mouseshow;
-   exit;
-  end;
- n:=(x2-x1) div 2;
- for a:=1 to 25 do
-  begin
-   for i:=y1 to y2 do
-    begin
-     index:=n+1;
-     for j:=n+x1 downto x1 do
-      if j mod a=0 then
-       begin
-        dec(index);
-        screen[i,index+x1]:=template2^[i,j];
-       end;
-     for j:=index+x1 downto x1 do screen[i,j]:=0;
-     index:=n-1;
-     for j:=n+x1 to x2 do
-      if j mod a=0 then
-       begin
-        inc(index);
-        screen[i,index+x1]:=template2^[i,j];
-       end;
-     for j:=index+x1 to x2 do screen[i,j]:=0;
-    end;
-   if a>25 then exit;
-   a:=round(a*1.2);
-   delay(tslice);
-  end;
- j:=x2-x1+1;
- for i:=y1 to y2 do
-  fillchar(screen[i,x1],j,4);
-end;
-
-procedure setflag(flag: byte);
-begin
- biostsbyte:=biostsbyte or flag;
- asm
-  mov ah, 1
-   int 16h
- end;
-end;
-
-procedure clrflag(flag : byte);
-begin
- biostsbyte:=biostsbyte and (not flag);
- asm
-  mov ah, 1
-   int 16h
- end;
-end;
-
-procedure zoomplanet2;
-var indexi,indexj,a: integer;
-    c2: real;
-begin
- mousehide;
- for a:=80 downto 1 do
-  begin
-   if a>10 then
-    begin
-     c2:=sin(a/120*1.57);
-     scrollback(round(c2*-4),0);
-     dec(a);
-    end
-   else if a>5 then
-    begin
-     c2:=cos(a/10*1.57);
-     scrollback(round(c2*2),round(c2*2));
-    end;
-   indexi:=0;
-   i:=12;
-   repeat
-    inc(indexi,a);
-    inc(i);
-    indexj:=0;
-    j:=26;
-    repeat
-     inc(indexj,a);
-     inc(j);
-     if (indexi<121) and (indexj<121) then screen[i,j+a]:=planet^[indexi,indexj];
-    until (indexj>119);
-   until (indexi>119);
-   if a>10 then delay(tslice div 2)
-    else delay(round(c2*tslice*7));
-  end;
- mouseshow;
-end;
-
-procedure zoomplanet;
-var indexi,indexj,a: integer;
-    c2: real;
-begin
- mousehide;
- for a:=80 downto 1 do
-  begin
-   if a>10 then
-    begin
-     c2:=sin(a/120*1.57);
-     scrollback(round(c2*-4),round(c2*-4));
-     dec(a);
-    end
-   else if a>5 then
-    begin
-     c2:=cos(a/10*1.57);
-     scrollback(round(c2*2),round(c2*2));
-    end;
-   indexi:=0;
-   i:=11;
-   repeat
-    inc(indexi,a);
-    inc(i);
-    indexj:=0;
-    j:=26;
-    repeat
-     inc(indexj,a);
-     inc(j);
-     if (indexi<121) and (indexj<121) then screen[i+a,j+a]:=planet^[indexi,indexj];
-    until (indexj>119);
-   until (indexi>119);
-   if a>10 then delay(tslice div 2)
-    else delay(round(c2*tslice*7));
-  end;
- mouseshow;
-end;
-
-procedure removeplanet;
-var indexi,indexj,a,a2: integer;
-    c2: real;
-begin
- if not showplanet then exit;
- mousehide;
- for a:=1 to 80 do
-  begin
-   addtime;
-   showtime;
-   indexi:=0;
-   i:=72-round(60/a);
-   repeat
-    inc(indexi,a);
-    inc(i);
-    indexj:=0;
-    j:=87-round(60/a);
-    repeat
-     inc(indexj,a);
-     inc(j);
-     if (indexi<121) and (indexj<121) then screen[i,j]:=planet^[indexi,indexj];
-    until (indexj>119);
-   until (indexi>119);
-   for i:=13 to 72-round(60/a) do
-    begin
-     a2:=backgry+i;
-     if a2>199 then a2:=a2-200;
-     for j:=27 to 146 do
-      begin
-       b:=backgrx+j;
-       if b>319 then b:=b-320;
-       screen[i,j]:=backgr^[a2,b];
-      end;
-    end;
-   for i:=72+round(60/a) to 131 do
-    begin
-     a2:=backgry+i;
-     if a2>199 then a2:=a2-200;
-     for j:=27 to 146 do
-      begin
-       b:=backgrx+j;
-       if b>319 then b:=b-320;
-       screen[i,j]:=backgr^[a2,b];
-      end;
-    end;
-   for i:=73-round(60/a) to 71+round(60/a) do
-    begin
-     a2:=backgry+i;
-     if a2>199 then a2:=a2-200;
-     for j:=26 to 87-round(60/a) do
-      begin
-       b:=backgrx+j;
-       if b>319 then b:=b-320;
-       screen[i,j]:=backgr^[a2,b];
-      end;
-     for j:=87+round(60/a) to 147 do
-      begin
-       b:=backgrx+j;
-       if b>319 then b:=b-320;
-       screen[i,j]:=backgr^[a2,b];
-      end;
-    end;
-   delay(tslice div 2)
-  end;
- mouseshow;
-end;
-
-procedure engage2(x1,y1: integer);
-var vgafile: file of screentype;
-    temp: ^screentype;
-    c2: real;
-begin
- new(temp);
- assign(vgafile,'data\main2.vga');
- reset(vgafile);
- if ioresult<>0 then errorhandler('main2.vga',1);
- read(vgafile,temp^);
- if ioresult<>0 then errorhandler('main2.vga',5);
- close(vgafile);
- setcolor(95);
- i:=0;
- t:=0;
- if y1>0 then
-  repeat
-   inc(t,2);
-   for a:=0 to 319 do
-    for b:=0 to 149 do
-     begin
-      x:=a+backgrx;
-      if x>319 then x:=x-320;
-      y:=b+backgry;
-      if y>199 then y:=y-200;
-      if temp^[b,a]=255 then screen[b,a]:=backgr^[y,x];
-     end;
-   if y1>0 then inc(backgry,round(4*sin(i/y1*3.14)))
-    else dec(backgry,round(4*sin(i/y1*3.14)));
-   if backgry>199 then backgry:=backgry-200
-    else if backgry<0 then backgry:=backgry+200;
-   if y1>0 then inc(i) else dec(i);
-   inc(t,2);
-  until i=y1;
- j:=0;
- if x1>0 then
-  repeat
-   inc(t,2);
-   for a:=0 to 319 do
-    for b:=0 to 149 do
-     begin
-      x:=a+backgrx;
-      if x>319 then x:=x-320;
-      y:=b+backgry;
-      if y>199 then y:=y-200;
-      if temp^[b,a]=255 then screen[b,a]:=backgr^[y,x];
-     end;
-   if x1>0 then inc(backgrx,round(4*sin(j/x1*3.14)))
-    else dec(backgrx,round(4*sin(j/x1*3.14)));
-   if backgrx>319 then backgrx:=backgrx-320
-    else if backgrx<0 then backgrx:=backgrx+320;
-   if x1>0 then inc(j) else dec(j);
-   inc(t,2);
-  until j=x1;
- t:=1;
- for j:=0 to 319 do
-  begin
-   x1:=backgrx+j;
-   if x1>319 then x1:=x1-320;
-   for i:=0 to 199 do
-    begin
-     y1:=backgry+i;
-     if y1>199 then y1:=y1-200;
-     temp^[y1,x1]:=backgr^[i,j];
-    end;
-  end;
- mymove(temp^,backgr^,16000);
- backgrx:=0;
- backgry:=0;
- dispose(temp);
- for a:=1 to 55 do
-  begin
-   addlotstime(17);
-   showtime;
-   for j:=1 to 319 do
-    begin
-     for i:=1 to 199 do
-      if (backgr^[i,j]<>0) and (backgr^[i,j]<32) then
-       begin
-        x:=j+round((160-j)/200*a);
-        y:=i+round((70-i)/200*a);
-        backgr^[y,x]:=backgr^[i,j]+34;
-        if (y<>i) or (j<>x) then backgr^[i,j]:=0;
-       end;
-    end;
-   for j:=0 to 319 do
-    for i:=0 to 199 do
-     if backgr^[i,j]>31 then dec(backgr^[i,j],32);
-   scrollback(0,0);
-   delay(tslice div 6);
-  end;
-end;
-
-
-procedure scrollback(x1,y1: integer);
-var temp: ^screentype;
-    vgafile: file of screentype;
-begin
- new(temp);
- assign(vgafile,'data\main2.vga');
- reset(vgafile);
- if ioresult<>0 then errorhandler('main2.vga',1);
- read(vgafile,temp^);
- close(vgafile);
- backgry:=backgry+y1;
- backgrx:=backgrx+x1;
- if backgrx>319 then backgrx:=backgrx-320
-  else if backgrx<0 then backgrx:=backgrx+320;
- if backgry>199 then backgry:=backgry-200
-  else if backgry<0 then backgry:=backgry+200;
- for a:=0 to 319 do
-  for b:=0 to 149 do
-   begin
-    j:=a+backgrx;
-    if j>319 then j:=j-320;
-    i:=b+backgry;
-    if i>199 then i:=i-200;
-    if temp^[b,a]=255 then screen[b,a]:=backgr^[i,j];
-   end;
- dispose(temp);
-end;
-
-procedure focus;
-var temp: ^screentype;
-    a: integer;
-    vgafile: file of screentype;
-begin
- new(temp);
- mymove2(screen,temp^,16000);
- for a:=2 to 17 do
-  begin
-  for j:=0 to 319 do
-   begin
-    for i:=0 to 199 do
-     begin
-      setfillstyle(1,temp^[i,j]);
-      bar(j-a div 2,i-a div 2,j+a div 2,i+a div 2);
-      i:=i+a;
-      if i>199 then i:=199;
-     end;
-    j:=j+a;
-    if j>319 then j:=319;
-   end;
-   delay(tslice div 2);
-  end;
- assign(vgafile,'data\destiny.vga');
- reset(vgafile);
- read(vgafile,temp^);
- close(vgafile);
- loadpal('data\destiny.pal');
- for a:=17 downto 2 do
-  begin
-  if a=8 then set256colors(colors);
-  for j:=0 to 319 do
-   begin
-    for i:=0 to 199 do
-     begin
-      setfillstyle(1,temp^[i,j]);
-      bar(j-a div 2,i-a div 2,j+a div 2,i+a div 2);
-      i:=i+a;
-      if i>199 then i:=199;
-     end;
-    j:=j+a;
-    if j>319 then j:=319;
-   end;
-  delay(tslice div 2);
- end;
- screen:=temp^;
- dispose(temp);
-end;
-
-
-{ for i:=23 to 56 do
-  fillchar(screen[i,194],118,0);
- tcolor:=47;
- printxy(194,23,'SCANNING EM BANDS');
- for a:=1 to 2000 do
-  begin
-   t1:=t1+0.01;
-   if t1=6.28 then t1:=0;
-   for b:=0 to 34 do
-    begin
-     j:=abs(round(20*(sin(b*0.09+t1))));
-     x:=20;
-     for i:=0 to j do
-      begin
-       screen[55-j,b*3+199]:=x;
-       screen[55-j,b*3+200]:=x;
-      end;
-     screen[54-j,b*3+199]:=0;
-     screen[54-j,b*3+200]:=0;
-    end;
-  end;
- sprinkle(194,30,311,56,17);
- printxy(194,23,'AQUIRING TRANSMISSION');
- printxy(194,23,'ANALYZING DATA STREAM');
- y:=0;
- x:=0;
- for a:=1 to 5000 do
-  begin
-   printxy(x*5+194,y*6+31,chr(48+random(2)));
-   inc(x);
-   if x>20 then
-    begin
-     x:=0;
-     inc(y);
-     if y>3 then y:=0;
-    end;
-   delay(tslice div 10);
-  end;
- sprinkle(194,30,311,56,17);
- printxy(194,23,'INITIALIZE CYPHER KEY');
- t:=ptr(random(1000),0);
- for a:=1 to 2000 do
-  begin
-   inc(t);
-   printxy(x*5+194,y*6+31,t^);
-   inc(x);
-   if x>20 then
-    begin
-     x:=0;
-     inc(y);
-     if y>3 then y:=0;
-    end;
-   delay(tslice div 10);
-  end;
- sprinkle(194,30,311,56,17);
- printxy(194,23,'MATRIX ESTABLISHED   ');
- for i:=29 to 55 do
-  fillchar(screen[i,194],118,0);
- printxy(194,29,'TRANSFERING CYPHER');
-}
-
-
-
-{----------------------------------------------------------------------------}
-procedure displaysanity;
-begin
- j:=ship.crew[crewindex].san;
- if j>100 then j:=100 else if j<1 then j:=1;
- t1:=22/(j*0.64);
- for i:=88 downto 88-round(j*0.64) do
-  fillchar(screen[i,303],10,round((88-i)*t1)+73);
- if j<100 then
-  for i:=24 to 88-round(j*0.65) do
-   fillchar(screen[i,303],10,0);
-end;
-
-procedure redraw2;
-var a: integer;
-    s: string[20];
-begin {120,37,294,112}
- mousehide;
- displaycursor;
- drawstats(crewindex);
- showportrait(ship.crew[crewindex].index);
- s:=ship.crew[crewindex].name;
- i:=20;
- while (i>1) and (s[i]=' ') do dec(i);
- s[0]:=chr(i);
- for i:=103 to 108 do
-  fillchar(screen[i,121],119,0);
- x:=ship.crew[crewindex].emo;
- y:=ship.crew[crewindex].phy;
- z:=ship.crew[crewindex].men;
- printxy(123+(120-length(s)*6) div 2,103,s);
- str(ship.crew[crewindex].xp:10,s);
- for i:=1 to 7 do if s[i]=' ' then s[i]:='0';
- printxy(198,120,s);
- str(ship.crew[crewindex].level:2,s);
- printxy(154,120,s);
- displaylevel(ship.crew[crewindex].level);
- displaysanity;
- case ship.crew[crewindex].men of
-    0..5: s:='         Braindead';
-   6..19: s:='           Foolish';
-  20..39: s:='     Below Average';
-  40..59: s:='           Average';
-  60..79: s:='Highly Intelligent';
-  80..98: s:='            Genius';
-      99: s:='       Supragenius';
-  else errorhandler('crew bug 1',6);
- end;
- printxy(140,137,s);
- case ship.crew[crewindex].phy of
-    0..5: s:='   Skeletal';
-   6..19: s:=' Ill Health';
-  20..39: s:='Poor Health';
-  40..59: s:='    Average';
-  60..79: s:='  Atheletic';
-  80..98: s:='   Powerful';
-      99: s:='  Herculean';
-  else errorhandler('crew bug 2',6);
- end;
- printxy(175,144,s);
- case ship.crew[crewindex].emo of
-    0..5: s:='  Psychotic';
-   6..19: s:='   Neurotic';
-  20..39: s:='   Unstable';
-  40..59: s:='    Average';
-  60..79: s:='       Calm';
-  80..98: s:='    Logical';
-      99: s:='Calculating';
-  else errorhandler('crew bug 3',6);
- end;
- printxy(175,151,s);
- i:=round((y+x*y/100)/100) mod 100;
- if i<0 then i:=0;
- case i of
-   0..24: s:=' Introverted';
-  25..49: s:='    Reserved';
-  50..74: s:='    Friendly';
-  75..99: s:='Affectionate';
-  else errorhandler('crew bug 4',6);
- end;
- printxy(170,158,s);
- if y=0 then i:=z else i:=round(z-x/y) mod 100;
- if i<0 then i:=0;
- case i of
-   0..24: s:='Unscrupulous';
-  25..49: s:='  Suspicious';
-  50..74: s:='   Concerned';
-  75..99: s:=' Sympathetic';
-  else errorhandler('crew bug 5',6);
- end;
- printxy(170,165,s);
- i:=abs(round(x-z/4+y/4)) mod 100;
- if i<0 then i:=0;
- case i of
-    0..24: s:='     Ruthless';
-   25..49: s:='Uncooperative';
-   50..74: s:='     Trusting';
-   75..99: s:='  Softhearted';
-   else errorhandler('crew bug 7',6);
- end;
- printxy(165,172,s);
- if x=0 then i:=z else i:=round(z-y/x) mod 100;
- if i<0 then i:=0;
- case i of
-   0..24: s:=' Conforming';
-  25..49: s:='  Practical';
-  50..74: s:='Independent';
-  75..99: s:='Imaginative';
-  else errorhandler('crew bug 8',6);
- end;
- printxy(175,179,s);
- i:=abs(2*z-y-x) mod 100;
- if i<0 then i:=0;
- case i of
-   0..24: s:='  Slothful';
-  25..49: s:='  Carefree';
-  50..74: s:='Restrained';
-  75..99: s:='Compulsive';
-  else errorhandler('crew bug 9',6);
- end;
- printxy(180,186,s);
- mouseshow;
-end;
-
-procedure findmouse2;
-var before: integer;
-begin
- if not mouse.getstatus(left) then exit;
- before:=crewindex;
- case mouse.x of
-  280..297: case mouse.y of
-             146..160: if crewindex=1 then crewindex:=6 else dec(crewindex);
-             162..176: if crewindex=6 then crewindex:=1 else inc(crewindex);
-            end;
-  302..311: if (mouse.y>154) and (mouse.y<170) then done:=true;
- end;
- if before<>crewindex then redraw2;
- idletime:=0;
-end;
-
-procedure processkey2;
-var ans: char;
-    before: integer;
-begin
- ans:=readkey;
- before:=crewindex;
- case ans of
-  #27: done:=true;
-  #0: begin
-       ans:=readkey;
-       case ans of
-        #72: if crewindex=1 then crewindex:=6 else dec(crewindex);
-        #80: if crewindex=6 then crewindex:=1 else inc(crewindex);
-       end;
-      end;
-  '`': bossmode;
- end;
- if before<>crewindex then redraw2;
- idletime:=0;
-end;
-
-procedure mainloop2;
-begin
- repeat
-  findmouse2;
-  if fastkeypressed then processkey2;
-  inc(idletime);
-  if idletime=maxidle then screensaver;
-  adjustgraph;
-  adjustlights;
-  if mouseindex<6 then inc(mouseindex) else mouseindex:=0;
-  mousehide;
-  mousesetcursor(mcursor^[mouseindex]);
-  mouseshow;
-  if msgindex<32 then inc(msgindex) else msgindex:=0;
-  if msgindex=0 then displaymsg
-  else displaylittlemsgs;
-  delay(tslice*5);
- until done;
-end;
-
-procedure readypsychicdata;
-begin
- mousehide;
- compressfile(tempdir+'\current.vga',@screen);
- fading;
- playmod(true,'sound\creweval.mod');
- loadscreen('data\char3.vga',@screen);
- new(mcursor);
- new(holo);
- new(msgs);
- new(littlemsgs);
- for a:=0 to 6 do
-  for i:=0 to 15 do
-   mymove(screen[i+180,10+a*17],mcursor^[a,i],4);
- for i:=35 to 63 do
-  mymove(screen[i,84],holo^[i,84],9);
- for a:=0 to 8 do
-  for i:=0 to 8 do
-   mymove(screen[(a div 3)*10+145+i,(a mod 3)*40+10],msgs^[a,i],10);
- for a:=0 to 7 do
-  for i:=0 to 4 do
-   mymove(screen[(a div 2)*10+145+i,(a mod 2)*20+130],littlemsgs^[a,i],4);
- for i:=130 to 196 do
-  fillchar(screen[i,4],262,0);
- tcolor:=176;
- printxy(19,137,'Mental Capacity');
- printxy(16,144,'Physical Prowess');
- printxy(9,151,'Emotional Stability');
- printxy(27,158,'Extroversion');
- printxy(14,165,'Conscientiousness');
- printxy(24,172,'Agreeableness');
- printxy(32,179,'Creativity');
- printxy(32,186,'Discipline');
- graphindex:=0;
- adjustgraph;
- crewindex:=1;
- mouseindex:=0;
- displaycursor;
- tcolor:=170;
- bkcolor:=0;
- redraw2;
- fadein;
- mouseshow;
- done:=false;
- graphindex:=1;
- msgindex:=32;
- oldt1:=t1;
-end;
-
-procedure psychicevaluation;
-begin
- readypsychicdata;
- mainloop2;
- dispose(littlemsgs);
- dispose(msgs);
- dispose(holo);
- dispose(mcursor);
- stopmod;
- removedata;
-end;
-
-
-procedure getspikes;
-var tech: integer;
-begin
- tech:=hi(ship.wandering.techlevel)*10+lo(ship.wandering.techlevel);
- randseed:=ship.wandering.alienid*ship.wandering.alienid*ship.wandering.alienid;
- for j:=1 to 4 do spikes[1,j]:=random(249)+31;
- randomize;
- for j:=1 to 4 do spikes[2,j]:=0;
- j:=1;
- randseed:=ship.wandering.alienid;
- while (tech>0) and (j<4) do
-  begin
-   spikes[2,j]:=random(tech)+random(4);
-   tech:=tech-spikes[2,j]+random(4);
-   inc(j);
-  end;
- if tech>0 then spikes[2,4]:=tech;
- randomize;
-end;
-
-procedure drawscope;
-begin
- randseed:=tempplan^[curplan].seed;
- if showplanet then
-  begin
-   x1:=random(628)/100;
-   i:=random(20)+4;
-   x:=round(cos(x1)*i)+250;
-   y:=round(sin(x1)*i)+150;
-   for j:=0 to 35+random(20) do
-    begin
-     x1:=random(628)/100;
-     i:=random(7);
-     screen[round(i*sin(x1))+y,round(i*cos(x1))+x]:=random(31);
-    end;
-  end;
- for j:=0 to random(45)+15 do
-  begin
-   x1:=random(628)/100;
-   i:=random(30);
-   screen[round(i*sin(x1))+150,round(i*cos(x1))+250]:=random(31);
-  end;
- for i:=120 to 180 do
-  mymove(screen[i,210],scope^[i,210],20);
- randomize;
-end;
-
-procedure drawcleangraph;
-begin
- mousehide;
- randomize;
- if ship.wandering.alienid<16000 then
-  begin
-   dist:=ship.wandering.relx;
-   if ship.wandering.rely>dist then dist:=ship.wandering.rely;
-   if ship.wandering.relz>dist then dist:=ship.wandering.relz;
-   dist:=abs(round(dist/1280));
-  end
- else dist:=18;
- for i:=21 to 49 do
-  fillchar(screen[i,31],249,0);
- for i:=61 to 89 do
-  fillchar(screen[i,31],249,0);
- for j:=31 to 279 do screen[43,j]:=random(22)+8;
- for j:=1 to 4 do if spikes[2,j]>0 then
-  begin
-   signaly:=round(spikes[2,j]*(19-dist)*ship.crew[3].level/3150*spikes[2,j]);
-   if signaly>18 then signaly:=18;
-   if ship.wandering.alienid<16000 then screen[40-signaly,spikes[1,j]]:=random(22)+8;
-  end;
- line(31,64+dist,279,64+dist);
- if (ship.wandering.alienid<16000) then
-  begin
-   x:=ship.wandering.relx;
-   y:=ship.wandering.rely;
-   z:=ship.wandering.relz;
-   x:=round((x+z)*0.0005);
-   y:=round((y+z)*0.0005);
-   scope^[150+y,250+x]:=random(10)+7;
-  end;
- for i:=120 to 180 do
-  mymove(scope^[i,210],screen[i,210],20);
- mouseshow;
-end;
-
-procedure drawgraph;
-label error;
-begin
- if ship.wandering.alienid<16000 then
-  begin
-   dist:=ship.wandering.relx;
-   if ship.wandering.rely>dist then dist:=ship.wandering.rely;
-   if ship.wandering.relz>dist then dist:=ship.wandering.relz;
-   dist:=abs(round(dist/1280));
-  end
- else dist:=18;
- mousehide;
- for i:=21 to 49 do
-  fillchar(screen[i,31],249,0);
- for i:=61 to 89 do
-  fillchar(screen[i,31],249,0);
- n2:=(n2*1.0-ship.crew[3].level/2000);
- if n2<0.11 then n2:=0.11;
- if rotatemode=0 then n2:=1;
- for j:=31 to 279 do screen[43-random(round(n2*noise))+round(n2/2),j]:=random(22)+8;
- moveto(31,83-random(round(n2*noise))+round(n2/2));
- setcolor(31);
- for j:=31 to 279 do
-  begin
-   inc(j,2);
-   if j>279 then goto error;
-   if random(12)=0 then lineto(j,83-random(19-dist))
-    else lineto(j,83-random(round(n2*noise))+round(n2/2));
-  end;
-error:
- for j:=1 to 4 do if spikes[2,j]>0 then
-  begin
-   signaly:=round(spikes[2,j]*(19-dist)*ship.crew[3].level/3150*spikes[2,j]);
-   if signaly>18 then signaly:=18;
-   if ship.wandering.alienid<16000 then screen[40-signaly,spikes[1,j]]:=random(22)+8;
-  end;
- for i:=120 to 180 do
-  mymove(scope^[i,210],screen[i,210],20);
- for i:=1 to round(noise*n2) do
-  begin
-   x:=random(23000);
-   y:=random(23000);
-   z:=random(23000);
-   x:=round((x+z)*0.0005);
-   y:=round((y+z)*0.0005);
-   screen[150+y,250+x]:=random(10)+5;
-  end;
- if (ship.wandering.alienid<16000) then
-  begin
-   x:=ship.wandering.relx;
-   y:=ship.wandering.rely;
-   z:=ship.wandering.relz;
-   x:=round((x+z)*0.0005);
-   y:=round((y+z)*0.0005);
-   scope^[150+y,250+x]:=random(10)+7;
-  end;
- mouseshow;
-end;
-
-procedure cleanwhatzup;
-var str1: string[5];
-    esttech,tech: integer;
-    r: real;
-begin
- esttech:=0;
- if ship.wandering.alienid<16000 then
-  begin
-   tech:=hi(ship.wandering.techlevel)*10+lo(ship.wandering.techlevel);
-   j:=1;
-   randseed:=ship.wandering.alienid;
-   while (tech>0) and (j<4) do
-    begin
-     i:=random(tech)+random(4);
-     tech:=tech-i+random(4);
-     inc(esttech,i);
-     inc(j);
-    end;
-   if tech>0 then esttech:=esttech+tech;
-  end;
- mousehide;
- printxy(37,119,'Interferance');
- printxy(37,126,'Noise Filter');
- printxy(37,136,'Estimating...');
- printxy(40,143,'Tech Level');
- printxy(45,150,'Distance');
- printxy(134,119,'Active');
- printxy(134,126,'Active');
- if ship.wandering.alienid<16000 then
-  begin
-   r:=sqr(ship.wandering.relx/10);
-   r:=r+sqr(ship.wandering.rely/10);
-   r:=r+sqr(ship.wandering.relz/10);
-   r:=sqrt(r)*100;
-  end
- else r:=0;
- str(r:8:1,str1);
- printxy(119,150,str1+' KKm');
- str((esttech/10):3:1,str1);
- printxy(149,143,str1);
- mouseshow;
-end;
-
-procedure whatzup;
-var str1: string[5];
-    total,a: integer;
-    esttech,estdist: real;
-begin
- mousehide;
- printxy(37,119,'Interferance');
- printxy(37,126,'Noise Filter');
- printxy(37,136,'Estimating...');
- printxy(40,143,'Tech Level');
- printxy(45,150,'Distance');
- str(round(noise*5.55556):3,str1);
- printxy(144,119,str1+'%');
- str((1-n2)*100:3:0,str1);
- printxy(144,126,str1+'%');
- if ship.wandering.alienid>15999 then
-  begin
-   esttech:=random(round(n2*noise));
-   estdist:=random(round(n2*noise));
-  end
- else
-  begin
-   esttech:=0;
-   dist:=ship.wandering.relx;
-   if ship.wandering.rely>dist then dist:=ship.wandering.rely;
-   if ship.wandering.relz>dist then dist:=ship.wandering.relz;
-   dist:=abs(round(dist/1280));
-   for j:=1 to 4 do if spikes[2,j]>0 then
-    begin
-     signaly:=round(spikes[2,j]*(19-dist)*ship.crew[3].level/3150*spikes[2,j]);
-     if signaly>=(round(n2*noise)-round(n2/2)) then esttech:=esttech+signaly;
-    end;
-   total:=0;
-   a:=0;
-   for j:=31 to 279 do
-    begin
-     if random(8)=0 then
-      begin
-       total:=total+random(19-dist);
-       inc(a);
-      end
-     else
-      begin
-       i:=random(round(n2*noise))-round(n2/2);
-       if i>1 then begin total:=total+i; inc(a); end;
-      end;
-    end;
-   estdist:=18-total/a;
-   if estdist<1 then estdist:=1;
-   esttech:=sqrt(esttech/ship.crew[3].level*3150/(19-estdist));
-  end;
- str((esttech/10):3:1,str1);
- printxy(149,143,str1);
- str((estdist*1280000):8:0,str1);
- printxy(119,150,str1+' KKM');
- mouseshow;
-end;
-
-procedure processsweepkey;
-var ans: char;
-begin
- ans:=readkey;
- case ans of
-  #27: done:=true;
-  '?': whatzup;
-  '`': bossmode;
- end;
-end;
-
-procedure findsweepmouse;
-var button: boolean;
-begin
- if mouse.getstatus(left) then button:=true else button:=false;
- if not button then exit;
- case mouse.y of
-    52..58: if (mouse.x>19) and (mouse.x<28) then
-             begin
-              if rotatemode=0 then
-               begin
-                rotatemode:=1;
-                n2:=1;
-                plainfadearea(21,53,26,57,-32);
-               end
-               else
-                begin
-                 rotatemode:=0;
-                 plainfadearea(21,53,26,57,32);
-                end;
-             end;
-  116..131: if (mouse.x>19) and (mouse.x<28) then
-             begin
-              if infoindex=0 then infoindex:=1 else
-               begin
-                infoindex:=0;
-                printxy(134,119,'  ');
-                printxy(134,126,'  ');
-              end;
-             end;
-  133..151: if (mouse.x<29) and (mouse.x>18) then done:=true;
- end;
-end;
-
-procedure mainsweeploop;
-begin
- repeat
-  if fastkeypressed then processsweepkey;
-  findsweepmouse;
-  if infoindex=0 then
-   begin
-    drawgraph;
-    whatzup;
-   end
-  else
-   begin
-    drawcleangraph;
-    cleanwhatzup;
-   end;
-  adjustlights;
-  delay(tslice*4);
- until done;
-end;
-
-procedure readysweepdata;
-begin
- mousehide;
- compressfile(tempdir+'\current.vga',@screen);
- fading;
- playmod(true,'sound\scanner.mod');
- loadscreen('data\scan.vga',@screen);
- fadein;
- new(scope);
- drawscope;
- if ship.wandering.alienid<16000 then getspikes;
- mouseshow;
- done:=false;
- tcolor:=29;
- bkcolor:=0;
- rotatemode:=0;
- infoindex:=0;
- n2:=1;
- oldt1:=t1;
- if showplanet then
-  begin
-   if tempplan^[curplan].orbit=0 then noise:=18
-    else noise:=round((exp(abs(tempplan^[curplan].orbit-6)))/10)
-  end
-  else noise:=0;
-end;
-
-procedure sweepinfo;
-begin
- readysweepdata;
- mainsweeploop;
- dispose(scope);
- stopmod;
- removedata;
-end;
-
-
-{procedure setupbreach1;
-var a: integer;
-begin
- new(shippix);
- new(msgpix);
- new(override);
- for a:=0 to 9 do
-  for i:=0 to 19 do
-   move(screen[i+(a div 5)*20+20,(a mod 5)*30+110],shippix^[a,i],30);
- for a:=0 to 9 do
-  for i:=0 to 4 do
-   move(screen[i+(a div 3)*10+20,(a mod 3)*10+60],msgpix^[a,i],10);
- for i:=90 to 110 do
-  move(screen[i,200],override^[i,200],41);
- for i:=90 to 110 do
-  fillchar(screen[i,200],41,0);
- for i:=20 to 60 do
-  fillchar(screen[i,60],201,0);
- fadein;
-end;
-
-procedure breach1wait(t: integer);
-var modth,modtm,modts,curth,curtm,curts: byte;
-    a,b,c: integer;
-begin
- asm
-  mov ah, 2Ch
-   int 21h
-  mov modth, ch
-  mov modtm, cl
-  mov modts, dh
- end;
- repeat
-  if random(2)=0 then
-   begin
-    a:=random(10);
-    for i:=0 to 19 do
-     move(shippix^[a,i],screen[i+91,100],30);
-    for b:=0 to 3 do
-     begin
-      a:=random(6);
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+90+b*6,70],10);
-      if random(2)=0 then
-       begin
-        a:=random(6);
-        for i:=0 to 4 do
-         move(msgpix^[a,i],screen[i+90+b*6,80],10);
-        c:=90;
-       end
-      else
-       begin
-        c:=80;
-        for i:=0 to 4 do
-         fillchar(screen[i+90+b*6,90],10,0);
-       end;
-      a:=random(3)+6;
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+90+b*6,c],10);
-     end;
-    end;
-  if random(2)=0 then
-   begin
-    a:=random(10);
-    for i:=0 to 19 do
-     move(shippix^[a,i],screen[i+91,220],30);
-    for b:=0 to 3 do
-     begin
-      a:=random(6);
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+90+b*6,190],10);
-      if random(2)=0 then
-       begin
-        a:=random(6);
-        for i:=0 to 4 do
-         move(msgpix^[a,i],screen[i+90+b*6,200],10);
-        c:=210;
-       end
-      else
-       begin
-        c:=200;
-        for i:=0 to 4 do
-         fillchar(screen[i+90+b*6,210],10,0);
-       end;
-      a:=random(3)+6;
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+90+b*6,c],10);
-     end;
-   end;
-  delay(tslice*10);
-  asm
-   mov ah, 2Ch
-    int 21h
-   mov curth, ch
-   mov curtm, cl
-   mov curts, dh
-  end;
-  i:=abs(curth-modth)*3600+abs(curtm-modtm)*60+curts-modts;
- until i>t;
-end;
-
-procedure overridebreach1;
-var a: integer;
-begin
- for a:=0 to 10 do
-  begin
-   for i:=90 to 112 do
-    begin
-     fillchar(screen[i,190],61,0);
-     fillchar(screen[i,70],61,0);
-    end;
-   delay(tslice*5);
-   for i:=90 to 110 do
-    begin
-     move(override^[i,200],screen[i,200],41);
-     move(override^[i,200],screen[i,80],41);
-    end;
-   delay(tslice*8);
-  end;
-end;
-
-procedure uploadencodes;
-var str1: string[4];
-    a,b,c,i,j: integer;
-begin
- str1:='7A1E';
- for j:=0 to 300 do
-  begin
-   for b:=0 to 3 do
-    begin
-     for c:=0 to random(4)+1 do
-      begin
-       a:=random(6);
-       for i:=0 to 4 do
-        move(msgpix^[a,i],screen[i+90+b*6,70+c*10],10);
-      end;
-      if c<4 then
-       for i:=0 to 5 do
-        fillchar(screen[i+90+b*6,80+c*10],(5-c)*10,0);
-      a:=random(3)+6;
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+90+b*6,80+c*10],10);
-    end;
-   for b:=0 to 3 do
-    begin
-     for c:=0 to random(4)+1 do
-      begin
-       a:=random(6);
-       for i:=0 to 4 do
-        move(msgpix^[a,i],screen[i+90+b*6,190+c*10],10);
-      end;
-      if c<4 then
-       for i:=0 to 5 do
-        fillchar(screen[i+90+b*6,200+c*10],(5-c)*10,0);
-      a:=random(3)+6;
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+90+b*6,200+c*10],10);
-    end;
-   delay(tslice div 2);
-   printxy(70,30,str1);
-   inc(str1[4]);
-   if str1[4]='[' then
-    begin
-     str1[4]:='0';
-     inc(str1[3]);
-     if str1[3]='[' then
-      begin
-       str1[3]:='0';
-       inc(str1[2]);
-      end
-     else if str1[3]=':' then str1[3]:='A';
-    end
-   else if str1[4]=':' then str1[4]:='A';
-  end;
- for i:=89 to 112 do
-  begin
-   fillchar(screen[i,190],61,0);
-   fillchar(screen[i,70],61,0);
-  end;
-end;
-
-procedure setupbreach2;
-var a: integer;
-begin
- new(peoplepix);
- new(override2);
- for a:=0 to 3 do
-  for i:=0 to 28 do
-   move(screen[i+21,25+a*30],peoplepix^[a,i],29);
- for a:=0 to 3 do
-  for i:=0 to 28 do
-   move(screen[i+51,25+a*30],peoplepix^[a+4,i],29);
- for a:=0 to 3 do
-  for i:=0 to 28 do
-   move(screen[i+21,173+a*30],peoplepix^[a+8,i],29);
- for a:=0 to 3 do
-  for i:=0 to 28 do
-   move(screen[i+51,173+a*30],peoplepix^[a+12,i],29);
- for i:=0 to 40 do
-  move(screen[i+130,30],override2^[i],111);
- for i:=21 to 79 do
-  begin
-   fillchar(screen[i,24],120,0);
-   fillchar(screen[i,173],120,0);
-   fillchar(screen[i+100,24],120,0);
-  end;
- for i:=21 to 79 do
-  begin
-   move(screen[i+100,173],screen[i,24],120);
-   move(screen[i+100,173],screen[i,173],120);
-   move(screen[i+100,173],screen[i+100,24],120);
-  end;
- for a:=0 to 9 do
-  for i:=0 to 4 do
-   for j:=0 to 9 do
-    if msgpix^[a,i,j]>0 then msgpix^[a,i,j]:=111;
- a:=random(16);
- for i:=0 to 28 do
-  move(peoplepix^[a,i],screen[36+i,191],29);
- a:=random(16);
- for i:=0 to 28 do
-  move(peoplepix^[a,i],screen[136+i,191],29);
- a:=random(16);
- for i:=0 to 28 do
-  move(peoplepix^[a,i],screen[36+i,42],29);
- a:=random(16);
- for i:=0 to 28 do
-  move(peoplepix^[a,i],screen[136+i,42],29);
-end;
-
-procedure breach2wait(t: integer);
-var modth,modtm,modts,curth,curtm,curts: byte;
-    a,b: integer;
-begin
- asm
-  mov ah, 2Ch
-   int 21h
-  mov modth, ch
-  mov modtm, cl
-  mov modts, dh
- end;
- repeat
-  for b:=0 to 3 do
-    begin
-     for c:=0 to random(3)+2 do
-      begin
-       a:=random(6);
-       for i:=0 to 4 do
-        move(msgpix^[a,i],screen[i+138+b*6,230+c*10],10);
-      end;
-      if c<5 then
-       for i:=0 to 5 do
-        fillchar(screen[i+138+b*6,220+c*10],(7-c)*10,0);
-      a:=random(3)+6;
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+138+b*6,220+c*10],10);
-    end;
-  for b:=0 to 3 do
-    begin
-     for c:=0 to random(3)+2 do
-      begin
-       a:=random(6);
-       for i:=0 to 4 do
-        move(msgpix^[a,i],screen[i+38+b*6,230+c*10],10);
-      end;
-      if c<5 then
-       for i:=0 to 5 do
-        fillchar(screen[i+38+b*6,220+c*10],(7-c)*10,0);
-      a:=random(3)+6;
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+38+b*6,220+c*10],10);
-    end;
-  for b:=0 to 3 do
-    begin
-     for c:=0 to random(3)+2 do
-      begin
-       a:=random(6);
-       for i:=0 to 4 do
-        move(msgpix^[a,i],screen[i+138+b*6,81+c*10],10);
-      end;
-      if c<5 then
-       for i:=0 to 5 do
-        fillchar(screen[i+138+b*6,71+c*10],(7-c)*10,0);
-      a:=random(3)+6;
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+138+b*6,71+c*10],10);
-    end;
-  for b:=0 to 3 do
-    begin
-     for c:=0 to random(3)+2 do
-      begin
-       a:=random(6);
-       for i:=0 to 4 do
-        move(msgpix^[a,i],screen[i+38+b*6,81+c*10],10);
-      end;
-      if c<5 then
-       for i:=0 to 5 do
-        fillchar(screen[i+38+b*6,71+c*10],(7-c)*10,0);
-      a:=random(3)+6;
-      for i:=0 to 4 do
-       move(msgpix^[a,i],screen[i+38+b*6,71+c*10],10);
-    end;
-  if random(2)=0 then
-   begin
-    a:=random(16);
-    for i:=0 to 28 do
-     move(peoplepix^[a,i],screen[36+i,191],29);
-   end;
-  if random(2)=0 then
-   begin
-    a:=random(16);
-    for i:=0 to 28 do
-     move(peoplepix^[a,i],screen[136+i,191],29);
-   end;
-  if random(2)=0 then
-   begin
-    a:=random(16);
-    for i:=0 to 28 do
-     move(peoplepix^[a,i],screen[36+i,42],29);
-   end;
-  if random(2)=0 then
-   begin
-    a:=random(16);
-    for i:=0 to 28 do
-     move(peoplepix^[a,i],screen[136+i,42],29);
-   end;
-  delay(tslice*10);
-  asm
-   mov ah, 2Ch
-    int 21h
-   mov curth, ch
-   mov curtm, cl
-   mov curts, dh
-  end;
-  i:=abs(curth-modth)*3600+abs(curtm-modtm)*60+curts-modts;
- until i>t;
-end;
-
-procedure overridebreach2;
-var a: integer;
-begin
- for a:=0 to 10 do
-  begin
-   for i:=0 to 40 do
-    begin
-     fillchar(screen[i+30,30],111,0);
-     fillchar(screen[i+130,30],111,0);
-     fillchar(screen[i+30,179],111,0);
-     fillchar(screen[i+130,179],111,0);
-    end;
-   delay(tslice*4);
-   for i:=0 to 40 do
-    begin
-     move(override2^[i],screen[i+30,30],111);
-     move(override2^[i],screen[i+130,30],111);
-     move(override2^[i],screen[i+30,179],111);
-     move(override2^[i],screen[i+130,179],111);
-    end;
-   delay(tslice*9);
-  end;
-end;
-
-procedure loadscreens;
-var t: pscreentype;
-    a,b: integer;
-    temppal: paltype;
-begin
- fillchar(colors,768,0);
- init320200;
- set256colors(colors);
- new(t);
- for a:=1 to 4 do
-  begin
-   loadscreen('data\blast0'+chr(a+48)+'',t);
-   setpage(a-1);
-   for i:=0 to 199 do
-    for j:=0 to 319 do
-     setpix(j,i,t^[i,j]);
-  end;
- dispose(t);
- b:=0;
- fillchar(temppal,768,0);
- for a:=1 to 24 do
-  begin
-   showpage(b);
-   inc(b);
-   if b=4 then b:=0;
-   for j:=0 to 255 do
-    for i:=1 to 3 do
-     temppal[j,i]:=round(a*colors[j,i]/24);
-   showpage(b);
-   inc(b);
-   if b=4 then b:=0;
-   set256colors(temppal);
-   delay(tslice);
-  end;
- set256colors(colors);
-end;
-
-procedure cycleengines(t: integer);
-var modth,modtm,modts,curth,curtm,curts: byte;
-begin
- asm
-  mov ah, 2Ch
-   int 21h
-  mov modth, ch
-  mov modtm, cl
-  mov modts, dh
- end;
- i:=0;
- set256colors(colors);
- repeat
-  showpage(i);
-  inc(i);
-  if i=4 then i:=0;
-  asm
-   mov ah, 2Ch
-    int 21h
-   mov curth, ch
-   mov curtm, cl
-   mov curts, dh
-  end;
-  delay(tslice div 2);
-  j:=abs(curth-modth)*3600+abs(curtm-modtm)*60+curts-modts;
- until j>t;
-end;
-
-procedure fadeinintro2;
-var a: integer;
-    temppal: paltype;
-begin
- fillchar(temppal,768,0);
- for a:=1 to 24 do
-  begin
-   for j:=0 to 31 do
-    for i:=1 to 3 do
-     temppal[j,i]:=round(a*colors[j,i]/24);
-   for j:=49 to 255 do
-    for i:=1 to 3 do
-     temppal[j,i]:=round(a*colors[j,i]/24);
-   set256colors(temppal);
-   delay(tslice);
-  end;
- for a:=0 to 34 do
-  begin
-   for i:=32 to 48 do
-    colors[i,1]:=round((i-32)*a/17);
-   set256colors(colors);
-   delay(tslice);
-  end;
-end;
-
-procedure shipschasing;
-var a,b,x1,y1,x2,y2: integer;
-    dx1,dx2,dy1,dy2: real;
-    t: pscreentype;
-begin
- x1:=60;
- y1:=199;
- x2:=20;
- y2:=240;
- dx1:=4.6;
- dx2:=4.9;
- dy1:=-1;
- dy2:=-1;
- new(t);
- mymove2(screen,t^,16000);
- for a:=0 to 180 do
-  begin
-   mymove2(t^[y1,x1],screen[y1,x1],1);
-   mymove2(t^[y1+1,x1],screen[y1+1,x1],1);
-   dx1:=dx1-0.05;
-   dx2:=dx2-0.05;
-   dy1:=dy1+0.003;
-   dy2:=dy2-0.004;
-   x1:=x1+round(dx1);
-   y1:=y1+round(dy1);
-   if a<165 then
-    begin
-     for b:=0 to random(3) do
-      screen[y1+random(2),x1+random(2)]:=84+random(3);
-     screen[y1,x1]:=17+random(3);
-    end;
-   if y2<200 then
-    begin
-     mymove2(t^[y2,x2],screen[y2,x2],1);
-     mymove2(t^[y2+1,x2],screen[y2+1,x2],1);
-    end;
-   x2:=x2+round(dx2);
-   y2:=y2+round(dy2);
-   if y2<200 then
-    begin
-     for b:=0 to random(3) do
-      screen[y2+random(2),x2+random(2)]:=84+random(3);
-     screen[y2,x2]:=17+random(3);
-    end;
-   delay(round(tslice*1.5));
-  end;
- dispose(t);
-end;
-
-procedure shipanimation;
-var t,bg: pscreentype;
-    a,b,x,y,x2,y2,i2,y3,x3: integer;
-begin
- new(t);
- loadscreen('data\lilship',t);
- set256colors(colors);
- new(bg);
- y3:=69;
- x2:=148;
- mymove2(screen,bg^,16000);
- for a:=0 to 8 do
-  begin
-   x:=(a mod 3)*90;
-   y:=(a div 3)*60;
-   for b:=0 to 5 do
-    begin
-     dec(y3,2);
-     dec(x2,2);
-     for i:=0 to 55 do
-      begin
-       y2:=i+y3;
-       i2:=y+i;
-       if y2>0 then
-        for j:=0 to 82 do
-         if t^[i2,x+j]>0 then screen[y2,x2+j]:=t^[i2,x+j]
-          else screen[y2,x2+j]:=bg^[y2,x2+j];
-       if a<2 then mymove2(bg^[y2,x2+82],screen[y2,x2+82],2);
-      end;
-     if a<2 then
-      begin
-       y2:=69-a*10-b;
-       for i:=56 to 60 do
-        mymove2(bg^[y2+i,x2],screen[y2+i,x2],27);
-      end;
-     delay(tslice div 3);
-    end;
-  end;
- wait(1);
- dispose(t);
- dispose(bg);
-end;
-
-procedure atmosphereanimation;
-var t,bk: pscreentype;
-    a,b,x,y: integer;
-    dx,dy: real;
-begin
- new(t);
- loadscreen('data\world3',t);
- new(bk);
- mymove2(screen,bk^,16000);
- x:=260;
- y:=199;
- dx:=-5.5;
- dy:=-0.970;
- for a:=0 to 100 do
-  begin
-   mymove2(bk^[y,x],screen[y,x],1);
-   mymove2(bk^[y+1,x],screen[y+1,x],1);
-   dx:=dx+0.1;
-   dy:=dy+0.005;
-   x:=x+round(dx);
-   y:=y+round(dy);
-     for b:=0 to random(3) do
-      screen[y+random(2),x+random(2)]:=224+random(3);
-     screen[y,x]:=250+random(3);
-   delay(round(tslice*1.5));
-  end;
- for a:=0 to 15 do
-  begin
-   x:=(a mod 4)*70;
-   y:=(a div 4)*50;
-   for i:=0 to 49 do
-    mymove2(t^[y+i,x],screen[80+i,190],17);
-   delay(tslice*3);
-  end;
- for i:=0 to 49 do
-  mymove2(bk^[80+i,190],screen[80+i,190],17);
- wait(4);
- dispose(t);
- dispose(bk);
-end;
-
-(*{**************}
-
- loadpalette('data\main.pal');
- writestr2('Code Master:','Robert W.','Morgan III');
- if fastkeypressed then goto continue;
- wait(1);
- fading;
- if fastkeypressed then goto continue;
-{#1.5}
- domainscreen;
- for i:=1 to 120 do
-  mymove2(screen[i+12,28],planet^[i],30);
- makeplanet(0,true);
- fadein;
- tcolor:=31;
- bkcolor:=3;
- printxy(13,151,'Link Established.');
- makeplanet(1,true);
- printxy(13,157,'Security Override ALPHA-C7.');
- makeplanet(1,true);
- printxy(13,163,'Activating IRONSEED Phage.');
- makeplanet(1,true);
- printxy(13,169,'Approach Coordinates:');
- printxy(16,175,'(180.06,29.73,800.41)');
- makeplanet(1,true);
- printxy(13,181,'Autopilot Engaged.');
- makeplanet(1,true);
- scrollmainscreen;
- bkcolor:=0;
- fading;
- if fastkeypressed then goto continue;
-{#1.6}
- loadpalette('data\main.pal');
- writestr2('World Design:','Jeremy','Holt');
- wait(1);
- fading;
- if fastkeypressed then goto continue;
-{#1.7}
- loadscreen('data\breach1',@screen);
- setupbreach1;
- tcolor:=31;
- breach1wait(1);
- printxy(50,20,'Receiving Transmission...');
- breach1wait(1);
- printxy(50,20,'Uploading Encodes to Port 0x96A9...');
- breach1wait(1);
- printxy(50,30,': 0x');
- uploadencodes;
- printxy(50,30,'Transmission Complete.');
- breach1wait(1);
- printxy(50,40,'Holo-Bitscan Phage Detect Virus');
- printxy(50,46,' at Port 0x96A9.');
- overridebreach1;
- printxy(50,56,'Security Breach!');
- printxy(50,62,' Virus Signature: "IRONSEED".');
- wait(1);
- dispose(shippix);
- dispose(override);
- fading;
- if fastkeypressed then goto continue;
-{#1.8}
- loadpalette('data\main.pal');
- writestr2('Soundtrak:','Andrew G. Sega',' Necros of the Psychic Monks');
- wait(1);
- fading;
- if fastkeypressed then goto continue;
-{#1.9}
- loadscreen('data\breach2',@screen);
- setupbreach2;
- fadein;
- breach2wait(2);
- overridebreach2;
- dispose(override2);
- dispose(peoplepix);
- dispose(msgpix);
- wait(1);
- fading;
- if fastkeypressed then goto continue;
-{#1.10}
- loadpalette('data\main.pal');
- writestr2('Design Consultant:','Chris P.','Cash');
- wait(1);
- fading;
- if fastkeypressed then goto continue;
-{#1.11}
- loadscreen('data\charcom',@screen);
- fadein;
- readyencode;
- tcolor:=191;
- printxy(20,153,'Ship IRONSEED to Relay Point:');
- charcomstuff(1);
- printxy(170,153,'Link Established.');
- charcomstuff(1);
- printxy(20,159,'Receiving Encode Variants.');
- powerupencodes;
- charcomstuff(1);
- printxy(20,165,'Wiping Source Encodes.');
- charcomstuff(1);
- printxy(20,171,'Terminating Transmission.');
- charcomstuff(1);
- printxy(20,177,'Control Protocol Transfered to Human Encode "PRIME".');
- charcomstuff(1);
- fadecharcom;
- if fastkeypressed then goto continue;
-{#1.12}
- loadpalette('data\main.pal');
- writestr2('Tech Consultant:','David W.','Rankin Jr.');
- wait(1);
- fading;
- if fastkeypressed then goto continue;
-{#1.13}
- loadscreens;
- cycleengines(3);
- blast(63,63,63);
- setgraphmode(0);
- set256colors(colors);
- loadscreen('data\cloud',@screen);
- set256colors(colors);
- if fastkeypressed then goto continue;
-{#1.14}
- shipanimation;
- fading;
- if fastkeypressed then goto continue;
-{PART II. ********************************************************************}
-{#2.0}
- stopmod;
- playmod(false,'sound\intro2.mod');
- ampsetpanning(0,Pan_Surround);
- ampsetpanning(1,Pan_Surround);
- wait(2);
- fillchar(colors,768,0);
- fillchar(screen,64000,0);
- set256colors(colors);
- printxy2(117,170,254,'Sometime Later...');
- printxy2(80,180,255,'Thousands of Light Years Away...');
- for a:=0 to 63 do
-  begin
-   setrgb256(254,a,0,0);
-   delay(tslice);
-  end;
- wait(3);
- for a:=10 to 63 do
-  begin
-   setrgb256(255,a,0,0);
-   delay(tslice);
-  end;
- colors[254,1]:=63;
- colors[255,1]:=63;
- wait(5);
- fading;
-
- if fastkeypressed then goto continue;
-{#2.1}
- loadscreen('data\battle1',@screen);
- for i:=1 to 120 do
-  mymove2(screen[i+12,28],planet^[i],30);
- makeplanet(0,false);
- fadein;
- makeplanet(12,false);
- fading;
- if fastkeypressed then goto continue;
-{#2.2}
- loadscreen('data\ship1',@screen);
- set256colors(colors);
- tcolor:=255;
- wait(2);
- printxy(50,125,'Orders: Approach and Destroy.');
- wait(2);
- printxy(50,135,'Jamming all Emissions.');
- wait(2);
- printxy(50,145,'Targeting...');
- wait(2);
- printxy(50,155,'Locked and Loading...');
- wait(2);
- printxy(50,165,'Closing for Fire...');
- wait(2);
- if fastkeypressed then goto continue;
-{#2.3}
- shrinkalienscreen;
- fadeinalienscreen;
- alienscreenwait;
- fading;
- if fastkeypressed then goto continue;
-{#2.4}
- getbackgroundforis2;
- fadein;
- tcolor:=26;
- printxy(13,160,'Enemy Closing Rapidly..');
- wait(2);
- printxy(13,167,'Shields Imploding...');
- is2wait(-1,0,0,-2);
- wait(1);
- printxy(13,174,'Destruction Immanent.');
- is2wait(-3,0,-1,-1);
- wait(1);
- printxy(13,182,'Attempting Crash Landing.');
- is2wait(-1,-1,0,0);
- wait(1);
- fading;
- if fastkeypressed then goto continue;
-{#2.5}
- radius:=2000;
- c2:=1.16;
- r2:=round(sqrt(radius));
- c:=random(120);
- ecl:=105;
- loadscreen('data\battle1',@screen);
- for i:=1 to 120 do
-  mymove2(screen[i+12,28],planet^[i],30);
- makeplanet(0,false);
- fadein;
- wait(4);
- if fastkeypressed then goto continue;
-{#2.6}
- shipschasing;
- fading;
- if fastkeypressed then goto continue;
-{#2.7}
- loadscreen('data\world2',@screen);
- fadein;
- wait(4);
- atmosphereanimation;
- if fastkeypressed then goto continue;
-{#2.8}
- wait(8);
- blast(63,0,0);
- if fastkeypressed then goto continue;
-{#end}
- fillchar(colors,768,0);
- set256colors(colors);
-                                        { <-- wait here !!!!!}
-*)
-
-procedure rotatecube2(src,tar: byte; fkey: boolean);
-label skip1,skip2,skip3;
-begin  {215,145}
- getcube(src,tar);
- if (ship.options[6]=0) or (fkey) then
-  begin
-   mousehide;
-   for i:=0 to 44 do
-    move(cubetar^[i,0],screen[i+145,215],51);
-   mouseshow;
-   cube:=tar;
-   exit;
-  end;
- b:=tslice div 4;
- mousehide;
- for t:=1 to 21 do
-  begin
-   m:=round(10.5624*sin(3*t/20));
-   q:=round(sin(3*t/40)*51);
-   part:=51/q;
-   for j:=0 to q-1 do
-    begin
-     index:=round(j*part);
-     if index<51 then
-      for i:=145 to 159 do
-       screen[i,j+215-m]:=cubetar^[i-145,index];
-    end;
-   if (51+2*m-q)=0 then goto skip1;
-   part:=51/(51+2*m-q);
-   for j:=215-m+q to 266+m do
-    begin
-     index:=round((j-215+m-q)*part);
-     if index<51 then
-      for i:=145 to 159 do
-       screen[i,j]:=cubesrc^[i-145,index];
-    end;
- skip1:
-{   q:=round(sin((16-t*3/4)/20)*51); }
-   if q=0 then goto skip2;
-   part:=51/q;
-   for j:=0 to q-1 do
-    begin
-     index:=round(j*part);
-     if index<51 then
-      for i:=160 to 174 do
-       screen[i,j+215-m]:=cubetar^[i-145,index];
-    end;
-   if (51+2*m-q)=0 then goto skip2;
-   part:=51/(51+2*m-q);
-   for j:=215-m+q to 266+m do
-    begin
-     index:=round((j-215+m-q)*part);
-     if index<51 then
-      for i:=160 to 174 do
-       screen[i,j]:=cubesrc^[i-145,index];
-    end;
- skip2:
-   q:=round(sin(3*t/40)*51);
-   part:=51/q;
-   for j:=0 to q-1 do
-    begin
-     index:=round(j*part);
-     if index<51 then
-      for i:=175 to 189 do
-       screen[i,j+215-m]:=cubetar^[i-145,index];
-    end;
-   if (51+2*m-q)=0 then goto skip3;
-   part:=51/(51+2*m-q);
-   for j:=215-m+q to 266+m do
-    begin
-     index:=round((j-215+m-q)*part);
-     if index<51 then
-      for i:=175 to 189 do
-       screen[i,j]:=cubesrc^[i-145,index];
-    end;
- skip3:
-    for i:=145 to 189 do
-     begin
-      for j:=266+m to 278 do screen[i,j]:=back4[j-266,i-145];
-      for j:=202 to 214-m do screen[i,j]:=back3[j-202,i-145];
-     end;
-    delay(b);
-   end;
- for i:=0 to 44 do
-  move(cubetar^[i,0],screen[i+145,215],51);
- mouseshow;
- cube:=tar;
-end;
-
-procedure rotatecube(src,tar: byte; fkey: boolean);
-label skip1,skip2,skip3;
-begin  {215,145}
- if tar+src=5 then
-  begin
-   if (tar=2) or (tar=3) then rotatecube2(src,tar-2,fkey)
-   else if (tar>0) then rotatecube2(src,tar-1,fkey)
-   else rotatecube2(src,tar+1,fkey);
-  end;
- if random(4)=0 then
-  begin
-   rotatecube2(src,tar,fkey);
-   exit;
-  end;
- getcube(src,tar);
- if (ship.options[6]=0) or (fkey) then
-  begin
-   mousehide;
-   for i:=0 to 44 do
-    move(cubetar^[i,0],screen[i+145,215],51);
-   mouseshow;
-   cube:=tar;
-   exit;
-  end;
- mousehide;
- getback;
- b:=tslice div 4;
- for t:=1 to 20 do
-  begin
-  m:=round(10.5624*sin(3*t/20));
-  q:=round(sin(3*t/40)*45);
-  part:=45/q;
-  for j:=0 to q-1 do
-   begin
-    index:=round(j*part);
-    if index<46 then
-     for i:=215 to 231 do
-      screen[j+145-m,i]:=cubetar^[index,i-215];
-   end;
-  if (45+2*m-q)=0 then goto skip1;
-  part:=45/(45+2*m-q);
-  for j:=145-m+q to 188+m do
-   begin
-    index:=round((j-145+m-q)*part);
-    if index<46 then
-     for i:=215 to 231 do
-      screen[j,i]:=cubesrc^[index,i-215];
-   end;
-skip1:
-{  q:=round(sin((16-t*3/4)/10)*45); }
-  if q=0 then goto skip2;
-  part:=45/q;
-  for j:=0 to q-1 do
-   begin
-    index:=round(j*part);
-    if index<46 then
-     for i:=232 to 249 do
-      screen[j+145-m,i]:=cubetar^[index,i-215];
-   end;
-  if (45+2*m-q)=0 then goto skip2;
-  part:=45/(45+2*m-q);
-  for j:=145-m+q to 188+m do
-   begin
-    index:=round((j-145+m-q)*part);
-    if index<46 then
-     for i:=232 to 249 do
-      screen[j,i]:=cubesrc^[index,i-215];
-   end;
-skip2:
-  q:=round(sin(3*t/40)*45);
-  part:=45/q;
-  for j:=0 to q-1 do
-   begin
-    index:=round(j*part);
-    if index<46 then
-     for i:=250 to 265 do
-      screen[j+145-m,i]:=cubetar^[index,i-215];
-   end;
-  if (45+2*m-q)=0 then goto skip3;
-  part:=45/(45+2*m-q);
-  for j:=145-m+q to 188+m do
-   begin
-    index:=round((j-145+m-q)* part);
-    if index<46 then
-     for i:=250 to 265 do
-      screen[j,i]:=cubesrc^[index,i-215];
-   end;
-skip3:
-   for j:=133 to 145-m do
-    mymove(back1[j-133],screen[j,215],13);
-   for j:=190+m to 199 do
-    mymove(back2[j-190],screen[j,215],13);
-   delay(b);
-  end;
- for i:=0 to 44 do
-  move(cubetar^[i],screen[i+145,215],51);
- mymove(back2,screen[190,215],13);
- mouseshow;
- cube:=tar;
-end;
diff --git a/makedata/vga2pcx.pas b/makedata/vga2pcx.pas
deleted file mode 100644
index 72df3c8..0000000
--- a/makedata/vga2pcx.pas
+++ /dev/null
@@ -1,220 +0,0 @@
-program convertvgafilestopcxfiles;
-
-uses crt, graph, data;
-
-type
- pcxheadertype= record
-   signature,version,rleflag,bitpx: byte;
-   x1,y1,x2,y2,hres,vres: word;
-   colors: array[0..47] of byte;
-   vmode,nplanes: byte;
-   bplin,paltype,scrnw,scrnh: word;
-   filler: array[0..53] of byte;
-  end;
-{ colortype= array[1..3] of byte;
- paltype= array[0..255] of colortype; }
-var
- pcxheader: pcxheadertype;
- colors: paltype;
- i,j: integer;
-
-procedure errorhandler(s: string; errtype: integer);
-begin
- writeln;
- writeln;
- case errtype of
-  1: writeln('Opening File Error: ',s);
-  5: writeln('Read/Write File Error: ',s);
-  6: writeln('Program Error: ',s);
-  7: writeln('DOS Error: ',s);
-  8: writeln('PCX Error: ',s);
- end;
- halt(4);
-end;
-
-procedure initheader;
-begin
- with pcxheader do
-  begin
-   signature:=10;
-   version:=5;
-   rleflag:=1;
-   paltype:=1;
-   vmode:=0;
-   fillchar(colors,48,0);
-   fillchar(filler,54,0);
-  end;
- fillchar(colors,768,0);
-end;
-
-procedure displaystatus;
-begin
- writeln('PCXHEADER:');
- with pcxheader do
-  begin
-   writeln('  signature: ',signature);
-   write(  '  version  : ',version,', ');
-   case version of
-    0: writeln('version 2.5');
-    2: writeln('version 2.8 with palette');
-    3: writeln('version 2.8 without palette');
-    5: writeln('version 3.0+');
-    else writeln('unknown version');
-   end;
-   writeln('  rleflag  : ',rleflag);
-   write(  '  paltype  : ',paltype,', ');
-   case paltype of
-    1: writeln('color image');
-    2: writeln('grayscale image');
-    else writeln('unknown image type');
-   end;
-   writeln('  vmode    : ',vmode);
-   writeln('  bitpx    : ',bitpx);
-   writeln('  nplanes  : ',nplanes);
-   writeln('  bplin    : ',bplin);
-   writeln('  x1       : ',x1);
-   writeln('  y1       : ',y1);
-   writeln('  x2       : ',x2);
-   writeln('  y2       : ',y2);
-   writeln('  hres     : ',hres);
-   writeln('  vres     : ',vres);
-   writeln('  scrnw    : ',scrnw);
-   writeln('  scrnh    : ',scrnh);
-  end;
-end;
-
-procedure getpalette(s: string);
-var f: file;
-    ft: file of paltype;
-    j: word;
-begin
- if pcxheader.bitpx=1 then
-  begin
-   colors[1,1]:=63;
-   colors[1,2]:=63;
-   colors[1,3]:=63;
-  end
- else if pcxheader.bitpx=4 then
-  move(pcxheader.colors,colors,48)
- else if (pcxheader.bitpx=8) and (pcxheader.nplanes=1) then
-  begin
-   assign(f,s);
-   reset(f,1);
-   j:=filesize(f)-771;
-   if ioresult<>0 then errorhandler(s,1);
-   seek(f,j);
-   if ioresult<>0 then errorhandler(s,5);
-   blockread(f,i,1);
-   blockread(f,colors,768);
-   if ioresult<>0 then errorhandler(s,5);
-   close(f);
-
-{   if colors[0,1]<>12 then fillchar(colors,768,0); }
-
-   setgraphmode(0);
-   set256colors(colors);
-   for j:=0 to 255 do
-    for i:=0 to 199 do
-     screen[i,j]:=j;
-
-   readkey;
-
-
-  end;
- assign(ft,'tmp.pal');
- rewrite(ft);
- if ioresult<>0 then errorhandler('tmp.pal',5);
- write(ft,colors);
- if ioresult<>0 then errorhandler('tmp.pal',5);
- close(ft);
-end;
-
-procedure decode8bit(s: string);
-var hdrbyte,datbyte: byte;
-    cntbyte: integer;
-    size,bytecnt: longint;
-    f: file of byte;
-    ft: file of byte;
-    x,y: integer;
-label jumpend;
-begin
- assign(ft,'tmp.vga');
- if ioresult<>0 then errorhandler('tmp.vga',1);
- rewrite(ft);
- if ioresult<>0 then errorhandler('tmp.vga',5);
- assign(f,s);
- reset(f);
- if ioresult<>0 then errorhandler(s,1);
- seek(f,128);
- if ioresult<>0 then errorhandler(s,5);
- bytecnt:=0;
- cntbyte:=0;
- size:=(pcxheader.x2-pcxheader.x1+1);
- size:=size*(pcxheader.y2-pcxheader.y1+1);
- if size>64000 then size:=64000;
- x:=-1;
- y:=0;
- while (bytecnt<size) do
-  begin
-   read(f,hdrbyte);
-   if ioresult<>0 then goto jumpend;
-   if (hdrbyte and $C0)=$C0 then
-    begin
-     cntbyte:=hdrbyte and $3F;
-     read(f,datbyte);
-     if ioresult<>0 then goto jumpend;
-    end
-   else
-    begin
-     cntbyte:=1;
-     datbyte:=hdrbyte;
-    end;
-   for j:=1 to cntbyte do
-    begin
-     inc(x);
-     if (x>pcxheader.x2) then
-      begin
-       x:=-1;
-       inc(y);
-      end;
-     if x<320 then
-      begin
-       write(ft,datbyte);
-       screen[y,x]:=datbyte;
-      end;
-    end;
-   bytecnt:=bytecnt+cntbyte;
-  end;
-jumpend:
- close(ft);
- close(f);
-end;
-
-procedure decode124bit(s: string);
-begin
- {****************}
-end;
-
-procedure decodepcx(s: string);
-var f: file;
-begin
- textmode(co80);
- initheader;
- assign(f,s);
- reset(f,1);
- if ioresult<>0 then errorhandler(s,1);
- blockread(f,pcxheader,sizeof(pcxheader));
- if ioresult<>0 then errorhandler(s,5);
- close(f);
- displaystatus;
- if pcxheader.signature<>10 then errorhandler(s,8);
- getpalette(s);
- if pcxheader.bitpx=8 then
-  decode8bit(s)
- else decode124bit(s);
-end;
-
-begin
- decodepcx('\data\images\example3.pcx');
- readkey;
-end.
\ No newline at end of file
diff --git a/makedata/viewpal.pas b/makedata/viewpal.pas
deleted file mode 100644
index 93e9b73..0000000
--- a/makedata/viewpal.pas
+++ /dev/null
@@ -1,19 +0,0 @@
-program viewpalette;
-
-uses crt,graph,data;
-
-var
- j: integer;
-
-
-begin
- loadpal(paramstr(1));
- set256colors(colors);
- for j:=0 to 255 do
-  begin
-   setcolor(j);
-   line(j,0,j,199);
-  end;
- readkey;
- textmode(co80);
-end.
\ No newline at end of file
diff --git a/makedata/voctool.pas b/makedata/voctool.pas
deleted file mode 100644
index 7f46117..0000000
--- a/makedata/voctool.pas
+++ /dev/null
@@ -1,411 +0,0 @@
-unit voctool;
-{version 4.1}
-
-interface
-
-procedure playvoice(n: integer);
-procedure playadjustedvoice(n: integer; s: byte);
-procedure playloop(n: integer);
-
-const
- vocbreakend= 0;
- vocbreaknow= 1;
-type
- voctype=
-  object
-   statusword,errstat,version,driversize: word;
-   fileheader: string;
-   fileheaderlength: byte;
-   paused,installed: boolean;
-   ptrtodriver,oldexitproc: pointer;
-   function getvocerrmessage: string;
-   procedure vocexitproc;
-   procedure getversion;
-   procedure setport(portnumber: word);
-   procedure setirq(irqnumber: word);
-   procedure deinstalldriver;
-   procedure setspeaker(onoff: boolean);
-   procedure output(bufferaddress: pointer);
-   procedure outputloop (bufferaddress: pointer);
-   procedure stop;
-   procedure pause;
-   procedure continue;
-   procedure breakloop(breakmode: word);
-   constructor initialize;
-  end;
- cachetype=
-  object
-   index,cacheindex: byte;
-   oldexitproc: pointer;
-   handles,files: array[0..10] of word;
-   constructor initialize;
-   procedure findfile(n: integer);
-   procedure loadfile(n: integer);
-   procedure cacheexitproc;
-  end;
-var
- voc: voctype;
- cache: cachetype;
- vocptr: pointer;
- speed: ^byte;
-
-implementation
-
-uses data,emstool;
-
-type
- typecasttype= array [0..6000] of char;
- tempvoctype= array[0..8000] of byte;
-
-procedure playvoice(n: integer);
-begin
- if (not voc.installed) or (ship.options[3]=0) then exit;
- voc.stop;
- if cache.files[cache.cacheindex]<>n then
-  begin
-   ems.handle:=cache.handles[cache.cacheindex];
-   ems.savemap;
-   cache.findfile(n);
-   ems.handle:=cache.handles[cache.cacheindex];
-   ems.restoremap;
-  end;
- voc.output(vocptr);
-end;
-
-procedure playadjustedvoice(n: integer; s: byte);
-begin
- if (not voc.installed) or (ship.options[3]=0) then exit;
- voc.stop;
- if cache.files[cache.cacheindex]<>n then
-  begin
-   ems.handle:=cache.handles[cache.cacheindex];
-   ems.savemap;
-   cache.findfile(n);
-   ems.handle:=cache.handles[cache.cacheindex];
-   ems.restoremap;
-  end;
- speed:=vocptr;
- inc(speed,30);
- speed^:=s;
- voc.output(vocptr);
-end;
-
-procedure playloop(n: integer);
-begin
- if (not voc.installed) or (ship.options[3]=0) then exit;
- voc.stop;
- if cache.files[cache.cacheindex]<>n then
-  begin
-   ems.handle:=cache.handles[cache.cacheindex];
-   ems.savemap;
-   cache.findfile(n);
-   ems.handle:=cache.handles[cache.cacheindex];
-   ems.restoremap;
-  end;
- voc.outputloop(vocptr);
-end;
-
-{$F+}
-procedure voctype.vocexitproc;
-{$F-}
-begin
- voctype.deinstalldriver;
- exitproc:=voc.oldexitproc;
-end;
-
-function voctype.getvocerrmessage: string;
-var s: string;
-begin
- case voc.errstat of
-  100: s:='Driver File CT-VOICE.DRV Not Found.';
-  110: s:='No Memory Available For Driver File.';
-  120: s:='False Driver File.';
-  200: s:='Voc File Not Found.';
-  210: s:='No Memory Available For Driver File.';
-  220: s:='File Not In Voc Format.';
-  300: s:='Memory Allocation Error Occurred.';
-  400: s:='No Sound Blaster Card Found.';
-  410: s:='False Port Address Used.';
-  420: s:='False Interrupt Used.';
-  500: s:='No Loop In Process.';
-  510: s:='No Sample For Output.';
-  520: s:='No Sample Available.';
-  else s:='Unknown Failure.';
- end;
- getvocerrmessage:=s;
-end;
-
-procedure voctype.getversion;
-var
- vdummy : word;
-begin
- asm
-  mov bx, 0
-  call voc.ptrtodriver
-  mov vdummy, ax
- end;
- voc.version:=vdummy;
-end;
-
-procedure voctype.setport(portnumber: word);
-begin
- asm
-  mov bx, 1
-  mov ax, portnumber
-  call voc.ptrtodriver
- end;
-end;
-
-procedure voctype.setirq(irqnumber: word);
-begin
- asm
-  mov bx, 2
-  mov ax, irqnumber
-  call voc.PtrToDriver
- end;
-end;
-
-constructor voctype.initialize;
-var
- out,vseg,vofs: word;
- f: File;
-begin
- voc.statusword:=0;
- voc.errstat:=0;
- voc.paused:=false;
- voc.fileheaderlength:=$1A;
- voc.fileheader:='Creative Voice File'+#$1A+#$1A+#$00+#$0A+#$01+#$29+#$11+#$01;
- voc.ptrtodriver:=nil;
- assign(f,'ct-voice.drv');
- reset(f,1);
- if ioresult<>0 then errorhandler('CT-VOICE.DRV',1);
- voc.driversize:=filesize(f);
- getmem(ptrtodriver,voc.driversize);
- if ptrtodriver=nil then
-  begin
-   voc.installed:=false;
-   voc.errstat:=110;
-   exit;
-  end;
- blockread(f,ptrtodriver^,voc.driversize);
- if ioresult<>0 then errorhandler('CT-VOICE.DRV',5);
- close(f);
- if (typecasttype(ptrtodriver^)[3]<>'C') or
-  (typecasttype(ptrtodriver^)[4]<>'T') then
-  begin
-   voc.installed:=false;
-   voc.errstat:=120;
-   exit;
-  end;
- voc.getversion;
- vseg:=seg(statusword);
- vofs:=ofs(statusword);
- asm
-  mov bx, 3
-  call voc.ptrtodriver
-  mov out, ax
-  mov bx, 5
-  mov es, vseg
-  mov di, vofs
-  call voc.ptrtodriver
- end;
- case out of
-  1:voc.errstat:=400;
-  2:voc.errstat:=410;
-  3:voc.errstat:=420;
- end;
- if voc.errstat<>0 then
-  begin
-   voc.installed:=false;
-   exit;
-  end;
- voc.installed:=true;
- voc.oldexitproc:=exitproc;
- exitproc:=@voctype.vocexitproc;
-end;
-
-procedure voctype.deinstalldriver;
-begin
- if voc.installed then
- asm
-  mov bx, 9
-  call voc.ptrtodriver
- end;
- freemem(voc.ptrtodriver,voc.driversize);
-end;
-
-procedure voctype.setspeaker(onoff: boolean);
-var
- switch: byte;
-begin
- switch:=ord(onoff) and $01;
- asm
-  mov bx, 4
-  mov al, switch
-  call voc.ptrtodriver
- end;
-end;
-
-procedure voctype.output(bufferaddress: pointer);
-var
- vseg,vofs: word;
-begin
- if (not voc.installed) or (ship.options[3]=0) then exit;
- voc.setspeaker(true);
- vseg:=seg(bufferaddress^);
- vofs:=ofs(bufferaddress^)+voc.fileheaderlength;
- asm
-  mov bx, 6
-  mov es, vseg
-  mov di, vofs
-  call voc.ptrtodriver
- end;
-end;
-
-procedure voctype.outputloop(bufferaddress: pointer);
-var
- vseg,vofs: word;
-begin
- if (not voc.installed) or (ship.options[3]=0) then exit;
- vseg:=seg(bufferaddress^);
- vofs:=ofs(bufferaddress^)+voc.fileheaderlength;
- asm
-  mov bx, 6
-  mov es, vseg
-  mov di, vofs
-  call voc.ptrtodriver
- end;
-end;
-
-procedure voctype.stop;
-begin
- asm
-  mov bx, 8
-  call voc.ptrtodriver
- end;
-end;
-
-procedure voctype.pause;
-var
- switch: word;
-begin
- voc.paused:=true;
- asm
-  mov bx,10
-  call voc.ptrtodriver
-  mov switch, ax
- end;
- if switch=1 then
-  begin
-   voc.paused:=false;
-   voc.errstat:=510;
-  end;
-end;
-
-procedure voctype.continue;
-var
- switch: word;
-begin
- asm
-  mov bx,11
-  call voc.ptrtodriver
-  mov switch, AX
- end;
- if switch=1 then
-  begin
-   voc.paused:=false;
-   voc.errstat:=520;
-  end;
-end;
-
-procedure voctype.breakloop(breakmode: word);
-begin
- asm
-  mov bx, 12
-  mov ax, breakmode
-  call voc.ptrtodriver
-  mov breakmode, ax
- end;
- if breakmode=1 then voc.errstat:=500;
-end;
-
-constructor cachetype.initialize;
-var j,i: integer;
-begin
- cache.oldexitproc:=exitproc;
- exitproc:=@cachetype.cacheexitproc;
- cache.cacheindex:=0;
- for j:=0 to 10 do cache.handles[j]:=0;
- for j:=0 to 10 do
-  begin
-   ems.getmem(4);
-   if ems.error<>0 then errorhandler(ems.getemserrmessage,4);
-   for i:=0 to 3 do ems.setmapping(i,i);
-   ems.savemap;
-   cache.handles[j]:=ems.handle;
-   cache.files[j]:=0;
-  end;
- cache.index:=0;
-end;
-
-procedure cachetype.findfile(n: integer);
-var j: integer;
-begin
- j:=0;
- while (j<11) and (cache.files[j]<>n) do inc(j);
- if j=11 then loadfile(n)
-  else
-   cache.cacheindex:=j;
-end;
-
-procedure cachetype.loadfile(n: integer);
-var temp: ^tempvoctype;
-    vocfile: file;
-    nums: string[3];
-    j,total: word;
-begin
- new(temp);
- ems.handle:=cache.handles[cache.index];
- ems.restoremap;
- str(n:3,nums);
- if n<100 then nums[1]:='0';
- if n<10 then nums[2]:='0';
- assign(vocfile,'SOUND\IS'+nums+'.VOC');
- reset(vocfile,1);
- total:=0;
- repeat
-  blockread(vocfile,temp^,8000,j);
-  move(temp^,ptr(ems.frame0,total)^,j);
-  total:=total+j;
- until j<8000;
- if ioresult<>0 then errorhandler('SOUND\IS'+nums+'.VOC',1);
- close(vocfile);
- if ioresult<>0 then errorhandler('SOUND\IS'+nums+'.VOC',5);
- ems.savemap;
- cache.files[cache.index]:=n;
- cache.cacheindex:=cache.index;
- inc(cache.index);
- cache.index:=cache.index mod 11;
- dispose(temp);
-end;
-
-{$F+}
-procedure cachetype.cacheexitproc;
-{$F-}
-var j: integer;
-begin
- for j:=0 to 10 do
-  if cache.handles[j]<>0 then
-   begin
-    ems.handle:=cache.handles[j];
-    ems.restoremap;
-    ems.freemem;
-    cache.handles[j]:=0;
-   end;
- exitproc:=cache.oldexitproc;
-end;
-
-begin
- vocptr:=ptr(ems.frame0,0);
- voc.initialize;
-end.
\ No newline at end of file
diff --git a/makedata/weapmake.pas b/makedata/weapmake.pas
index 9efe8be..d163372 100644
--- a/makedata/weapmake.pas
+++ b/makedata/weapmake.pas
@@ -1,4 +1,20 @@
 program generateweapondata;
+(********************************************************************
+    This file is part of Ironseed.
+
+    Ironseed is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    Ironseed is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with Ironseed.  If not, see <http://www.gnu.org/licenses/>.
+********************************************************************)
 
 uses crt;
 
diff --git a/makedata/win.pas b/makedata/win.pas
deleted file mode 100644
index b71776b..0000000
--- a/makedata/win.pas
+++ /dev/null
@@ -1,130 +0,0 @@
-
-{*******************************************************}
-{                                                       }
-{       Turbo Pascal Version 6.0                        }
-{       Window Interface Unit                           }
-{                                                       }
-{       Copyright (C) 1989,90 Borland International     }
-{                                                       }
-{*******************************************************}
-
-unit Win;
-
-{$D-,S-}
-
-interface
-
-uses Crt;
-
-type
-
-{ Window title string }
-
-  TitleStr = string[63];
-
-{ Window frame characters }
-
-  FrameChars = array[1..8] of Char;
-
-{ Window state record }
-
-  WinState = record
-    WindMin, WindMax: Word;
-    WhereX, WhereY: Byte;
-    TextAttr: Byte;
-  end;
-
-const
-
-{ Standard frame character sets }
-
-  SingleFrame: FrameChars = '';
-  DoubleFrame: FrameChars = '';
-
-{ Direct write routines }
-
-procedure WriteStr(X, Y: Byte; S: String; Attr: Byte);
-procedure WriteChar(X, Y, Count: Byte; Ch: Char; Attr: Byte);
-
-{ Window handling routines }
-
-procedure FillWin(Ch: Char; Attr: Byte);
-procedure ReadWin(var Buf);
-procedure WriteWin(var Buf);
-function WinSize: Word;
-procedure SaveWin(var W: WinState);
-procedure RestoreWin(var W: WinState);
-procedure FrameWin(Title: TitleStr; var Frame: FrameChars;
-  TitleAttr, FrameAttr: Byte);
-procedure UnFrameWin;
-
-implementation
-
-{$L WIN}
-
-procedure WriteStr(X, Y: Byte; S: String; Attr: Byte);
-external {WIN};
-
-procedure WriteChar(X, Y, Count: Byte; Ch: Char; Attr: Byte);
-external {WIN};
-
-procedure FillWin(Ch: Char; Attr: Byte);
-external {WIN};
-
-procedure WriteWin(var Buf);
-external {WIN};
-
-procedure ReadWin(var Buf);
-external {WIN};
-
-function WinSize: Word;
-external {WIN};
-
-procedure SaveWin(var W: WinState);
-begin
-  W.WindMin := WindMin;
-  W.WindMax := WindMax;
-  W.WhereX := WhereX;
-  W.WhereY := WhereY;
-  W.TextAttr := TextAttr;
-end;
-
-procedure RestoreWin(var W: WinState);
-begin
-  WindMin := W.WindMin;
-  WindMax := W.WindMax;
-  GotoXY(W.WhereX, W.WhereY);
-  TextAttr := W.TextAttr;
-end;
-
-procedure FrameWin(Title: TitleStr; var Frame: FrameChars;
-  TitleAttr, FrameAttr: Byte);
-var
-  W, H, Y: Word;
-begin
-  W := Lo(WindMax) - Lo(WindMin) + 1;
-  H := Hi(WindMax) - Hi(WindMin) + 1;
-  WriteChar(1, 1, 1, Frame[1], FrameAttr);
-  WriteChar(2, 1, W - 2, Frame[2], FrameAttr);
-  WriteChar(W, 1, 1, Frame[3], FrameAttr);
-  if Length(Title) > W - 2 then Title[0] := Chr(W - 2);
-  WriteStr((W - Length(Title)) shr 1 + 1, 1, Title, TitleAttr);
-  for Y := 2 to H - 1 do
-  begin
-    WriteChar(1, Y, 1, Frame[4], FrameAttr);
-    WriteChar(W, Y, 1, Frame[5], FrameAttr);
-  end;
-  WriteChar(1, H, 1, Frame[6], FrameAttr);
-  WriteChar(2, H, W - 2, Frame[7], FrameAttr);
-  WriteChar(W, H, 1, Frame[8], FrameAttr);
-  Inc(WindMin, $0101);
-  Dec(WindMax, $0101);
-end;
-
-procedure UnFrameWin;
-begin
-  Dec(WindMin, $0101);
-  Inc(WindMax, $0101);
-end;
-
-end.
diff --git a/makedata/world2.cpr b/makedata/world2.cpr
deleted file mode 100644
index 020155f..0000000
Binary files a/makedata/world2.cpr and /dev/null differ
diff --git a/makedata/world2.pal b/makedata/world2.pal
deleted file mode 100644
index ac29ecb..0000000
Binary files a/makedata/world2.pal and /dev/null differ
diff --git a/makedata/world3.cpr b/makedata/world3.cpr
deleted file mode 100644
index 0533660..0000000
Binary files a/makedata/world3.cpr and /dev/null differ
diff --git a/makedata/evolve.txt b/other/evolve.txt
similarity index 100%
rename from makedata/evolve.txt
rename to other/evolve.txt
diff --git a/itemdata.txt b/other/itemdata.txt
similarity index 100%
rename from itemdata.txt
rename to other/itemdata.txt
diff --git a/makedata/items.txt b/other/items.txt
similarity index 100%
rename from makedata/items.txt
rename to other/items.txt
diff --git a/makedata/stuff.txt b/other/stuff.txt
similarity index 100%
rename from makedata/stuff.txt
rename to other/stuff.txt
diff --git a/sysdata.txt b/other/sysdata.txt
similarity index 100%
rename from sysdata.txt
rename to other/sysdata.txt
diff --git a/makedata/xp.txt b/other/xp.txt
similarity index 100%
rename from makedata/xp.txt
rename to other/xp.txt
diff --git a/png/alien.png b/png/alien.png
new file mode 100644
index 0000000..63426ee
Binary files /dev/null and b/png/alien.png differ
diff --git a/png/alien1.png b/png/alien1.png
new file mode 100644
index 0000000..2164801
Binary files /dev/null and b/png/alien1.png differ
diff --git a/png/alien10.png b/png/alien10.png
new file mode 100644
index 0000000..fb03158
Binary files /dev/null and b/png/alien10.png differ
diff --git a/png/alien2.png b/png/alien2.png
new file mode 100644
index 0000000..759ca82
Binary files /dev/null and b/png/alien2.png differ
diff --git a/png/alien3.png b/png/alien3.png
new file mode 100644
index 0000000..661d107
Binary files /dev/null and b/png/alien3.png differ
diff --git a/png/alien4.png b/png/alien4.png
new file mode 100644
index 0000000..64f511f
Binary files /dev/null and b/png/alien4.png differ
diff --git a/png/alien5.png b/png/alien5.png
new file mode 100644
index 0000000..e3e9d90
Binary files /dev/null and b/png/alien5.png differ
diff --git a/png/alien6.png b/png/alien6.png
new file mode 100644
index 0000000..fbabeef
Binary files /dev/null and b/png/alien6.png differ
diff --git a/png/alien7.png b/png/alien7.png
new file mode 100644
index 0000000..994329c
Binary files /dev/null and b/png/alien7.png differ
diff --git a/png/alien8.png b/png/alien8.png
new file mode 100644
index 0000000..d3a6737
Binary files /dev/null and b/png/alien8.png differ
diff --git a/png/alien9.png b/png/alien9.png
new file mode 100644
index 0000000..9519d5e
Binary files /dev/null and b/png/alien9.png differ
diff --git a/png/back01.png b/png/back01.png
new file mode 100644
index 0000000..8937ab3
Binary files /dev/null and b/png/back01.png differ
diff --git a/png/back02.png b/png/back02.png
new file mode 100644
index 0000000..16730dd
Binary files /dev/null and b/png/back02.png differ
diff --git a/png/back03.png b/png/back03.png
new file mode 100644
index 0000000..5751d95
Binary files /dev/null and b/png/back03.png differ
diff --git a/png/back04.png b/png/back04.png
new file mode 100644
index 0000000..03a9eb5
Binary files /dev/null and b/png/back04.png differ
diff --git a/png/back05.png b/png/back05.png
new file mode 100644
index 0000000..49944e8
Binary files /dev/null and b/png/back05.png differ
diff --git a/png/back06.png b/png/back06.png
new file mode 100644
index 0000000..45d2d92
Binary files /dev/null and b/png/back06.png differ
diff --git a/png/back07.png b/png/back07.png
new file mode 100644
index 0000000..5ea82af
Binary files /dev/null and b/png/back07.png differ
diff --git a/png/back08.png b/png/back08.png
new file mode 100644
index 0000000..18dbdc9
Binary files /dev/null and b/png/back08.png differ
diff --git a/png/back09.png b/png/back09.png
new file mode 100644
index 0000000..f8e01fc
Binary files /dev/null and b/png/back09.png differ
diff --git a/png/back10.png b/png/back10.png
new file mode 100644
index 0000000..157269a
Binary files /dev/null and b/png/back10.png differ
diff --git a/png/back11.png b/png/back11.png
new file mode 100644
index 0000000..598b032
Binary files /dev/null and b/png/back11.png differ
diff --git a/png/back12.png b/png/back12.png
new file mode 100644
index 0000000..a25c989
Binary files /dev/null and b/png/back12.png differ
diff --git a/png/back13.png b/png/back13.png
new file mode 100644
index 0000000..450a986
Binary files /dev/null and b/png/back13.png differ
diff --git a/png/back14.png b/png/back14.png
new file mode 100644
index 0000000..24da5a2
Binary files /dev/null and b/png/back14.png differ
diff --git a/png/back15.png b/png/back15.png
new file mode 100644
index 0000000..e31507c
Binary files /dev/null and b/png/back15.png differ
diff --git a/png/back16.png b/png/back16.png
new file mode 100644
index 0000000..2af78eb
Binary files /dev/null and b/png/back16.png differ
diff --git a/png/back17.png b/png/back17.png
new file mode 100644
index 0000000..9332135
Binary files /dev/null and b/png/back17.png differ
diff --git a/png/back18.png b/png/back18.png
new file mode 100644
index 0000000..1420152
Binary files /dev/null and b/png/back18.png differ
diff --git a/png/back19.png b/png/back19.png
new file mode 100644
index 0000000..ceb3d70
Binary files /dev/null and b/png/back19.png differ
diff --git a/png/back20.png b/png/back20.png
new file mode 100644
index 0000000..4ec22db
Binary files /dev/null and b/png/back20.png differ
diff --git a/png/back21.png b/png/back21.png
new file mode 100644
index 0000000..8c32325
Binary files /dev/null and b/png/back21.png differ
diff --git a/png/back22.png b/png/back22.png
new file mode 100644
index 0000000..1745dc9
Binary files /dev/null and b/png/back22.png differ
diff --git a/png/battle1.png b/png/battle1.png
new file mode 100644
index 0000000..a7f6a4b
Binary files /dev/null and b/png/battle1.png differ
diff --git a/png/cargo.png b/png/cargo.png
new file mode 100644
index 0000000..41439fd
Binary files /dev/null and b/png/cargo.png differ
diff --git a/png/channel7.png b/png/channel7.png
new file mode 100644
index 0000000..c49057c
Binary files /dev/null and b/png/channel7.png differ
diff --git a/png/char.png b/png/char.png
new file mode 100644
index 0000000..1f84de4
Binary files /dev/null and b/png/char.png differ
diff --git a/png/char2.png b/png/char2.png
new file mode 100644
index 0000000..6882d46
Binary files /dev/null and b/png/char2.png differ
diff --git a/png/charani.png b/png/charani.png
new file mode 100644
index 0000000..fdd74e7
Binary files /dev/null and b/png/charani.png differ
diff --git a/png/charcom.png b/png/charcom.png
new file mode 100644
index 0000000..9872a09
Binary files /dev/null and b/png/charcom.png differ
diff --git a/png/cloud.png b/png/cloud.png
new file mode 100644
index 0000000..88bf85e
Binary files /dev/null and b/png/cloud.png differ
diff --git a/png/com.png b/png/com.png
new file mode 100644
index 0000000..86763e5
Binary files /dev/null and b/png/com.png differ
diff --git a/png/end1.png b/png/end1.png
new file mode 100644
index 0000000..33c6dfa
Binary files /dev/null and b/png/end1.png differ
diff --git a/png/end2.png b/png/end2.png
new file mode 100644
index 0000000..9a71ec4
Binary files /dev/null and b/png/end2.png differ
diff --git a/png/end3.png b/png/end3.png
new file mode 100644
index 0000000..78ee63f
Binary files /dev/null and b/png/end3.png differ
diff --git a/png/end4.png b/png/end4.png
new file mode 100644
index 0000000..7a4e6b3
Binary files /dev/null and b/png/end4.png differ
diff --git a/png/end5.png b/png/end5.png
new file mode 100644
index 0000000..bc9b476
Binary files /dev/null and b/png/end5.png differ
diff --git a/png/end6.png b/png/end6.png
new file mode 100644
index 0000000..2a34540
Binary files /dev/null and b/png/end6.png differ
diff --git a/png/fight.png b/png/fight.png
new file mode 100644
index 0000000..6a701bd
Binary files /dev/null and b/png/fight.png differ
diff --git a/png/font.png b/png/font.png
new file mode 100644
index 0000000..bd48b64
Binary files /dev/null and b/png/font.png differ
diff --git a/png/font0.png b/png/font0.png
new file mode 100644
index 0000000..f030268
Binary files /dev/null and b/png/font0.png differ
diff --git a/png/icons.png b/png/icons.png
new file mode 100644
index 0000000..6b8a947
Binary files /dev/null and b/png/icons.png differ
diff --git a/png/image01.png b/png/image01.png
new file mode 100644
index 0000000..d959bb1
Binary files /dev/null and b/png/image01.png differ
diff --git a/png/image02.png b/png/image02.png
new file mode 100644
index 0000000..c745371
Binary files /dev/null and b/png/image02.png differ
diff --git a/png/image03.png b/png/image03.png
new file mode 100644
index 0000000..78945d3
Binary files /dev/null and b/png/image03.png differ
diff --git a/png/image04.png b/png/image04.png
new file mode 100644
index 0000000..478bd41
Binary files /dev/null and b/png/image04.png differ
diff --git a/png/image05.png b/png/image05.png
new file mode 100644
index 0000000..69ac512
Binary files /dev/null and b/png/image05.png differ
diff --git a/png/image06.png b/png/image06.png
new file mode 100644
index 0000000..32afa97
Binary files /dev/null and b/png/image06.png differ
diff --git a/png/image07.png b/png/image07.png
new file mode 100644
index 0000000..d21a62f
Binary files /dev/null and b/png/image07.png differ
diff --git a/png/image08.png b/png/image08.png
new file mode 100644
index 0000000..42ee832
Binary files /dev/null and b/png/image08.png differ
diff --git a/png/image09.png b/png/image09.png
new file mode 100644
index 0000000..5932895
Binary files /dev/null and b/png/image09.png differ
diff --git a/png/image10.png b/png/image10.png
new file mode 100644
index 0000000..1c4c350
Binary files /dev/null and b/png/image10.png differ
diff --git a/png/image11.png b/png/image11.png
new file mode 100644
index 0000000..ee630f9
Binary files /dev/null and b/png/image11.png differ
diff --git a/png/image12.png b/png/image12.png
new file mode 100644
index 0000000..11f6a50
Binary files /dev/null and b/png/image12.png differ
diff --git a/png/image13.png b/png/image13.png
new file mode 100644
index 0000000..0fab082
Binary files /dev/null and b/png/image13.png differ
diff --git a/png/image14.png b/png/image14.png
new file mode 100644
index 0000000..eeba701
Binary files /dev/null and b/png/image14.png differ
diff --git a/png/image15.png b/png/image15.png
new file mode 100644
index 0000000..62af545
Binary files /dev/null and b/png/image15.png differ
diff --git a/png/image16.png b/png/image16.png
new file mode 100644
index 0000000..fe06886
Binary files /dev/null and b/png/image16.png differ
diff --git a/png/image17.png b/png/image17.png
new file mode 100644
index 0000000..947717c
Binary files /dev/null and b/png/image17.png differ
diff --git a/png/image18.png b/png/image18.png
new file mode 100644
index 0000000..e5fe20f
Binary files /dev/null and b/png/image18.png differ
diff --git a/png/image19.png b/png/image19.png
new file mode 100644
index 0000000..dcfb3d9
Binary files /dev/null and b/png/image19.png differ
diff --git a/png/image20.png b/png/image20.png
new file mode 100644
index 0000000..4e575cf
Binary files /dev/null and b/png/image20.png differ
diff --git a/png/image21.png b/png/image21.png
new file mode 100644
index 0000000..20c9427
Binary files /dev/null and b/png/image21.png differ
diff --git a/png/image22.png b/png/image22.png
new file mode 100644
index 0000000..c2a1c66
Binary files /dev/null and b/png/image22.png differ
diff --git a/png/image23.png b/png/image23.png
new file mode 100644
index 0000000..9be7fc6
Binary files /dev/null and b/png/image23.png differ
diff --git a/png/image24.png b/png/image24.png
new file mode 100644
index 0000000..c8fd20f
Binary files /dev/null and b/png/image24.png differ
diff --git a/png/image25.png b/png/image25.png
new file mode 100644
index 0000000..c155316
Binary files /dev/null and b/png/image25.png differ
diff --git a/png/image26.png b/png/image26.png
new file mode 100644
index 0000000..55c3b40
Binary files /dev/null and b/png/image26.png differ
diff --git a/png/image27.png b/png/image27.png
new file mode 100644
index 0000000..aa0d444
Binary files /dev/null and b/png/image27.png differ
diff --git a/png/image28.png b/png/image28.png
new file mode 100644
index 0000000..a9b0030
Binary files /dev/null and b/png/image28.png differ
diff --git a/png/image29.png b/png/image29.png
new file mode 100644
index 0000000..ec808eb
Binary files /dev/null and b/png/image29.png differ
diff --git a/png/image30.png b/png/image30.png
new file mode 100644
index 0000000..8670262
Binary files /dev/null and b/png/image30.png differ
diff --git a/png/image31.png b/png/image31.png
new file mode 100644
index 0000000..a5cc054
Binary files /dev/null and b/png/image31.png differ
diff --git a/png/image32.png b/png/image32.png
new file mode 100644
index 0000000..f67847b
Binary files /dev/null and b/png/image32.png differ
diff --git a/png/intro2.png b/png/intro2.png
new file mode 100644
index 0000000..bcd6f15
Binary files /dev/null and b/png/intro2.png differ
diff --git a/png/intro5.png b/png/intro5.png
new file mode 100644
index 0000000..23009d9
Binary files /dev/null and b/png/intro5.png differ
diff --git a/png/landform.png b/png/landform.png
new file mode 100644
index 0000000..0115e3f
Binary files /dev/null and b/png/landform.png differ
diff --git a/png/log.png b/png/log.png
new file mode 100644
index 0000000..f5be52a
Binary files /dev/null and b/png/log.png differ
diff --git a/png/main-cube.png b/png/main-cube.png
new file mode 100644
index 0000000..46bb3b2
Binary files /dev/null and b/png/main-cube.png differ
diff --git a/png/main-status-bulb.png b/png/main-status-bulb.png
new file mode 100644
index 0000000..a33d883
Binary files /dev/null and b/png/main-status-bulb.png differ
diff --git a/makedata/planicon.pal b/png/main.pal
similarity index 69%
rename from makedata/planicon.pal
rename to png/main.pal
index 6aa7182..ee1c765 100644
Binary files a/makedata/planicon.pal and b/png/main.pal differ
diff --git a/png/main.png b/png/main.png
new file mode 100644
index 0000000..7b24a05
Binary files /dev/null and b/png/main.png differ
diff --git a/png/main3.png b/png/main3.png
new file mode 100644
index 0000000..99366f1
Binary files /dev/null and b/png/main3.png differ
diff --git a/png/mouse--char.png b/png/mouse--char.png
new file mode 100644
index 0000000..115e0a3
Binary files /dev/null and b/png/mouse--char.png differ
diff --git a/png/mouse--com.png b/png/mouse--com.png
new file mode 100644
index 0000000..f47e79e
Binary files /dev/null and b/png/mouse--com.png differ
diff --git a/png/mouse-1.png b/png/mouse-1.png
new file mode 100644
index 0000000..c2d52c1
Binary files /dev/null and b/png/mouse-1.png differ
diff --git a/png/mouse-2.png b/png/mouse-2.png
new file mode 100644
index 0000000..338a3ec
Binary files /dev/null and b/png/mouse-2.png differ
diff --git a/png/mouse-3.png b/png/mouse-3.png
new file mode 100644
index 0000000..1341c9c
Binary files /dev/null and b/png/mouse-3.png differ
diff --git a/png/planet-icons.png b/png/planet-icons.png
new file mode 100644
index 0000000..0ef70bc
Binary files /dev/null and b/png/planet-icons.png differ
diff --git a/png/planicon.png b/png/planicon.png
new file mode 100644
index 0000000..d5b5de6
Binary files /dev/null and b/png/planicon.png differ
diff --git a/png/psyche.png b/png/psyche.png
new file mode 100644
index 0000000..883874a
Binary files /dev/null and b/png/psyche.png differ
diff --git a/png/saver.png b/png/saver.png
new file mode 100644
index 0000000..5fc0812
Binary files /dev/null and b/png/saver.png differ
diff --git a/png/sector.png b/png/sector.png
new file mode 100644
index 0000000..8035130
Binary files /dev/null and b/png/sector.png differ
diff --git a/png/shield-icons.png b/png/shield-icons.png
new file mode 100644
index 0000000..db9db5d
Binary files /dev/null and b/png/shield-icons.png differ
diff --git a/png/ship1.png b/png/ship1.png
new file mode 100644
index 0000000..8085371
Binary files /dev/null and b/png/ship1.png differ
diff --git a/png/shippart.png b/png/shippart.png
new file mode 100644
index 0000000..5851eb3
Binary files /dev/null and b/png/shippart.png differ
diff --git a/png/tech1.png b/png/tech1.png
new file mode 100644
index 0000000..92ad580
Binary files /dev/null and b/png/tech1.png differ
diff --git a/png/trade.png b/png/trade.png
new file mode 100644
index 0000000..62fda53
Binary files /dev/null and b/png/trade.png differ
diff --git a/png/waricon.png b/png/waricon.png
new file mode 100644
index 0000000..32b7580
Binary files /dev/null and b/png/waricon.png differ
diff --git a/png/weapon-icons.png b/png/weapon-icons.png
new file mode 100644
index 0000000..2c5ceb4
Binary files /dev/null and b/png/weapon-icons.png differ
diff --git a/png/world.png b/png/world.png
new file mode 100644
index 0000000..edf73d8
Binary files /dev/null and b/png/world.png differ
diff --git a/save1/CONTACTS.DTA b/save1/CONTACTS.DTA
deleted file mode 100644
index 031a2fd..0000000
Binary files a/save1/CONTACTS.DTA and /dev/null differ
diff --git a/save1/EVENTS.DTA b/save1/EVENTS.DTA
deleted file mode 100644
index ef0d0a8..0000000
Binary files a/save1/EVENTS.DTA and /dev/null differ
diff --git a/save1/LOGS.DTA b/save1/LOGS.DTA
deleted file mode 100644
index 5affc62..0000000
Binary files a/save1/LOGS.DTA and /dev/null differ
diff --git a/save1/PENDING.DTA b/save1/PENDING.DTA
deleted file mode 100644
index 002aade..0000000
Binary files a/save1/PENDING.DTA and /dev/null differ
diff --git a/save1/PLANETS.DTA b/save1/PLANETS.DTA
deleted file mode 100644
index ae2e927..0000000
Binary files a/save1/PLANETS.DTA and /dev/null differ
diff --git a/save1/SHIP.DTA b/save1/SHIP.DTA
deleted file mode 100644
index 4db26b1..0000000
Binary files a/save1/SHIP.DTA and /dev/null differ
diff --git a/save1/SYSTEMS.DTA b/save1/SYSTEMS.DTA
deleted file mode 100644
index 42d9a9e..0000000
Binary files a/save1/SYSTEMS.DTA and /dev/null differ
diff --git a/save2/CONTACTS.DTA b/save2/CONTACTS.DTA
deleted file mode 100644
index 031a2fd..0000000
Binary files a/save2/CONTACTS.DTA and /dev/null differ
diff --git a/save2/EVENTS.DTA b/save2/EVENTS.DTA
deleted file mode 100644
index 1a5614c..0000000
Binary files a/save2/EVENTS.DTA and /dev/null differ
diff --git a/save2/LOGS.DTA b/save2/LOGS.DTA
deleted file mode 100644
index 08dd109..0000000
Binary files a/save2/LOGS.DTA and /dev/null differ
diff --git a/save2/PENDING.DTA b/save2/PENDING.DTA
deleted file mode 100644
index 002aade..0000000
Binary files a/save2/PENDING.DTA and /dev/null differ
diff --git a/save2/PLANETS.DTA b/save2/PLANETS.DTA
deleted file mode 100644
index e24ccd3..0000000
Binary files a/save2/PLANETS.DTA and /dev/null differ
diff --git a/save2/SHIP.DTA b/save2/SHIP.DTA
deleted file mode 100644
index 2e38453..0000000
Binary files a/save2/SHIP.DTA and /dev/null differ
diff --git a/save2/SYSTEMS.DTA b/save2/SYSTEMS.DTA
deleted file mode 100644
index 42d9a9e..0000000
Binary files a/save2/SYSTEMS.DTA and /dev/null differ
diff --git a/save3/CONTACTS.DTA b/save3/CONTACTS.DTA
deleted file mode 100644
index 031a2fd..0000000
Binary files a/save3/CONTACTS.DTA and /dev/null differ
diff --git a/save3/EVENTS.DTA b/save3/EVENTS.DTA
deleted file mode 100644
index ef0d0a8..0000000
Binary files a/save3/EVENTS.DTA and /dev/null differ
diff --git a/save3/LOGS.DTA b/save3/LOGS.DTA
deleted file mode 100644
index 5affc62..0000000
Binary files a/save3/LOGS.DTA and /dev/null differ
diff --git a/save3/PENDING.DTA b/save3/PENDING.DTA
deleted file mode 100644
index 002aade..0000000
Binary files a/save3/PENDING.DTA and /dev/null differ
diff --git a/save3/PLANETS.DTA b/save3/PLANETS.DTA
deleted file mode 100644
index e6b0a8c..0000000
Binary files a/save3/PLANETS.DTA and /dev/null differ
diff --git a/save3/SHIP.DTA b/save3/SHIP.DTA
deleted file mode 100644
index d4b642d..0000000
Binary files a/save3/SHIP.DTA and /dev/null differ
diff --git a/save3/SYSTEMS.DTA b/save3/SYSTEMS.DTA
deleted file mode 100644
index 9d77e4a..0000000
Binary files a/save3/SYSTEMS.DTA and /dev/null differ
diff --git a/save4/CONTACTS.DTA b/save4/CONTACTS.DTA
deleted file mode 100644
index 101a951..0000000
Binary files a/save4/CONTACTS.DTA and /dev/null differ
diff --git a/save4/EVENTS.DTA b/save4/EVENTS.DTA
deleted file mode 100644
index 457f14d..0000000
Binary files a/save4/EVENTS.DTA and /dev/null differ
diff --git a/save4/LOGS.DTA b/save4/LOGS.DTA
deleted file mode 100644
index 0324038..0000000
Binary files a/save4/LOGS.DTA and /dev/null differ
diff --git a/save4/PENDING.DTA b/save4/PENDING.DTA
deleted file mode 100644
index 002aade..0000000
Binary files a/save4/PENDING.DTA and /dev/null differ
diff --git a/save4/PLANETS.DTA b/save4/PLANETS.DTA
deleted file mode 100644
index 6687b68..0000000
Binary files a/save4/PLANETS.DTA and /dev/null differ
diff --git a/save4/SHIP.DTA b/save4/SHIP.DTA
deleted file mode 100644
index 1f879ef..0000000
Binary files a/save4/SHIP.DTA and /dev/null differ
diff --git a/save4/SYSTEMS.DTA b/save4/SYSTEMS.DTA
deleted file mode 100644
index 42d9a9e..0000000
Binary files a/save4/SYSTEMS.DTA and /dev/null differ
diff --git a/save5/CONTACTS.DTA b/save5/CONTACTS.DTA
deleted file mode 100644
index 031a2fd..0000000
Binary files a/save5/CONTACTS.DTA and /dev/null differ
diff --git a/save5/EVENTS.DTA b/save5/EVENTS.DTA
deleted file mode 100644
index ef0d0a8..0000000
Binary files a/save5/EVENTS.DTA and /dev/null differ
diff --git a/save5/LOGS.DTA b/save5/LOGS.DTA
deleted file mode 100644
index 5affc62..0000000
Binary files a/save5/LOGS.DTA and /dev/null differ
diff --git a/save5/PENDING.DTA b/save5/PENDING.DTA
deleted file mode 100644
index 002aade..0000000
Binary files a/save5/PENDING.DTA and /dev/null differ
diff --git a/save5/PLANETS.DTA b/save5/PLANETS.DTA
deleted file mode 100644
index 1fd168a..0000000
Binary files a/save5/PLANETS.DTA and /dev/null differ
diff --git a/save5/SHIP.DTA b/save5/SHIP.DTA
deleted file mode 100644
index 5a6db72..0000000
Binary files a/save5/SHIP.DTA and /dev/null differ
diff --git a/save5/SYSTEMS.DTA b/save5/SYSTEMS.DTA
deleted file mode 100644
index 9d77e4a..0000000
Binary files a/save5/SYSTEMS.DTA and /dev/null differ
diff --git a/save6/CONTACTS.DTA b/save6/CONTACTS.DTA
deleted file mode 100644
index 101a951..0000000
Binary files a/save6/CONTACTS.DTA and /dev/null differ
diff --git a/save6/EVENTS.DTA b/save6/EVENTS.DTA
deleted file mode 100644
index 457f14d..0000000
Binary files a/save6/EVENTS.DTA and /dev/null differ
diff --git a/save6/LOGS.DTA b/save6/LOGS.DTA
deleted file mode 100644
index 0324038..0000000
Binary files a/save6/LOGS.DTA and /dev/null differ
diff --git a/save6/PENDING.DTA b/save6/PENDING.DTA
deleted file mode 100644
index 002aade..0000000
Binary files a/save6/PENDING.DTA and /dev/null differ
diff --git a/save6/PLANETS.DTA b/save6/PLANETS.DTA
deleted file mode 100644
index 8830bf6..0000000
Binary files a/save6/PLANETS.DTA and /dev/null differ
diff --git a/save6/SHIP.DTA b/save6/SHIP.DTA
deleted file mode 100644
index 25968da..0000000
Binary files a/save6/SHIP.DTA and /dev/null differ
diff --git a/save6/SYSTEMS.DTA b/save6/SYSTEMS.DTA
deleted file mode 100644
index 43879dc..0000000
Binary files a/save6/SYSTEMS.DTA and /dev/null differ
diff --git a/save7/CONTACTS.DTA b/save7/CONTACTS.DTA
deleted file mode 100644
index 031a2fd..0000000
Binary files a/save7/CONTACTS.DTA and /dev/null differ
diff --git a/save7/EVENTS.DTA b/save7/EVENTS.DTA
deleted file mode 100644
index ef0d0a8..0000000
Binary files a/save7/EVENTS.DTA and /dev/null differ
diff --git a/save7/LOGS.DTA b/save7/LOGS.DTA
deleted file mode 100644
index 5affc62..0000000
Binary files a/save7/LOGS.DTA and /dev/null differ
diff --git a/save7/PENDING.DTA b/save7/PENDING.DTA
deleted file mode 100644
index 002aade..0000000
Binary files a/save7/PENDING.DTA and /dev/null differ
diff --git a/save7/PLANETS.DTA b/save7/PLANETS.DTA
deleted file mode 100644
index 1a5a5b6..0000000
Binary files a/save7/PLANETS.DTA and /dev/null differ
diff --git a/save7/SHIP.DTA b/save7/SHIP.DTA
deleted file mode 100644
index ca09b81..0000000
Binary files a/save7/SHIP.DTA and /dev/null differ
diff --git a/save7/SYSTEMS.DTA b/save7/SYSTEMS.DTA
deleted file mode 100644
index 9d77e4a..0000000
Binary files a/save7/SYSTEMS.DTA and /dev/null differ
diff --git a/save8/CONTACTS.DTA b/save8/CONTACTS.DTA
deleted file mode 100644
index b7b83b8..0000000
Binary files a/save8/CONTACTS.DTA and /dev/null differ
diff --git a/save8/EVENTS.DTA b/save8/EVENTS.DTA
deleted file mode 100644
index 457f14d..0000000
Binary files a/save8/EVENTS.DTA and /dev/null differ
diff --git a/save8/LOGS.DTA b/save8/LOGS.DTA
deleted file mode 100644
index 0324038..0000000
Binary files a/save8/LOGS.DTA and /dev/null differ
diff --git a/save8/PENDING.DTA b/save8/PENDING.DTA
deleted file mode 100644
index 002aade..0000000
Binary files a/save8/PENDING.DTA and /dev/null differ
diff --git a/save8/PLANETS.DTA b/save8/PLANETS.DTA
deleted file mode 100644
index 342fde0..0000000
Binary files a/save8/PLANETS.DTA and /dev/null differ
diff --git a/save8/SHIP.DTA b/save8/SHIP.DTA
deleted file mode 100644
index 56a0b4e..0000000
Binary files a/save8/SHIP.DTA and /dev/null differ
diff --git a/save8/SYSTEMS.DTA b/save8/SYSTEMS.DTA
deleted file mode 100644
index 19b1e93..0000000
Binary files a/save8/SYSTEMS.DTA and /dev/null differ
diff --git a/sound.cfg b/sound.cfg
deleted file mode 100644
index 08a875e..0000000
Binary files a/sound.cfg and /dev/null differ
diff --git a/sound/AARD.MOD b/sound/AARD.MOD
deleted file mode 100644
index 0de2bc7..0000000
Binary files a/sound/AARD.MOD and /dev/null differ
diff --git a/sound/CARGO.MOD b/sound/CARGO.MOD
deleted file mode 100644
index 465cade..0000000
Binary files a/sound/CARGO.MOD and /dev/null differ
diff --git a/sound/CHARGEN.MOD b/sound/CHARGEN.MOD
deleted file mode 100644
index fb1025a..0000000
Binary files a/sound/CHARGEN.MOD and /dev/null differ
diff --git a/sound/COMBAT.MOD b/sound/COMBAT.MOD
deleted file mode 100644
index b2c33ed..0000000
Binary files a/sound/COMBAT.MOD and /dev/null differ
diff --git a/sound/COMPONT.MOD b/sound/COMPONT.MOD
deleted file mode 100644
index 8f8d128..0000000
Binary files a/sound/COMPONT.MOD and /dev/null differ
diff --git a/sound/CREWCOMM.MOD b/sound/CREWCOMM.MOD
deleted file mode 100644
index a16e91c..0000000
Binary files a/sound/CREWCOMM.MOD and /dev/null differ
diff --git a/sound/CREWEVAL.MOD b/sound/CREWEVAL.MOD
deleted file mode 100644
index 6d50cde..0000000
Binary files a/sound/CREWEVAL.MOD and /dev/null differ
diff --git a/sound/DIMENSIO.MOD b/sound/DIMENSIO.MOD
deleted file mode 100644
index 40145d4..0000000
Binary files a/sound/DIMENSIO.MOD and /dev/null differ
diff --git a/sound/DPAK.MOD b/sound/DPAK.MOD
deleted file mode 100644
index c725253..0000000
Binary files a/sound/DPAK.MOD and /dev/null differ
diff --git a/sound/ERMIGEN.MOD b/sound/ERMIGEN.MOD
deleted file mode 100644
index 39bb1d6..0000000
Binary files a/sound/ERMIGEN.MOD and /dev/null differ
diff --git a/sound/GAME.MOD b/sound/GAME.MOD
deleted file mode 100644
index 465cade..0000000
Binary files a/sound/GAME.MOD and /dev/null differ
diff --git a/sound/GENER1.MOD b/sound/GENER1.MOD
deleted file mode 100644
index 84100e7..0000000
Binary files a/sound/GENER1.MOD and /dev/null differ
diff --git a/sound/GUILD.MOD b/sound/GUILD.MOD
deleted file mode 100644
index 167635d..0000000
Binary files a/sound/GUILD.MOD and /dev/null differ
diff --git a/sound/ICON.MOD b/sound/ICON.MOD
deleted file mode 100644
index f03a1fc..0000000
Binary files a/sound/ICON.MOD and /dev/null differ
diff --git a/sound/INTRO1.MOD b/sound/INTRO1.MOD
deleted file mode 100644
index ead56cd..0000000
Binary files a/sound/INTRO1.MOD and /dev/null differ
diff --git a/sound/INTRO2.MOD b/sound/INTRO2.MOD
deleted file mode 100644
index eac3d0f..0000000
Binary files a/sound/INTRO2.MOD and /dev/null differ
diff --git a/sound/LOVE.MOD b/sound/LOVE.MOD
deleted file mode 100644
index 051fb66..0000000
Binary files a/sound/LOVE.MOD and /dev/null differ
diff --git a/sound/PHADOR.MOD b/sound/PHADOR.MOD
deleted file mode 100644
index 6fcbb87..0000000
Binary files a/sound/PHADOR.MOD and /dev/null differ
diff --git a/sound/PROBE.MOD b/sound/PROBE.MOD
deleted file mode 100644
index a0f1e79..0000000
Binary files a/sound/PROBE.MOD and /dev/null differ
diff --git a/sound/PSYEVAL.MOD b/sound/PSYEVAL.MOD
deleted file mode 100644
index f2d1def..0000000
Binary files a/sound/PSYEVAL.MOD and /dev/null differ
diff --git a/sound/QUAI.MOD b/sound/QUAI.MOD
deleted file mode 100644
index 01b6d59..0000000
Binary files a/sound/QUAI.MOD and /dev/null differ
diff --git a/sound/SCANNER.MOD b/sound/SCANNER.MOD
deleted file mode 100644
index cdc7591..0000000
Binary files a/sound/SCANNER.MOD and /dev/null differ
diff --git a/sound/SCAVENG.MOD b/sound/SCAVENG.MOD
deleted file mode 100644
index 2fa0a86..0000000
Binary files a/sound/SCAVENG.MOD and /dev/null differ
diff --git a/sound/SECTOR.MOD b/sound/SECTOR.MOD
deleted file mode 100644
index f1b6e1e..0000000
Binary files a/sound/SECTOR.MOD and /dev/null differ
diff --git a/sound/SENGZHAC.MOD b/sound/SENGZHAC.MOD
deleted file mode 100644
index fe7a55a..0000000
Binary files a/sound/SENGZHAC.MOD and /dev/null differ
diff --git a/sound/TITARIAN.MOD b/sound/TITARIAN.MOD
deleted file mode 100644
index ee8a482..0000000
Binary files a/sound/TITARIAN.MOD and /dev/null differ
diff --git a/sound/VICTORY.MOD b/sound/VICTORY.MOD
deleted file mode 100644
index c13d837..0000000
Binary files a/sound/VICTORY.MOD and /dev/null differ
diff --git a/sound/VOID.MOD b/sound/VOID.MOD
deleted file mode 100644
index c7ca8bd..0000000
Binary files a/sound/VOID.MOD and /dev/null differ
diff --git a/version.txt b/version.txt
index b111351..d76d053 100644
--- a/version.txt
+++ b/version.txt
@@ -173,3 +173,6 @@ v1.20.0016:
 
 
 	
+v1.30.0001:
+	Source, graphical assets and sound effects have been released under GPL.
+	The DMP library has been replaced with stubs.
